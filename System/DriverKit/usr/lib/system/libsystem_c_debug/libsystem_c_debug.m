int sigaltstack(const stack_t *a1, stack_t *a2)
{
  if (!a1 || a1->ss_size >= 0x8000)
    return __sigaltstack(a1, a2);
  *__error() = 12;
  return -1;
}

int sigvec(int a1, sigvec *a2, sigvec *a3)
{
  return sigvec__(a1, (const sigaction *)a2, (sigaction *)a3, 1);
}

uint64_t sigvec__(int a1, const sigaction *a2, sigaction *a3, int a4)
{
  unsigned int v5;

  if (a2)
    a2->sa_flags ^= 2u;
  if (a4)
    v5 = sigaction(a1, a2, a3);
  else
    v5 = _sigaction_nobind(a1, a2, a3);
  if (!v5 && a3)
    a3->sa_flags ^= 2u;
  return v5;
}

uint64_t _sigvec_nobind(int a1, const sigaction *a2, sigaction *a3)
{
  return sigvec__(a1, a2, a3, 0);
}

int sigsetmask(int a1)
{
  int v2;
  sigset_t v3;
  sigset_t v4;

  v4 = a1;
  v3 = 0;
  v2 = sigprocmask(3, &v4, &v3);
  if (v2)
    return v2;
  else
    return v3;
}

int sigblock(int a1)
{
  int v2;
  sigset_t v3;
  sigset_t v4;

  v4 = a1;
  v3 = 0;
  v2 = sigprocmask(1, &v4, &v3);
  if (v2)
    return v2;
  else
    return v3;
}

uint64_t sigpause_NOCANCEL(int a1)
{
  int v2;
  sigset_t v3;
  int v4;
  int v6;

  v4 = a1;
  v3 = 0;
  if (!__unix_conforming)
    __unix_conforming = 1;
  if (v4 > 0 && v4 < 32)
  {
    if (sigprocmask(1, 0, &v3) >= 0)
    {
      v6 = v4;
      if (v4 <= 32)
        v2 = 1 << (v6 - 1);
      else
        v2 = 0;
      v3 &= ~v2;
      return sigsuspend_NOCANCEL(&v3);
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sighold(int a1)
{
  int v2;
  sigset_t v3;
  int v4;
  int v6;

  v4 = a1;
  v3 = 0;
  if (a1 > 0 && v4 < 32)
  {
    v3 = 0;
    v6 = v4;
    v2 = 1 << (v6 - 1);
    v3 |= v2;
    return sigprocmask(1, &v3, 0);
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sigrelse(int a1)
{
  int v2;
  sigset_t v3;
  int v4;
  int v6;

  v4 = a1;
  v3 = 0;
  if (a1 > 0 && v4 < 32)
  {
    v3 = 0;
    v6 = v4;
    v2 = 1 << (v6 - 1);
    v3 |= v2;
    return sigprocmask(2, &v3, 0);
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sigignore(int a1)
{
  if (signal(a1, (void (__cdecl *)(int))((char *)&dword_0 + 1)) == (void (__cdecl *)(int))-1)
    return -1;
  else
    return 0;
}

void (__cdecl *__cdecl sigset(int a1, void (__cdecl *a2)(int)))(int)
{
  int v4;
  void (__cdecl *v5)(int);
  sigaction v6;
  _BOOL4 v7;
  sigset_t v8;
  void (__cdecl *v9)(int);
  int v10;
  int v12;

  v10 = a1;
  v9 = a2;
  v8 = 0;
  v7 = 0;
  v6.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v6.sa_mask = 0;
  if (a1 > 0 && v10 < 32)
  {
    if (sigprocmask(0, 0, &v8) == -1)
    {
      return (void (__cdecl *)(int))-1;
    }
    else
    {
      v12 = v10;
      if (v10 <= 32)
        v4 = 1 << (v12 - 1);
      else
        v4 = 0;
      v7 = (v8 & v4) != 0;
      if (v9 == (void (__cdecl *)(int))((char *)&dword_4 + 1))
      {
        if (v7)
        {
          return (void (__cdecl *)(int))(&dword_4 + 1);
        }
        else if (sigaction(v10, 0, &v6) == -1 || sighold(v10) == -1)
        {
          return (void (__cdecl *)(int))-1;
        }
        else
        {
          return v6.__sigaction_u.__sa_handler;
        }
      }
      else if (v7 && sigrelse(v10) == -1)
      {
        return (void (__cdecl *)(int))-1;
      }
      else
      {
        v5 = signal(v10, v9);
        if (v5 == (void (__cdecl *)(int))-1)
        {
          return (void (__cdecl *)(int))-1;
        }
        else if (v7)
        {
          return (void (__cdecl *)(int))(&dword_4 + 1);
        }
        else
        {
          return v5;
        }
      }
    }
  }
  else
  {
    *__error() = 22;
    return (void (__cdecl *)(int))-1;
  }
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  unint64_t v3;
  mach_timebase_info info;
  rusage v5;
  int v6;
  uint64_t v7;
  timeval v8;
  int v9;
  timeval v10;
  clockid_t v11;

  v11 = __clock_id;
  if (__clock_id)
  {
    if (__clock_id == _CLOCK_MONOTONIC)
    {
      v8.tv_sec = 0;
      *(_QWORD *)&v8.tv_usec = 0;
      v7 = 0;
      v6 = 0;
      if (_mach_boottime_usec(&v7, &v8))
      {
        return 0;
      }
      else
      {
        v7 *= 1000;
        return 1000000000 * v8.tv_sec + 1000 * v8.tv_usec - v7;
      }
    }
    else if (__clock_id == _CLOCK_PROCESS_CPUTIME_ID)
    {
      _platform_memset(&v5, 0, 144);
      if (getrusage(0, &v5))
        return 0;
      else
        return 1000000000 * v5.ru_utime.tv_sec
             + 1000 * v5.ru_utime.tv_usec
             + 1000000000 * v5.ru_stime.tv_sec
             + 1000 * v5.ru_stime.tv_usec;
    }
    else
    {
      info = 0;
      if (mach_timebase_info(&info) == 0)
      {
        v3 = v11 - 4;
        if (v3 <= 0xC)
          __asm { BR              X8 }
        *__error() = 22;
        return 0;
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    v10.tv_sec = 0;
    *(_QWORD *)&v10.tv_usec = 0;
    v9 = 0;
    if (gettimeofday(&v10, 0))
      return 0;
    else
      return 1000000000 * v10.tv_sec + 1000 * v10.tv_usec;
  }
}

uint64_t _mach_boottime_usec(uint64_t *a1, timeval *a2)
{
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;

  do
  {
    v5 = mach_boottime_usec();
    if (!v5)
      v5 = _boottime_fallback_usec();
    __dmb(0xBu);
    v3 = gettimeofday(a2, 0);
    if (v3)
      return v3;
    __dmb(0xBu);
    v4 = mach_boottime_usec();
    if (!v4)
      v4 = _boottime_fallback_usec();
  }
  while (v5 != v4);
  *a1 = v5;
  return 0;
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  if (__clock_id <= _CLOCK_THREAD_CPUTIME_ID)
    __asm { BR              X8 }
  *__error() = 22;
  return -1;
}

int clock_getres(clockid_t __clock_id, timespec *__res)
{
  mach_timebase_info info;
  timespec *v6;
  clockid_t v7;

  v7 = __clock_id;
  v6 = __res;
  if (__clock_id == _CLOCK_REALTIME)
    goto LABEL_14;
  if (__clock_id == _CLOCK_MONOTONIC_RAW_APPROX || __clock_id == _CLOCK_MONOTONIC_RAW)
    goto LABEL_15;
  if (__clock_id == _CLOCK_MONOTONIC)
    goto LABEL_14;
  if (__clock_id == _CLOCK_UPTIME_RAW_APPROX || __clock_id == _CLOCK_UPTIME_RAW)
    goto LABEL_15;
  if (__clock_id == _CLOCK_PROCESS_CPUTIME_ID)
  {
LABEL_14:
    v6->tv_nsec = 1000;
    v6->tv_sec = 0;
    return 0;
  }
  if (__clock_id != _CLOCK_THREAD_CPUTIME_ID)
  {
    *__error() = 22;
    return -1;
  }
LABEL_15:
  info = 0;
  if (mach_timebase_info(&info))
    return -1;
  v6->tv_nsec = info.numer / info.denom + (info.numer % info.denom != 0);
  v6->tv_sec = 0;
  return 0;
}

int clock_settime(clockid_t __clock_id, const timespec *__tp)
{
  timeval v3;
  const timespec *v4;
  clockid_t v5;

  v5 = __clock_id;
  v4 = __tp;
  if (__clock_id)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    v3.tv_sec = 0;
    *(_QWORD *)&v3.tv_usec = 0;
    v3.tv_sec = v4->tv_sec;
    v3.tv_usec = v4->tv_nsec / 1000;
    return settimeofday(&v3, 0);
  }
}

uint64_t _boottime_fallback_usec()
{
  size_t v1;
  uint64_t v2;
  uint64_t v3;

  v2 = 0;
  v3 = 0;
  v1 = 16;
  if (sysctlbyname("kern.boottime", &v2, &v1, 0, 0) == -1)
    return 0;
  else
    return 1000000 * v2 + (int)v3;
}

void *__cdecl sbrk(int a1)
{
  if (!sbrk_needs_init
    || (sbrk_needs_init = 0, !vm_allocate(mach_task_self_, (vm_address_t *)&sbrk_curbrk, sbrk_region_size, 83886081)))
  {
    if (a1 <= 0)
      return (void *)sbrk_curbrk;
    if (a1 <= (unint64_t)sbrk_region_size)
    {
      sbrk_curbrk += a1;
      sbrk_region_size -= a1;
      return (void *)(sbrk_curbrk - a1);
    }
  }
  *__error() = 12;
  return (void *)-1;
}

void *__cdecl brk(const void *a1)
{
  *__error() = 12;
  return (void *)-1;
}

void (__cdecl *__cdecl bsd_signal(int a1, void (__cdecl *a2)(int)))(int)
{
  int v3;
  sigaction v4;
  sigaction v5;
  void (__cdecl *v6)(int);
  int v7;
  int v9;

  v7 = a1;
  v6 = a2;
  v5.sa_mask = 0;
  v4.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v4.sa_mask = 0;
  v5.__sigaction_u.__sa_handler = a2;
  v5.sa_flags = 2;
  v9 = a1;
  if (a1 <= 32)
    v3 = 1 << (v9 - 1);
  else
    v3 = 0;
  v5.sa_mask |= v3;
  if (sigaction(v7, &v5, &v4) == -1)
    return (void (__cdecl *)(int))-1;
  else
    return v4.__sigaction_u.__sa_handler;
}

void strtoencf16(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v3;
  char v4;
  void *v8;
  uint64_t v9;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    _ffpp_strtoencf16_l(a1, a2, a3, (uint64_t)v8);
  else
    _ffpp_strtoencf16_l(a1, a2, a3, (uint64_t)__global_locale);
}

void _ffpp_strtoencf16_l(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  _DWORD v5[8];
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int v13;
  int v14;
  char v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20[8];

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = a4;
  _platform_memset(v5, 0, 104);
  v5[0] = 11;
  v5[1] = -14;
  v5[2] = 16;
  v5[3] = 2;
  v5[4] = -7;
  v5[5] = 5;
  v5[6] = 22;
  v6 = v19;
  v7 = v18;
  v8 = v17;
  v9 = v16;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  if (fastParse64((uint64_t)v5))
  {
    v4 = fegetround();
    generalSlowpath((uint64_t)v5, v4, v20, 8, 0);
  }
}

void strtoencf32(float *a1, uint64_t a2, uint64_t a3)
{
  char v3;
  char v4;
  void *v8;
  uint64_t v9;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    _ffpp_strtoencf32_l(a1, a2, a3, (uint64_t)v8);
  else
    _ffpp_strtoencf32_l(a1, a2, a3, (uint64_t)__global_locale);
}

void _ffpp_strtoencf32_l(float *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unsigned int v4;
  int v5;
  BOOL v6;
  int v7;
  int v8;
  int v9;
  unint64_t v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  int v15;
  unsigned int v16;
  __int16 v17;
  int v18;
  _QWORD v19[4];
  float *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  unsigned int v33[32];

  v32 = a1;
  v31 = a2;
  v30 = a3;
  v29 = a4;
  v28 = 0;
  v24 = 0u;
  v19[0] = 0xFFFFFF8200000018;
  v19[1] = 0x400000080;
  v19[2] = 0x28FFFFFFD2;
  v19[3] = 113;
  v20 = a1;
  v21 = a2;
  v22 = a3;
  v23 = a4;
  *(_QWORD *)&v24 = 0;
  DWORD2(v24) = 0;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  if (!fastParse64((uint64_t)v19))
    return;
  if (v27 >= -10 && v27 <= 10 && SDWORD2(v24) <= 7)
  {
    if ((v28 & 1) != 0)
      v7 = -(int)v24;
    else
      v7 = v24;
    if (v27 < 0)
      *v20 = (float)v7 / _ffpp_strtoencf32_l_floatPowerOf10[-v27];
    else
      *v20 = (float)v7 * _ffpp_strtoencf32_l_floatPowerOf10[v27];
    return;
  }
  v18 = fegetround();
  if (SDWORD2(v24) > 19)
  {
    v17 = v27 + WORD4(v24) - 19;
    v16 = 36;
  }
  else
  {
    v17 = v27;
    v16 = 4;
  }
  v15 = __clz(v24);
  v6 = 1;
  if (v15 >= 5)
    v6 = SDWORD2(v24) < 20;
  if (!v6)
    __assert_rtn("_ffpp_strtoencf32_l", "strtofp.c", 2901, "normalizeDigits <= 4 || info.digitCount < 20");
  v12 = (*((unint64_t *)&powersOf10_Float + v17 + 70) * (unsigned __int128)(unint64_t)((_QWORD)v24 << v15)) >> 64;
  v11 = __clz(v12);
  if (v11 >= 2)
    __assert_rtn("_ffpp_strtoencf32_l", "strtofp.c", 2919, "normalizeProduct <= 1");
  v13 = v12 << v11;
  v14 = ((unint64_t)(55732705 * v17) >> 24) + 1 - v15 + 64 - v11;
  v10 = v13 + v16;
  switch(v18)
  {
    case 0:
LABEL_31:
      v9 = (v13 + 0x7FFFFFFFFFLL) >> 40;
      v8 = (v10 + 0x8000000000) >> 40;
      break;
    case 4194304:
      if ((v28 & 1) != 0)
      {
        v9 = v13 >> 40;
        v8 = v10 >> 40;
      }
      else
      {
        v9 = (v13 + 0xFFFFFFFFFFLL) >> 40;
        v8 = (v10 + 0x10000000000) >> 40;
      }
      break;
    case 8388608:
      if ((v28 & 1) != 0)
      {
        v9 = (v13 + 0xFFFFFFFFFFLL) >> 40;
        v8 = (v10 + 0x10000000000) >> 40;
      }
      else
      {
        v9 = v13 >> 40;
        v8 = (v13 + 4) >> 40;
      }
      break;
    case 12582912:
      v9 = v13 >> 40;
      v8 = v10 >> 40;
      break;
    default:
      goto LABEL_31;
  }
  if (!v9)
    ++v14;
  if (v14 >= 129)
  {
    overflow((uint64_t)v19);
    return;
  }
  if (v14 <= -126)
  {
    if (v14 <= -150)
    {
      underflow((uint64_t)v19);
      return;
    }
    goto LABEL_44;
  }
  if (v8 != v9)
  {
LABEL_44:
    v5 = fegetround();
    generalSlowpath((uint64_t)v19, v5, v33, 32, 0);
    return;
  }
  v4 = 0x80000000;
  if ((v28 & 1) == 0)
    v4 = 0;
  *(_DWORD *)v20 = v4 | ((v14 << 23) + 1056964608) | v9 & 0x7FFFFF;
}

float strtof(const char *a1, char **a2)
{
  char v2;
  char v3;
  float v7;
  char **v8;
  const char *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t StatusReg;

  v9 = a1;
  v8 = a2;
  v7 = 0.0;
  v10 = 0;
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v10 = pthread_getspecific(__locale_key);
  }
  else
  {
    v11 = __locale_key;
    v12 = __locale_key;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v10 = *(void **)(StatusReg + 8 * v12);
  }
  if (v10)
    _ffpp_strtoencf32_l(&v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)v10);
  else
    _ffpp_strtoencf32_l(&v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)__global_locale);
  return v7;
}

float strtof_l(const char *a1, char **a2, locale_t a3)
{
  float v4;
  locale_t v5;
  char **v6;
  const char *v7;

  v7 = a1;
  v6 = a2;
  v5 = a3;
  v4 = 0.0;
  _ffpp_strtoencf32_l(&v4, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
  return v4;
}

void strtoencf64(double *a1, uint64_t a2, uint64_t a3)
{
  char v3;
  char v4;
  void *v8;
  uint64_t v9;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    _ffpp_strtoencf64_l(a1, a2, a3, (uint64_t)v8);
  else
    _ffpp_strtoencf64_l(a1, a2, a3, (uint64_t)__global_locale);
}

void _ffpp_strtoencf64_l(double *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  BOOL v7;
  uint64_t v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  unint64_t v15;
  uint64_t v16;
  BOOL v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  unint64_t v25;
  __int16 v26;
  __int16 v27;
  unsigned int v28;
  __int16 v29;
  int v30;
  double v31;
  _QWORD v32[4];
  double *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  double *v43;
  unsigned int v44[164];

  v43 = a1;
  v42 = a2;
  v41 = a3;
  v40 = a4;
  v39 = 0;
  v32[0] = 0xFFFFFC0200000035;
  v32[1] = 0x800000400;
  v32[2] = 0x136FFFFFEBBLL;
  v32[3] = 768;
  v33 = a1;
  v34 = a2;
  v35 = a3;
  v36 = a4;
  v37 = 0uLL;
  v38 = 0uLL;
  if (!fastParse64((uint64_t)v32))
    return;
  if (SHIDWORD(v38) >= -22 && SHIDWORD(v38) <= 18)
  {
    if ((HIDWORD(v38) & 0x80000000) != 0)
    {
      if (SDWORD2(v37) <= 15)
      {
        if ((v39 & 1) != 0)
          v8 = -(uint64_t)v37;
        else
          v8 = v37;
        *v33 = (double)v8 / _ffpp_strtoencf64_l_doublePowerOf10[-HIDWORD(v38)];
        return;
      }
    }
    else if (HIDWORD(v38))
    {
      if (SDWORD2(v37) <= 19)
      {
        v31 = _ffpp_strtoencf64_l_doublePowerOf10[SHIDWORD(v38)];
        if ((v39 & 1) != 0)
          v31 = -v31;
        *v33 = (double)(v37 & 0x7FF) * v31 + (double)((unint64_t)v37 & 0xFFFFFFFFFFFFF800) * v31;
        return;
      }
    }
    else if (SDWORD2(v37) <= 19)
    {
      if ((v39 & 1) == 0)
      {
        *v33 = (double)(unint64_t)v37;
        return;
      }
      if ((v37 & 0x8000000000000000) == 0)
      {
        *v33 = (double)-(uint64_t)v37;
        return;
      }
    }
  }
  v30 = fegetround();
  if (SDWORD2(v37) > 19)
  {
    v29 = WORD6(v38) + WORD4(v37) - 19;
    v28 = 80;
  }
  else
  {
    v29 = WORD6(v38);
    v28 = 12;
  }
  v27 = (585 * v29 + 256) >> 14;
  v26 = v29 - 28 * v27;
  v25 = (powersOf10_CoarseBinary64[v27 + 15] * (unsigned __int128)*((unint64_t *)powersOf10_Exact64 + v26)) >> 64;
  v23 = __clz(v37);
  v7 = 1;
  if (v23 >= 5)
    v7 = SDWORD2(v37) < 20;
  if (!v7)
    __assert_rtn("_ffpp_strtoencf64_l", "strtofp.c", 3156, "normalizeDigits <= 4 || info.digitCount < 20");
  v20 = __clz((v25 * (unsigned __int128)(unint64_t)((_QWORD)v37 << v23)) >> 64);
  if (v20 >= 3)
    __assert_rtn("_ffpp_strtoencf64_l", "strtofp.c", 3176, "normalizeProduct <= 2");
  v21 = (v25 * (unsigned __int128)(unint64_t)((_QWORD)v37 << v23)) >> 64 << v20;
  v24 = ((unint64_t)(55732705 * (__int16)(28 * v27)) >> 24) + ((unint64_t)(55732705 * v26) >> 24) + 2;
  v22 = v24 - v23 + 64 - v20;
  v17 = v39 & 1;
  switch(v30)
  {
    case 0:
      goto LABEL_40;
    case 4194304:
      v17 = (v39 & 1) == 0;
      break;
    case 8388608:
      break;
    case 12582912:
      goto LABEL_39;
    default:
LABEL_40:
      v19 = 1023;
      v18 = v28 + 1024;
      goto LABEL_41;
  }
  if (!v17)
  {
LABEL_39:
    v19 = 0;
    v18 = v28;
    goto LABEL_41;
  }
  v19 = 2047;
  v18 = v28 + 2048;
LABEL_41:
  v15 = (v21 + (unint64_t)v19) >> 11;
  v14 = v24 - v23 + 64 - v20;
  if (!v15)
    v14 = v22 + 1;
  if (v14 >= 1025)
  {
    overflow((uint64_t)v32);
    return;
  }
  if (v14 <= -1022)
  {
    if (v14 <= -1075)
    {
      underflow((uint64_t)v32);
      return;
    }
    v13 = -1010 - v22;
    if (-1010 - v22 >= 63 && v22 != -1073)
      goto LABEL_77;
    v6 = 0;
    if (v13 >= 1)
      v6 = v13 < 64;
    if (!v6)
      __assert_rtn("_ffpp_strtoencf64_l", "strtofp.c", 3240, "0 < shift && shift < 64");
    v10 = v39 & 1;
    switch(v30)
    {
      case 0:
        goto LABEL_63;
      case 4194304:
        v10 = (v39 & 1) == 0;
        break;
      case 8388608:
        break;
      case 12582912:
LABEL_62:
        v12 = 0;
        v11 = v28;
        goto LABEL_64;
      default:
LABEL_63:
        v12 = (1 << (13 - v22)) - 1;
        v11 = (1 << (13 - v22)) + v28;
LABEL_64:
        v16 = (unint64_t)(v21 + v12) >> v13;
        if ((unint64_t)(v21 + v11) >> v13 == v16)
        {
          if (!v16)
            v16 = 1 << (v22 - 14);
          v4 = 0x8000000000000000;
          if ((v39 & 1) == 0)
            v4 = 0;
          v9 = v4 | v16;
          if ((v4 | v16) != 0x10000000000000)
            *__error() = 34;
          *(_QWORD *)v33 = v9;
          return;
        }
LABEL_77:
        generalSlowpath((uint64_t)v32, v30, v44, 164, 0);
        return;
    }
    if (v10)
    {
      v12 = (1 << v13) - 1;
      v11 = v12 + v28;
      goto LABEL_64;
    }
    goto LABEL_62;
  }
  if ((v21 + (unint64_t)v18) >> 11 != v15)
    goto LABEL_77;
  v5 = 0x8000000000000000;
  if ((v39 & 1) == 0)
    v5 = 0;
  *(_QWORD *)v33 = v5 | ((unint64_t)(v14 + 1022) << 52) | v15 & 0xFFFFFFFFFFFFFLL;
}

void strtoencf64x(double *a1, uint64_t a2, uint64_t a3)
{
  char v3;
  char v4;
  void *v8;
  uint64_t v9;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    _ffpp_strtoencf64_l(a1, a2, a3, (uint64_t)v8);
  else
    _ffpp_strtoencf64_l(a1, a2, a3, (uint64_t)__global_locale);
}

double strtod(const char *a1, char **a2)
{
  char v2;
  char v3;
  double v7[3];
  void *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t StatusReg;

  *(_QWORD *)&v7[2] = a1;
  *(_QWORD *)&v7[1] = a2;
  v7[0] = 0.0;
  v8 = 0;
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v10 = __locale_key;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v8 = *(void **)(StatusReg + 8 * v10);
  }
  if (v8)
    _ffpp_strtoencf64_l(v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)v8);
  else
    _ffpp_strtoencf64_l(v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)__global_locale);
  return v7[0];
}

double strtod_l(const char *a1, char **a2, locale_t a3)
{
  double v4[4];

  *(_QWORD *)&v4[3] = a1;
  *(_QWORD *)&v4[2] = a2;
  *(_QWORD *)&v4[1] = a3;
  v4[0] = 0.0;
  _ffpp_strtoencf64_l(v4, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
  return v4[0];
}

long double strtold(const char *a1, char **a2)
{
  char v2;
  char v3;
  double v7[3];
  void *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t StatusReg;

  *(_QWORD *)&v7[2] = a1;
  *(_QWORD *)&v7[1] = a2;
  v7[0] = 0.0;
  v8 = 0;
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v10 = __locale_key;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v8 = *(void **)(StatusReg + 8 * v10);
  }
  if (v8)
    _ffpp_strtoencf64_l(v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)v8);
  else
    _ffpp_strtoencf64_l(v7, (uint64_t)a1, (uint64_t)a2, (uint64_t)__global_locale);
  return v7[0];
}

long double strtold_l(const char *a1, char **a2, locale_t a3)
{
  double v4[4];

  *(_QWORD *)&v4[3] = a1;
  *(_QWORD *)&v4[2] = a2;
  *(_QWORD *)&v4[1] = a3;
  v4[0] = 0.0;
  _ffpp_strtoencf64_l(v4, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3);
  return v4[0];
}

uint64_t fastParse64(uint64_t a1)
{
  lconv *v1;
  char v2;
  unsigned int v4;
  unsigned __int8 *v5;
  int v6;
  int v7;
  _BYTE *v8;
  int v9;
  unsigned __int8 v10;
  unsigned __int8 n;
  int v12;
  unsigned __int8 *v13;
  unsigned int v14;
  unsigned int k;
  unsigned int v16;
  unsigned int m;
  int v18;
  char *j;
  int v20;
  unsigned __int8 *v21;
  unsigned __int8 v22;
  unsigned __int8 i;
  unsigned __int8 *v24;
  unsigned __int8 *v25;
  char *ii;
  int v27;
  char *decimal_point;
  int v29;
  int v30;
  uint64_t v31;
  unsigned __int8 *v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;

  v32 = *(unsigned __int8 **)(a1 + 40);
  v31 = 0;
  v30 = 0;
  v29 = 0;
  *(_BYTE *)(a1 + 96) = 0;
  while (*v32 < 0x30u || *v32 > 0x39u)
  {
    if (*v32 == 45)
    {
      *(_BYTE *)(a1 + 96) = 1;
      ++v32;
      break;
    }
    if (*v32 == 43)
    {
      ++v32;
      break;
    }
    if (*v32 != 32 && !isspace(*v32))
      break;
    ++v32;
  }
  switch(*v32)
  {
    case '0':
      if (v32[1] == 120 || v32[1] == 88)
      {
        hexFloat((uint64_t)v32, a1);
        return 0;
      }
      while (*v32 == 48)
        ++v32;
LABEL_67:
      v24 = v32;
      v22 = *v32 - 48;
      if (v22 < 0xAu)
      {
        v31 = v22;
        for (i = *++v32 - 48; i < 0xAu; i = *v32 - 48)
        {
          v31 = 10 * v31 + i;
          ++v32;
        }
        v30 = (_DWORD)v32 - (_DWORD)v24;
      }
      if (*(_QWORD *)(a1 + 56))
      {
        if (*v32 != 32 && *v32 && *v32 != 101 && *v32 != 69)
        {
          v1 = localeconv_l(*(locale_t *)(a1 + 56));
          if (!v1->decimal_point[1])
          {
            if (*(unsigned __int8 *)v1->decimal_point == *v32)
              ++v32;
            goto LABEL_90;
          }
          v21 = v32;
          v20 = 1;
          for (j = v1->decimal_point; *j; ++j)
            v20 = v20 & (*v32++ == *j);
          if (v20)
          {
LABEL_90:
            v18 = (int)v32;
            if (v30)
            {
              v14 = *v32 - 48;
              if (v14 < 0xA)
              {
                ++v32;
                v31 = 10 * v31 + v14;
                for (k = *v32 - 48; k < 0xA; k = *v32 - 48)
                {
                  ++v32;
                  v31 = 10 * v31 + k;
                }
              }
              v30 += (_DWORD)v32 - v18;
            }
            else
            {
              while (*v32 == 48)
                ++v32;
              v24 = v32;
              v16 = *v32 - 48;
              if (v16 < 0xA)
              {
                ++v32;
                v31 = v16;
                for (m = *v32 - 48; m < 0xA; m = *v32 - 48)
                {
                  v31 = 10 * v31 + m;
                  ++v32;
                }
              }
              v30 = (_DWORD)v32 - (_DWORD)v24;
            }
            v29 = v18 - (_DWORD)v32;
            goto LABEL_104;
          }
          v32 = v21;
        }
      }
      else if (*v32 == 46)
      {
        ++v32;
        goto LABEL_90;
      }
LABEL_104:
      if (*v32 == 101 || *v32 == 69)
      {
        v13 = v32;
        v34 = v32 + 1;
        v12 = 1;
        if (*v34 == 45)
        {
          v12 = -1;
          ++v34;
        }
        else if (*v34 == 43)
        {
          ++v34;
        }
        v10 = *v34 - 48;
        if (v10 >= 0xAu)
        {
          v32 = v13;
        }
        else
        {
          v9 = v10;
          v32 = v34 + 1;
          for (n = *v32 - 48; n < 0xAu; n = *v32 - 48)
          {
            ++v32;
            v9 = 10 * v9 + n;
          }
          if (v32 - v13 > 9)
          {
            v8 = v13 + 1;
            if (v13[1] == 45 || *v8 == 43)
              v8 = v13 + 2;
            while (*v8 == 48)
              ++v8;
            if (v32 - v8 > 8)
              v9 = 99999999;
          }
          v29 += v9 * v12;
        }
      }
      if (*(_QWORD *)(a1 + 48))
        **(_QWORD **)(a1 + 48) = v32;
      if (v30)
      {
        if (v29 + v30 >= *(_DWORD *)(a1 + 16))
        {
          if (v29 + v30 <= *(_DWORD *)(a1 + 20))
          {
            v7 = 0;
            if (v30 <= 19)
            {
              v25 = 0;
            }
            else
            {
              v31 = 0;
              v6 = 0;
              v5 = v24;
              while (v6 < 19)
              {
                v4 = *v5 - 48;
                if (v4 < 0xA)
                {
                  v31 = 10 * v31 + v4;
                  ++v6;
                }
                ++v5;
              }
              v25 = v5;
              v7 = v30 - 19;
            }
            *(_DWORD *)(a1 + 72) = v30;
            *(_QWORD *)(a1 + 80) = v25;
            *(_DWORD *)(a1 + 88) = v7;
            *(_QWORD *)(a1 + 64) = v31;
            *(_DWORD *)(a1 + 92) = v29;
            return 1;
          }
          else
          {
            overflow(a1);
            return 0;
          }
        }
        else
        {
          underflow(a1);
          return 0;
        }
      }
      else
      {
        _platform_bzero(*(_QWORD *)(a1 + 32), *(int *)(a1 + 12));
        if ((*(_BYTE *)(a1 + 96) & 1) != 0)
          v2 = 0x80;
        else
          v2 = 0;
        *(_BYTE *)(*(_QWORD *)(a1 + 32) + *(_DWORD *)(a1 + 12) - 1) = v2;
        return 0;
      }
    case 'i':
    case 'I':
      if ((v32[1] == 110 || v32[1] == 78) && (v32[2] == 102 || v32[2] == 70))
      {
        if ((v32[3] == 105 || v32[3] == 73)
          && (v32[4] == 110 || v32[4] == 78)
          && (v32[5] == 105 || v32[5] == 73)
          && (v32[6] == 116 || v32[6] == 84)
          && (v32[7] == 121 || v32[7] == 89))
        {
          v33 = v32 + 8;
        }
        else
        {
          v33 = v32 + 3;
        }
        if (*(_QWORD *)(a1 + 48))
          **(_QWORD **)(a1 + 48) = v33;
        infinity(a1);
        return 0;
      }
      break;
    case 'n':
    case 'N':
      if ((v32[1] == 97 || v32[1] == 65) && (v32[2] == 110 || v32[2] == 78))
      {
        parseNan((uint64_t)v32, a1);
        return 0;
      }
      break;
    default:
      if (*v32 >= 0x30u && *v32 <= 0x39u)
        goto LABEL_67;
      if (*(_QWORD *)(a1 + 56))
      {
        decimal_point = localeconv_l(*(locale_t *)(a1 + 56))->decimal_point;
        if (decimal_point[1])
        {
          v27 = 1;
          for (ii = decimal_point; *ii; ++ii)
            v27 = v27 & (*v32++ == *ii);
          if (v27 && *v32 >= 0x30u && *v32 <= 0x39u)
            goto LABEL_90;
        }
        else if (*decimal_point == *v32 && *++v32 >= 0x30u && *v32 <= 0x39u)
        {
          goto LABEL_90;
        }
      }
      else if (*v32 == 46 && *++v32 >= 0x30u && *v32 <= 0x39u)
      {
        goto LABEL_90;
      }
      break;
  }
  if (*(_QWORD *)(a1 + 48))
    **(_QWORD **)(a1 + 48) = *(_QWORD *)(a1 + 40);
  _platform_bzero(*(_QWORD *)(a1 + 32), *(int *)(a1 + 12));
  return 0;
}

void generalSlowpath(uint64_t a1, int a2, unsigned int *a3, int a4, char a5)
{
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  char v15;
  unint64_t v16;
  int v17;
  int v18;
  unsigned __int16 v19;
  char v20;
  unint64_t v21;
  unint64_t v22;
  __int128 v23;
  int v24;
  __int128 v25;
  __int128 v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  unsigned int *v32;
  unsigned int *v33;
  unint64_t v34;
  unint64_t v35;
  unsigned int *v36;
  int v37;
  int v38;
  int v39;
  int v40;
  __int128 v41;
  __int128 v42;
  int v43;
  unsigned int *v44;
  unsigned int *v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  int v52;
  unsigned int *v53;
  int v54;
  __int128 v55;
  unsigned __int8 v56;
  int v57;
  unsigned int *v58;
  int v59;
  uint64_t v60;

  v60 = a1;
  v59 = a2;
  v58 = a3;
  v57 = a4;
  v56 = a5 & 1;
  v55 = 0uLL;
  v54 = 0;
  v53 = 0;
  v52 = 0;
  v52 = *(_DWORD *)(a1 + 72);
  if (v52 > *(_DWORD *)(a1 + 24))
    v52 = *(_DWORD *)(v60 + 24) + 1;
  v51 = 0;
  v51 = *(_DWORD *)(v60 + 92) - v52 + *(_DWORD *)(v60 + 72);
  v50 = (1701 * v52) >> 9;
  v49 = (v50 + 31) / 32;
  v48 = 0;
  if (v51 >= 0)
    v18 = v51;
  else
    v18 = -v51;
  v48 = (1189 * (v18 + 1)) >> 9;
  v47 = (v48 + 31) / 32;
  if (v51 >= 0)
  {
    v46 = v49 + v47;
    v44 = 0;
    v45 = 0;
    if (v49 + v47 <= v57)
    {
      _platform_bzero(v58, 4 * v57);
      v45 = v58;
      v44 = v58;
      goto LABEL_14;
    }
    if (((v56 ^ 1) & 1) != 0)
      __assert_rtn("generalSlowpath", "strtofp.c", 1867, "heapAllocOK");
    v53 = (unsigned int *)calloc(v46, 4uLL);
    if (v53)
    {
      v45 = v53;
      v44 = v53;
LABEL_14:
      initMPFromDigits((uint64_t)&v44, v60);
      multiplyByFiveToTheN(&v44, v51);
      if (v45 - v44 > v46)
        __assert_rtn("generalSlowpath", "strtofp.c", 1879, "(workMP.msw - workMP.lsw) <= totalWordsNeeded");
      v43 = bitCountMP((uint64_t)v44, (uint64_t)v45);
      v54 = v43 + v51;
      *(_QWORD *)&v42 = shiftRightMPWithRounding((uint64_t)v44, (uint64_t)v45, v43 - *(_DWORD *)v60, 0, *(_BYTE *)(v60 + 96) & 1, v59);
      *((_QWORD *)&v42 + 1) = v5;
      v55 = v42;
      v6 = bitCountMP(v42, v5);
      if (v6 > *(_DWORD *)v60)
      {
        ++v54;
        *(_QWORD *)&v41 = shiftRightMPWithTruncation(v55, *((uint64_t *)&v55 + 1), 1);
        *((_QWORD *)&v41 + 1) = v7;
        v55 = v41;
      }
      if (v54 > *(_DWORD *)(v60 + 8))
      {
        free(v53);
        overflow(v60);
        return;
      }
      goto LABEL_53;
    }
LABEL_12:
    _platform_bzero(*(_QWORD *)(v60 + 32), *(int *)(v60 + 12));
    return;
  }
  v40 = v50;
  if (v50 < v48 + *(_DWORD *)v60 + 2)
    v40 = v48 + *(_DWORD *)v60 + 2;
  v39 = (v40 + 31) / 32 + 2;
  v38 = v47;
  v37 = v39 + v47;
  v36 = 0;
  if (v39 + v47 > v57)
  {
    if (((v56 ^ 1) & 1) != 0)
      __assert_rtn("generalSlowpath", "strtofp.c", 1925, "heapAllocOK");
    v53 = (unsigned int *)calloc(v37, 4uLL);
    if (!v53)
      goto LABEL_12;
    v36 = v53;
  }
  else
  {
    _platform_bzero(v58, 4 * v57);
    v36 = v58;
  }
  v34 = (unint64_t)v36;
  v35 = (unint64_t)v36;
  v32 = &v36[v39];
  v33 = v32;
  fiveToTheN((uint64_t)&v32, -v51);
  if (v33 - v32 > v38)
    __assert_rtn("generalSlowpath", "strtofp.c", 1940, "(denominator.msw - denominator.lsw) <= denominatorWordsNeeded");
  if (!*(v33 - 1))
    __assert_rtn("generalSlowpath", "strtofp.c", 1941, "denominator.msw[-1] != 0");
  initMPFromDigits((uint64_t)&v34, v60);
  if (!*(_DWORD *)(v35 - 4))
    __assert_rtn("generalSlowpath", "strtofp.c", 1946, "numerator.msw[-1] != 0");
  v31 = 0;
  v17 = bitCountMP((uint64_t)v32, (uint64_t)v33);
  v8 = bitCountMP(v34, v35);
  v31 = v17 - v8 + *(_DWORD *)v60 + 2;
  if (v31 <= 0)
  {
    v31 = 0;
  }
  else
  {
    shiftLeftMP(&v34, v31);
    if (!*(_DWORD *)(v35 - 4))
      __assert_rtn("generalSlowpath", "strtofp.c", 1950, "numerator.msw[-1] != 0");
    if ((uint64_t)(v35 - v34) / 4 >= v39)
      __assert_rtn("generalSlowpath", "strtofp.c", 1951, "(numerator.msw - numerator.lsw) < numeratorWordsNeeded");
  }
  v30 = 0;
  v28 = divideMPByMP(v34, v35, v32, (unint64_t)v33, &v30);
  v29 = v9;
  v27 = bitCountMP(v28, v9);
  v54 = v27 + v51 - v31;
  if (v54 <= *(_DWORD *)(v60 + 4))
  {
    if (v54 <= *(_DWORD *)(v60 + 4) - *(_DWORD *)v60)
    {
      free(v53);
      underflow(v60);
      return;
    }
    v24 = v54 - (*(_DWORD *)(v60 + 4) - *(_DWORD *)v60 + 1);
    v54 = *(_DWORD *)(v60 + 4);
    *(_QWORD *)&v23 = shiftRightMPWithRounding(v28, v29, v27 - v24, v30, *(_BYTE *)(v60 + 96) & 1, v59);
    *((_QWORD *)&v23 + 1) = v13;
    v55 = v23;
    v14 = bitCountMP(v23, v13);
    if (v14 < *(_DWORD *)v60)
      *__error() = 34;
    else
      ++v54;
  }
  else
  {
    *(_QWORD *)&v26 = shiftRightMPWithRounding(v28, v29, v27 - *(_DWORD *)v60, v30, *(_BYTE *)(v60 + 96) & 1, v59);
    *((_QWORD *)&v26 + 1) = v10;
    v55 = v26;
    v11 = bitCountMP(v26, v10);
    if (v11 > *(_DWORD *)v60)
    {
      ++v54;
      *(_QWORD *)&v25 = shiftRightMPWithTruncation(v55, *((uint64_t *)&v55 + 1), 1);
      *((_QWORD *)&v25 + 1) = v12;
      v55 = v25;
    }
    if (v54 > *(_DWORD *)(v60 + 8))
    {
      free(v53);
      overflow(v60);
      return;
    }
  }
LABEL_53:
  v22 = (*((_QWORD *)&v55 + 1) - (_QWORD)v55) / 4;
  v21 = (*(_DWORD *)v60 + 31) / 32;
  if (v22 < v21)
    _platform_bzero(v55 + 4 * v22, 4 * (v21 - v22));
  j___platform_memmove(*(_QWORD *)(v60 + 32), v55, (*(_DWORD *)v60 + 7) / 8u);
  free(v53);
  v19 = v54 - *(_DWORD *)(v60 + 4);
  if (*(int *)(v60 + 12) <= 8)
    v19 <<= 15 - (8 * *(_BYTE *)(v60 + 12) - *(_BYTE *)v60);
  if ((*(_BYTE *)(v60 + 96) & 1) != 0)
    v15 = 0x80;
  else
    v15 = 0;
  v20 = HIBYTE(v19) | v15;
  v16 = (*(_DWORD *)(v60 + 12) - 2);
  if (v16 <= 0xE)
    __asm { BR              X8 }
  *(_BYTE *)(*(_QWORD *)(v60 + 32) + *(int *)(v60 + 12) - 1) = v20;
}

uint64_t hexFloat(uint64_t result, uint64_t a2)
{
  __int16 v2;
  unsigned int v3;
  unint64_t v4;
  int v5;
  int v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  unint64_t v11;
  int v12;
  int v13;
  unsigned int j;
  int v15;
  int v16;
  _BYTE *v17;
  int v18;
  _BYTE *i;
  _BYTE *v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  _BYTE *v28;
  uint64_t v30;

  v30 = result;
  v28 = (_BYTE *)(result + 2);
  v27 = 0;
  v25 = 0;
  v24 = 0;
  v22 = 0;
  while (1)
  {
    v10 = 0;
    if (hexdigit[*v28] < 0x10u)
      v10 = v27 < 0x1000000000000000;
    if (!v10)
      break;
    v27 = 16 * v27 + hexdigit[*v28++];
  }
  while (1)
  {
    v9 = 0;
    if (hexdigit[*v28] < 0x10u)
      v9 = v25 < 0x800000000000000;
    if (!v9)
      break;
    v25 = (16 * v25) | (v27 >> 60);
    v27 = 16 * v27 + hexdigit[*v28++];
  }
  while (hexdigit[*v28] < 0x10u)
  {
    v24 |= hexdigit[*v28];
    v22 += 4;
    ++v28;
  }
  v21 = (_DWORD)v28 - (result + 2);
  if (*(_QWORD *)(a2 + 56))
  {
    result = (uint64_t)localeconv_l(*(locale_t *)(a2 + 56));
    v20 = v28;
    for (i = *(_BYTE **)result; *i; ++i)
    {
      if (*v28 != *i)
      {
        v28 = v20;
        goto LABEL_34;
      }
      ++v28;
    }
  }
  else
  {
    if (*v28 != 46)
      goto LABEL_34;
    ++v28;
  }
  v18 = (int)v28;
  if (!v25)
  {
    while (1)
    {
      v8 = 0;
      if (hexdigit[*v28] < 0x10u)
        v8 = v27 < 0x1000000000000000;
      if (!v8)
        break;
      v27 = 16 * v27 + hexdigit[*v28++];
    }
  }
  while (1)
  {
    v7 = 0;
    if (hexdigit[*v28] < 0x10u)
      v7 = v25 < 0x800000000000000;
    if (!v7)
      break;
    v25 = (16 * v25) | (v27 >> 60);
    v27 = 16 * v27 + hexdigit[*v28++];
  }
  v22 -= 4 * ((_DWORD)v28 - v18);
  while (hexdigit[*v28] < 0x10u)
    v24 |= hexdigit[*v28++];
  v21 += (_DWORD)v28 - v18;
LABEL_34:
  if (*v28 == 112 || *v28 == 80)
  {
    v17 = v28++;
    v16 = 0;
    if (*v28 == 45)
    {
      v16 = 1;
      ++v28;
    }
    else if (*v28 == 43)
    {
      ++v28;
    }
    if (*v28 >= 0x30u && *v28 <= 0x39u)
    {
      v15 = 0;
      for (j = *v28 - 48; j < 0xA; j = *v28 - 48)
      {
        if (v15 <= 99999999)
          v15 = 10 * v15 + j;
        else
          v15 = 99999999;
        ++v28;
      }
      if (v16)
        v15 = -v15;
      v22 += v15;
    }
    else
    {
      v28 = v17;
    }
  }
  if (!v27 && !v25)
  {
    if (!v21)
      v28 = (_BYTE *)(v30 + 1);
    v23 = *(_DWORD *)(a2 + 4);
    goto LABEL_111;
  }
  if (!v25)
  {
    if ((v27 & 0x8000000000000000) != 0)
    {
      v25 = v27 >> 1;
      v27 <<= 63;
      v22 -= 63;
    }
    else
    {
      v25 = v27;
      v27 = 0;
      v22 -= 64;
    }
  }
  v13 = __clz(v25) - 1;
  if (v13 > 0)
  {
    v25 = (v25 << v13) | (v27 >> (64 - v13));
    v27 <<= v13;
    v22 -= v13;
  }
  v23 = v22 + 127;
  if (v24)
    v27 |= 1uLL;
  if (v23 <= *(_DWORD *)(a2 + 8) && v23 >= *(_DWORD *)(a2 + 4) - *(_DWORD *)a2 + 1)
  {
    if (v23 <= *(_DWORD *)(a2 + 4))
    {
      v12 = 128 - (v23 - *(_DWORD *)(a2 + 4) + *(_DWORD *)a2);
      v23 = *(_DWORD *)(a2 + 4);
    }
    else
    {
      v12 = 127 - *(_DWORD *)a2;
    }
    if (v12 >= 64)
    {
      v11 = (v25 << (0x80 - v12)) | (v27 >> (v12 - 64));
      if (v27 << (0x80 - v12))
        v11 |= 1uLL;
      v27 = v25 >> (v12 - 64);
      v26 = 0;
    }
    else
    {
      v11 = v27 << (64 - v12);
      v27 = (v27 >> v12) | (v25 << (64 - v12));
      v26 = v25 >> v12;
    }
    result = fegetround();
    switch((_DWORD)result)
    {
      case 0:
        goto LABEL_133;
      case 0x400000:
        if ((*(_BYTE *)(a2 + 96) & 1) == 0)
        {
          if (v11)
          {
            if (!++v27)
              ++v26;
          }
        }
        goto LABEL_95;
      case 0x800000:
        if ((*(_BYTE *)(a2 + 96) & 1) != 0)
        {
          if (v11)
          {
            if (!++v27)
              ++v26;
          }
        }
        goto LABEL_95;
    }
    if ((_DWORD)result != 12582912)
    {
LABEL_133:
      if ((v11 > 0x8000000000000000 || v11 == 0x8000000000000000 && (v27 & 1) != 0) && !++v27)
        ++v26;
    }
LABEL_95:
    if (v23 == *(_DWORD *)(a2 + 4))
      v6 = *(_DWORD *)a2 - 1;
    else
      v6 = *(_DWORD *)a2;
    if (v6 > 64 && v26 >> (v6 - 64) || v6 == 64 && v26 || v6 < 64 && (v26 || v27 >> v6))
    {
      if (v23 > *(_DWORD *)(a2 + 4))
        v27 = (v27 >> 1) | (v26 << 63);
      ++v23;
    }
    else if (v23 == *(_DWORD *)(a2 + 4) && v11)
    {
      result = (uint64_t)__error();
      *(_DWORD *)result = 34;
    }
  }
LABEL_111:
  if (*(_QWORD *)(a2 + 48))
    **(_QWORD **)(a2 + 48) = v28;
  if (v23 > *(_DWORD *)(a2 + 8))
    return overflow(a2);
  if (v23 < *(_DWORD *)(a2 + 4) - *(_DWORD *)a2 + 1)
    return underflow(a2);
  v5 = *(_DWORD *)(a2 + 12);
  switch(v5)
  {
    case 2:
      if ((*(_BYTE *)(a2 + 96) & 1) != 0)
        v2 = 0x8000;
      else
        v2 = 0;
      **(_WORD **)(a2 + 32) = v2 | (((_WORD)v23 - (unsigned __int16)*(_DWORD *)(a2 + 4)) << 10) | v27 & 0x3FF;
      break;
    case 4:
      v3 = 0x80000000;
      if ((*(_BYTE *)(a2 + 96) & 1) == 0)
        v3 = 0;
      **(_DWORD **)(a2 + 32) = v3 | ((v23 - *(_DWORD *)(a2 + 4)) << 23) | v27 & 0x7FFFFF;
      break;
    case 8:
      v4 = 0x8000000000000000;
      if ((*(_BYTE *)(a2 + 96) & 1) == 0)
        v4 = 0;
      **(_QWORD **)(a2 + 32) = v4 | ((uint64_t)(v23 - *(_DWORD *)(a2 + 4)) << 52) | v27 & 0xFFFFFFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t infinity(uint64_t result)
{
  __int16 v1;
  int v2;
  unint64_t v3;
  int v4;

  v4 = *(_DWORD *)(result + 12);
  switch(v4)
  {
    case 2:
      if ((*(_BYTE *)(result + 96) & 1) != 0)
        v1 = -1024;
      else
        v1 = 31744;
      **(_WORD **)(result + 32) = v1;
      break;
    case 4:
      v2 = -8388608;
      if ((*(_BYTE *)(result + 96) & 1) == 0)
        v2 = 2139095040;
      **(_DWORD **)(result + 32) = v2;
      break;
    case 8:
      v3 = 0xFFF0000000000000;
      if ((*(_BYTE *)(result + 96) & 1) == 0)
        v3 = 0x7FF0000000000000;
      **(_QWORD **)(result + 32) = v3;
      break;
    default:
      return _platform_bzero(*(_QWORD *)(result + 32), *(int *)(result + 12));
  }
  return result;
}

uint64_t parseNan(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  char v3;
  char v4;
  char v5;
  int v6;
  BOOL v7;
  __int128 v8;
  __int128 v9;
  unsigned int v10;
  _BYTE *v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  v14 = a1;
  v13 = a2;
  v12 = (_BYTE *)(a1 + 3);
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v11 = (_BYTE *)(a1 + 3);
  if (*(_BYTE *)(a1 + 3) == 40)
  {
    ++v12;
    v10 = 10;
    if (*v12 == 48)
    {
      if (*++v12 == 120)
      {
        v10 = 16;
        ++v12;
      }
      else
      {
        v10 = 8;
      }
    }
    *(_QWORD *)&v9 = &v15;
    *((_QWORD *)&v9 + 1) = &v17;
    v8 = v9;
    while (hexdigit[*v12] < v10)
    {
      multiplyMPByN((uint64_t)&v8, v10);
      addToMP((uint64_t)&v8, hexdigit[*v12]);
      *((_QWORD *)&v8 + 1) = *((_QWORD *)&v9 + 1);
      ++v12;
    }
    if (*v12 == 41)
    {
      ++v12;
    }
    else
    {
      v15 = 0;
      v16 = 0;
      v17 = 0;
      while (1)
      {
        v7 = 0;
        if (*v12)
          v7 = *v12 != 41;
        if (!v7)
          break;
        ++v12;
      }
      if (*v12 == 41)
        ++v12;
      else
        v12 = v11;
    }
  }
  result = j___platform_memmove(*(_QWORD *)(v13 + 32), &v15, *(int *)(v13 + 12));
  v6 = *(_DWORD *)(v13 + 12);
  switch(v6)
  {
    case 2:
      if ((*(_BYTE *)(v13 + 96) & 1) != 0)
        v3 = -2;
      else
        v3 = 126;
      *(_BYTE *)(*(_QWORD *)(v13 + 32) + 1) |= v3;
      break;
    case 4:
      *(_BYTE *)(*(_QWORD *)(v13 + 32) + 2) |= 0xC0u;
      if ((*(_BYTE *)(v13 + 96) & 1) != 0)
        v4 = -1;
      else
        v4 = 127;
      *(_BYTE *)(*(_QWORD *)(v13 + 32) + 3) = v4;
      break;
    case 8:
      *(_BYTE *)(*(_QWORD *)(v13 + 32) + 6) |= 0xF8u;
      if ((*(_BYTE *)(v13 + 96) & 1) != 0)
        v5 = -1;
      else
        v5 = 127;
      *(_BYTE *)(*(_QWORD *)(v13 + 32) + 7) = v5;
      break;
  }
  if (*(_QWORD *)(v13 + 48))
    **(_QWORD **)(v13 + 48) = v12;
  return result;
}

uint64_t underflow(uint64_t a1)
{
  uint64_t result;
  __int16 v2;
  unsigned int v3;
  unint64_t v4;
  int v5;
  unsigned __int8 v6;

  *__error() = 34;
  v6 = 0;
  result = fegetround();
  if ((_DWORD)result == 0x800000 && (*(_BYTE *)(a1 + 96) & 1) != 0
    || (_DWORD)result == 0x400000 && (*(_BYTE *)(a1 + 96) & 1) == 0)
  {
    v6 = 1;
  }
  v5 = *(_DWORD *)(a1 + 12);
  switch(v5)
  {
    case 2:
      if ((*(_BYTE *)(a1 + 96) & 1) != 0)
        v2 = 0x8000;
      else
        v2 = 0;
      **(_WORD **)(a1 + 32) = v2 | v6;
      break;
    case 4:
      v3 = 0x80000000;
      if ((*(_BYTE *)(a1 + 96) & 1) == 0)
        v3 = 0;
      **(_DWORD **)(a1 + 32) = v3 | v6;
      break;
    case 8:
      v4 = 0x8000000000000000;
      if ((*(_BYTE *)(a1 + 96) & 1) == 0)
        v4 = 0;
      **(_QWORD **)(a1 + 32) = v4 | v6;
      break;
  }
  return result;
}

uint64_t overflow(uint64_t a1)
{
  int v2;

  *__error() = 34;
  v2 = fegetround();
  if (v2 == 12582912
    || v2 == 0x800000 && (*(_BYTE *)(a1 + 96) & 1) == 0
    || v2 == 0x400000 && (*(_BYTE *)(a1 + 96) & 1) != 0)
  {
    return max_value(a1);
  }
  else
  {
    return infinity(a1);
  }
}

uint64_t multiplyMPByN(uint64_t result, unsigned int a2)
{
  _DWORD *i;
  unint64_t v3;
  unint64_t v4;

  v3 = 0;
  for (i = *(_DWORD **)result; (unint64_t)i < *(_QWORD *)(result + 8); ++i)
  {
    v4 = v3 + *i * (unint64_t)a2;
    *i = v4;
    v3 = HIDWORD(v4);
  }
  while (v3)
  {
    **(_DWORD **)(result + 8) = v3;
    v3 >>= 32;
    *(_QWORD *)(result + 8) += 4;
  }
  return result;
}

uint64_t addToMP(uint64_t result, unint64_t a2)
{
  BOOL v2;
  _DWORD *i;
  unint64_t v5;

  for (i = *(_DWORD **)result; ; ++i)
  {
    v2 = 0;
    if (a2)
      v2 = (unint64_t)i < *(_QWORD *)(result + 8);
    if (!v2)
      break;
    v5 = a2 + *i;
    *i = v5;
    a2 = HIDWORD(v5);
  }
  while (a2)
  {
    *i = a2;
    a2 >>= 32;
    ++i;
  }
  if ((unint64_t)i > *(_QWORD *)(result + 8))
    *(_QWORD *)(result + 8) = i;
  return result;
}

uint64_t max_value(uint64_t result)
{
  __int16 v1;
  int v2;
  unint64_t v3;
  int v4;

  v4 = *(_DWORD *)(result + 12);
  switch(v4)
  {
    case 2:
      if ((*(_BYTE *)(result + 96) & 1) != 0)
        v1 = -1025;
      else
        v1 = 31743;
      **(_WORD **)(result + 32) = v1;
      break;
    case 4:
      v2 = -8388609;
      if ((*(_BYTE *)(result + 96) & 1) == 0)
        v2 = 2139095039;
      **(_DWORD **)(result + 32) = v2;
      break;
    case 8:
      v3 = 0xFFEFFFFFFFFFFFFFLL;
      if ((*(_BYTE *)(result + 96) & 1) == 0)
        v3 = 0x7FEFFFFFFFFFFFFFLL;
      **(_QWORD **)(result + 32) = v3;
      break;
    default:
      return _platform_memset(*(_QWORD *)(result + 32), 0xFFFFFFFFLL, *(int *)(result + 12));
  }
  return result;
}

uint64_t initMPFromDigits(uint64_t result, uint64_t a2)
{
  int v2;
  unsigned int k;
  int j;
  unint64_t v5;
  _BYTE *v6;
  int v7;
  uint64_t v8;
  unint64_t i;
  _DWORD *v10;
  uint64_t v11;

  v11 = result;
  v10 = *(_DWORD **)result;
  for (i = *(_QWORD *)(a2 + 64); i; i >>= 32)
    *v10++ = i;
  *(_QWORD *)(result + 8) = v10;
  v8 = *(unsigned int *)(a2 + 88);
  v7 = 0;
  if (*(_DWORD *)(a2 + 72) > *(_DWORD *)(a2 + 24))
  {
    LODWORD(v8) = *(_DWORD *)(a2 + 24) - (*(_DWORD *)(a2 + 72) - *(_DWORD *)(a2 + 88));
    v7 = *(_DWORD *)(a2 + 88) - v8;
  }
  v6 = *(_BYTE **)(a2 + 80);
  while ((int)v8 > 0)
  {
    if ((int)v8 <= 9)
      v2 = v8;
    else
      v2 = 9;
    v5 = 0;
    for (j = 0; j < v2; ++j)
    {
      for (k = *v6 - 48; k > 9; k = *v6 - 48)
        ++v6;
      v5 = 10 * v5 + k;
      ++v6;
    }
    multiplyMPByN(v11, initMPFromDigits_powersOfTen[v2]);
    result = addToMP(v11, v5);
    LODWORD(v8) = v8 - v2;
  }
  if (v7 > 0)
  {
    result = multiplyMPByN(v11, 0xAu);
    while (v7 > 0)
    {
      if (*v6 == 48)
      {
        --v7;
      }
      else if (*v6 >= 0x31u && *v6 <= 0x39u)
      {
        return addToMP(v11, 1uLL);
      }
      ++v6;
    }
  }
  return result;
}

unsigned int **multiplyByFiveToTheN(unsigned int **result, int a2)
{
  unsigned int v2;
  BOOL v3;
  __int128 v4;
  unsigned int *v5;
  BOOL v6;
  unsigned int *v7;
  uint64_t v8;
  BOOL v9;
  uint64_t v10;
  char v11;
  __int128 v12;
  unsigned int *v13;
  BOOL v14;
  unsigned int *v15;
  int v16;
  unsigned int *v17;
  __int128 v18;
  unsigned __int128 v19;
  unsigned int *v20;
  unsigned __int128 v21;

  while (a2 > 40)
  {
    v21 = 0u;
    v20 = *result;
    while (v20 < result[1])
    {
      v2 = v21 - 1413876383 * *v20;
      v3 = __CFADD__((_QWORD)v21, 0xC35CA4BFABB9F561 * *v20);
      *(_QWORD *)&v4 = v21 - 0x3CA35B4054460A9FLL * *v20;
      *((_QWORD *)&v4 + 1) = ((__PAIR128__(493038065, 0xC35CA4BFABB9F561) * *v20) >> 64)
                           + v3
                           + *((_QWORD *)&v21 + 1);
      v5 = v20++;
      *v5 = v2;
      *(_QWORD *)&v4 = v4 >> 32;
      *((_QWORD *)&v4 + 1) >>= 32;
      v21 = v4;
    }
    while (1)
    {
      v6 = (_QWORD)v21 == 0;
      if (*((_QWORD *)&v21 + 1))
        v6 = 0;
      if (v6)
        break;
      v7 = v20++;
      *v7 = v21;
      v21 >>= 32;
    }
    result[1] = v20;
    a2 -= 40;
  }
  while (a2 > 0)
  {
    v19 = 0u;
    if (a2 <= 27)
      v16 = a2;
    else
      v16 = 27;
    v18 = powersOfFive[v16];
    v17 = *result;
    while (v17 < result[1])
    {
      v8 = *v17 * (_QWORD)v18;
      v9 = __CFADD__((_QWORD)v19, v8);
      v10 = v19 + v8;
      v11 = v9;
      *(_QWORD *)&v12 = v10;
      *((_QWORD *)&v12 + 1) = ((v18 * (unsigned __int128)*v17) >> 64) + ((v11 & 1) != 0) + *((_QWORD *)&v19 + 1);
      v13 = v17++;
      *v13 = v10;
      *(_QWORD *)&v12 = v12 >> 32;
      *((_QWORD *)&v12 + 1) >>= 32;
      v19 = v12;
    }
    while (1)
    {
      v14 = (_QWORD)v19 == 0;
      if (*((_QWORD *)&v19 + 1))
        v14 = 0;
      if (v14)
        break;
      v15 = v17++;
      *v15 = v19;
      v19 >>= 32;
    }
    result[1] = v17;
    a2 -= 27;
  }
  return result;
}

uint64_t bitCountMP(uint64_t a1, uint64_t a2)
{
  if (a2 == a1)
  {
    return 0;
  }
  else
  {
    if (!*(_DWORD *)(a2 - 4))
      __assert_rtn("bitCountMP", "strtofp.c", 1056, "work.msw[-1] != 0");
    return (32 - __clz(*(_DWORD *)(a2 - 4)) + 32 * ((a2 - a1) / 4 - 1));
  }
}

uint64_t shiftRightMPWithRounding(uint64_t a1, uint64_t a2, int a3, int a4, char a5, int a6)
{
  _DWORD *i;
  unsigned int v8;
  _DWORD *j;
  unint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  unsigned int v13;
  _DWORD *m;
  _DWORD *k;
  int v16;
  int v17;
  char v18;
  int v19;
  int v20;
  __int128 v21;
  __int128 v22;

  *(_QWORD *)&v21 = a1;
  *((_QWORD *)&v21 + 1) = a2;
  v19 = a4;
  v18 = a5 & 1;
  if (!a3)
    return v21;
  if (a3 < 0)
  {
    shiftLeftMP(&v21, -a3);
    return v21;
  }
  v22 = v21;
  v17 = a3 / 32;
  v16 = a3 % 32;
  if (a3 % 32)
  {
    *(_QWORD *)&v22 = v22 + 4 * v17;
    v13 = *(_DWORD *)v22 & ((1 << v16) - 1);
    v12 = (unsigned int *)(v22 + 4);
    v10 = (*(_DWORD *)v22 >> v16);
    while ((unint64_t)v12 < *((_QWORD *)&v22 + 1))
    {
      v11 = v10 | ((unint64_t)*v12 << (32 - v16));
      *(v12 - 1) = v11;
      v10 = HIDWORD(v11);
      ++v12;
    }
    if (v10)
      *(v12 - 1) = v10;
    else
      *((_QWORD *)&v22 + 1) -= 4;
    if (!a6)
      goto LABEL_49;
    if (a6 != 0x400000)
    {
      if (a6 != 0x800000)
      {
        if (a6 == 12582912)
          return v22;
LABEL_49:
        v8 = 1 << (v16 - 1);
        if (v13 >= v8)
        {
          if (v13 > v8)
            goto LABEL_59;
          for (i = (_DWORD *)v21; (unint64_t)i < (unint64_t)v22; ++i)
            v19 |= *i;
          if (v19 || *((_QWORD *)&v22 + 1) > (unint64_t)v22 && (*(_DWORD *)v22 & 1) != 0)
            goto LABEL_59;
        }
        return v22;
      }
      v18 = !(a5 & 1);
    }
    v20 = a4 | v13;
    for (j = (_DWORD *)v21; (unint64_t)j < (unint64_t)v22; ++j)
      v20 |= *j;
    if ((v18 & 1) == 0 && v20)
      goto LABEL_59;
    return v22;
  }
  *(_QWORD *)&v22 = v22 + 4 * v17;
  switch(a6)
  {
    case 0:
      break;
    case 4194304:
LABEL_12:
      for (k = (_DWORD *)v21; (unint64_t)k < (unint64_t)v22; ++k)
        v19 |= *k;
      if ((v18 & 1) == 0 && v19)
        goto LABEL_59;
      return v22;
    case 8388608:
      v18 = !(a5 & 1);
      goto LABEL_12;
    case 12582912:
      return v22;
  }
  if (*(_DWORD *)(v22 - 4) >= 0x80000000)
  {
    if (*(_DWORD *)(v22 - 4) > 0x80000000)
      goto LABEL_59;
    for (m = (_DWORD *)v21; (unint64_t)m < (uint64_t)v22 - 4; ++m)
      v19 |= *m;
    if (v19 || *((_QWORD *)&v22 + 1) > (unint64_t)v22 && (*(_DWORD *)v22 & 1) != 0)
LABEL_59:
      addToMP((uint64_t)&v22, 1uLL);
  }
  return v22;
}

uint64_t shiftRightMPWithTruncation(uint64_t a1, uint64_t a2, int a3)
{
  return shiftRightMPWithRounding(a1, a2, a3, 0, 0, 12582912);
}

unsigned int **fiveToTheN(uint64_t a1, int a2)
{
  unsigned int *v2;
  int v4;
  unsigned int *v5;
  unint64_t v6;

  if (a2 <= 27)
    v4 = a2;
  else
    v4 = 27;
  v6 = powersOfFive[v4];
  v5 = *(unsigned int **)a1;
  while (v6)
  {
    v2 = v5++;
    *v2 = v6;
    v6 >>= 32;
  }
  *(_QWORD *)(a1 + 8) = v5;
  return multiplyByFiveToTheN((unsigned int **)a1, a2 - v4);
}

_QWORD *shiftLeftMP(_QWORD *result, int a2)
{
  _DWORD *i;
  unint64_t v3;
  unint64_t v4;
  int v5;
  int v6;
  _QWORD *v7;

  v7 = result;
  v6 = a2 / 32;
  v5 = a2 % 32;
  if (a2 / 32 > 0)
  {
    _platform_memmove(*result + 4 * v6, *result, 4 * ((result[1] - *result) / 4));
    result = (_QWORD *)_platform_bzero(*v7, 4 * v6);
    v7[1] += 4 * v6;
  }
  if (v5 > 0)
  {
    v3 = 0;
    for (i = (_DWORD *)*v7; (unint64_t)i < v7[1]; ++i)
    {
      v4 = v3 | ((unint64_t)*i << v5);
      *i = v4;
      v3 = HIDWORD(v4);
    }
    if (v3)
    {
      *i = v3;
      v7[1] = i + 1;
    }
  }
  return result;
}

uint64_t divideMPByMP(unint64_t a1, unint64_t a2, unsigned int *a3, unint64_t a4, _DWORD *a5)
{
  unint64_t v5;
  BOOL v6;
  BOOL v8;
  _DWORD *j;
  int v10;
  _DWORD *v11;
  unsigned int *v12;
  _DWORD *v13;
  unsigned int *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unsigned int v20;
  int i;
  int v22;
  int v23;
  unsigned int v24;
  unsigned int *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unsigned int *v30;
  unint64_t v31;
  __int128 v32;
  __int128 v33;

  *(_QWORD *)&v32 = a1;
  *((_QWORD *)&v32 + 1) = a2;
  v30 = a3;
  v31 = a4;
  if (a2 <= a1)
    __assert_rtn("divideMPByMP", "strtofp.c", 1343, "numerator.msw > numerator.lsw");
  if (v31 <= (unint64_t)v30)
    __assert_rtn("divideMPByMP", "strtofp.c", 1344, "denominator.msw > denominator.lsw");
  if (!*(_DWORD *)(*((_QWORD *)&v32 + 1) - 4))
    __assert_rtn("divideMPByMP", "strtofp.c", 1345, "numerator.msw[-1] != 0");
  if (!*(_DWORD *)(v31 - 4))
    __assert_rtn("divideMPByMP", "strtofp.c", 1346, "denominator.msw[-1] != 0");
  if ((uint64_t)(v31 - (_QWORD)v30) / 4 == 1)
  {
    v28 = *v30;
    v26 = 0;
    v25 = (unsigned int *)*((_QWORD *)&v32 + 1);
    while ((unint64_t)v25 > (unint64_t)v32)
    {
      v27 = (v26 << 32) + *--v25;
      v24 = v27 / v28;
      *v25 = v24;
      v26 = v27 - v24 * v28;
    }
    *a5 = v26 != 0;
    while (!*(_DWORD *)(*((_QWORD *)&v32 + 1) - 4))
      *((_QWORD *)&v32 + 1) -= 4;
    return v32;
  }
  else
  {
    v23 = __clz(*(_DWORD *)(v31 - 4));
    shiftLeftMP(&v30, v23);
    shiftLeftMP(&v32, v23);
    if (*(_DWORD *)(*((_QWORD *)&v32 + 1) - 4) >= *(_DWORD *)(v31 - 4))
    {
      **((_DWORD **)&v32 + 1) = 0;
      *((_QWORD *)&v32 + 1) += 4;
    }
    v8 = 1;
    if (*((_QWORD *)&v32 + 1) >= (unint64_t)v30)
      v8 = v31 < (unint64_t)v32;
    if (!v8)
      __assert_rtn("divideMPByMP", "strtofp.c", 1390, "(numerator.msw < denominator.lsw) || (denominator.msw < numerator.lsw)");
    *(_QWORD *)&v33 = *((_QWORD *)&v32 + 1) + 4;
    *((_QWORD *)&v33 + 1) = *((_QWORD *)&v32 + 1) + 4;
    v22 = (*((_QWORD *)&v32 + 1) - (_QWORD)v32) / 4 - (uint64_t)(v31 - (_QWORD)v30) / 4;
    for (i = 0; i < v22; ++i)
    {
      v19 = *(unsigned int *)(*((_QWORD *)&v32 + 1) - 8)
          + ((unint64_t)*(unsigned int *)(*((_QWORD *)&v32 + 1) - 4) << 32);
      if (*(_DWORD *)(*((_QWORD *)&v32 + 1) - 4) == *(_DWORD *)(v31 - 4))
        v20 = -1;
      else
        v20 = v19 / *(unsigned int *)(v31 - 4);
      while (1)
      {
        v18 = v19 - v20 * (unint64_t)*(unsigned int *)(v31 - 4);
        if (v18 > 0xFFFFFFFF
          || *(unsigned int *)(v31 - 8) * (unint64_t)v20 <= *(unsigned int *)(*((_QWORD *)&v32 + 1) - 12)
                                                                 + (v18 << 32))
        {
          break;
        }
        --v20;
      }
      v15 = 0;
      v14 = v30;
      v13 = (_DWORD *)(*((_QWORD *)&v32 + 1) + 4 * ((uint64_t)(v31 - (_QWORD)v30) / -4) - 4);
      while ((unint64_t)v14 < v31)
      {
        v5 = v15 + v20 * (unint64_t)*v14;
        v6 = *v13 < v5;
        *v13 -= v5;
        v15 = HIDWORD(v5) + v6;
        ++v13;
        ++v14;
      }
      if (*(unsigned int *)(*((_QWORD *)&v32 + 1) - 4) < v15)
      {
        --v20;
        v16 = 0;
        v12 = v30;
        v11 = (_DWORD *)(*((_QWORD *)&v32 + 1) + 4 * ((uint64_t)(v31 - (_QWORD)v30) / -4) - 4);
        while ((unint64_t)v12 < v31)
        {
          v17 = v16 + *v11 + (unint64_t)*v12;
          *v11 = v17;
          v16 = HIDWORD(v17);
          ++v11;
          ++v12;
        }
      }
      *(_QWORD *)&v33 = v33 - 4;
      *(_DWORD *)v33 = v20;
      *((_QWORD *)&v32 + 1) -= 4;
    }
    v10 = 0;
    for (j = (_DWORD *)v32; (unint64_t)j < *((_QWORD *)&v32 + 1); ++j)
      v10 |= *j;
    *a5 = v10 != 0;
    while (!*(_DWORD *)(*((_QWORD *)&v33 + 1) - 4))
      *((_QWORD *)&v33 + 1) -= 4;
  }
  return v33;
}

int lchflags(const char *a1, __uint32_t a2)
{
  __int128 v3;
  uint64_t v4;
  __uint32_t v5;
  const char *v6;

  v6 = a1;
  v5 = a2;
  v3 = xmmword_D24C8;
  v4 = 0;
  return setattrlist(a1, &v3, &v5, 4uLL, 1u);
}

int lchmod(const char *a1, mode_t a2)
{
  int v3;
  _QWORD v4[3];
  mode_t v5;
  const char *v6;

  v6 = a1;
  v5 = a2;
  v4[1] = 0;
  v4[2] = 0;
  v4[0] = 0x2000000000005;
  v3 = a2;
  return setattrlist(a1, v4, &v3, 4uLL, 1u);
}

int lutimes(const char *a1, const timeval *a2)
{
  timeval v3;
  unsigned __int128 v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  stat v9;
  const timeval *v10;
  const char *v11;

  v11 = a1;
  v10 = a2;
  _platform_memset(&v9, 0, 144);
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v4 = 0u;
  v5 = 0u;
  if (lstat(v11, &v9) < 0)
    return -1;
  if ((v9.st_mode & 0xF000) == 0xA000)
  {
    v7 = 0;
    v8 = 0;
    v6 = 0x140000000005;
    if (v10)
    {
      *(_QWORD *)&v5 = v10->tv_sec;
      *((_QWORD *)&v5 + 1) = 1000 * v10->tv_usec;
      *(_QWORD *)&v4 = v10[1].tv_sec;
      *((_QWORD *)&v4 + 1) = 1000 * v10[1].tv_usec;
    }
    else
    {
      v3.tv_sec = 0;
      *(_QWORD *)&v3.tv_usec = 0;
      if (gettimeofday(&v3, 0) < 0)
        return -1;
      *(_QWORD *)&v5 = v3.tv_sec;
      *((_QWORD *)&v5 + 1) = 1000 * v3.tv_usec;
      v4 = __PAIR128__(*((unint64_t *)&v5 + 1), v3.tv_sec);
    }
    return setattrlist(v11, &v6, &v4, 0x20uLL, 1u);
  }
  return utimes(v11, v10);
}

int fstatvfs(int a1, statvfs *a2)
{
  int v3;
  statfs v6;

  _platform_bzero(&v6, 512);
  v3 = fstatfs(a1, &v6);
  if (!v3)
    cvt_statfs_to_statvfs(&v6.f_bsize, (uint64_t)a2);
  return v3;
}

unsigned int *cvt_statfs_to_statvfs(unsigned int *result, uint64_t a2)
{
  *(_QWORD *)a2 = (int)result[1];
  *(_QWORD *)(a2 + 8) = *result;
  *(_DWORD *)(a2 + 16) = *((_QWORD *)result + 1);
  *(_DWORD *)(a2 + 20) = *((_QWORD *)result + 2);
  *(_DWORD *)(a2 + 24) = *((_QWORD *)result + 3);
  *(_DWORD *)(a2 + 28) = *((_QWORD *)result + 4);
  *(_DWORD *)(a2 + 32) = *((_QWORD *)result + 5);
  *(_DWORD *)(a2 + 36) = *((_QWORD *)result + 5);
  *(_QWORD *)(a2 + 40) = (int)result[12];
  *(_QWORD *)(a2 + 56) = 255;
  *(_QWORD *)(a2 + 48) = 0;
  if ((result[16] & 1) != 0)
    *(_QWORD *)(a2 + 48) |= 1uLL;
  if ((result[16] & 8) != 0)
    *(_QWORD *)(a2 + 48) |= 2uLL;
  return result;
}

int statvfs(const char *a1, statvfs *a2)
{
  int v3;
  statfs v6;

  _platform_bzero(&v6, 512);
  v3 = statfs(a1, &v6);
  if (!v3)
    cvt_statfs_to_statvfs(&v6.f_bsize, (uint64_t)a2);
  return v3;
}

uint64_t (*backtrace_set_pcs_func(uint64_t (*result)(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5)))(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5)
{
  uint64_t (*v1)(uint64_t, int, _DWORD *, int, unint64_t);

  if (result)
    v1 = result;
  else
    v1 = _thread_stack_pcs;
  backtrace_get_pcs_func = (uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v1;
  return result;
}

int backtrace(void **a1, int a2)
{
  BOOL v3;
  _DWORD v4[2];
  void **v5;

  v5 = a1;
  v4[1] = a2;
  v4[0] = 0;
  backtrace_get_pcs_func(a1, a2, v4, 1, 0);
  while (1)
  {
    v3 = 0;
    if (v4[0])
      v3 = v5[v4[0] - 1] == 0;
    if (!v3)
      break;
    --v4[0];
  }
  return v4[0];
}

uint64_t backtrace_async(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  BOOL v4;
  int v5;
  unsigned int v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = 0;
  v5 = _thread_stack_async_pcs(a1, a2, &v6, 1, 0);
  while (1)
  {
    v4 = 0;
    if (v6)
      v4 = *(_QWORD *)(v9 + 8 * (v6 - 1)) == 0;
    if (!v4)
      break;
    --v6;
  }
  if (v7)
    *v7 = v5;
  return v6;
}

int backtrace_from_fp(void *startfp, void **array, int size)
{
  BOOL v4;
  _DWORD v5[2];
  void **v6;
  void *v7;

  v7 = startfp;
  v6 = array;
  v5[1] = size;
  v5[0] = 0;
  _thread_stack_pcs((uint64_t)array, size, v5, 1, (unint64_t)startfp);
  while (1)
  {
    v4 = 0;
    if (v5[0])
      v4 = v6[v5[0] - 1] == 0;
    if (!v4)
      break;
    --v5[0];
  }
  return v5[0];
}

void backtrace_image_offsets(void *const *array, image_offset *image_offsets, int size)
{
  uint64_t v3;
  uint64_t v4;
  char *v5;
  int i;
  uint64_t v7;
  uint64_t *v8;
  int v9;
  image_offset *v10;
  void *const *v11;

  v11 = array;
  v10 = image_offsets;
  v9 = size;
  v8 = &v3;
  v5 = (char *)&v3 - ((32 * size + 15) & 0xFFFFFFFFFFFFFFF0);
  v7 = size;
  _dyld_images_for_addresses(size, array);
  for (i = 0; i < v9; ++i)
  {
    v4 = 20;
    uuid_copy(v10[i].uuid, (const unsigned __int8 *)&v5[32 * i]);
    *(_DWORD *)&v10->uuid[i * v4 + 16] = *(_QWORD *)&v5[32 * i + 16];
  }
}

uint64_t __confstr_init(uint64_t result)
{
  __dirhelper_func = *(_UNKNOWN **)(result + 32);
  return result;
}

uint64_t __dirhelper(unsigned int a1, uint64_t a2, uint64_t a3)
{
  if (__dirhelper_func)
    return __dirhelper_func(a1, a2, a3);
  else
    return 0;
}

size_t confstr(int a1, char *a2, size_t a3)
{
  _BYTE v13[1032];
  char *v14;
  char *v15;
  char *v16;
  int v17;
  int v18;
  char *v19;
  int v20;
  size_t v21;
  size_t v22;
  char *v23;
  int v24;
  int v26[2];

  v24 = a1;
  v23 = a2;
  v22 = a3;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  v17 = a1;
  if (a1 != 1)
  {
    if ((v17 - 2) <= 2)
      goto LABEL_58;
    if (v17 != 6 && v17 != 5)
    {
      if (v17 == 7)
        goto LABEL_58;
      if (v17 == 9 || v17 == 8)
        goto LABEL_60;
      if (v17 == 10)
        goto LABEL_58;
      if (v17 == 12 || v17 == 11)
        goto LABEL_60;
      if (v17 == 13)
        goto LABEL_58;
      if (v17 == 14)
      {
        v19 = "_POSIX_V6_LP64_OFF64";
        goto LABEL_62;
      }
      if ((v17 - 20) <= 3)
      {
LABEL_58:
        v19 = (char *)&unk_D495D;
        goto LABEL_62;
      }
      if (v17 != 25 && v17 != 24)
      {
        if (v17 == 27 || v17 == 26)
          goto LABEL_58;
        if (v17 != 29 && v17 != 28)
        {
          if (v17 == 31 || v17 == 30)
            goto LABEL_58;
          if (v17 != 33 && v17 != 32)
          {
            if (v17 != 35 && v17 != 34)
            {
              if (v17 != 0x10000)
              {
                if (v17 == 65537)
                {
                  v15 = v13;
                  _platform_bzero(v13, 1024);
                  v19 = v15;
                  if (!v15)
                    goto LABEL_84;
                  if (!__dirhelper(1u, (uint64_t)v19, 1024))
                  {
                    v18 = 0;
                    v18 = *__error();
                    v19 = getenv("TMPDIR");
                    if (!v19 || access(v19, 2))
                    {
                      v19 = "/var/tmp/";
                      if (access("/var/tmp/", 2))
                      {
                        if (v18 == 12)
                          *__error() = 12;
                        else
                          *__error() = 5;
                        return 0;
                      }
                    }
                  }
                }
                else
                {
                  if (v17 != 65538)
                  {
                    *__error() = 22;
                    return 0;
                  }
                  v14 = v13;
                  _platform_bzero(v13, 1024);
                  v19 = v14;
                  if (!v14)
                  {
LABEL_84:
                    *__error() = 12;
                    return 0;
                  }
                  if (!__dirhelper(2u, (uint64_t)v19, 1024))
                  {
                    if (*__error() != 12)
                      *__error() = 5;
                    return 0;
                  }
                }
                goto LABEL_62;
              }
              v16 = v13;
              _platform_bzero(v13, 1024);
              v19 = v16;
              if (!v16)
                goto LABEL_84;
              if (!__dirhelper(0, (uint64_t)v19, 1024))
              {
                if (*__error() != 12)
                  *__error() = 5;
                return 0;
              }
LABEL_62:
              if (v22 && v23)
                _platform_strlcpy(v23, v19, v22);
              return _platform_strlen(v19) + 1;
            }
            goto LABEL_58;
          }
        }
LABEL_60:
        v19 = "-W 64";
        goto LABEL_62;
      }
    }
    v19 = "-W 32";
    goto LABEL_62;
  }
  v26[0] = 8;
  v26[1] = 1;
  if (sysctl(v26, 2u, 0, &v21, 0, 0) != -1)
  {
    if (v22 && v23)
    {
      v19 = (char *)malloc_type_malloc(v21, 1675882533);
      if (!v19)
        return 0;
      if (sysctl(v26, 2u, v19, &v21, 0, 0) == -1)
      {
        v20 = *__error();
        free(v19);
        *__error() = v20;
        return 0;
      }
      _platform_strncpy(v23, v19, v22 - 1);
      v23[v22 - 1] = 0;
      free(v19);
    }
    return v21;
  }
  return 0;
}

char *__cdecl devname_r(dev_t a1, mode_t a2, char *buf, int len)
{
  stat v5;
  dirent *v6;
  DIR *v7;
  int v8;
  char *v9;
  mode_t v10;
  dev_t v11;
  char v13[5];
  uint64_t v14;

  v11 = a1;
  v10 = a2;
  v9 = buf;
  v8 = len;
  v7 = 0;
  v6 = 0;
  _platform_memset(&v5, 0, 144);
  _platform_strcpy(v13, "/dev/");
  v7 = opendir("/dev/");
  if (!v7)
    return 0;
  while (1)
  {
    v6 = readdir(v7);
    if (!v6)
      break;
    bcopy(v6->d_name, &v14, v6->d_namlen + 1);
    if (!lstat(v13, &v5) && v11 == v5.st_rdev && v10 == (v5.st_mode & 0xF000))
    {
      if (v6->d_namlen + 1 <= v8)
      {
        _platform_strcpy(v9, v6->d_name);
        closedir(v7);
        return v9;
      }
      break;
    }
  }
  closedir(v7);
  return 0;
}

char *__cdecl devname(dev_t a1, mode_t a2)
{
  if (devname_buf)
    return devname_r(a1, a2, (char *)devname_buf, 255);
  devname_buf = malloc_type_malloc(255, 3415254828);
  if (devname_buf)
    return devname_r(a1, a2, (char *)devname_buf, 255);
  else
    return 0;
}

uint64_t getdiskbyname(const char *a1)
{
  int v1;
  char v2;
  int v4;
  char v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  __int16 v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;
  int v15;
  int v16;
  __int16 v17;
  int v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _DWORD *v36;
  char v37[3];
  char v38[3];
  char v39[3];
  char v40[3];
  char v41;
  char v42;
  char v43;
  char v44;
  char *v45;
  char *i;
  char *v47;
  uint64_t *v48;
  const char *v49;
  char *v51[2];

  v49 = a1;
  v48 = 0;
  v47 = 0;
  *(_OWORD *)v51 = off_D8610;
  i = 0;
  v45 = 0;
  v44 = 0;
  v43 = 0;
  v36 = 0;
  if (cgetent(&v47, v51, a1) < 0)
    return 0;
  if (!getdiskbyname_dp)
  {
    getdiskbyname_dp = malloc_type_malloc(280, 0x101204068DD910ELL);
    if (!getdiskbyname_dp)
      return 0;
  }
  _platform_bzero(getdiskbyname_dp, 280);
  v45 = (char *)(getdiskbyname_dp + 8);
  for (i = v47; ; ++i)
  {
    v19 = 0;
    if ((unint64_t)v45 < getdiskbyname_dp + 23)
    {
      v1 = *i;
      *v45 = v1;
      v19 = 0;
      if (v1)
      {
        v19 = 0;
        if (*v45 != 124)
          v19 = *v45 != 58;
      }
    }
    if (!v19)
      break;
    ++v45;
  }
  *v45 = 0;
  cgetstr(v47, "b0", (char **)(getdiskbyname_dp + 24));
  cgetstr(v47, "b1", (char **)(getdiskbyname_dp + 32));
  if (cgetstr(v47, "ty", &v45) <= 0 || _platform_strcmp(v45, "removable"))
  {
    if (v45 && !_platform_strcmp(v45, "simulated"))
      *(_DWORD *)(getdiskbyname_dp + 88) |= 8u;
  }
  else
  {
    *(_DWORD *)(getdiskbyname_dp + 88) |= 1u;
  }
  if (cgetcap(v47, "sf", 58))
    *(_DWORD *)(getdiskbyname_dp + 88) |= 4u;
  v35 = 0;
  if (cgetnum(v47, "se", &v35) == -1)
    v18 = 512;
  else
    v18 = v35;
  *(_DWORD *)(getdiskbyname_dp + 40) = v18;
  cgetnum(v47, "nt", (uint64_t *)(getdiskbyname_dp + 48));
  cgetnum(v47, "ns", (uint64_t *)(getdiskbyname_dp + 44));
  cgetnum(v47, "nc", (uint64_t *)(getdiskbyname_dp + 52));
  if (cgetstr(v47, "dt", &v45) <= 0)
  {
    v34 = 0;
    if (cgetnum(v47, "dt", &v34) == -1)
      v17 = 0;
    else
      v17 = v34;
    *(_WORD *)(getdiskbyname_dp + 4) = v17;
  }
  else
  {
    *(_WORD *)(getdiskbyname_dp + 4) = gettype(v45, (const char **)dktypenames);
  }
  v33 = 0;
  if (cgetnum(v47, "sc", &v33) == -1)
    v16 = *(_DWORD *)(getdiskbyname_dp + 44) * *(_DWORD *)(getdiskbyname_dp + 48);
  else
    v16 = v33;
  *(_DWORD *)(getdiskbyname_dp + 56) = v16;
  v32 = 0;
  if (cgetnum(v47, "su", &v32) == -1)
    v15 = *(_DWORD *)(getdiskbyname_dp + 56) * *(_DWORD *)(getdiskbyname_dp + 52);
  else
    v15 = v32;
  *(_DWORD *)(getdiskbyname_dp + 60) = v15;
  v31 = 0;
  if (cgetnum(v47, "rm", &v31) == -1)
    v14 = 3600;
  else
    v14 = v31;
  *(_WORD *)(getdiskbyname_dp + 72) = v14;
  v30 = 0;
  if (cgetnum(v47, "il", &v30) == -1)
    v13 = 1;
  else
    v13 = v30;
  *(_WORD *)(getdiskbyname_dp + 74) = v13;
  v29 = 0;
  if (cgetnum(v47, "sk", &v29) == -1)
    v12 = 0;
  else
    v12 = v29;
  *(_WORD *)(getdiskbyname_dp + 76) = v12;
  v28 = 0;
  if (cgetnum(v47, "cs", &v28) == -1)
    v11 = 0;
  else
    v11 = v28;
  *(_WORD *)(getdiskbyname_dp + 78) = v11;
  v27 = 0;
  if (cgetnum(v47, "hs", &v27) == -1)
    v10 = 0;
  else
    v10 = v27;
  *(_DWORD *)(getdiskbyname_dp + 80) = v10;
  v26 = 0;
  if (cgetnum(v47, "ts", &v26) == -1)
    v9 = 0;
  else
    v9 = v26;
  *(_DWORD *)(getdiskbyname_dp + 84) = v9;
  v25 = 0;
  if (cgetnum(v47, "bs", &v25) == -1)
    v8 = 0x2000;
  else
    v8 = v25;
  *(_DWORD *)(getdiskbyname_dp + 140) = v8;
  v24 = 0;
  if (cgetnum(v47, "sb", &v24) == -1)
    v7 = 0x2000;
  else
    v7 = v24;
  *(_DWORD *)(getdiskbyname_dp + 144) = v7;
  _platform_strcpy(&v41, "px");
  _platform_strcpy(v40, "bx");
  _platform_strcpy(v39, "fx");
  _platform_strcpy(v38, "ox");
  _platform_strcpy(v37, "tx");
  v43 = 96;
  v48 = (uint64_t *)(getdiskbyname_dp + 148);
  v44 = 97;
  while (v44 < 105)
  {
    v37[1] = v44;
    v38[1] = v44;
    v39[1] = v44;
    v40[1] = v44;
    v42 = v44;
    if (cgetnum(v47, &v41, v48) == -1)
    {
      *(_DWORD *)v48 = 0;
    }
    else
    {
      cgetnum(v47, v38, (uint64_t *)((char *)v48 + 4));
      v23 = 0;
      if (cgetnum(v47, v39, &v23) == -1)
        v6 = 0;
      else
        v6 = v23;
      *((_DWORD *)v48 + 2) = v6;
      if (*((_DWORD *)v48 + 2))
      {
        v22 = 0;
        if (cgetnum(v47, v40, &v22))
          *((_BYTE *)v48 + 13) = 8;
        else
          *((_BYTE *)v48 + 13) = v22 / *((unsigned int *)v48 + 2);
      }
      v21 = 0;
      if (cgetnum(v47, v37, &v21) == -1)
        v5 = 0;
      else
        v5 = v21;
      *((_BYTE *)v48 + 12) = v5;
      if (!*((_BYTE *)v48 + 12) && cgetstr(v47, v37, &v45) > 0)
      {
        v2 = gettype(v45, (const char **)fstypenames);
        *((_BYTE *)v48 + 12) = v2;
      }
      v43 = v44;
    }
    ++v44;
    v48 += 2;
  }
  *(_WORD *)(getdiskbyname_dp + 138) = v43 - 96;
  _platform_strcpy(&v41, "dx");
  v36 = (_DWORD *)(getdiskbyname_dp + 92);
  v44 = 48;
  while (v44 < 53)
  {
    v42 = v44;
    v20 = 0;
    if (cgetnum(v47, &v41, &v20) == -1)
      v4 = 0;
    else
      v4 = v20;
    *v36 = v4;
    ++v44;
    ++v36;
  }
  *(_DWORD *)getdiskbyname_dp = -2108275369;
  *(_DWORD *)(getdiskbyname_dp + 132) = -2108275369;
  free(v47);
  return getdiskbyname_dp;
}

uint64_t gettype(const char *a1, const char **a2)
{
  const char **i;

  for (i = a2; *i; ++i)
  {
    if (!strcasecmp(a1, *i))
      return (i - a2);
  }
  if (isdigit(*a1))
    return atoi(a1);
  else
    return 0;
}

FTS *__cdecl fts_open(char *const *a1, int a2, int (__cdecl *a3)(const FTSENT **, const FTSENT **))
{
  uint64_t v4;
  int v6;

  v6 = a2;
  if ((a2 & 0xFFFFF300) != 0)
  {
    *__error() = 22;
    return 0;
  }
  else
  {
    if ((a2 & 0x800) != 0)
      v6 = a2 | 8;
    v4 = malloc_type_calloc(1, 72, 0x10B0040C1B4BCF7);
    if (v4)
    {
      *(_QWORD *)(v4 + 56) = a3;
      *(_DWORD *)(v4 + 64) = v6;
      return (FTS *)__fts_open((uint64_t *)a1, v4);
    }
    else
    {
      return 0;
    }
  }
}

uint64_t __fts_open(uint64_t *a1, uint64_t a2)
{
  int v2;
  __int16 v3;
  uint64_t v4;
  int v5;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v15;

  v15 = a1;
  v9 = 0;
  if ((*(_DWORD *)(a2 + 64) & 2) != 0)
    *(_DWORD *)(a2 + 64) |= 4u;
  if (fts_maxarglen(a1) <= 0x400)
  {
    v2 = fts_palloc(a2, 1024);
  }
  else
  {
    v7 = fts_maxarglen(v15);
    v2 = fts_palloc(a2, v7);
  }
  if (v2)
    goto LABEL_38;
  v10 = fts_alloc(a2, (uint64_t)&unk_D495D, 0);
  if (!v10)
  {
LABEL_37:
    free(*(void **)(a2 + 32));
LABEL_38:
    free((void *)a2);
    return 0;
  }
  *(_WORD *)(v10 + 86) = -1;
  v12 = 0;
  v11 = 0;
  while (*v15)
  {
    v8 = _platform_strlen(*v15);
    v13 = fts_alloc(a2, *v15, v8);
    if (!v13)
      goto LABEL_36;
    *(_WORD *)(v13 + 86) = 0;
    *(_QWORD *)(v13 + 8) = v10;
    *(_QWORD *)(v13 + 40) = v13 + 104;
    if ((*(_DWORD *)(a2 + 64) & 0x400) != 0)
      v3 = fts_stat(a2, v13, -1, -1);
    else
      v3 = fts_stat(a2, v13, *(_DWORD *)(a2 + 64) & 1, -1);
    *(_WORD *)(v13 + 88) = v3;
    if (*(_WORD *)(v13 + 88) == 5)
      *(_WORD *)(v13 + 88) = 1;
    if (*(_QWORD *)(a2 + 56))
    {
      *(_QWORD *)(v13 + 16) = v12;
      v12 = v13;
    }
    else
    {
      *(_QWORD *)(v13 + 16) = 0;
      if (v12)
        *(_QWORD *)(v9 + 16) = v13;
      else
        v12 = v13;
      v9 = v13;
    }
    ++v15;
    ++v11;
  }
  if (*(_QWORD *)(a2 + 56) && v11 > 1)
    v12 = fts_sort(a2, v12, v11);
  v4 = fts_alloc(a2, (uint64_t)&unk_D495D, 0);
  *(_QWORD *)a2 = v4;
  if (!v4)
  {
LABEL_36:
    fts_lfree(v12);
    fts_free((unsigned int *)v10);
    goto LABEL_37;
  }
  *(_QWORD *)(*(_QWORD *)a2 + 16) = v12;
  *(_WORD *)(*(_QWORD *)a2 + 88) = 9;
  if ((*(_DWORD *)(a2 + 64) & 4) == 0)
  {
    v5 = open_NOCANCEL(".", 0x1000000);
    *(_DWORD *)(a2 + 40) = v5;
    if (v5 < 0)
      *(_DWORD *)(a2 + 64) |= 4u;
  }
  if ((*(_DWORD *)(a2 + 64) & 4) == 0 && getenv("FTS_USE_THREAD_FCHDIR"))
    *(_DWORD *)(a2 + 64) |= 0x400u;
  if (!v11)
    fts_free((unsigned int *)v10);
  return a2;
}

FTS *__cdecl fts_open_b(char *const *a1, int a2, void *a3)
{
  uint64_t v4;
  int v6;

  v6 = a2;
  if ((a2 & 0xFFFFF300) != 0)
  {
    *__error() = 22;
    return 0;
  }
  else
  {
    if ((a2 & 0x800) != 0)
      v6 = a2 | 8;
    v4 = malloc_type_calloc(1, 72, 0x10B0040C1B4BCF7);
    if (v4)
    {
      *(_QWORD *)(v4 + 56) = _Block_copy(a3);
      *(_DWORD *)(v4 + 64) = v6 | 0x80000000;
      return (FTS *)__fts_open((uint64_t *)a1, v4);
    }
    else
    {
      return 0;
    }
  }
}

int fts_close(FTS *a1)
{
  unsigned int fts_rfd;
  _ftsent *fts_link;
  int v4;
  int v5;
  _ftsent *fts_cur;
  unsigned int *v7;

  v5 = 0;
  if (a1->fts_cur)
  {
    fts_cur = a1->fts_cur;
    while (fts_cur->fts_level >= 0)
    {
      v7 = (unsigned int *)fts_cur;
      if (fts_cur->fts_link)
        fts_link = fts_cur->fts_link;
      else
        fts_link = fts_cur->fts_parent;
      fts_cur = fts_link;
      fts_free(v7);
    }
    fts_free((unsigned int *)fts_cur);
  }
  if ((a1->fts_options & 4) != 0)
    fts_rfd = -1;
  else
    fts_rfd = a1->fts_rfd;
  if (a1->fts_child)
    fts_lfree((uint64_t)a1->fts_child);
  free(a1->fts_array);
  a1->fts_array = 0;
  free(a1->fts_path);
  a1->fts_path = 0;
  if (a1->fts_options < 0 && a1->fts_compar)
    _Block_release(a1->fts_compar);
  if (fts_rfd != -1)
  {
    v4 = *__error();
    if (fts_fchdir((uint64_t)a1, fts_rfd))
    {
      v5 = -1;
      v4 = *__error();
    }
    if (close_NOCANCEL(fts_rfd))
    {
      v5 = -1;
      v4 = *__error();
    }
    *__error() = v4;
  }
  free(a1);
  return v5;
}

void fts_free(unsigned int *a1)
{
  int v1;

  if ((a1[15] & 0x80000000) == 0)
  {
    v1 = *__error();
    close_NOCANCEL(a1[15]);
    *__error() = v1;
  }
  free(a1);
}

void fts_lfree(uint64_t a1)
{
  unsigned int *v1;

  while (1)
  {
    v1 = (unsigned int *)a1;
    if (!a1)
      break;
    a1 = *(_QWORD *)(a1 + 16);
    fts_free(v1);
  }
}

uint64_t fts_fchdir(uint64_t a1, unsigned int a2)
{
  if ((*(_DWORD *)(a1 + 64) & 0x400) != 0)
    return pthread_fchdir_np(a2);
  else
    return fchdir(a2);
}

FTSENT *__cdecl fts_read(FTS *a1)
{
  int v1;
  unsigned int *v2;
  int v3;
  char *v4;
  __int16 v5;
  int fts_pathlen;
  int v8;
  int fts_instr;
  _ftsent *v10;
  _ftsent *fts_cur;
  _ftsent *i;
  FTSENT *fts_parent;

  if (!a1->fts_cur || (a1->fts_options & 0x200) != 0)
    return 0;
  fts_cur = a1->fts_cur;
  fts_instr = a1->fts_cur->fts_instr;
  a1->fts_cur->fts_instr = 3;
  if (fts_instr == 1)
  {
    fts_cur->fts_info = fts_stat((uint64_t)a1, (uint64_t)fts_cur, 0, -1);
    return fts_cur;
  }
  if (fts_instr == 2 && (fts_cur->fts_info == 12 || fts_cur->fts_info == 13))
  {
    fts_cur->fts_info = fts_stat((uint64_t)a1, (uint64_t)fts_cur, 1, -1);
    if (fts_cur->fts_info == 1 && (a1->fts_options & 4) == 0)
    {
      v1 = open_NOCANCEL(".", 0x1000000);
      fts_cur->fts_symfd = v1;
      if (v1 >= 0)
      {
        fts_cur->fts_flags |= 2u;
      }
      else
      {
        fts_cur->fts_errno = *__error();
        fts_cur->fts_info = 7;
      }
    }
    return fts_cur;
  }
  else if (fts_cur->fts_info == 1)
  {
    if (fts_instr == 4 || (a1->fts_options & 0x40) != 0 && fts_cur->fts_dev != a1->fts_dev)
    {
      if ((fts_cur->fts_flags & 2) != 0)
      {
        close_NOCANCEL(fts_cur->fts_symfd);
        fts_cur->fts_symfd = -1;
      }
      if (a1->fts_child)
      {
        fts_lfree((uint64_t)a1->fts_child);
        a1->fts_child = 0;
      }
      fts_cur->fts_info = 6;
      return fts_cur;
    }
    else
    {
      if (a1->fts_child && (a1->fts_options & 0x100) != 0)
      {
        a1->fts_options &= ~0x100u;
        fts_lfree((uint64_t)a1->fts_child);
        a1->fts_child = 0;
      }
      if (a1->fts_child)
      {
        if (fts_safe_changedir((uint64_t)a1, (uint64_t)fts_cur, -1, (uint64_t)fts_cur->fts_accpath))
        {
          fts_cur->fts_errno = *__error();
          fts_cur->fts_flags |= 1u;
          for (i = a1->fts_child; i; i = i->fts_link)
            i->fts_accpath = i->fts_parent->fts_accpath;
        }
      }
      else
      {
        v2 = fts_build((uint64_t)a1, 3);
        a1->fts_child = (_ftsent *)v2;
        if (!v2)
        {
          if ((a1->fts_options & 0x200) != 0)
            return 0;
          else
            return fts_cur;
        }
      }
      fts_cur = a1->fts_child;
      a1->fts_child = 0;
LABEL_52:
      if (!fts_cur->fts_parent->fts_level
        && fts_cur->fts_parent->fts_pathlen == 1
        && *fts_cur->fts_parent->fts_path == 47)
      {
        fts_pathlen = 0;
      }
      else
      {
        fts_pathlen = fts_cur->fts_parent->fts_pathlen;
      }
      v4 = &a1->fts_path[fts_pathlen];
      *v4 = 47;
      _platform_memmove(v4 + 1, fts_cur->fts_name, fts_cur->fts_namelen + 1);
      a1->fts_cur = fts_cur;
      return fts_cur;
    }
  }
  else
  {
    while (1)
    {
      v10 = fts_cur;
      fts_cur = fts_cur->fts_link;
      if (!fts_cur)
        break;
      fts_free((unsigned int *)v10);
      if (!fts_cur->fts_level)
      {
        a1->fts_cur = fts_cur;
        if ((a1->fts_options & 4) != 0 || !fts_fchdir((uint64_t)a1, a1->fts_rfd))
        {
          fts_load((uint64_t)a1, (uint64_t)fts_cur);
          return a1->fts_cur;
        }
        else
        {
          a1->fts_options |= 0x200u;
          return 0;
        }
      }
      if (fts_cur->fts_instr != 4)
      {
        if (fts_cur->fts_instr == 2)
        {
          fts_cur->fts_info = fts_stat((uint64_t)a1, (uint64_t)fts_cur, 1, -1);
          if (fts_cur->fts_info == 1 && (a1->fts_options & 4) == 0)
          {
            v3 = open_NOCANCEL(".", 0x1000000);
            fts_cur->fts_symfd = v3;
            if (v3 >= 0)
            {
              fts_cur->fts_flags |= 2u;
            }
            else
            {
              fts_cur->fts_errno = *__error();
              fts_cur->fts_info = 7;
            }
          }
          fts_cur->fts_instr = 3;
        }
        goto LABEL_52;
      }
    }
    fts_parent = v10->fts_parent;
    fts_free((unsigned int *)v10);
    if (fts_parent->fts_level == -1)
    {
      fts_free((unsigned int *)fts_parent);
      *__error() = 0;
      a1->fts_cur = 0;
      return 0;
    }
    a1->fts_path[fts_parent->fts_pathlen] = 0;
    if (fts_parent->fts_level)
    {
      if ((fts_parent->fts_flags & 2) != 0)
      {
        if ((a1->fts_options & 4) == 0 && fts_fchdir((uint64_t)a1, fts_parent->fts_symfd))
        {
          v8 = *__error();
          close_NOCANCEL(fts_parent->fts_symfd);
          fts_parent->fts_symfd = -1;
          *__error() = v8;
          a1->fts_options |= 0x200u;
          a1->fts_cur = fts_parent;
          return 0;
        }
        close_NOCANCEL(fts_parent->fts_symfd);
        fts_parent->fts_symfd = -1;
      }
      else if ((fts_parent->fts_flags & 1) == 0
             && fts_safe_changedir((uint64_t)a1, (uint64_t)fts_parent, -1, (uint64_t)".."))
      {
        a1->fts_options |= 0x200u;
        a1->fts_cur = fts_parent;
        return 0;
      }
    }
    else if ((a1->fts_options & 4) == 0 && fts_fchdir((uint64_t)a1, a1->fts_rfd))
    {
      a1->fts_options |= 0x200u;
      a1->fts_cur = fts_parent;
      return 0;
    }
    if (fts_parent->fts_errno)
      v5 = 7;
    else
      v5 = 6;
    fts_parent->fts_info = v5;
    a1->fts_cur = fts_parent;
    return fts_parent;
  }
}

uint64_t fts_stat(uint64_t a1, uint64_t a2, int a3, int a4)
{
  return (unsigned __int16)fts_stat2(a1, a2, a3, a4, 0);
}

uint64_t fts_safe_changedir(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int v5;
  int v6;
  int v7;
  stat v8;
  stat v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;

  v16 = a1;
  v15 = a2;
  v14 = a3;
  v13 = a4;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  _platform_memset(&v9, 0, 144);
  v10 = v14;
  if ((*(_DWORD *)(v16 + 64) & 4) != 0)
    return 0;
  if (v14 < 0)
  {
    v10 = open_NOCANCEL(v13, 17825792);
    if ((v10 & 0x80000000) != 0)
      return -1;
  }
  if (!fstat(v10, &v9))
  {
    if (v14 == -1)
    {
      if (!_platform_strcmp(v13, "..") && (*(_WORD *)(v15 + 90) & 8) != 0)
      {
        close_NOCANCEL(v10);
        v10 = *(_DWORD *)(v15 + 60);
        *(_DWORD *)(v15 + 60) = -1;
        *(_WORD *)(v15 + 90) &= ~8u;
      }
    }
    else
    {
      _platform_memset(&v8, 0, 144);
      v7 = open_NOCANCEL(".", 0x1000000);
      if (v7 < 0)
      {
        v12 = -1;
        goto LABEL_20;
      }
      if (fstat(v7, &v8))
      {
        v11 = *__error();
        close_NOCANCEL(v7);
        v6 = v11;
        *__error() = v6;
        v12 = -1;
        goto LABEL_20;
      }
      if (v9.st_dev == v8.st_dev)
      {
        close_NOCANCEL(v7);
      }
      else
      {
        *(_DWORD *)(v15 + 60) = v7;
        *(_WORD *)(v15 + 90) |= 8u;
      }
    }
    v12 = fts_fchdir(v16, v10);
    goto LABEL_20;
  }
  v12 = -1;
LABEL_20:
  v11 = *__error();
  if (v14 < 0)
    close_NOCANCEL(v10);
  v5 = v11;
  *__error() = v5;
  return v12;
}

unsigned int *fts_build(uint64_t a1, int a2)
{
  int v2;
  int v3;
  int v4;
  _BYTE *v5;
  unsigned int *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE *v12;
  int v13;
  int v14;
  int v15;
  __int16 v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  _BYTE v22[64];
  unsigned int *v23;
  uint64_t v24;
  int v25;
  unsigned int *v26;
  unsigned int *v27;
  _BYTE *v28;
  _BYTE v29[172];
  int v30;
  uint64_t v31;

  v31 = a1;
  v30 = a2;
  _platform_memset(v29, 0, 168);
  v28 = v29;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  _platform_memset(v22, 0, 64);
  v12 = 0;
  v24 = *(_QWORD *)v31;
  if (!open_directory(v31, (uint64_t)v22, *(const char **)(v24 + 40)))
  {
    if (v30 == 3)
    {
      *(_WORD *)(v24 + 88) = 4;
      *(_DWORD *)(v24 + 56) = *__error();
    }
    return 0;
  }
  if (v30 == 2)
  {
    v15 = 0;
  }
  else if ((*(_DWORD *)(v31 + 64) & 0x800) != 0)
  {
    if ((*(_DWORD *)(v31 + 64) & 0x10) != 0)
      v2 = 64;
    else
      v2 = 80;
    v15 = v2;
  }
  else if ((*(_DWORD *)(v31 + 64) & 8) != 0)
  {
    if ((*(_DWORD *)(v31 + 64) & 0x10) != 0)
      v3 = 48;
    else
      v3 = 16;
    v15 = v3;
  }
  else
  {
    v15 = 32;
  }
  v18 = 0;
  if (v15 || v30 == 3)
  {
    v11 = v31;
    v10 = v24;
    v4 = dir_fd((uint64_t)v22);
    if (fts_safe_changedir(v11, v10, v4, 0))
    {
      if (v15 && v30 == 3)
        *(_DWORD *)(v24 + 56) = *__error();
      *(_WORD *)(v24 + 90) |= 1u;
      v17 = 0;
      v18 = *__error();
      close_directory((uint64_t)v22);
    }
    else
    {
      v17 = 1;
    }
  }
  else
  {
    v17 = 0;
  }
  if (!*(_WORD *)(v24 + 86) && *(_WORD *)(v24 + 64) == 1 && **(_BYTE **)(v24 + 48) == 47)
    v9 = 0;
  else
    v9 = *(unsigned __int16 *)(v24 + 64);
  if ((*(_DWORD *)(v31 + 64) & 4) != 0)
  {
    v5 = (_BYTE *)(*(_QWORD *)(v31 + 32) + v9);
    v12 = v5 + 1;
    *v5 = 47;
  }
  v20 = v9 + 1;
  v19 = *(_DWORD *)(v31 + 44) - (v9 + 1);
  v16 = *(_WORD *)(v24 + 86) + 1;
  v14 = 0;
  v23 = 0;
  v26 = 0;
  v25 = 0;
  while ((read_dirent((uint64_t)v22, (uint64_t)v28) & 1) != 0)
  {
    if ((*(_DWORD *)(v31 + 64) & 0x20) != 0
      || **(_BYTE **)v28 != 46
      || *(_BYTE *)(*(_QWORD *)v28 + 1)
      && (*(_BYTE *)(*(_QWORD *)v28 + 1) != 46 || *(_BYTE *)(*(_QWORD *)v28 + 2)))
    {
      v27 = (unsigned int *)fts_alloc(v31, *(_QWORD *)v28, (int)*((_QWORD *)v28 + 1));
      if (!v27)
        goto LABEL_45;
      if (*((_QWORD *)v28 + 1) >= (unint64_t)v19)
      {
        v21 = *(_QWORD *)(v31 + 32);
        if (fts_palloc(v31, *((_DWORD *)v28 + 2) + v20 + 1))
        {
LABEL_45:
          v13 = *__error();
          fts_free(v27);
          fts_lfree((uint64_t)v26);
          close_directory((uint64_t)v22);
          *(_WORD *)(v24 + 88) = 7;
          *(_DWORD *)(v31 + 64) |= 0x200u;
          *__error() = v13;
          return 0;
        }
        if (v21 != *(_QWORD *)(v31 + 32))
        {
          v14 = 1;
          if ((*(_DWORD *)(v31 + 64) & 4) != 0)
            v12 = (_BYTE *)(*(_QWORD *)(v31 + 32) + v20);
        }
        v19 = *(_DWORD *)(v31 + 44) - v20;
      }
      if ((unint64_t)(v20 + *((_QWORD *)v28 + 1)) >= 0xFFFF)
      {
        fts_free(v27);
        fts_lfree((uint64_t)v26);
        close_directory((uint64_t)v22);
        *(_WORD *)(v24 + 88) = 7;
        *(_DWORD *)(v31 + 64) |= 0x200u;
        *__error() = 63;
        return 0;
      }
      *((_WORD *)v27 + 43) = v16;
      *((_QWORD *)v27 + 1) = *(_QWORD *)v31;
      *((_WORD *)v27 + 32) = v20 + *((_QWORD *)v28 + 1);
      if (v18)
      {
        if (v15)
        {
          *((_WORD *)v27 + 44) = 10;
          v27[14] = v18;
        }
        else
        {
          *((_WORD *)v27 + 44) = 11;
        }
        *((_QWORD *)v27 + 5) = *(_QWORD *)(v24 + 40);
      }
      else
      {
        v8 = (v15 | *((_DWORD *)v28 + 40)) - 16;
        if (v8 <= 0x4E)
          __asm { BR              X8 }
        *((_WORD *)v27 + 44) = 11;
        if ((*(_DWORD *)(v31 + 64) & 4) != 0)
          v7 = (unsigned int *)*((_QWORD *)v27 + 6);
        else
          v7 = v27 + 26;
        *((_QWORD *)v27 + 5) = v7;
      }
      *((_QWORD *)v27 + 2) = 0;
      if (v26)
      {
        *((_QWORD *)v23 + 2) = v27;
        v23 = v27;
      }
      else
      {
        v23 = v27;
        v26 = v27;
      }
      ++v25;
    }
  }
  close_directory((uint64_t)v22);
  if (v14)
    fts_padjust(v31, (uint64_t)v26);
  if ((*(_DWORD *)(v31 + 64) & 4) != 0)
  {
    if (v20 == *(_DWORD *)(v31 + 44) || !v25)
      --v12;
    *v12 = 0;
  }
  if (v17 && (v30 == 1 || !v25))
  {
    if (*(_WORD *)(v24 + 86))
    {
      if (!fts_safe_changedir(v31, v24, -1, (uint64_t)".."))
        goto LABEL_83;
    }
    else if ((*(_DWORD *)(v31 + 64) & 4) != 0 || !fts_fchdir(v31, *(_DWORD *)(v31 + 40)))
    {
      goto LABEL_83;
    }
    *(_WORD *)(v24 + 88) = 7;
    *(_DWORD *)(v31 + 64) |= 0x200u;
    return 0;
  }
LABEL_83:
  if (v25)
  {
    if (*(_QWORD *)(v31 + 56) && v25 > 1)
      return (unsigned int *)fts_sort(v31, (uint64_t)v26, v25);
    return v26;
  }
  else
  {
    if (v30 == 3)
      *(_WORD *)(v24 + 88) = 6;
    return 0;
  }
}

char *fts_load(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char *result;
  uint64_t v4;
  char *v5;
  uint64_t v6;

  v2 = *(unsigned __int16 *)(a2 + 66);
  *(_WORD *)(a2 + 64) = *(_WORD *)(a2 + 66);
  _platform_memmove(*(_QWORD *)(a1 + 32), a2 + 104, v2 + 1);
  result = strrchr((const char *)(a2 + 104), 47);
  if (result && (result != (char *)(a2 + 104) || result[1]))
  {
    v5 = result + 1;
    v6 = _platform_strlen(result + 1);
    result = (char *)_platform_memmove(a2 + 104, v5, v6 + 1);
    *(_WORD *)(a2 + 66) = v6;
  }
  v4 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a2 + 48) = v4;
  *(_QWORD *)(a2 + 40) = v4;
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 80);
  return result;
}

int fts_set(FTS *a1, FTSENT *a2, int a3)
{
  if (a3 <= 4)
  {
    a2->fts_instr = a3;
    return 0;
  }
  else
  {
    *__error() = 22;
    return 1;
  }
}

FTSENT *__cdecl fts_children(FTS *a1, int a2)
{
  unsigned int v3;
  _ftsent *fts_cur;
  int v6;

  if (!a2 || a2 == 256)
  {
    fts_cur = a1->fts_cur;
    *__error() = 0;
    if ((a1->fts_options & 0x200) != 0)
    {
      return 0;
    }
    else if (fts_cur->fts_info == 9)
    {
      return fts_cur->fts_link;
    }
    else if (fts_cur->fts_info == 1)
    {
      if (a1->fts_child)
        fts_lfree((uint64_t)a1->fts_child);
      if (a2 == 256)
      {
        a1->fts_options |= 0x100u;
        v6 = 2;
      }
      else
      {
        v6 = 1;
      }
      if (fts_cur->fts_level || *fts_cur->fts_accpath == 47 || (a1->fts_options & 4) != 0)
      {
        a1->fts_child = (_ftsent *)fts_build((uint64_t)a1, v6);
        if (*__error())
          fts_cur->fts_errno = *__error();
        return a1->fts_child;
      }
      else
      {
        v3 = open_NOCANCEL(".", 0x1000000);
        if ((v3 & 0x80000000) == 0)
        {
          a1->fts_child = (_ftsent *)fts_build((uint64_t)a1, v6);
          if (*__error())
            fts_cur->fts_errno = *__error();
          if (fts_fchdir((uint64_t)a1, v3))
          {
            close_NOCANCEL(v3);
            return 0;
          }
          else
          {
            close_NOCANCEL(v3);
            return a1->fts_child;
          }
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

uint64_t fts_palloc(uint64_t a1, int a2)
{
  uint64_t v3;

  *(_DWORD *)(a1 + 44) += a2 + 256;
  if (*(_DWORD *)(a1 + 44) <= 0xFFFEu)
  {
    v3 = malloc_type_realloc(*(_QWORD *)(a1 + 32), *(int *)(a1 + 44), 527110675);
    if (v3)
    {
      *(_QWORD *)(a1 + 32) = v3;
      return 0;
    }
    else
    {
      free(*(void **)(a1 + 32));
      *(_QWORD *)(a1 + 32) = 0;
      return 1;
    }
  }
  else
  {
    free(*(void **)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0;
    *__error() = 63;
    return 1;
  }
}

unint64_t fts_maxarglen(_QWORD *a1)
{
  unint64_t v2;
  unint64_t v3;

  v2 = 0;
  while (*a1)
  {
    v3 = _platform_strlen(*a1);
    if (v3 > v2)
      v2 = v3;
    ++a1;
  }
  return v2 + 1;
}

uint64_t fts_alloc(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v4 = a3 + 112;
  if ((*(_DWORD *)(a1 + 64) & 8) == 0)
    v4 = a3 + 263;
  v5 = malloc_type_calloc(1, v4, 616728129);
  if (!v5)
    return 0;
  *(_DWORD *)(v5 + 60) = -1;
  *(_QWORD *)(v5 + 48) = *(_QWORD *)(a1 + 32);
  *(_WORD *)(v5 + 66) = a3;
  *(_WORD *)(v5 + 92) = 3;
  if ((*(_DWORD *)(a1 + 64) & 8) == 0)
    *(_QWORD *)(v5 + 96) = (v5 + 104 + a3 + 9) & 0xFFFFFFFFFFFFFFF8;
  j___platform_memmove(v5 + 104, a2, a3);
  return v5;
}

uint64_t fts_sort(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v3;
  uint64_t v5;
  uint64_t i;
  _QWORD *v7;
  _QWORD *v8;
  int v9;
  uint64_t v11;

  v9 = a3;
  if (a3 > *(_DWORD *)(a1 + 48))
  {
    *(_DWORD *)(a1 + 48) = a3 + 40;
    v5 = reallocarray_DARWIN_EXTSN(*(_QWORD *)(a1 + 16), *(int *)(a1 + 48), 8);
    if (!v5)
    {
      free(*(void **)(a1 + 16));
      *(_QWORD *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 48) = 0;
      return a2;
    }
    *(_QWORD *)(a1 + 16) = v5;
  }
  v7 = *(_QWORD **)(a1 + 16);
  for (i = a2; i; i = *(_QWORD *)(i + 16))
  {
    v3 = v7++;
    *v3 = i;
  }
  if (*(int *)(a1 + 64) >= 0)
    qsort(*(void **)(a1 + 16), v9, 8uLL, *(int (__cdecl **)(const void *, const void *))(a1 + 56));
  else
    qsort_b(*(void **)(a1 + 16), v9, 8uLL, *(void **)(a1 + 56));
  v8 = *(_QWORD **)(a1 + 16);
  v11 = *v8;
  while (--v9)
  {
    *(_QWORD *)(*v8 + 16) = v8[1];
    ++v8;
  }
  *(_QWORD *)(*v8 + 16) = 0;
  return v11;
}

BOOL open_directory(uint64_t a1, uint64_t a2, const char *a3)
{
  BOOL v3;

  _platform_memset(a2, 0, 64);
  *(_BYTE *)(a2 + 53) = (*(_DWORD *)(a1 + 64) & 8) != 0;
  v3 = (*(_DWORD *)(a1 + 64) & 0x20) != 0;
  *(_BYTE *)(a2 + 55) = v3;
  *(_BYTE *)(a2 + 54) = v3;
  *(_DWORD *)(a2 + 48) = open_NOCANCEL(a3, 17825796);
  if (*(_DWORD *)(a2 + 48) != -1
    && (*(_QWORD *)(a2 + 32) = malloc_type_malloc(0x8000, 1219660950)) != 0
    && ((*(_WORD *)(a2 + 8) = 5, (*(_BYTE *)(a2 + 53) & 1) != 0)
      ? (*(_DWORD *)(a2 + 12) = -2113929205, *(_DWORD *)(a2 + 24) = 1)
      : (*(_DWORD *)(a2 + 12) = -2113430005, *(_DWORD *)(a2 + 24) = 557),
        (advance_directory(a2) & 1) != 0))
  {
    return 1;
  }
  else
  {
    if (*(_DWORD *)(a2 + 48) != -1)
      close_NOCANCEL(*(unsigned int *)(a2 + 48));
    *(_DWORD *)(a2 + 48) = -1;
    free(*(void **)(a2 + 32));
    *(_QWORD *)(a2 + 32) = 0;
    *(_QWORD *)a2 = opendir(a3);
    return *(_QWORD *)a2 != 0;
  }
}

uint64_t dir_fd(uint64_t a1)
{
  if (*(_QWORD *)a1)
    return dirfd(*(DIR **)a1);
  else
    return *(unsigned int *)(a1 + 48);
}

void close_directory(uint64_t a1)
{
  if (*(_QWORD *)a1)
  {
    closedir(*(DIR **)a1);
    *(_QWORD *)a1 = 0;
  }
  if (*(_DWORD *)(a1 + 48) != -1)
  {
    close_NOCANCEL(*(unsigned int *)(a1 + 48));
    *(_DWORD *)(a1 + 48) = -1;
  }
  free(*(void **)(a1 + 32));
  *(_QWORD *)(a1 + 32) = 0;
}

uint64_t read_dirent(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  int v5;
  BOOL v6;
  BOOL v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  int *v14;
  unsigned int *v15;
  dirent *v16;
  char v19;

  if (*(_QWORD *)a1)
  {
    v16 = readdir(*(DIR **)a1);
    if (v16)
    {
      *(_QWORD *)a2 = v16->d_name;
      *(_QWORD *)(a2 + 8) = v16->d_namlen;
      *(_DWORD *)(a2 + 160) = v16->d_type;
      *(_BYTE *)(a2 + 164) = 0;
      v19 = 1;
    }
    else
    {
      v19 = 0;
    }
  }
  else if (*(_DWORD *)(a1 + 48) == -1)
  {
    v19 = 0;
  }
  else if ((*(_BYTE *)(a1 + 54) & 1) != 0)
  {
    *(_BYTE *)(a1 + 54) = 0;
    *(_QWORD *)a2 = ".";
    *(_QWORD *)(a2 + 8) = 1;
    *(_DWORD *)(a2 + 160) = 4;
    *(_BYTE *)(a2 + 164) = 0;
    v19 = 1;
  }
  else if ((*(_BYTE *)(a1 + 55) & 1) != 0)
  {
    *(_BYTE *)(a1 + 55) = 0;
    *(_QWORD *)a2 = "..";
    *(_QWORD *)(a2 + 8) = 2;
    *(_DWORD *)(a2 + 160) = 4;
    *(_BYTE *)(a2 + 164) = 0;
    v19 = 1;
  }
  else
  {
    if (*(_DWORD *)(a1 + 60) == *(_DWORD *)(a1 + 56))
    {
      if ((*(_BYTE *)(a1 + 52) & 1) != 0)
      {
        v19 = 0;
        return v19 & 1;
      }
      if ((advance_directory(a1) & 1) == 0)
      {
        v19 = 0;
        return v19 & 1;
      }
      if ((*(_BYTE *)(a1 + 52) & 1) != 0)
      {
        v19 = 0;
        return v19 & 1;
      }
    }
    _platform_memset(a2, 0, 168);
    v15 = 0;
    v14 = 0;
    if ((*(_BYTE *)(a1 + 53) & 1) != 0)
    {
      v14 = *(int **)(a1 + 40);
      ++*(_DWORD *)(a1 + 60);
      *(_QWORD *)(a1 + 40) = (char *)v14 + *v14;
      v6 = 1;
      if (*(_DWORD *)(a1 + 60) != *(_DWORD *)(a1 + 56))
        v6 = *(_QWORD *)(a1 + 40) + (unint64_t)**(unsigned int **)(a1 + 40) <= *(_QWORD *)(a1 + 32) + 0x8000;
      if (!v6)
      {
        v10 = _os_assert_log(v6);
        _os_crash((uint64_t)v10);
        __break(1u);
      }
      if (!v14[7])
      {
        v9 = _os_assert_log(v14[7] != 0);
        _os_crash((uint64_t)v9);
        __break(1u);
      }
      *(_QWORD *)a2 = (char *)v14 + v14[6] + 24;
      *(_QWORD *)(a2 + 8) = (v14[7] - 1);
      if (*(_QWORD *)a2 + (unint64_t)v14[7] > *(_QWORD *)(a1 + 32) + 0x8000)
      {
        v8 = _os_assert_log(0);
        _os_crash((uint64_t)v8);
        __break(1u);
      }
    }
    else
    {
      v15 = *(unsigned int **)(a1 + 40);
      ++*(_DWORD *)(a1 + 60);
      *(_QWORD *)(a1 + 40) = (char *)v15 + *v15;
      v7 = 1;
      if (*(_DWORD *)(a1 + 60) != *(_DWORD *)(a1 + 56))
        v7 = *(_QWORD *)(a1 + 40) + (unint64_t)**(unsigned int **)(a1 + 40) <= *(_QWORD *)(a1 + 32) + 0x8000;
      if (!v7)
      {
        v13 = _os_assert_log(0);
        _os_crash((uint64_t)v13);
        __break(1u);
      }
      if (!v15[7])
      {
        v12 = _os_assert_log(v15[7] != 0);
        _os_crash((uint64_t)v12);
        __break(1u);
      }
      *(_QWORD *)a2 = (char *)v15 + (int)v15[6] + 24;
      *(_QWORD *)(a2 + 8) = v15[7] - 1;
      if (*(_QWORD *)a2 + (unint64_t)v15[7] > *(_QWORD *)(a1 + 32) + 0x8000)
      {
        v11 = _os_assert_log(0);
        _os_crash((uint64_t)v11);
        __break(1u);
      }
    }
    if ((*(_BYTE *)(a1 + 53) & 1) != 0)
      v5 = v14[9];
    else
      v5 = v15[9];
    v4 = (v5 - 1);
    if (v4 <= 6)
      __asm { BR              X8 }
    *(_DWORD *)(a2 + 160) = 0;
    *(_BYTE *)(a2 + 164) = 0;
    if ((*(_BYTE *)(a2 + 164) & 1) != 0)
    {
      *(_DWORD *)(a2 + 16) = v15[8];
      *(_WORD *)(a2 + 22) = v15[32];
      *(_QWORD *)(a2 + 24) = *((_QWORD *)v15 + 15);
      *(_DWORD *)(a2 + 32) = v15[26];
      *(_DWORD *)(a2 + 36) = v15[27];
      *(_DWORD *)(a2 + 40) = v15[36];
      *(_OWORD *)(a2 + 48) = *(_OWORD *)(v15 + 22);
      *(_OWORD *)(a2 + 64) = *(_OWORD *)(v15 + 14);
      *(_OWORD *)(a2 + 80) = *(_OWORD *)(v15 + 18);
      *(_OWORD *)(a2 + 96) = *(_OWORD *)(v15 + 10);
      *(_QWORD *)(a2 + 112) = *(_QWORD *)(v15 + 37);
      *(_DWORD *)(a2 + 128) = v15[35];
      *(_DWORD *)(a2 + 132) = v15[29];
      *(_WORD *)(a2 + 20) = v15[28] & 0xFFF;
      if (*(_QWORD *)(v15 + 33) % 512)
        v3 = *(_QWORD *)(v15 + 33) / 512 + 1;
      else
        v3 = *(_QWORD *)(v15 + 33) / 512;
      *(_QWORD *)(a2 + 120) = v3;
    }
    v19 = 1;
  }
  return v19 & 1;
}

uint64_t fts_stat2(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5)
{
  dev_t st_dev;
  __darwin_ino64_t st_ino;
  stat *v8;
  char *v9;
  int v10;
  _BYTE v11[144];
  stat *v12;
  __darwin_ino64_t v13;
  dev_t v14;
  uint64_t i;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = a4;
  v16 = a5;
  i = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  _platform_memset(v11, 0, 144);
  if (v17 == -1)
  {
    v9 = *(char **)(v19 + 40);
    v17 = -2;
  }
  else
  {
    v9 = (char *)(v19 + 104);
  }
  if ((*(_DWORD *)(v20 + 64) & 8) != 0)
    v8 = (stat *)v11;
  else
    v8 = *(stat **)(v19 + 96);
  v12 = v8;
  if (v18)
  {
    v16 = 0;
  }
  else if (v16 && (*(_DWORD *)(v20 + 64) & 2) != 0 && (*(_WORD *)(v16 + 4) & 0xA000) == 0xA000)
  {
    v16 = 0;
  }
  if (v16)
  {
    j___platform_memmove(v12, v16, 144);
    goto LABEL_30;
  }
  if ((*(_DWORD *)(v20 + 64) & 2) == 0 && !v18)
  {
    if (!fstatat(v17, v9, v12, 32))
      goto LABEL_30;
LABEL_28:
    *(_DWORD *)(v19 + 56) = *__error();
    goto LABEL_29;
  }
  if (fstatat(v17, v9, v12, 0))
  {
    v10 = *__error();
    if (!fstatat(v17, v9, v12, 32))
    {
      if (v10 == 62)
        *(_DWORD *)(v19 + 56) = 62;
      *__error() = 0;
      return 13;
    }
    *(_DWORD *)(v19 + 56) = v10;
LABEL_29:
    _platform_memset(v12, 0, 144);
    return 10;
  }
  if (v18 == -1 && (v12->st_mode & 0xF000) != 0x4000 && fstatat(v17, v9, v12, 32))
    goto LABEL_28;
LABEL_30:
  switch(v12->st_mode & 0xF000)
  {
    case 16384:
      st_dev = v12->st_dev;
      *(_DWORD *)(v19 + 80) = v12->st_dev;
      v14 = st_dev;
      st_ino = v12->st_ino;
      *(_QWORD *)(v19 + 72) = st_ino;
      v13 = st_ino;
      *(_WORD *)(v19 + 84) = v12->st_nlink;
      if (*(_BYTE *)(v19 + 104) != 46
        || *(_BYTE *)(v19 + 105) && (*(_BYTE *)(v19 + 105) != 46 || *(_BYTE *)(v19 + 106)))
      {
        for (i = *(_QWORD *)(v19 + 8); *(__int16 *)(i + 86) >= 0; i = *(_QWORD *)(i + 8))
        {
          if (v13 == *(_QWORD *)(i + 72) && v14 == *(_DWORD *)(i + 80))
          {
            *(_QWORD *)v19 = i;
            return 2;
          }
        }
        return 1;
      }
      else
      {
        return 5;
      }
    case 40960:
      return 12;
    case 32768:
      return 8;
    default:
      return 3;
  }
}

uint64_t fts_padjust(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *i;

  v3 = *(_QWORD *)(result + 32);
  for (i = *(_QWORD **)(result + 8); i; i = (_QWORD *)i[2])
  {
    if ((_QWORD *)i[5] != i + 13)
      i[5] = v3 + i[5] - i[6];
    i[6] = v3;
  }
  while (*(__int16 *)(a2 + 86) >= 0)
  {
    if (*(_QWORD *)(a2 + 40) != a2 + 104)
      *(_QWORD *)(a2 + 40) = v3 + *(_QWORD *)(a2 + 40) - *(_QWORD *)(a2 + 48);
    *(_QWORD *)(a2 + 48) = v3;
    if (*(_QWORD *)(a2 + 16))
      v2 = *(_QWORD *)(a2 + 16);
    else
      v2 = *(_QWORD *)(a2 + 8);
    a2 = v2;
  }
  return result;
}

uint64_t advance_directory(uint64_t a1)
{
  int v2;
  char *v3;
  char v5;

  if ((*(_BYTE *)(a1 + 52) & 1) != 0)
  {
    v5 = 1;
  }
  else
  {
    if (*(_DWORD *)(a1 + 48) == -1)
    {
      v3 = _os_assert_log(*(_DWORD *)(a1 + 48) != -1);
      _os_crash((uint64_t)v3);
      __break(1u);
    }
    *(_DWORD *)(a1 + 56) = getattrlistbulk(*(_DWORD *)(a1 + 48), (void *)(a1 + 8), *(void **)(a1 + 32), 0x8000uLL, 8uLL);
    if (*(_DWORD *)(a1 + 56) == -1)
    {
      v2 = *__error();
      close_NOCANCEL(*(unsigned int *)(a1 + 48));
      *(_DWORD *)(a1 + 48) = -1;
      *__error() = v2;
      v5 = 0;
    }
    else
    {
      if (!*(_DWORD *)(a1 + 56))
        *(_BYTE *)(a1 + 52) = 1;
      *(_DWORD *)(a1 + 60) = 0;
      *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 32);
      v5 = 1;
    }
  }
  return v5 & 1;
}

BOOL compat_mode(const char *function, const char *mode)
{
  char v3;
  BOOL v4;
  int v5;
  BOOL v6;
  BOOL v7;
  char *modea;
  char *v9;
  char v12;

  if ((parsed & 1) == 0 && (bootstrapping & 1) == 0)
  {
    pthread_once(&threadsafe, (void (*)(void))check_env_var);
    parsed = 1;
  }
  if (!strcasecmp("unix2003", mode))
  {
    v12 = unix2003_mode & 1;
    return v12 & 1;
  }
  if (!strcasecmp("legacy", mode))
  {
    v12 = (unix2003_mode ^ 1) & 1;
    return v12 & 1;
  }
  if (!strcasecmp("bootstrap", mode))
  {
    v12 = bootstrapping & 1;
    return v12 & 1;
  }
  if (!strcasecmp("error", mode))
  {
    v12 = parse_error & 1;
    return v12 & 1;
  }
  v9 = strpbrk(mode, "!^&|");
  if (!v9)
  {
LABEL_27:
    fprintf(__stderrp, "invalid mode %s (while checking for %s)\n", mode, function);
    v12 = 0;
    return v12 & 1;
  }
  if (*v9 == 33)
  {
    if (v9 == mode)
    {
      v12 = !compat_mode(function, mode + 1);
      return v12 & 1;
    }
    goto LABEL_27;
  }
  modea = (char *)malloc_type_malloc(v9 - mode + 1, 2696640939);
  _platform_strlcpy(modea, mode, v9 - mode + 1);
  v7 = compat_mode(function, modea);
  free(modea);
  v6 = compat_mode(function, v9 + 1);
  v5 = *v9;
  switch(v5)
  {
    case '&':
      v4 = 0;
      if (v7)
        v4 = v6;
      v12 = v4;
      break;
    case '^':
      v12 = v7 != v6;
      return v12 & 1;
    case '|':
      v3 = 1;
      if (!v7)
        v3 = v6;
      v12 = v3 & 1;
      break;
    default:
      goto LABEL_27;
  }
  return v12 & 1;
}

char *check_env_var()
{
  char *result;
  char *v1;

  result = getenv("COMMAND_MODE");
  v1 = result;
  if (result)
  {
    result = (char *)strcasecmp(result, "legacy");
    if ((_DWORD)result)
    {
      result = (char *)strcasecmp(v1, "unix2003");
      if ((_DWORD)result)
        parse_error = 1;
      unix2003_mode = 1;
    }
    else
    {
      unix2003_mode = 0;
    }
  }
  return result;
}

int getloadavg(double a1[], int a2)
{
  double v2;
  int v4;
  size_t v5;
  int i;
  _QWORD v7[2];
  uint64_t v8;
  int v9;
  double *__attribute__((__org_arrdim(0,0))) v10;
  int v12[2];

  v10 = a1;
  v9 = a2;
  v7[0] = 0;
  v7[1] = 0;
  v8 = 0;
  i = 0;
  v12[0] = 2;
  v12[1] = 2;
  v5 = 24;
  if (sysctl(v12, 2u, v7, &v5, 0, 0) < 0)
    return -1;
  if ((unint64_t)v9 >= 3)
    v4 = 3;
  else
    v4 = v9;
  v9 = v4;
  for (i = 0; i < v9; ++i)
  {
    LODWORD(v2) = *((_DWORD *)v7 + i);
    v2 = (double)*(unint64_t *)&v2 / (double)v8;
    v10[i] = v2;
  }
  return v9;
}

ttyent *__cdecl getttynam(const char *a1)
{
  ttyent *v2;

  setttyent();
  do
    v2 = getttyent();
  while (v2 && _platform_strcmp(a1, v2->ty_name));
  endttyent();
  return v2;
}

int setttyent(void)
{
  if (!seq)
  {
    if (regcomp(&brapreg, brapat[0], 1))
      return 0;
    if (regcomp(&decpreg, decpat[0], 1))
    {
      regfree(&brapreg);
      return 0;
    }
    if (regcomp(&hexpreg, hexpat[0], 3))
    {
      regfree(&decpreg);
      regfree(&brapreg);
      return 0;
    }
    seq = malloc_type_malloc(284, 0x1000040F3ACBFE9);
    if (!seq)
    {
      regfree(&hexpreg);
      regfree(&decpreg);
      regfree(&brapreg);
      return 0;
    }
  }
  *(_DWORD *)(seq + 4) = 0;
  *(_DWORD *)seq = 0;
  slot = 1;
  if (tf)
  {
    rewind((FILE *)tf);
    return 1;
  }
  else
  {
    tf = (uint64_t)fopen("/etc/ttys", "r");
    return tf != 0;
  }
}

ttyent *getttyent(void)
{
  char v0;
  char v1;
  char *v2;
  const char *v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v7;
  BOOL v8;
  _xlocale *v9;
  char *v10;
  regmatch_t v11;
  regmatch_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  char *v17;
  char *v18;
  _BYTE *v19;
  int v20;
  int v21;
  _xlocale *v23;
  uint64_t v24;
  regmatch_t __pmatch;
  regmatch_t v26;
  uint64_t v27;

  if (v0)
    v1 = 1;
  else
    v1 = 0;
  if ((v1 & 1) != 0)
  {
    v23 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v24 = __locale_key;
    v23 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v24);
  }
  if (v23)
    v9 = v23;
  else
    v9 = (_xlocale *)__global_locale;
  if (getttyent_line || (getttyent_line = malloc_type_malloc(1024, 1236060795)) != 0)
  {
    if (!tf && !setttyent())
      return 0;
    while (1)
    {
      while (1)
      {
        if (slot < *(_DWORD *)seq)
        {
          ++slot;
          return (ttyent *)&getttyent_nonexistent;
        }
        if (*(int *)(seq + 4) > 0)
        {
          v2 = (char *)getttyent_tty;
          v3 = (const char *)(seq + 12);
          v4 = (*(_DWORD *)(seq + 8))++;
          sprintf(v2, v3, v4);
          ++slot;
          --*(_DWORD *)(seq + 4);
          return (ttyent *)&getttyent_tty;
        }
        if (slot == *(_DWORD *)seq)
        {
          ++slot;
          return (ttyent *)&getttyent_tty;
        }
        do
        {
          while (1)
          {
            v17 = (char *)getttyent_line;
            if (!fgets((char *)getttyent_line, 1024, (FILE *)tf))
              return 0;
            if (j___platform_strchr(v17, 10))
              break;
            do
            {
              v20 = getc((FILE *)tf);
              v8 = 0;
              if (v20 != 10)
                v8 = v20 != -1;
            }
            while (v8);
          }
          while (isspace_l(*v17, v9))
            ++v17;
        }
        while (!*v17 || *v17 == 35);
        zapchar = 0;
        getttyent_tty = (uint64_t)v17;
        v18 = skip(v17);
        qword_DE890 = (uint64_t)v18;
        if (*v18)
        {
          v18 = skip(v18);
          qword_DE898 = (uint64_t)v18;
          if (*v18)
            v18 = skip(v18);
          else
            qword_DE898 = 0;
        }
        else
        {
          qword_DE898 = 0;
          qword_DE890 = 0;
        }
        dword_DE8A0 = 0;
        qword_DE8A8 = 0;
        qword_DE8B0 = 0;
        qword_DE8B8 = 0;
        v16 = -1;
        while (*v18)
        {
          if (_platform_strncmp(v18, "off", 3) || !isspace_l(v18[3], v9))
          {
            if (_platform_strncmp(v18, "on", 2) || !isspace_l(v18[2], v9))
            {
              if (_platform_strncmp(v18, "secure", 6) || !isspace_l(v18[6], v9))
              {
                if (_platform_strncmp(v18, "window", 6) || v18[6] != 61)
                {
                  if (_platform_strncmp(v18, "onerror", 7) || v18[7] != 61)
                  {
                    if (_platform_strncmp(v18, "onoption", 8) || v18[8] != 61)
                    {
                      if (_platform_strncmp(v18, "slot", 4) || v18[4] != 61)
                        break;
                      v10 = (char *)value((uint64_t)v18);
                      if (v10)
                        v16 = atoi(v10);
                    }
                    else
                    {
                      qword_DE8B8 = value((uint64_t)v18);
                    }
                  }
                  else
                  {
                    qword_DE8B0 = value((uint64_t)v18);
                  }
                }
                else
                {
                  qword_DE8A8 = value((uint64_t)v18);
                }
              }
              else
              {
                dword_DE8A0 |= 2u;
              }
            }
            else
            {
              dword_DE8A0 |= 1u;
            }
          }
          else
          {
            dword_DE8A0 &= ~1u;
          }
          v18 = skip(v18);
        }
        if (zapchar == 35 || *v18 == 35)
        {
          do
          {
            v21 = *++v18;
            v7 = 1;
            if (v21 != 32)
              v7 = v21 == 9;
          }
          while (v7);
        }
        qword_DE8C0 = (uint64_t)v18;
        if (!*v18)
          qword_DE8C0 = 0;
        v19 = (_BYTE *)j___platform_strchr(v18, 10);
        if (v19)
          *v19 = 0;
        if (regexec(&brapreg, (const char *)getttyent_tty, 3uLL, &__pmatch, 0))
          goto LABEL_87;
        v11 = __pmatch;
        v12 = v26;
        __pmatch = v26;
        if (regexec(&decpreg, (const char *)getttyent_tty, 3uLL, &__pmatch, 4))
          break;
        v14 = strtol((const char *)(getttyent_tty + v26.rm_so), 0, 10);
        v13 = strtol((const char *)(getttyent_tty + v27), 0, 10);
        v15 = 0;
LABEL_82:
        if (v14 <= v13)
        {
          *(_DWORD *)(seq + 4) = v13 - v14 + 1;
          *(_DWORD *)(seq + 8) = v14;
          if (v15)
            v5 = 120;
          else
            v5 = 100;
          sprintf((char *)(seq + 12), "%.*s%%0%d%c%s", SLODWORD(v11.rm_so), (const char *)getttyent_tty, LODWORD(v26.rm_eo) - LODWORD(v26.rm_so), v5, (const char *)(getttyent_tty + v11.rm_eo));
          goto LABEL_87;
        }
      }
      __pmatch = v12;
      if (!regexec(&hexpreg, (const char *)getttyent_tty, 3uLL, &__pmatch, 4))
      {
        v14 = strtol((const char *)(getttyent_tty + v26.rm_so), 0, 16);
        v13 = strtol((const char *)(getttyent_tty + v27), 0, 16);
        v15 = 1;
        goto LABEL_82;
      }
LABEL_87:
      if (v16 <= slot)
      {
        if (*(int *)(seq + 4) <= 0)
        {
          ++slot;
          return (ttyent *)&getttyent_tty;
        }
      }
      else
      {
        *(_DWORD *)seq = v16;
      }
    }
  }
  return 0;
}

int endttyent(void)
{
  int v0;

  if (!tf)
    return 1;
  v0 = fclose((FILE *)tf);
  tf = 0;
  return v0 != -1;
}

char *skip(char *a1)
{
  char *v1;
  char *v2;
  BOOL v4;
  int v5;
  int v6;
  int v7;
  char *v8;
  char *v9;

  v9 = a1;
  v5 = 0;
  v8 = a1;
  while (1)
  {
    v6 = *v9;
    if (!*v9)
      break;
    if (v6 == 34)
    {
      v5 ^= 1u;
    }
    else
    {
      if (v5 == 1 && *v9 == 92 && v9[1] == 34)
        ++v9;
      v1 = v8++;
      *v1 = *v9;
      if (v5 != 1)
      {
        if (v6 == 35)
        {
          zapchar = 35;
          *v9 = 0;
          break;
        }
        if (v6 == 9 || v6 == 32 || v6 == 10)
        {
          zapchar = v6;
          v2 = v9++;
          *v2 = 0;
          while (1)
          {
            v7 = *v9;
            v4 = 1;
            if (v7 != 9)
            {
              v4 = 1;
              if (v7 != 32)
                v4 = v7 == 10;
            }
            if (!v4)
              break;
            ++v9;
          }
          break;
        }
      }
    }
    ++v9;
  }
  *(v8 - 1) = 0;
  return v9;
}

uint64_t value(uint64_t a1)
{
  uint64_t v3;

  v3 = j___platform_strchr(a1, 61);
  if (v3)
    return v3 + 1;
  else
    return 0;
}

char *getusershell(void)
{
  char *v1;

  if (!curshell)
    curshell = (uint64_t)initshells();
  v1 = *(char **)curshell;
  if (*(_QWORD *)curshell)
    curshell += 8;
  return v1;
}

char **initshells()
{
  char v0;
  char v1;
  int v2;
  _QWORD *v3;
  char *v4;
  BOOL v6;
  BOOL v7;
  _xlocale *v8;
  stat v9;
  FILE *v10;
  char *v11;
  _QWORD *v12;
  _xlocale *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t StatusReg;

  v12 = 0;
  v11 = 0;
  v10 = 0;
  _platform_memset(&v9, 0, 144);
  v14 = 0;
  if (v0)
    v1 = 1;
  else
    v1 = 0;
  if ((v1 & 1) != 0)
  {
    v14 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v15 = __locale_key;
    v16 = __locale_key;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v14 = *(_xlocale **)(StatusReg + 8 * v16);
  }
  if (v14)
    v8 = v14;
  else
    v8 = (_xlocale *)__global_locale;
  if (shells)
    free((void *)shells);
  shells = 0;
  if (strings)
    free((void *)strings);
  strings = 0;
  v10 = fopen("/etc/shells", "r");
  if (!v10)
    return okshells;
  v2 = fileno(v10);
  if (fstat(v2, &v9) == -1 || (strings = malloc_type_malloc(LODWORD(v9.st_size), 1989054691)) == 0)
  {
    fclose(v10);
    return okshells;
  }
  else
  {
    shells = malloc_type_calloc(LODWORD(v9.st_size) / 3, 8, 0x10040436913F5);
    if (shells)
    {
      v12 = (_QWORD *)shells;
      v11 = (char *)strings;
      while (fgets(v11, 1025, v10))
      {
        while (1)
        {
          v7 = 0;
          if (*v11 != 35)
          {
            v7 = 0;
            if (*v11 != 47)
              v7 = *v11 != 0;
          }
          if (!v7)
            break;
          ++v11;
        }
        if (*v11 != 35 && *v11)
        {
          v3 = v12++;
          *v3 = v11;
          while (1)
          {
            v6 = 0;
            if (!isspace_l(*v11, v8))
            {
              v6 = 0;
              if (*v11 != 35)
                v6 = *v11 != 0;
            }
            if (!v6)
              break;
            ++v11;
          }
          v4 = v11++;
          *v4 = 0;
        }
      }
      *v12 = 0;
      fclose(v10);
      return (char **)shells;
    }
    else
    {
      fclose(v10);
      free((void *)strings);
      strings = 0;
      return okshells;
    }
  }
}

void endusershell(void)
{
  if (shells)
    free((void *)shells);
  shells = 0;
  if (strings)
    free((void *)strings);
  strings = 0;
  curshell = 0;
}

void setusershell(void)
{
  curshell = (uint64_t)initshells();
}

int getvfsbyname(const char *a1, vfsconf *a2)
{
  size_t v3;
  int i;
  int v5;
  void *v6;
  const char *v7;
  uint64_t v9;
  int v10;
  int v11;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  i = 0;
  v9 = 3;
  v10 = 1;
  v3 = 4;
  if (sysctl((int *)&v9, 3u, &v5, &v3, 0, 0) < 0)
    return -1;
  v10 = 2;
  v3 = 40;
  for (i = 0; i < v5; ++i)
  {
    v11 = i;
    if (sysctl((int *)&v9, 4u, v6, &v3, 0, 0) >= 0)
    {
      if (!_platform_strcmp(v7, (char *)v6 + 4))
        return 0;
    }
    else if (*__error() != 45)
    {
      return -1;
    }
  }
  *__error() = 2;
  return -1;
}

uint64_t _init_clock_port()
{
  mach_port_t host;

  host = mach_host_self();
  if (host_get_clock_service(host, 0, (clock_serv_t *)&clock_port))
    abort();
  if (semaphore_create(mach_task_self_, (semaphore_t *)&clock_sem, 0, 0))
    abort();
  return mach_port_deallocate(mach_task_self_, host);
}

uint64_t nanosleep_NOCANCEL(_QWORD *a1, _QWORD *a2)
{
  char *v2;
  char *v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  FILE *v9;
  FILE *v10;
  mach_timespec_t cur_time;
  mach_timespec_t v12;
  mach_error_t time;
  mach_error_t v14;
  _QWORD *v15;
  _QWORD *v16;

  v16 = a1;
  v15 = a2;
  v14 = 0;
  time = 0;
  v12 = 0;
  cur_time = 0;
  if (!__unix_conforming)
    __unix_conforming = 1;
  if (v16 && (uint64_t)*v16 >= 0 && v16[1] < 0x3B9ACA00uLL)
  {
    if (!v15 || (v14 = clock_get_time(clock_port, &cur_time)) == 0)
    {
      time = __semwait_signal_nocancel(clock_sem, 0, 1, 1, *v16, v16[1]);
      if (time < 0)
      {
        if (*__error() == 60)
          return 0;
        if (*__error() == 4)
        {
          if (v15)
          {
            time = clock_get_time(clock_port, &v12);
            if (time)
            {
              v9 = __stderrp;
              v3 = mach_error_string(time);
              fprintf(v9, "clock_get_time() failed: %s\n", v3);
              return -1;
            }
            v4 = cur_time.tv_nsec + v16[1];
            cur_time.tv_nsec += *((_DWORD *)v16 + 2);
            if ((int)v4 >= 1000000000)
            {
              cur_time.tv_nsec -= 1000000000;
              ++cur_time.tv_sec;
            }
            cur_time.tv_sec += *v16;
            if (cur_time.tv_sec <= v12.tv_sec)
            {
              if (cur_time.tv_sec >= v12.tv_sec)
                v7 = cur_time.tv_nsec - v12.tv_nsec;
              else
                v7 = -1000000000;
              v8 = v7;
            }
            else
            {
              v8 = 1000000000;
            }
            if (v8 <= 0)
            {
              v5 = v15;
              *v15 = 0;
              v5[1] = 0;
            }
            else
            {
              cur_time.tv_nsec -= v12.tv_nsec;
              if (cur_time.tv_nsec < 0)
              {
                cur_time.tv_nsec += 1000000000;
                --cur_time.tv_sec;
              }
              cur_time.tv_sec -= v12.tv_sec;
              *v15 = cur_time.tv_sec;
              v15[1] = cur_time.tv_nsec;
            }
          }
        }
        else
        {
          *__error() = 22;
        }
      }
      return -1;
    }
    v10 = __stderrp;
    v2 = mach_error_string(v14);
    fprintf(v10, "clock_get_time() failed: %s\n", v2);
    *__error() = 22;
    return -1;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int ftw(const char *a1, int (__cdecl *a2)(const char *, const stat *, int), int a3)
{
  return both_ftw(a1, (uint64_t)a2, 0, a3, 1);
}

uint64_t both_ftw(const char *a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  int v6;
  unint64_t v7;
  int v8;
  stat v9;
  int v10;
  int v11;
  _BOOL4 v12;
  unsigned int v13;
  int v14;
  int v15;
  FTS *v16;
  FTSENT *v17;
  uint64_t v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;

  v23 = (char *)a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v19 = a5;
  v24 = 0;
  v25 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = -1;
  if (a4 < 1 || v20 > 10240)
  {
    *__error() = 22;
    v13 = -1;
    goto LABEL_32;
  }
  v15 = 1;
  if ((v19 & 8) == 0)
    v15 |= 4u;
  if ((v19 & 2) != 0)
    v15 |= 0x40u;
  if ((v19 & 1) != 0)
    v15 |= 0x10u;
  else
    v15 |= 2u;
  v12 = (v19 & 4) != 0;
  if ((v19 & 8) != 0)
  {
    v10 = open_NOCANCEL(".", 0);
    if (v10 < 0)
    {
      v13 = -1;
      goto LABEL_32;
    }
    v15 |= 4u;
  }
  _platform_memset(&v9, 0, 144);
  v8 = stat(v23, &v9);
  if (v8 < 0 && (*__error() == 62 || *__error() == 63 || *__error() == 2 || *__error() == 20 || *__error() == 13))
  {
    v13 = -1;
  }
  else if (v8 < 0 || !v21 || (v9.st_mode & 0xF000) == 0x4000)
  {
    v24 = v23;
    v25 = 0;
    v16 = fts_open(&v24, v15, 0);
    if (v16)
    {
      v13 = 0;
      v17 = fts_read(v16);
      if (v17)
      {
        v7 = v17->fts_info - 1;
        if (v7 <= 0xC)
          __asm { BR              X8 }
        v13 = -1;
      }
    }
    else
    {
      v13 = -1;
    }
  }
  else
  {
    *__error() = 20;
    v13 = -1;
  }
LABEL_32:
  v11 = *__error();
  if (v16)
    fts_close(v16);
  if (v10 >= 0)
    close_NOCANCEL(v10);
  v6 = v11;
  *__error() = v6;
  return v13;
}

int nftw(const char *a1, int (__cdecl *a2)(const char *, const stat *, int, FTW *), int a3, int a4)
{
  return both_ftw(a1, 0, (uint64_t)a2, a3, a4);
}

int sigemptyset(sigset_t *a1)
{
  int result;

  result = 0;
  *a1 = 0;
  return result;
}

int sigfillset(sigset_t *a1)
{
  *a1 = -1;
  return 0;
}

int sigaddset(sigset_t *a1, int a2)
{
  if (a2 <= 0x20)
  {
    if (a2)
      *a1 |= 1 << (a2 - 1);
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sigdelset(sigset_t *a1, int a2)
{
  if (a2 <= 0x20)
  {
    if (a2)
      *a1 &= ~(1 << (a2 - 1));
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int sigismember(const sigset_t *a1, int a2)
{
  if (a2 <= 0x20)
  {
    return a2 && (*a1 & (1 << (a2 - 1))) != 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

char *__cdecl fflagstostr(unint64_t a1)
{
  char *v1;
  char *v2;
  char *v3;
  char *v5;
  int i;
  unint64_t v7;
  char *v8;
  char *v9;
  char *v10;

  v10 = (char *)malloc_type_malloc(273, 1958026931);
  if (!v10)
    return 0;
  v7 = a1;
  v8 = v10;
  for (i = 0; (unint64_t)i < 0x15; ++i)
  {
    if ((v7 & (unint64_t)(&mapping)[3 * i + 1]) != 0)
    {
      if (v8 > v10)
      {
        v1 = v8++;
        *v1 = 44;
      }
      if (LODWORD((&mapping)[3 * i + 2]))
        v5 = (&mapping)[3 * i];
      else
        v5 = (&mapping)[3 * i] + 2;
      v9 = v5;
      while (*v9)
      {
        v2 = v9++;
        v3 = v8++;
        *v3 = *v2;
      }
      v7 &= ~(unint64_t)(&mapping)[3 * i + 1];
    }
  }
  *v8 = 0;
  return v10;
}

int strtofflags(char **a1, unint64_t *a2, unint64_t *a3)
{
  int i;
  char *v5;
  char *__stringp;
  unint64_t *v7;
  unint64_t *v8;
  char **v9;

  v9 = a1;
  v8 = a2;
  v7 = a3;
  __stringp = 0;
  if (a2)
    *v8 = 0;
  if (v7)
    *v7 = 0;
  __stringp = *v9;
  while (1)
  {
    v5 = strsep(&__stringp, "\t ,");
    if (!v5)
      return 0;
    *v9 = v5;
    if (*v5)
    {
      for (i = 0; (unint64_t)i < 0x15; ++i)
      {
        if (!_platform_strcmp(v5, (&mapping)[3 * i] + 2))
        {
          if (LODWORD((&mapping)[3 * i + 2]))
          {
            if (v7)
              *v7 |= (unint64_t)(&mapping)[3 * i + 1];
          }
          else if (v8)
          {
            *v8 |= (unint64_t)(&mapping)[3 * i + 1];
          }
          break;
        }
        if (!_platform_strcmp(v5, (&mapping)[3 * i]))
        {
          if (LODWORD((&mapping)[3 * i + 2]))
          {
            if (v8)
              *v8 |= (unint64_t)(&mapping)[3 * i + 1];
          }
          else if (v7)
          {
            *v7 |= (unint64_t)(&mapping)[3 * i + 1];
          }
          break;
        }
      }
      if (i == 21)
        return 1;
    }
  }
}

uint64_t _thread_stack_pcs(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5)
{
  return __thread_stack_pcs(a1, a2, a3, a4 + 1, a5, 0);
}

uint64_t __thread_stack_pcs(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5, char a6)
{
  int v6;
  BOOL v9;
  unsigned int is_async_frame;
  uint64_t v11;
  unsigned int v12;
  char *v13;
  char *stackaddr_np;
  pthread_t v15;
  unint64_t v16;
  char *v17;
  char v18;
  unint64_t v19;
  int v20;
  _DWORD *v21;
  int v22;
  uint64_t v23;
  uint64_t vars0;

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v19 = a5;
  v18 = a6 & 1;
  v15 = pthread_self();
  stackaddr_np = (char *)pthread_get_stackaddr_np(v15);
  v13 = &stackaddr_np[-pthread_get_stacksize_np(v15)];
  v12 = 0;
  *v21 = 0;
  v17 = (char *)&vars0;
  v16 = pthread_stack_frame_decode_np(&vars0, 0);
  stackaddr_np -= v16 - (_QWORD)&vars0;
  if (&vars0 < (uint64_t *)v13 || v17 > stackaddr_np || (v17 & 1) != 0)
  {
    return 0;
  }
  else
  {
    while (1)
    {
      v9 = 1;
      if (!v19)
      {
        v6 = v20--;
        v9 = v6 != 0;
      }
      if (!v9 || v19 && v19 < v16)
        break;
      if (v16 < (unint64_t)v13
        || v16 > (unint64_t)stackaddr_np
        || (v16 & 1) != 0
        || v16 <= (unint64_t)v17)
      {
        return 0;
      }
      v17 = (char *)v16;
      v16 = pthread_stack_frame_decode_np(v16, 0);
    }
    while (v22--)
    {
      v11 = 0;
      is_async_frame = __is_async_frame(v17);
      if (is_async_frame)
      {
        if ((v18 & 1) != 0)
        {
          __thread_stack_async_pcs(v23, v22, v21, (uint64_t)v17);
          return is_async_frame;
        }
        v12 = 1;
      }
      v16 = pthread_stack_frame_decode_np(v17, &v11);
      *(_QWORD *)(v23 + 8 * (*v21)++) = v11;
      if (v16 < (unint64_t)v13
        || v16 > (unint64_t)stackaddr_np
        || (v16 & 1) != 0
        || v16 <= (unint64_t)v17)
      {
        return v12;
      }
      v17 = (char *)v16;
    }
    return v12;
  }
}

uint64_t _thread_stack_async_pcs(uint64_t a1, int a2, _DWORD *a3, int a4, unint64_t a5)
{
  return __thread_stack_pcs(a1, a2, a3, a4 + 1, a5, 1);
}

uint64_t thread_stack_pcs(uint64_t a1, int a2, _DWORD *a3)
{
  return __thread_stack_pcs(a1, a2, a3, 0, 0, 0);
}

uint64_t thread_stack_async_pcs(uint64_t a1, int a2, _DWORD *a3)
{
  return __thread_stack_pcs(a1, a2, a3, 0, 0, 1);
}

uint64_t __is_async_frame(_QWORD *a1)
{
  uint64_t v2;

  if (*a1 >> 60 == 1)
  {
    v2 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 824);
    if (v2)
      return *(unsigned int *)(v2 + 36);
    else
      return 0;
  }
  else
  {
    return 0;
  }
}

uint64_t __thread_stack_async_pcs(uint64_t a1, int a2, _DWORD *a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  int v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  v7 = 0;
  v7 = *(_QWORD *)(a4 - 8);
  v6 = 0;
  do
  {
    result = pthread_stack_frame_decode_np(v7, &v6);
    if (!v6)
      break;
    *(_QWORD *)(v11 + 8 * (*v9)++) = v6 + 1;
    if (!result)
      break;
    if ((result & 1) != 0)
      break;
    v7 = result;
  }
  while (v10--);
  return result;
}

int uname(utsname *a1)
{
  char *i;
  size_t v4;
  int v5;
  utsname *v6;
  int v7;
  int v8;

  v6 = a1;
  v5 = 0;
  v7 = 1;
  v8 = 1;
  v4 = 256;
  if (sysctl(&v7, 2u, a1, &v4, 0, 0) == -1)
    v5 = -1;
  v7 = 1;
  v8 = 10;
  v4 = 256;
  if (sysctl(&v7, 2u, v6->nodename, &v4, 0, 0) == -1)
    v5 = -1;
  v7 = 1;
  v8 = 2;
  v4 = 256;
  if (sysctl(&v7, 2u, v6->release, &v4, 0, 0) == -1)
    v5 = -1;
  v7 = 1;
  v8 = 4;
  v4 = 256;
  if (sysctl(&v7, 2u, v6->version, &v4, 0, 0) == -1)
  {
    v5 = -1;
  }
  else
  {
    for (i = v6->version; v4--; ++i)
    {
      if (*i == 10 || *i == 9)
      {
        if (v4 <= 1)
          *i = 0;
        else
          *i = 32;
      }
    }
  }
  v7 = 6;
  v8 = 1;
  v4 = 256;
  if (sysctl(&v7, 2u, v6->machine, &v4, 0, 0) == -1)
    return -1;
  return v5;
}

int isascii(int a1)
{
  return (a1 & 0xFFFFFF80) == 0;
}

int isalnum(int a1)
{
  return __istype(a1, 0x500u);
}

int isalpha(int a1)
{
  return __istype(a1, 0x100u);
}

int isblank(int a1)
{
  return __istype(a1, 0x20000u);
}

int iscntrl(int a1)
{
  return __istype(a1, 0x200u);
}

int isdigit(int a1)
{
  return __isctype(a1, 1024);
}

int isgraph(int a1)
{
  return __istype(a1, 0x800u);
}

int islower(int a1)
{
  return __istype(a1, 0x1000u);
}

int isprint(int a1)
{
  return __istype(a1, 0x40000u);
}

int ispunct(int a1)
{
  return __istype(a1, 0x2000u);
}

int isspace(int a1)
{
  return __istype(a1, 0x4000u);
}

int isupper(int a1)
{
  return __istype(a1, 0x8000u);
}

int isxdigit(int a1)
{
  return __isctype(a1, 0x10000);
}

int toascii(int a1)
{
  return a1 & 0x7F;
}

int tolower(int a1)
{
  return __tolower(a1);
}

int toupper(int a1)
{
  return __toupper(a1);
}

int digittoint(int a1)
{
  return __maskrune(a1, 0xFu);
}

int ishexnumber(int a1)
{
  return __istype(a1, 0x10000u);
}

int isideogram(int a1)
{
  return __istype(a1, 0x80000u);
}

int isnumber(int a1)
{
  return __istype(a1, 0x400u);
}

int isphonogram(int a1)
{
  return __istype(a1, 0x200000u);
}

int isrune(int a1)
{
  return __istype(a1, 0xFFFFFFF0);
}

int isspecial(int a1)
{
  return __istype(a1, 0x100000u);
}

int digittoint_l(int a1, locale_t a2)
{
  return __maskrune_l(a1, 0xFu, a2);
}

int isalnum_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x500u, a2);
}

int isalpha_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x100u, a2);
}

int isblank_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x20000u, a2);
}

int iscntrl_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x200u, a2);
}

int isdigit_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x400u, a2);
}

int isgraph_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x800u, a2);
}

int ishexnumber_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x10000u, a2);
}

int isideogram_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x80000u, a2);
}

int islower_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x1000u, a2);
}

int isnumber_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x400u, a2);
}

int isphonogram_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x200000u, a2);
}

int isprint_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x40000u, a2);
}

int ispunct_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x2000u, a2);
}

int isrune_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0xFFFFFFF0, a2);
}

int isspace_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x4000u, a2);
}

int isspecial_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x100000u, a2);
}

int isupper_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x8000u, a2);
}

int isxdigit_l(int a1, locale_t a2)
{
  return __istype_l(a1, 0x10000u, a2);
}

int tolower_l(int a1, locale_t a2)
{
  return __tolower_l(a1, a2);
}

int toupper_l(int a1, locale_t a2)
{
  return __toupper_l(a1, a2);
}

void bcopy(const void *a1, void *a2, size_t a3)
{
  j___platform_memmove_0(a2, a1, a3);
}

int iswalnum(wint_t a1)
{
  return __istype(a1, 0x500u);
}

int iswalpha(wint_t a1)
{
  return __istype(a1, 0x100u);
}

int iswcntrl(wint_t a1)
{
  return __istype(a1, 0x200u);
}

int iswctype(wint_t a1, wctype_t a2)
{
  return __istype(a1, a2);
}

int iswdigit(wint_t a1)
{
  return __isctype(a1, 1024);
}

int iswgraph(wint_t a1)
{
  return __istype(a1, 0x800u);
}

int iswlower(wint_t a1)
{
  return __istype(a1, 0x1000u);
}

int iswprint(wint_t a1)
{
  return __istype(a1, 0x40000u);
}

int iswpunct(wint_t a1)
{
  return __istype(a1, 0x2000u);
}

int iswspace(wint_t a1)
{
  return __istype(a1, 0x4000u);
}

int iswupper(wint_t a1)
{
  return __istype(a1, 0x8000u);
}

int iswxdigit(wint_t a1)
{
  return __isctype(a1, 0x10000);
}

wint_t towlower(wint_t a1)
{
  return __tolower(a1);
}

wint_t towupper(wint_t a1)
{
  return __toupper(a1);
}

int iswalnum_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x500u, a2);
}

int iswalpha_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x100u, a2);
}

int iswcntrl_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x200u, a2);
}

int iswctype_l(wint_t a1, wctype_t a2, locale_t a3)
{
  return __istype_l(a1, a2, a3);
}

int iswdigit_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x400u, a2);
}

int iswgraph_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x800u, a2);
}

int iswlower_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x1000u, a2);
}

int iswprint_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x40000u, a2);
}

int iswpunct_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x2000u, a2);
}

int iswspace_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x4000u, a2);
}

int iswupper_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x8000u, a2);
}

int iswxdigit_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x10000u, a2);
}

wint_t towlower_l(wint_t a1, locale_t a2)
{
  return __tolower_l(a1, a2);
}

wint_t towupper_l(wint_t a1, locale_t a2)
{
  return __toupper_l(a1, a2);
}

int iswblank(wint_t a1)
{
  return __istype(a1, 0x20000u);
}

wint_t iswascii(wint_t a1)
{
  return (a1 & 0xFFFFFF80) == 0;
}

wint_t iswhexnumber(wint_t a1)
{
  return __istype(a1, 0x10000u);
}

wint_t iswideogram(wint_t a1)
{
  return __istype(a1, 0x80000u);
}

wint_t iswnumber(wint_t a1)
{
  return __istype(a1, 0x400u);
}

wint_t iswphonogram(wint_t a1)
{
  return __istype(a1, 0x200000u);
}

wint_t iswrune(wint_t a1)
{
  return __istype(a1, 0xFFFFFFF0);
}

wint_t iswspecial(wint_t a1)
{
  return __istype(a1, 0x100000u);
}

int iswblank_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x20000u, a2);
}

wint_t iswhexnumber_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x10000u, a2);
}

wint_t iswideogram_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x80000u, a2);
}

wint_t iswnumber_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x400u, a2);
}

wint_t iswphonogram_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x200000u, a2);
}

wint_t iswrune_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0xFFFFFFF0, a2);
}

wint_t iswspecial_l(wint_t a1, locale_t a2)
{
  return __istype_l(a1, 0x100000u, a2);
}

locale_t duplocale(locale_t a1)
{
  int v1;
  BOOL v3;
  int v5;

  if (a1)
  {
    v3 = 1;
    if (a1 != (locale_t)-1)
      v3 = *((_QWORD *)a1 + 163) == 0x786C6F63616C6530;
    if (v3)
      v1 = 0;
    else
      v1 = -1;
    v5 = v1;
  }
  else
  {
    v5 = 0;
  }
  if (v5 >= 0)
    return (locale_t)_duplocale((os_unfair_lock_s *)a1);
  *__error() = 22;
  return 0;
}

uint64_t _duplocale(os_unfair_lock_s *a1)
{
  os_unfair_lock_s *v2;
  int i;
  uint64_t v4;
  os_unfair_lock_s *v7;

  v4 = malloc_type_malloc(1472, 0x10B0040F94CF6B0);
  if (!v4)
    return 0;
  *(_DWORD *)v4 = 1;
  *(_QWORD *)(v4 + 8) = destruct_locale;
  *(_DWORD *)(v4 + 1296) = 0;
  if (a1)
  {
    if (a1 == (os_unfair_lock_s *)-1)
    {
      a1 = (os_unfair_lock_s *)__global_locale;
    }
    else if (a1 == (os_unfair_lock_s *)&__c_locale)
    {
      j___platform_memmove(v4, &__c_locale, 1472);
      *(_DWORD *)v4 = 1;
      *(_QWORD *)(v4 + 8) = destruct_locale;
      *(_DWORD *)(v4 + 1296) = 0;
      return v4;
    }
  }
  else
  {
    v7 = (os_unfair_lock_s *)pthread_getspecific(__locale_key);
    if (v7)
      v2 = v7;
    else
      v2 = (os_unfair_lock_s *)__global_locale;
    a1 = v2;
  }
  os_unfair_lock_lock(a1 + 324);
  j___platform_memmove(v4 + 1304, &a1[326], 168);
  os_unfair_lock_unlock(a1 + 324);
  _platform_bzero(v4 + 16, 1288);
  for (i = 0; i < 6; ++i)
    xlocale_retain(*(unsigned int **)(v4 + 1320 + 8 * i));
  xlocale_retain(*(unsigned int **)(v4 + 1368));
  return v4;
}

int freelocale(locale_t a1)
{
  int v1;
  BOOL v3;

  if (!a1)
    goto LABEL_11;
  v3 = 1;
  if (a1 != (locale_t)-1)
    v3 = *((_QWORD *)a1 + 163) == 0x786C6F63616C6530;
  v1 = v3 ? 0 : -1;
  if (v1 < 0 || a1 == (locale_t)__global_locale || a1 == (locale_t)-1 || a1 == (locale_t)&__c_locale)
  {
LABEL_11:
    *__error() = 22;
    return -1;
  }
  else
  {
    xlocale_release((uint64_t)a1);
    return 0;
  }
}

uint64_t xlocale_release(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;

  if (result)
  {
    v3 = *(_DWORD *)result;
    do
    {
      v1 = v3;
      do
        v2 = __ldaxr((unsigned int *)result);
      while (v2 == v3 && __stlxr(v3 - 1, (unsigned int *)result));
      v3 = v2;
    }
    while (v2 != v1);
    if (v2 == 1)
    {
      if (*(_QWORD *)(result + 8))
        return (*(uint64_t (**)(uint64_t))(result + 8))(result);
    }
  }
  return result;
}

locale_t newlocale(int a1, const char *a2, locale_t a3)
{
  int v3;
  _xlocale *v4;
  int v5;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  uint64_t v10;
  _xlocale *v11;
  int v15;

  v10 = a1 & 0x3F;
  v9 = 0;
  if (a2)
  {
    v8 = 1;
    if ((unint64_t)_platform_strlen(a2) <= 0x1F)
    {
      if (*a2 != 46 || (v8 = 1, a2[1]) && (a2[1] != 46 || (v8 = 1, a2[2])))
        v8 = _platform_strchr(a2, 47) != 0;
    }
    v9 = v8;
  }
  if (v9)
    v3 = -1;
  else
    v3 = 0;
  if (v3 < 0)
    goto LABEL_13;
  if ((_DWORD)v10 == 63)
  {
    v4 = (_xlocale *)_duplocale((os_unfair_lock_s *)&__c_locale);
  }
  else
  {
    if (a3)
    {
      v7 = 1;
      if (a3 != (locale_t)-1)
        v7 = *((_QWORD *)a3 + 163) == 0x786C6F63616C6530;
      if (v7)
        v5 = 0;
      else
        v5 = -1;
      v15 = v5;
    }
    else
    {
      v15 = 0;
    }
    if (v15 < 0)
    {
LABEL_13:
      *__error() = 22;
      return 0;
    }
    v4 = (_xlocale *)_duplocale((os_unfair_lock_s *)a3);
  }
  v11 = v4;
  if (!v4)
    return 0;
  if (!(_DWORD)v10 || (_DWORD)v10 == 63 && !a2)
    return v4;
  if ((int)_modifylocale((uint64_t)v4, v10) >= 0)
    return v11;
  freelocale(v11);
  return 0;
}

uint64_t _modifylocale(uint64_t a1, int a2)
{
  unint64_t v3;
  int v4;
  int i;

  v4 = __detect_path_locale();
  if (v4)
  {
    *__error() = v4;
    return -1;
  }
  else
  {
    for (i = 1; i <= 32; i *= 2)
    {
      if ((i & a2) != 0)
      {
        v3 = (i - 1);
        if (v3 <= 0x1F)
          __asm { BR              X8 }
      }
    }
    return 0;
  }
}

uint64_t __numeric_ctype(uint64_t a1)
{
  const char *v2;
  int v3;

  v3 = *(unsigned __int8 *)(a1 + 1318);
  if (*(_BYTE *)(a1 + 1318))
  {
    if (v3 == 1)
    {
      return a1;
    }
    else if (v3 == 2)
    {
      return *(_QWORD *)(a1 + 1368);
    }
    else
    {
      return a1;
    }
  }
  else
  {
    if (*(_BYTE *)(a1 + 1314))
      v2 = *(const char **)(*(_QWORD *)(a1 + 1344) + 64);
    else
      v2 = (const char *)&C;
    if (_platform_strcmp(*(_QWORD *)(a1 + 1328) + 16, v2))
    {
      *(_QWORD *)(a1 + 1368) = newlocale(2, v2, (locale_t)&__c_locale);
      if (*(_QWORD *)(a1 + 1368))
      {
        *(_BYTE *)(a1 + 1318) = 2;
        return *(_QWORD *)(a1 + 1368);
      }
      else
      {
        *(_BYTE *)(a1 + 1318) = 1;
        return a1;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 1318) = 1;
      return a1;
    }
  }
}

const char *__cdecl querylocale(int a1, locale_t a2)
{
  int v2;
  _xlocale *v4;
  BOOL v5;
  const char *v6;
  int v7;
  int v8;
  locale_t v9;
  int v12;
  _QWORD *v13;

  v9 = a2;
  if (a2)
  {
    v5 = 1;
    if (a2 != (locale_t)-1)
      v5 = *((_QWORD *)a2 + 163) == 0x786C6F63616C6530;
    if (v5)
      v2 = 0;
    else
      v2 = -1;
    v12 = v2;
  }
  else
  {
    v12 = 0;
  }
  if (v12 < 0 || (a1 & 0x3F) == 0)
    goto LABEL_20;
  if (a2)
  {
    if (a2 == (locale_t)-1)
      v9 = (locale_t)__global_locale;
  }
  else
  {
    v13 = pthread_getspecific(__locale_key);
    v4 = (_xlocale *)(v13 ? v13 : __global_locale);
    v9 = v4;
  }
  v7 = ffs(a1) - 1;
  if ((unint64_t)v7 < 6)
  {
    v8 = querylocale_mapping[v7];
    if (v8 >= 6)
      __assert_rtn("querylocale", "xlocale.c", 437, "type < XLC_LAST");
    os_unfair_lock_lock((os_unfair_lock_t)v9 + 324);
    if (*((_QWORD *)v9 + v8 + 165))
      v6 = (const char *)(*((_QWORD *)v9 + v8 + 165) + 16);
    else
      v6 = (const char *)&C;
    os_unfair_lock_unlock((os_unfair_lock_t)v9 + 324);
    return v6;
  }
  else
  {
LABEL_20:
    *__error() = 22;
    return 0;
  }
}

locale_t uselocale(locale_t a1)
{
  int v1;
  BOOL v4;
  _xlocale *v5;
  unsigned int *v6;

  v6 = (unsigned int *)a1;
  if (a1)
  {
    v4 = 1;
    if (a1 != (locale_t)-1)
      v4 = *((_QWORD *)a1 + 163) == 0x786C6F63616C6530;
    if (v4)
      v1 = 0;
    else
      v1 = -1;
    if (v1 < 0)
    {
      *__error() = 22;
      return 0;
    }
    if (a1 == (locale_t)-1 || a1 == (locale_t)__global_locale)
      v6 = 0;
    xlocale_retain(v6);
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
    pthread_setspecific(__locale_key, v6);
    xlocale_release((uint64_t)v5);
  }
  else
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  if (v5)
    return v5;
  else
    return (locale_t)-1;
}

unsigned int *xlocale_retain(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v4;

  if (!a1)
    return 0;
  v4 = *a1;
  do
  {
    v1 = v4;
    do
      v2 = __ldaxr(a1);
    while (v2 == v4 && __stlxr(v4 + 1, a1));
    v4 = v2;
  }
  while (v2 != v1);
  return a1;
}

int ___mb_cur_max(void)
{
  char v0;
  char v1;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  if (v0)
    v1 = 1;
  else
    v1 = 0;
  if ((v1 & 1) != 0)
  {
    v4 = pthread_getspecific(__locale_key);
  }
  else
  {
    v5 = __locale_key;
    v4 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
  }
  if (v4)
    v3 = v4;
  else
    v3 = &__global_locale;
  return *(_DWORD *)(v3[166] + 64);
}

int ___mb_cur_max_l(locale_t a1)
{
  locale_t v2;

  v2 = a1;
  if (a1)
  {
    if (a1 == (locale_t)-1)
      v2 = (locale_t)&__global_locale;
  }
  else
  {
    v2 = (locale_t)&__c_locale;
  }
  return *(_DWORD *)(*((_QWORD *)v2 + 166) + 64);
}

uint64_t __xlocale_init()
{
  uint64_t result;

  if (__locale_key == -1)
  {
    __locale_key = 10;
    return pthread_key_init_np(10, __xlocale_release);
  }
  return result;
}

uint64_t __xlocale_release(uint64_t a1)
{
  return xlocale_release(a1);
}

void destruct_locale(uint64_t *a1)
{
  int i;

  for (i = 0; i < 6; ++i)
    xlocale_release(a1[i + 165]);
  xlocale_release(a1[171]);
  free(a1);
}

uint64_t xlocale_fill_name(uint64_t result, uint64_t a2)
{
  if (result)
    return _platform_strlcpy(result + 16, a2, 32);
  return result;
}

uint64_t _subsystem_init(uint64_t a1)
{
  uint64_t result;

  result = _simple_getenv(a1, "subsystem_root_path");
  if (result)
  {
    subsystem_root_path = result;
    result = _platform_strnlen(result, 1024);
    subsystem_root_path_len = result;
  }
  return result;
}

uint64_t open_with_subsystem(uint64_t a1, unsigned int a2)
{
  uint64_t next_subsystem_root_path;
  int v4;
  _BYTE v8[1024];

  if ((a2 & 0x200) != 0)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    v4 = open_NOCANCEL(a1, a2);
    if (v4 < 0 && *__error() == 2 && subsystem_root_path)
    {
      next_subsystem_root_path = subsystem_root_path;
      while (1)
      {
        next_subsystem_root_path = extract_next_subsystem_root_path((uint64_t)v8, 1024, next_subsystem_root_path);
        if (!append_path_to_subsystem_root((uint64_t)v8, 0x400uLL, a1))
          break;
        v4 = open_NOCANCEL(v8, a2);
        if (v4 < 0)
        {
          __error();
          if (next_subsystem_root_path)
            continue;
        }
        return v4;
      }
      *__error() = 63;
    }
    return v4;
  }
}

uint64_t extract_next_subsystem_root_path(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  char v6;

  v6 = 0;
  v5 = _platform_strlen(a3);
  if (!a2)
    return a3;
  v4 = _platform_memchr(a3, 58, v5);
  if (v4)
  {
    v5 = v4 - a3;
    v6 = 1;
  }
  if (v5 > a2 - 1)
    return 0;
  j___platform_memmove(a1, a3, v5);
  *(_BYTE *)(a1 + v5) = 0;
  if ((v6 & 1) != 0)
    return v4 + 1;
  else
    return 0;
}

BOOL append_path_to_subsystem_root(uint64_t a1, unint64_t a2, uint64_t a3)
{
  return _platform_strlcat(a1, a3, a2) < a2;
}

uint64_t stat_with_subsystem(const char *a1, stat *a2)
{
  uint64_t next_subsystem_root_path;
  int v4;
  char v7[1024];

  v4 = stat(a1, a2);
  if (v4 < 0 && *__error() == 2 && subsystem_root_path)
  {
    next_subsystem_root_path = subsystem_root_path;
    while (1)
    {
      next_subsystem_root_path = extract_next_subsystem_root_path((uint64_t)v7, 1024, next_subsystem_root_path);
      if (!append_path_to_subsystem_root((uint64_t)v7, 0x400uLL, (uint64_t)a1))
        break;
      v4 = stat(v7, a2);
      if (v4 < 0)
      {
        __error();
        if (next_subsystem_root_path)
          continue;
      }
      return v4;
    }
    *__error() = 63;
  }
  return v4;
}

tm *__cdecl getdate(const char *a1)
{
  int v1;
  int v3;
  int v4;
  char *v5;
  char *__filename;
  stat v7;
  char *v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  int i;
  int v16;
  FILE *v17;
  time_t v18;
  tm *v19;
  tm *v20;
  const char *v21;

  v21 = a1;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  i = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  _platform_memset(&v7, 0, 144);
  __filename = getenv("DATEMSK");
  if (!__filename || !*__filename)
  {
    getdate_err = 1;
    return 0;
  }
  v11 = *__error();
  v17 = fopen(__filename, "r");
  if (!v17)
  {
    getdate_err = 2;
    v4 = v11;
    *__error() = v4;
    return 0;
  }
  v1 = fileno(v17);
  if (fstat(v1, &v7) < 0)
  {
    getdate_err = 3;
    goto LABEL_55;
  }
  if ((v7.st_mode & 0xF000) != 0x8000)
  {
    getdate_err = 4;
    goto LABEL_55;
  }
  v16 = 1024;
  v8 = (char *)malloc_type_malloc(1024, 3424541391);
  if (!v8)
  {
    getdate_err = 6;
    goto LABEL_55;
  }
  for (i = 0; ; i = 0)
  {
    while (fgets(&v8[i], v16 - i, v17))
    {
      v14 = _platform_strlen(v8);
      if (v14 != v16 - 1 || v8[v14 - 1] == 10)
        goto LABEL_24;
      v16 += 1024;
      v5 = (char *)malloc_type_realloc(v8, v16, 3481111867);
      if (!v5)
      {
        getdate_err = 6;
        goto LABEL_54;
      }
      v8 = v5;
      i = v14;
    }
    if (ferror(v17))
    {
      getdate_err = 5;
      goto LABEL_54;
    }
    if (!i)
    {
      getdate_err = 7;
      goto LABEL_54;
    }
    v14 = _platform_strlen(v8);
LABEL_24:
    if (v8[v14 - 1] == 10)
      v8[v14 - 1] = 0;
    j___platform_memmove(&getdate_tm, &tmundef, 56);
    if (strptime(v21, v8, (tm *)&getdate_tm))
      break;
  }
  time(&v18);
  v20 = localtime(&v18);
  v12 = 0;
  v13 = 0;
  if (getdate_tm != -1)
    v12 |= 1u;
  if (dword_DE97C != -1)
    v12 |= 2u;
  if (dword_DE980 != -1)
    v12 |= 4u;
  if (dword_DE984 != -1)
    v13 |= 1u;
  if (dword_DE988 != -1)
    v13 |= 2u;
  if (dword_DE98C != -1)
    v13 |= 4u;
  v10 = dword_DE990;
  if (v12 <= 6uLL)
    __asm { BR              X8 }
  if (v13 <= 6uLL)
    __asm { BR              X8 }
  dword_DE990 = v20->tm_wday;
  qword_DE9A0 = v20->tm_gmtoff;
  dword_DE998 = -1;
  v9 = dword_DE988;
  if (mktime((tm *)&getdate_tm) == -1)
  {
    getdate_err = 8;
  }
  else if ((v13 & 2) == 0 || dword_DE988 == v9)
  {
    if (v10 == -1
      || v13 == 7
      || (dword_DE984 += v10 - dword_DE990 + (v10 - dword_DE990 < 0 ? 7 : 0), mktime((tm *)&getdate_tm) != -1))
    {
      v19 = (tm *)&getdate_tm;
    }
    else
    {
      getdate_err = 8;
    }
  }
  else
  {
    getdate_err = 8;
  }
LABEL_54:
  free(v8);
LABEL_55:
  fclose(v17);
  v3 = v11;
  *__error() = v3;
  return v19;
}

uint64_t _st_get_timezone()
{
  return timezone;
}

uint64_t _st_set_timezone(uint64_t result)
{
  timezone = result;
  return result;
}

int asxprintf(char **__ret, printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_list va;

  va_start(va, __format);
  return _vasprintf(0, (pthread_rwlock_t *)__domain, (void **)__ret, __loc, (char *)__format, (int *)va);
}

int dxprintf(int __fd, printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_list va;

  va_start(va, __format);
  return _vdprintf(0, (pthread_rwlock_t *)__domain, __fd, __loc, (char *)__format, (int *)va);
}

int fxprintf(FILE *__stream, printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_list va;

  va_start(va, __format);
  return __xvprintf(0, (uint64_t)__domain, (uint64_t)__stream, (uint64_t)__loc, (uint64_t)__format, (uint64_t)va);
}

int sxprintf(char *__str, size_t __size, printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_list va;

  va_start(va, __format);
  return _vsnprintf(0, (pthread_rwlock_t *)__domain, __str, __size, __loc, (char *)__format, (int *)va);
}

int xprintf(printf_domain_t __domain, locale_t __loc, const char *__format, ...)
{
  va_list va;

  va_start(va, __format);
  return __xvprintf(0, (uint64_t)__domain, (uint64_t)__stdoutp, (uint64_t)__loc, (uint64_t)__format, (uint64_t)va);
}

int vasxprintf(char **__ret, printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return _vasprintf(0, (pthread_rwlock_t *)__domain, (void **)__ret, __loc, (char *)__format, (int *)__ap);
}

int vdxprintf(int __fd, printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return _vdprintf(0, (pthread_rwlock_t *)__domain, __fd, __loc, (char *)__format, (int *)__ap);
}

int vfxprintf(FILE *__stream, printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return __xvprintf(0, (uint64_t)__domain, (uint64_t)__stream, (uint64_t)__loc, (uint64_t)__format, (uint64_t)__ap);
}

int vsxprintf(char *__str, size_t __size, printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return _vsnprintf(0, (pthread_rwlock_t *)__domain, __str, __size, __loc, (char *)__format, (int *)__ap);
}

int vxprintf(printf_domain_t __domain, locale_t __loc, const char *__format, va_list __ap)
{
  return __xvprintf(0, (uint64_t)__domain, (uint64_t)__stdoutp, (uint64_t)__loc, (uint64_t)__format, (uint64_t)__ap);
}

void free_printf_comp(printf_comp_t __pc)
{
  if (__pc)
  {
    xlocale_release(*((_QWORD *)__pc + 10));
    free(*((void **)__pc + 11));
    free(*((void **)__pc + 13));
    free(*((void **)__pc + 14));
    pthread_mutex_destroy((pthread_mutex_t *)__pc);
    free(__pc);
  }
}

printf_comp_t new_printf_comp(printf_domain_t __domain, locale_t __loc, const char *__fmt)
{
  uint64_t v3;
  _xlocale *v5;
  pthread_mutex_t *v6;
  int v7;
  int v8;
  _xlocale *v13;
  _QWORD v14[8];

  if (__domain)
  {
    v3 = _platform_strlen(__fmt);
    v6 = (pthread_mutex_t *)malloc_type_malloc(v3 + 129, 573463117);
    if (v6)
    {
      _platform_memset(v6, 0, 128);
      _platform_memset(v14, 0, 64);
      v14[0] = 850045863;
      j___platform_memmove(v6, v14, 64);
      v6[1].__sig = (uint64_t)&v6[2];
      _platform_strcpy(v6[1].__sig, __fmt);
      if (__loc)
      {
        if (__loc == (locale_t)-1)
          __loc = (locale_t)__global_locale;
        xlocale_retain((unsigned int *)__loc);
      }
      else
      {
        v13 = (_xlocale *)pthread_getspecific(__locale_key);
        if (v13)
          v5 = v13;
        else
          v5 = (_xlocale *)__global_locale;
        __loc = v5;
        xlocale_retain((unsigned int *)v5);
      }
      *(_QWORD *)&v6[1].__opaque[8] = __loc;
      pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
      pthread_rwlock_rdlock((pthread_rwlock_t *)__domain);
      v8 = __printf_comp((uint64_t)v6, (uint64_t)__domain);
      v7 = *__error();
      pthread_rwlock_unlock((pthread_rwlock_t *)__domain);
      if (v8 >= 0)
      {
        return (printf_comp_t)v6;
      }
      else
      {
        xlocale_release((uint64_t)__loc);
        pthread_mutex_destroy(v6);
        free(v6);
        *__error() = v7;
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

uint64_t __xprintf_domain_init()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *n;
  int m;
  char **v13;
  char *k;
  int j;
  char **v16;
  const char *i;
  _QWORD v18[25];

  xprintf_domain_default = malloc_type_calloc(1, 2552, 0x10800406116304FLL);
  if (!xprintf_domain_default)
    abort_report_np((uint64_t)"%s:%s:%u: No memory", v0, v1, v2, v3, v4, v5, v6, (uint64_t)"xprintf_domain.c");
  v10 = xprintf_domain_default;
  _platform_memset(v18, 0, 200);
  v18[0] = 766030772;
  result = j___platform_memmove(v10, v18, 200);
  for (i = "#$'*+,-.0123456789:;L_hjlqtvz"; *i; ++i)
    *(_BYTE *)(xprintf_domain_default + 200 + *i - 33) = 3;
  v16 = &_printf_tbl_defaults_fbsd;
  for (j = 6; j > 0; --j)
  {
    for (k = *v16; *k; ++k)
    {
      *(_BYTE *)(xprintf_domain_default + 200 + *k - 33) = 2;
      v8 = xprintf_domain_default + 296 + 24 * (*k - 33);
      *(_OWORD *)v8 = *(_OWORD *)(v16 + 1);
      *(_QWORD *)(v8 + 16) = 0;
    }
    v16 += 3;
  }
  v13 = &_printf_tbl_defaults_glibc;
  for (m = 1; m > 0; --m)
  {
    for (n = *v13; *n; ++n)
    {
      *(_BYTE *)(xprintf_domain_default + 200 + *n - 33) = 1;
      v9 = xprintf_domain_default + 296 + 24 * (*n - 33);
      *(_OWORD *)v9 = *(_OWORD *)(v13 + 1);
      *(_QWORD *)(v9 + 16) = 0;
    }
    v13 += 3;
  }
  return result;
}

printf_domain_t copy_printf_domain(printf_domain_t __domain)
{
  _printf_domain *v2;
  _QWORD v5[25];

  if (__domain)
  {
    v2 = (_printf_domain *)malloc_type_malloc(2552, 0x10800406116304FLL);
    if (v2)
    {
      pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
      pthread_rwlock_rdlock((pthread_rwlock_t *)__domain);
      j___platform_memmove(v2, __domain, 2552);
      pthread_rwlock_unlock((pthread_rwlock_t *)__domain);
      _platform_memset(v5, 0, 200);
      v5[0] = 766030772;
      j___platform_memmove(v2, v5, 200);
      return v2;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

void free_printf_domain(printf_domain_t __domain)
{
  if (__domain)
  {
    pthread_rwlock_destroy((pthread_rwlock_t *)__domain);
    free(__domain);
  }
}

printf_domain_t new_printf_domain(void)
{
  _printf_domain *v1;

  pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
  v1 = (_printf_domain *)malloc_type_malloc(2552, 0x10800406116304FLL);
  if (!v1)
    return 0;
  j___platform_memmove(v1, xprintf_domain_default, 2552);
  return v1;
}

int register_printf_domain_function(printf_domain_t __domain, int __spec, printf_function *__render, printf_arginfo_function *__arginfo, void *__context)
{
  char *v5;
  __int128 v8;

  *((_QWORD *)&v8 + 1) = __render;
  *(_QWORD *)&v8 = __arginfo;
  pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
  if (__domain
    && __spec >= 33
    && __spec <= 126
    && (pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init),
        *((_BYTE *)__domain + __spec + 167) != 3))
  {
    pthread_rwlock_wrlock((pthread_rwlock_t *)__domain);
    if (*((_QWORD *)&v8 + 1) && (_QWORD)v8)
    {
      *((_BYTE *)__domain + __spec + 167) = 1;
      v5 = (char *)__domain + 24 * __spec - 496;
      *(_OWORD *)v5 = v8;
      *((_QWORD *)v5 + 2) = __context;
    }
    else
    {
      *((_BYTE *)__domain + __spec + 167) = 0;
    }
    pthread_rwlock_unlock((pthread_rwlock_t *)__domain);
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t register_printf_domain_render(pthread_rwlock_t *a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  __int128 v6;

  *((_QWORD *)&v6 + 1) = a3;
  *(_QWORD *)&v6 = a4;
  pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
  if (a1
    && a2 >= 33
    && a2 <= 126
    && (pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init), a1->__opaque[a2 + 159] != 3))
  {
    pthread_rwlock_wrlock(a1);
    if (*((_QWORD *)&v6 + 1) && (_QWORD)v6)
    {
      a1->__opaque[a2 + 159] = 2;
      v4 = (uint64_t)&a1[-2] + 24 * a2 - 96;
      *(_OWORD *)v4 = v6;
      *(_QWORD *)(v4 + 16) = 0;
    }
    else
    {
      a1->__opaque[a2 + 159] = 0;
    }
    pthread_rwlock_unlock(a1);
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int register_printf_domain_render_std(printf_domain_t __domain, const char *__specs)
{
  unint64_t v3;

  if (!*__specs)
    return 0;
  v3 = (*__specs - 72);
  if (v3 <= 0xE)
    __asm { BR              X8 }
  *__error() = 22;
  return -1;
}

int asxprintf_exec(char **__ret, printf_comp_t __pc, ...)
{
  va_list va;

  va_start(va, __pc);
  if (__pc)
    return _vasprintf((uint64_t)__pc, 0, (void **)__ret, 0, 0, (int *)va);
  *__error() = 22;
  return -1;
}

int dxprintf_exec(int __fd, printf_comp_t __pc, ...)
{
  va_list va;

  va_start(va, __pc);
  if (__pc)
    return _vdprintf((uint64_t)__pc, 0, __fd, 0, 0, (int *)va);
  *__error() = 22;
  return -1;
}

int fxprintf_exec(FILE *__stream, printf_comp_t __pc, ...)
{
  va_list va;

  va_start(va, __pc);
  if (__pc)
    return __xvprintf((uint64_t)__pc, 0, (uint64_t)__stream, 0, 0, (uint64_t)va);
  *__error() = 22;
  return -1;
}

int sxprintf_exec(char *__str, size_t __size, printf_comp_t __pc, ...)
{
  va_list va;

  va_start(va, __pc);
  if (__pc)
    return _vsnprintf((uint64_t)__pc, 0, __str, __size, 0, 0, (int *)va);
  *__error() = 22;
  return -1;
}

int xprintf_exec(printf_comp_t __pc, ...)
{
  va_list va;

  va_start(va, __pc);
  if (__pc)
    return __xvprintf((uint64_t)__pc, 0, (uint64_t)__stdoutp, 0, 0, (uint64_t)va);
  *__error() = 22;
  return -1;
}

int vasxprintf_exec(char **__ret, printf_comp_t __pc, va_list __ap)
{
  if (__pc)
    return _vasprintf((uint64_t)__pc, 0, (void **)__ret, 0, 0, (int *)__ap);
  *__error() = 22;
  return -1;
}

int vdxprintf_exec(int __fd, printf_comp_t __pc, va_list __ap)
{
  if (__pc)
    return _vdprintf((uint64_t)__pc, 0, __fd, 0, 0, (int *)__ap);
  *__error() = 22;
  return -1;
}

int vfxprintf_exec(FILE *__stream, printf_comp_t __pc, va_list __ap)
{
  if (__pc)
    return __xvprintf((uint64_t)__pc, 0, (uint64_t)__stream, 0, 0, (uint64_t)__ap);
  *__error() = 22;
  return -1;
}

int vsxprintf_exec(char *__str, size_t __size, printf_comp_t __pc, va_list __ap)
{
  if (__pc)
    return _vsnprintf((uint64_t)__pc, 0, __str, __size, 0, 0, (int *)__ap);
  *__error() = 22;
  return -1;
}

int vxprintf_exec(printf_comp_t __pc, va_list __ap)
{
  if (__pc)
    return __xvprintf((uint64_t)__pc, 0, (uint64_t)__stdoutp, 0, 0, (uint64_t)__ap);
  *__error() = 22;
  return -1;
}

int login_tty(int a1)
{
  int v2;

  v2 = a1;
  setsid();
  if (ioctl(v2, 0x20007461uLL, 0) == -1)
    return -1;
  dup2(v2, 0);
  dup2(v2, 1);
  dup2(v2, 2);
  if (v2 > 2)
    close_NOCANCEL(v2);
  return 0;
}

uint64_t _mkpath_np(const char *a1, mode_t a2, char **a3)
{
  return _mkpath(-2, a1, a2, a3);
}

uint64_t _mkpath(int a1, const char *a2, mode_t a3, char **a4)
{
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  int v9;
  char *v10;
  int v11;
  stat v12;
  stat v13;
  int v14;
  unsigned int v15;
  mode_t v16;
  unsigned int v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char **v23;
  mode_t v24;
  const char *v25;
  int v26;

  v26 = a1;
  v25 = a2;
  v24 = a3;
  v23 = a4;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v14 = *__error();
  _platform_memset(&v13, 0, 144);
  if (mkdirat(v26, v25, v24))
  {
    v11 = *__error();
    switch(v11)
    {
      case 2:
        v22 = strdup(v25);
        if (v22)
        {
          v10 = v22;
          v20 = &v10[_platform_strlen(v22) - 1];
          v18 = v20;
          do
          {
            v19 = v20;
            if (v20 - 1 > v22 && *v20 == 46 && *(v20 - 1) == 47)
              v20 -= 2;
            if (v20 > v22 && *v20 == 47)
              --v20;
          }
          while (v20 < v19);
          if (v20 >= v18 || (v20[1] = 0, v21 = strdup(v22), (v25 = v21) != 0))
          {
            if (mkdirat(v26, v25, v24))
            {
              while (1)
              {
                v20 = strrchr(v22, 47);
                if (!v20)
                {
                  v15 = 2;
                  goto LABEL_67;
                }
                *v20 = 0;
                ++v17;
                if (!mkdirat(v26, v22, 0x1FFu))
                {
                  _platform_memset(&v12, 0, 144);
                  if (fstatat(v26, v22, &v12, 0) == -1)
                  {
                    v15 = 2;
                  }
                  else
                  {
                    if ((v12.st_mode & 0xC0) == 0xC0
                      || (v16 = v12.st_mode | 0xC0, fchmodat(v26, v22, v12.st_mode | 0xC0, 0) != -1))
                    {
                      if (v23)
                      {
                        v6 = strdup(v22);
                        *v23 = v6;
                      }
                      goto LABEL_54;
                    }
                    v15 = 2;
                  }
                  goto LABEL_67;
                }
                if (*__error() == 17)
                  break;
                if (*__error() != 2)
                  goto LABEL_8;
              }
              if (fstatat(v26, v22, &v13, 0) || (v13.st_mode & 0xF000) != 0x4000)
              {
                v15 = 20;
              }
              else
              {
                if (v23)
                {
                  v7 = strdup(v22);
                  *v23 = v7;
                }
LABEL_54:
                while (v17 > 1)
                {
                  v20 = strrchr(v22, 0);
                  *v20 = 47;
                  --v17;
                  if (mkdirat(v26, v22, 0x1FFu) == -1)
                  {
                    if (*__error() != 17)
                    {
                      v15 = *__error();
                      goto LABEL_67;
                    }
                  }
                  else if (v16 && fchmodat(v26, v22, v16, 0) == -1)
                  {
                    v15 = 2;
                    goto LABEL_67;
                  }
                }
                if (mkdirat(v26, v25, v24) == -1)
                {
                  v15 = *__error();
                  if (*__error() == 17 && !fstatat(v26, v25, &v13, 0) && (v13.st_mode & 0xF000) != 0x4000)
                    v15 = 20;
                }
              }
            }
            else if (v23)
            {
              v5 = strdup(v25);
              *v23 = v5;
            }
          }
          else
          {
            v15 = 12;
          }
        }
        else
        {
          v15 = 12;
        }
        break;
      case 17:
        if (fstatat(v26, v25, &v13, 0))
        {
          v15 = 5;
        }
        else if ((v13.st_mode & 0xF000) == 0x4000)
        {
          v15 = 17;
        }
        else
        {
          v15 = 20;
        }
        break;
      case 21:
        v15 = 17;
        break;
      default:
LABEL_8:
        v15 = *__error();
        break;
    }
  }
  else if (v23)
  {
    v4 = strdup(v25);
    *v23 = v4;
  }
LABEL_67:
  free(v22);
  free(v21);
  v9 = v14;
  *__error() = v9;
  return v15;
}

int mkpath_np(const char *path, mode_t omode)
{
  return _mkpath(-2, path, omode, 0);
}

int mkpathat_np(int dfd, const char *path, mode_t omode)
{
  return _mkpath(dfd, path, omode, 0);
}

int raise(int a1)
{
  _opaque_pthread_t *v1;
  pid_t v2;
  int v4;

  v1 = pthread_self();
  v4 = pthread_kill(v1, a1);
  if (!v4)
    return 0;
  if (v4 == 45)
  {
    v2 = getpid();
    return kill(v2, a1);
  }
  else
  {
    *__error() = v4;
    return -1;
  }
}

void uuid_clear(uuid_t uu)
{
  *(_QWORD *)uu = 0;
  *((_QWORD *)uu + 1) = 0;
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v12;

  v12 = uu1;
  v11 = (unsigned __int8 *)uu2;
  v9 = 0;
  v10 = 0;
  v7 = 0;
  v8 = 0;
  uuid_unpack((unsigned __int8 *)uu1, (uint64_t)&v9);
  uuid_unpack(v11, (uint64_t)&v7);
  if ((_DWORD)v9 == (_DWORD)v7)
  {
    if (WORD2(v9) == WORD2(v7))
    {
      if (HIWORD(v9) == HIWORD(v7))
      {
        if ((unsigned __int16)v10 == (unsigned __int16)v8)
        {
          return _platform_memcmp((char *)&v10 + 2, (char *)&v8 + 2, 6);
        }
        else if ((unsigned __int16)v10 < (int)(unsigned __int16)v8)
        {
          return -1;
        }
        else
        {
          return 1;
        }
      }
      else if (HIWORD(v9) < (int)HIWORD(v7))
      {
        return -1;
      }
      else
      {
        return 1;
      }
    }
    else if (WORD2(v9) < (int)WORD2(v7))
    {
      return -1;
    }
    else
    {
      return 1;
    }
  }
  else if (v9 < v7)
  {
    return -1;
  }
  else
  {
    return 1;
  }
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v2;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3;
  int i;

  for (i = 0; i < 16; ++i)
  {
    v2 = src++;
    v3 = dst++;
    *v3 = *v2;
  }
}

void uuid_generate_time(uuid_t out)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v4;

  v4 = out;
  v2 = 0;
  v3 = 0;
  v1 = 0;
  if (!uuid_generate_time_has_init)
  {
    if ((int)get_node_id(&uuid_generate_time_node_id) <= 0)
    {
      arc4random_buf(&uuid_generate_time_node_id, 6uLL);
      LOBYTE(uuid_generate_time_node_id) = uuid_generate_time_node_id | 1;
    }
    uuid_generate_time_has_init = 1;
  }
  get_clock(&v1, (int *)&v2, &v3);
  LOWORD(v3) = v3 | 0x8000;
  WORD2(v2) = v1;
  HIWORD(v2) = HIWORD(v1) & 0xFFF | 0x1000;
  *(_DWORD *)((char *)&v3 + 2) = uuid_generate_time_node_id;
  HIWORD(v3) = word_DE9BC;
  uuid_pack((int *)&v2, (uint64_t)v4);
}

uint64_t get_node_id(_DWORD *a1)
{
  _DWORD *v1;
  int v3;
  uint64_t v4;
  int i;
  int v6;
  _QWORD v7[2];
  unsigned __int8 *v8;
  int v9;
  _DWORD *v10;
  _BYTE v12[1024];
  _BYTE v13[40];

  v10 = a1;
  memset(v13, 0, 32);
  v8 = 0;
  memset(v7, 0, 12);
  v9 = socket(2, 2, 0);
  if (v9 >= 0)
  {
    _platform_bzero(v12, 1024);
    LODWORD(v7[0]) = 1024;
    *(_QWORD *)((char *)v7 + 4) = v12;
    if (ioctl(v9, 0xC00C6924uLL, v7) >= 0)
    {
      v6 = v7[0];
      for (i = 0; i < v6; i += v3)
      {
        v8 = (unsigned __int8 *)(*(_QWORD *)((char *)v7 + 4) + i);
        _platform_strncpy(v13, v8, 16);
        if (v8[17] == 18 && v8[22] == 6)
        {
          if ((v4 = (uint64_t)&v8[v8[21] + 24], *(_BYTE *)v4) && *(_BYTE *)v4 != 2
            || *(_BYTE *)(v4 + 1)
            || *(_BYTE *)(v4 + 2)
            || *(_BYTE *)(v4 + 3)
            || *(_BYTE *)(v4 + 4)
            || *(_BYTE *)(v4 + 5))
          {
            if (v10)
            {
              v1 = v10;
              *v10 = *(_DWORD *)v4;
              *((_WORD *)v1 + 2) = *(_WORD *)(v4 + 4);
              close_NOCANCEL(v9);
              return 1;
            }
          }
        }
        if ((unint64_t)v8[16] + 16 >= 0x20)
          v3 = v8[16] + 16;
        else
          v3 = 32;
      }
      close_NOCANCEL(v9);
      return 0;
    }
    else
    {
      close_NOCANCEL(v9);
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t get_clock(_DWORD *a1, int *a2, _WORD *a3)
{
  int v4;
  timeval v5;
  _WORD *v6;
  int *v7;
  _DWORD *v8;

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v5.tv_sec = 0;
  *(_QWORD *)&v5.tv_usec = 0;
  while (1)
  {
    gettimeofday(&v5, 0);
    if (!(_QWORD)get_clock_last && !DWORD2(get_clock_last))
    {
      arc4random_buf(&get_clock_clock_seq, 2uLL);
      get_clock_clock_seq &= 0x3FFFu;
      get_clock_last = (__int128)v5;
      *(_QWORD *)&get_clock_last = v5.tv_sec - 1;
    }
    if (v5.tv_sec < (uint64_t)get_clock_last
      || v5.tv_sec == (_QWORD)get_clock_last && v5.tv_usec < SDWORD2(get_clock_last))
    {
      get_clock_clock_seq = (get_clock_clock_seq + 1) & 0x3FFF;
      get_clock_adjustment = 0;
      get_clock_last = (__int128)v5;
      goto LABEL_14;
    }
    if (v5.tv_sec != (_QWORD)get_clock_last || v5.tv_usec != DWORD2(get_clock_last))
      break;
    if (get_clock_adjustment < 10)
    {
      ++get_clock_adjustment;
      goto LABEL_14;
    }
  }
  get_clock_adjustment = 0;
  get_clock_last = (__int128)v5;
LABEL_14:
  v4 = 10 * v5.tv_usec + get_clock_adjustment + 10000000 * LODWORD(v5.tv_sec) + 327237632;
  *v8 = (unint64_t)(10 * v5.tv_usec + get_clock_adjustment + 10000000 * v5.tv_sec + 122192928000000000) >> 32;
  *v7 = v4;
  *v6 = get_clock_clock_seq;
  return 0;
}

void uuid_generate_random(uuid_t out)
{
  uint64_t v1;
  uint64_t v2;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v3;
  _QWORD __buf[2];

  v3 = out;
  __buf[0] = 0;
  __buf[1] = 0;
  v1 = 0;
  v2 = 0;
  arc4random_buf(__buf, 0x10uLL);
  uuid_unpack((unsigned __int8 *)__buf, (uint64_t)&v1);
  LOWORD(v2) = v2 & 0x3FFF | 0x8000;
  HIWORD(v1) = HIWORD(v1) & 0xFFF | 0x4000;
  uuid_pack((int *)&v1, (uint64_t)v3);
}

void uuid_generate(uuid_t out)
{
  uuid_generate_random(out);
}

int uuid_is_null(const uuid_t uu)
{
  const unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v1;
  int i;

  for (i = 0; i < 16; ++i)
  {
    v1 = uu++;
    if (*v1)
      return 0;
  }
  return 1;
}

int *uuid_pack(int *result, uint64_t a2)
{
  unsigned int v2;

  v2 = *result;
  *(_BYTE *)(a2 + 3) = *result;
  v2 >>= 8;
  *(_BYTE *)(a2 + 2) = v2;
  v2 >>= 8;
  *(_BYTE *)(a2 + 1) = v2;
  *(_BYTE *)a2 = BYTE1(v2);
  LOWORD(v2) = *((_WORD *)result + 2);
  *(_BYTE *)(a2 + 5) = v2;
  *(_BYTE *)(a2 + 4) = BYTE1(v2);
  LOWORD(v2) = *((_WORD *)result + 3);
  *(_BYTE *)(a2 + 7) = v2;
  *(_BYTE *)(a2 + 6) = BYTE1(v2);
  LOWORD(v2) = *((_WORD *)result + 4);
  *(_BYTE *)(a2 + 9) = v2;
  *(_BYTE *)(a2 + 8) = BYTE1(v2);
  *(_DWORD *)(a2 + 10) = *(int *)((char *)result + 10);
  *(_WORD *)(a2 + 14) = *((_WORD *)result + 7);
  return result;
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  char *v2;
  char *v3;
  char v4;
  char __str[3];
  const char *v7;
  int i;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *__attribute__((__org_typedef(uuid_t))) v11;
  const char *v12;

  v12 = in;
  v11 = uu;
  v9 = 0;
  v10 = 0;
  i = 0;
  v7 = 0;
  if (_platform_strlen(in) != 36)
    return -1;
  i = 0;
  v7 = v12;
  while (i <= 36)
  {
    if (i == 8 || i == 13 || i == 18 || i == 23)
    {
      if (*v7 != 45)
        return -1;
    }
    else if ((i != 36 || *v7) && !isxdigit(*v7))
    {
      return -1;
    }
    ++i;
    ++v7;
  }
  LODWORD(v9) = strtoul(v12, 0, 16);
  WORD2(v9) = strtoul(v12 + 9, 0, 16);
  HIWORD(v9) = strtoul(v12 + 14, 0, 16);
  LOWORD(v10) = strtoul(v12 + 19, 0, 16);
  v7 = v12 + 24;
  __str[2] = 0;
  for (i = 0; i < 6; ++i)
  {
    v2 = (char *)v7++;
    __str[0] = *v2;
    v3 = (char *)v7++;
    __str[1] = *v3;
    v4 = strtoul(__str, 0, 16);
    *((_BYTE *)&v10 + i + 2) = v4;
  }
  uuid_pack((int *)&v9, (uint64_t)v11);
  return 0;
}

unsigned __int8 *uuid_unpack(unsigned __int8 *result, uint64_t a2)
{
  *(_DWORD *)a2 = result[3] | ((result[2] | ((result[1] | (*result << 8)) << 8)) << 8);
  *(_WORD *)(a2 + 4) = _byteswap_ushort(*((_WORD *)result + 2));
  *(_WORD *)(a2 + 6) = _byteswap_ushort(*((_WORD *)result + 3));
  *(_WORD *)(a2 + 8) = _byteswap_ushort(*((_WORD *)result + 4));
  *(_DWORD *)(a2 + 10) = *(_DWORD *)(result + 10);
  *(_WORD *)(a2 + 14) = *((_WORD *)result + 7);
  return result;
}

void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
{
  uuid_unparse_x((unsigned __int8 *)uu, out, (uint64_t)fmt_lower[0]);
}

unsigned __int8 *uuid_unparse_x(unsigned __int8 *result, _BYTE *a2, uint64_t a3)
{
  _BYTE *v3;
  unsigned __int8 *v4;
  char v5;
  _BYTE *v6;
  int i;
  unsigned __int8 *v8;

  v8 = result;
  for (i = 0; (unint64_t)i < 0x10; ++i)
  {
    if (i == 4 || i == 6 || i == 8 || i == 10)
    {
      v3 = a2++;
      *v3 = 45;
    }
    *a2 = *(_BYTE *)(a3 + ((int)*v8 >> 4));
    v4 = v8++;
    v5 = *(_BYTE *)(a3 + (*v4 & 0xF));
    v6 = a2 + 1;
    a2 += 2;
    *v6 = v5;
  }
  *a2 = 0;
  return result;
}

void uuid_unparse_upper(const uuid_t uu, uuid_string_t out)
{
  uuid_unparse_x((unsigned __int8 *)uu, out, (uint64_t)fmt_upper);
}

void uuid_unparse(const uuid_t uu, uuid_string_t out)
{
  uuid_unparse_x((unsigned __int8 *)uu, out, (uint64_t)fmt_upper);
}

pid_t tcgetsid(int a1)
{
  _DWORD v2[2];

  v2[1] = a1;
  v2[0] = 0;
  if (ioctl(a1, 0x40047463uLL, v2) >= 0)
    return v2[0];
  else
    return -1;
}

uint64_t _libc_initializer(_QWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t inited;
  uint64_t v5;

  _program_vars_init(a4);
  _libc_fork_init(a1);
  __confstr_init((uint64_t)a1);
  __atexit_init();
  inited = _init_clock_port();
  _arc4_fork_child(inited);
  __xlocale_init();
  __guard_setup(a3);
  v5 = _subsystem_init((uint64_t)a3);
  return _arc4_fork_child(v5);
}

uint64_t __libc_init(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  _QWORD v6[8];
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  v7 = a5;
  _platform_memset(v6, 0, 64);
  v6[0] = 1;
  v6[1] = v10;
  v6[2] = v9;
  v6[3] = v8;
  memset(&v6[4], 0, 32);
  return _libc_initializer(v6, 0, v7, v11);
}

void _libc_fork_prepare()
{
  _locale_lock_fork_prepare();
}

void _libc_fork_parent()
{
  _locale_lock_fork_parent();
}

void _libc_fork_child(uint64_t a1)
{
  qword_DDB20 = (uint64_t)"crashed on child side of fork pre-exec";
  _arc4_fork_child(a1);
  _init_clock_port();
  __environ_lock_fork_child();
  _locale_lock_fork_child();
}

char ***_NSGetArgv(void)
{
  return (char ***)NXArgv_pointer;
}

int *_NSGetArgc(void)
{
  return (int *)NXArgc_pointer;
}

char ***_NSGetEnviron(void)
{
  return (char ***)environ_pointer;
}

char **_NSGetProgname(void)
{
  return (char **)__progname_pointer;
}

mach_header_64 *_NSGetMachExecuteHeader(void)
{
  return (mach_header_64 *)_mh_execute_header_pointer;
}

uint64_t *_program_vars_init(uint64_t *result)
{
  NXArgv_pointer = result[2];
  NXArgc_pointer = result[1];
  environ_pointer = result[3];
  __progname_pointer = result[4];
  _mh_execute_header_pointer = *result;
  return result;
}

_QWORD *_libc_fork_init(_QWORD *result)
{
  if (*result < 2uLL)
  {
    _libSystem_atfork_prepare = (_UNKNOWN *)result[1];
    _libSystem_atfork_parent = (_UNKNOWN *)result[2];
    _libSystem_atfork_child = (_UNKNOWN *)result[3];
  }
  else
  {
    _libSystem_atfork_prepare_v2 = (_UNKNOWN *)result[5];
    _libSystem_atfork_parent_v2 = (_UNKNOWN *)result[6];
    _libSystem_atfork_child_v2 = (_UNKNOWN *)result[7];
  }
  return result;
}

pid_t fork(void)
{
  uint64_t v0;
  pid_t v2;

  if (_libSystem_atfork_prepare_v2)
    v0 = _libSystem_atfork_prepare_v2(0);
  else
    v0 = _libSystem_atfork_prepare();
  v2 = __fork(v0);
  if (v2 == -1)
  {
    if (_libSystem_atfork_parent_v2)
      _libSystem_atfork_parent_v2(0);
    else
      _libSystem_atfork_parent();
    return -1;
  }
  else if (v2)
  {
    if (_libSystem_atfork_parent_v2)
      _libSystem_atfork_parent_v2(0);
    else
      _libSystem_atfork_parent();
    return v2;
  }
  else
  {
    if (_libSystem_atfork_child_v2)
      _libSystem_atfork_child_v2(0);
    else
      _libSystem_atfork_child();
    return 0;
  }
}

pid_t vfork(void)
{
  uint64_t v0;
  pid_t v2;

  if (_libSystem_atfork_prepare_v2)
    v0 = _libSystem_atfork_prepare_v2(1);
  else
    v0 = ((uint64_t (*)())_libSystem_atfork_prepare)();
  v2 = __fork(v0);
  if (v2 == -1)
  {
    if (_libSystem_atfork_parent_v2)
      _libSystem_atfork_parent_v2(1);
    else
      _libSystem_atfork_parent();
    return -1;
  }
  else if (v2)
  {
    if (_libSystem_atfork_parent_v2)
      _libSystem_atfork_parent_v2(1);
    else
      _libSystem_atfork_parent();
    return v2;
  }
  else
  {
    if (_libSystem_atfork_child_v2)
      _libSystem_atfork_child_v2(1);
    else
      _libSystem_atfork_child();
    return 0;
  }
}

int gettimeofday(timeval *a1, void *a2)
{
  tm *v3;
  _QWORD v4[2];
  _DWORD *v5;
  void *v6;
  timeval *v7;

  v7 = a1;
  v6 = a2;
  v5 = a2;
  v4[0] = 0;
  v4[1] = 0;
  if (!a1)
  {
    if (!v5)
      return 0;
    v7 = (timeval *)v4;
  }
  if (__commpage_gettimeofday(v7) && (int)__gettimeofday(v7, 0) < 0)
    return -1;
  if (v5)
  {
    if (!gettimeofday_validtz)
    {
      v3 = localtime(&v7->tv_sec);
      dword_DEA40 = v3->tm_isdst;
      gettimeofday_cached_tz = -v3->tm_gmtoff / 60 + 60 * v3->tm_isdst;
      gettimeofday_validtz = 1;
    }
    v5[1] = dword_DEA40;
    *v5 = gettimeofday_cached_tz;
  }
  return 0;
}

int posix_spawnp(pid_t *a1, const char *a2, const posix_spawn_file_actions_t *a3, const posix_spawnattr_t *a4, char *const __argv[], char *const __envp[])
{
  uint64_t v6;
  _BYTE *v7;
  _BYTE v11[16];
  char *const *v12;
  int v13;
  int v14;
  _BYTE *v15;
  char *v16;
  stat v17;
  int v18;
  int v19;
  int i;
  int v21;
  int v22;
  char **v23;
  char *v24;
  char *v25;
  const char *v26;
  char *v27;
  char *const *__attribute__((__org_arrdim(0,0))) v28;
  char *const *__attribute__((__org_arrdim(0,0))) v29;
  const posix_spawnattr_t *v30;
  const posix_spawn_file_actions_t *v31;
  const char *v32;
  pid_t *v33;
  _BYTE v35[1024];

  v33 = a1;
  v32 = a2;
  v31 = a3;
  v30 = a4;
  v29 = __argv;
  v28 = __envp;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  i = 0;
  v19 = 0;
  v18 = 0;
  _platform_memset(&v17, 0, 144);
  v27 = getenv("PATH");
  if (!v27)
    v27 = "/usr/bin:/bin";
  if (!_platform_strchr(v32, 47))
  {
    v26 = v35;
    if (!*v32)
      return 2;
    v6 = _platform_strlen(v27);
    v16 = &v11[-((v6 + 16) & 0xFFFFFFFFFFFFFFF0)];
    _platform_bzero(v16, v6 + 1);
    v25 = v16;
    if (v16)
    {
      _platform_strcpy(v25, v27);
      goto LABEL_10;
    }
    return 12;
  }
  v26 = v32;
  v25 = 0;
  while (1)
  {
    v19 = posix_spawn(v33, v26, v31, v30, v29, v28);
    v14 = v19;
    if (v19 == 2)
      goto LABEL_10;
    if (v14 == 7)
      return v19;
    if (v14 == 8)
      break;
    if (v14 == 12)
      return v19;
    if (v14 != 20)
    {
      if (v14 == 26)
        return v19;
      if (v14 != 63 && v14 != 62 && stat(v26, &v17) == 0)
      {
        if (v19 != 13)
          return v19;
        v18 = 1;
      }
    }
LABEL_10:
    v24 = strsep(&v25, ":");
    if (!v24)
    {
      if (v18)
        return 13;
      else
        return 2;
    }
    if (*v24)
    {
      v22 = _platform_strlen(v24);
    }
    else
    {
      v24 = ".";
      v22 = 1;
    }
    v21 = _platform_strlen(v32);
    if ((unint64_t)(v22 + v21 + 2) > 0x400)
      return 63;
    v15 = v35;
    bcopy(v24, v35, v22);
    v7 = v15;
    v15[v22] = 47;
    bcopy(v32, &v7[v22 + 1], v21);
    v15[v22 + 1 + v21] = 0;
  }
  for (i = 0; v29[i]; ++i)
    ;
  if (i + 2 >= 3)
    v13 = i + 2;
  else
    v13 = 3;
  v12 = (char *const *)&v11[-((8 * v13 + 15) & 0xFFFFFFFFFFFFFFF0)];
  _platform_bzero(v12, 8 * v13);
  v23 = (char **)v12;
  if (v12)
  {
    if (i <= 0)
    {
      *v23 = "sh";
      v23[1] = (char *)v26;
      v23[2] = 0;
    }
    else
    {
      *v23 = *v29;
      v23[1] = (char *)v26;
      bcopy(v29 + 1, v23 + 2, 8 * i);
    }
    return posix_spawn(v33, "/bin/sh", v31, v30, v23, v28);
  }
  return v19;
}

int settimeofday(const timeval *a1, const timezone *a2)
{
  char *v3;
  int v4;
  const timezone *v5;
  const timeval *v6;

  v6 = a1;
  v5 = a2;
  v4 = __settimeofday(a1, a2);
  if (v6)
  {
    v3 = 0;
    asprintf(&v3, "settimeofday({%#lx,%#x}) == %d", v6->tv_sec, v6->tv_usec, v4);
    _simple_asl_log(5, "com.apple.settimeofday", v3);
    free(v3);
  }
  return v4;
}

int sigaction(int a1, const sigaction *a2, sigaction *a3)
{
  return __platform_sigaction(a1, a2, a3);
}

uint64_t _sigaction_nobind(int a1, const sigaction *a2, sigaction *a3)
{
  return sigaction(a1, a2, a3);
}

char *__cdecl stpcpy(char *__dst, const char *__src)
{
  uint64_t v3;

  v3 = _platform_strlen(__src);
  j___platform_memmove(__dst, __src, v3 + 1);
  return &__dst[v3];
}

char *__cdecl stpncpy(char *__dst, const char *__src, size_t __n)
{
  size_t v4;

  v4 = _platform_strnlen(__src, __n);
  if (v4 >= __n)
  {
    j___platform_memmove(__dst, __src, __n);
    return &__dst[__n];
  }
  else
  {
    j___platform_memmove(__dst, __src, v4);
    _platform_bzero(&__dst[v4], __n - v4);
    return &__dst[v4];
  }
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  uint64_t v3;
  uint64_t v4;

  v4 = _platform_strlen(__s1);
  v3 = _platform_strlen(__s2);
  j___platform_memmove(&__s1[v4], __s2, v3 + 1);
  return __s1;
}

char *__cdecl strncat(char *__s1, const char *__s2, size_t __n)
{
  size_t v4;
  size_t v5;
  uint64_t v6;

  v6 = _platform_strlen(__s1);
  v5 = _platform_strnlen(__s2, __n);
  if (v5 >= __n)
    v4 = __n;
  else
    v4 = v5;
  j___platform_memmove(&__s1[v6], __s2, v4);
  __s1[v6 + v4] = 0;
  return __s1;
}

int sync_volume_np(const char *a1, int a2)
{
  int v3;
  int v4;
  int v5;
  int v6;
  const char *v7;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  if ((a2 & 1) != 0)
    v5 |= 1u;
  if ((v6 & 2) != 0)
    v5 |= 2u;
  v4 = *__error();
  if (fsctl(v7, 0x80044101uLL, &v5, 0) == -1)
    v3 = *__error();
  else
    v3 = 0;
  *__error() = v4;
  return v3;
}

int fsync_volume_np(int a1, int a2)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  if ((a2 & 1) != 0)
    v5 |= 1u;
  if ((v6 & 2) != 0)
    v5 |= 2u;
  v4 = *__error();
  if (ffsctl(v7, 0x80004101uLL, &v5, 0) == -1)
    v3 = *__error();
  else
    v3 = 0;
  *__error() = v4;
  return v3;
}

uint64_t libc_set_introspection_hooks(uint64_t result, uint64_t a2, unint64_t a3)
{
  _QWORD *v5;

  v5 = (_QWORD *)result;
  if (a3 < 8)
    __assert_rtn("libc_set_introspection_hooks", "libc_hooks.c", 33, "size >= sizeof(libc_hooks_version)");
  if (a2)
  {
    if (a3 < 0x28)
      __assert_rtn("libc_set_introspection_hooks", "libc_hooks.c", 37, "size >= sizeof(libc_hooks)");
    if (a3 > 0x28)
      _platform_bzero(a2 + 1600, a3 - 40);
    result = j___platform_memmove(a2, &libc_hooks, 40);
  }
  if (v5)
  {
    if (!*v5)
      __assert_rtn("libc_set_introspection_hooks", "libc_hooks.c", 50, "new_hooks->version >= libc_hooks_version");
    if (a3 < 0x28)
      __assert_rtn("libc_set_introspection_hooks", "libc_hooks.c", 54, "size >= sizeof(libc_hooks)");
    result = j___platform_memmove(&libc_hooks, v5, 40);
    libc_hooks = 1;
  }
  return result;
}

int dirfd(DIR *dirp)
{
  if (dirp && dirp->__dd_fd >= 0)
    return dirp->__dd_fd;
  *__error() = 22;
  return -1;
}

uint64_t _os_log_redirect(uint64_t a1, uint64_t a2)
{
  uint64_t (*log_redirect_func)(uint64_t);
  char v4;

  v4 = 0;
  log_redirect_func = (uint64_t (*)(uint64_t))_os_find_log_redirect_func();
  if (log_redirect_func)
    v4 = log_redirect_func(a2) & 1;
  return v4 & 1;
}

BOOL _os_abort_on_assumes()
{
  if (getpid() == 1)
    return getenv("OS_ASSUMES_FATAL_PID1") != 0;
  else
    return getenv("OS_ASSUMES_FATAL") != 0;
}

uint64_t _os_get_build(void *a1, size_t a2)
{
  uint64_t result;
  size_t v4;
  void *v5;
  int v6[2];

  v5 = a1;
  v4 = a2;
  *(_QWORD *)v6 = 0x4100000001;
  result = sysctl(v6, 2u, a1, &v4, 0, 0);
  if (!(_DWORD)result && v4 == 1)
    return _platform_strlcpy(v5, "99Z999", a2);
  return result;
}

uint64_t _os_find_log_redirect_func()
{
  return 0;
}

uint64_t creat_NOCANCEL(uint64_t a1, unsigned __int16 a2)
{
  return __open_nocancel(a1, 1537, a2);
}

uint64_t gethostid(void)
{
  int v1;
  size_t v2;
  int v4[2];

  v1 = 0;
  v4[0] = 1;
  v4[1] = 11;
  v2 = 4;
  if (sysctl(v4, 2u, &v1, &v2, 0, 0) == -1)
    return -1;
  else
    return v1;
}

char *__cdecl getwd(char *a1)
{
  int *v1;
  char *v3;

  v3 = getcwd(a1, 0x400uLL);
  if (v3)
    return v3;
  v1 = __error();
  strerror_r(*v1, a1, 0x400uLL);
  return 0;
}

int killpg(pid_t a1, int a2)
{
  if (a1 != 1)
    return __kill(-a1, a2, 1);
  *__error() = 1;
  return -1;
}

void sethostid(uint64_t a1)
{
  uint64_t v1;
  int v2[2];

  v1 = a1;
  v2[0] = 1;
  v2[1] = 11;
  sysctl(v2, 2u, 0, 0, &v1, 8uLL);
}

pid_t setpgrp(void)
{
  pid_t v1;
  pid_t v2;

  v2 = getpgrp();
  v1 = getpid();
  if (v2 != v1)
    setpgid(v1, v1);
  return v1;
}

int setrgid(gid_t a1)
{
  return setregid(a1, 0xFFFFFFFF);
}

int setruid(uid_t a1)
{
  return setreuid(a1, 0xFFFFFFFF);
}

uint64_t __bt_close(_QWORD *a1)
{
  unsigned int v3;
  void *v4;

  v4 = (void *)a1[7];
  if (*((_QWORD *)v4 + 4))
  {
    mpool_put(*(MPOOL **)v4, *((void **)v4 + 4), 0);
    *((_QWORD *)v4 + 4) = 0;
  }
  if (__bt_sync((uint64_t)a1, 0) == -1)
  {
    return -1;
  }
  else if (mpool_close(*(MPOOL **)v4) == -1)
  {
    return -1;
  }
  else
  {
    if (*((_QWORD *)v4 + 6))
    {
      free(*((void **)v4 + 6));
      *((_QWORD *)v4 + 7) = 0;
      *((_QWORD *)v4 + 6) = 0;
    }
    if (*((_QWORD *)v4 + 60))
    {
      free(*((void **)v4 + 60));
      *((_QWORD *)v4 + 61) = 0;
      *((_QWORD *)v4 + 60) = 0;
    }
    if (*((_QWORD *)v4 + 62))
    {
      free(*((void **)v4 + 62));
      *((_QWORD *)v4 + 63) = 0;
      *((_QWORD *)v4 + 62) = 0;
    }
    v3 = *((_DWORD *)v4 + 128);
    free(v4);
    free(a1);
    if (close_NOCANCEL(v3))
      return -1;
    else
      return 0;
  }
}

uint64_t __bt_sync(uint64_t a1, int a2)
{
  unsigned int v3;
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v4 + 32))
  {
    mpool_put(*(MPOOL **)v4, *(void **)(v4 + 32), 0);
    *(_QWORD *)(v4 + 32) = 0;
  }
  if (a2)
  {
    *__error() = 22;
    return -1;
  }
  else if ((*(_DWORD *)(v4 + 636) & 0x11) == 0 && (*(_DWORD *)(v4 + 636) & 4) != 0)
  {
    if ((*(_DWORD *)(v4 + 636) & 2) != 0 && bt_meta(v4) == -1)
    {
      return -1;
    }
    else
    {
      v3 = mpool_sync(*(MPOOL **)v4);
      if (!v3)
        *(_DWORD *)(v4 + 636) &= ~4u;
      return v3;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t bt_meta(uint64_t a1)
{
  _QWORD *v2;
  __int128 v3;
  uint64_t v4;

  v2 = mpool_get(*(MPOOL **)a1, 0, 0);
  if (v2)
  {
    *(_QWORD *)&v3 = 0x300053162;
    DWORD2(v3) = *(_DWORD *)(a1 + 520);
    HIDWORD(v3) = *(_DWORD *)(a1 + 516);
    LODWORD(v4) = *(_DWORD *)(a1 + 616);
    HIDWORD(v4) = *(_DWORD *)(a1 + 636) & 0xA0;
    *(_OWORD *)v2 = v3;
    v2[2] = v4;
    mpool_put(*(MPOOL **)a1, v2, 1u);
    return 0;
  }
  else
  {
    return -1;
  }
}

unsigned int *__bt_pgin(unsigned int *result, int a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  __int16 v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  __int16 v14;
  __int16 v15;
  __int16 v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  int *v21;
  _BYTE *v22;
  _BYTE *v23;
  int *v24;
  char *v25;
  _BYTE *v26;
  _BYTE *v27;
  char v28;
  unsigned __int16 v29;
  unsigned __int16 i;
  unsigned __int16 j;

  if ((result[159] & 8) != 0)
  {
    if (a2)
    {
      v20 = *(_DWORD *)a3;
      *(_BYTE *)a3 = HIBYTE(*(_DWORD *)a3);
      *(_BYTE *)(a3 + 1) = BYTE2(v20);
      *(_BYTE *)(a3 + 2) = BYTE1(v20);
      *(_BYTE *)(a3 + 3) = v20;
      v19 = *(_DWORD *)(a3 + 4);
      *(_BYTE *)(a3 + 4) = HIBYTE(v19);
      *(_BYTE *)(a3 + 5) = BYTE2(v19);
      *(_BYTE *)(a3 + 6) = BYTE1(v19);
      *(_BYTE *)(a3 + 7) = v19;
      v18 = *(_DWORD *)(a3 + 8);
      *(_BYTE *)(a3 + 8) = HIBYTE(v18);
      *(_BYTE *)(a3 + 9) = BYTE2(v18);
      *(_BYTE *)(a3 + 10) = BYTE1(v18);
      *(_BYTE *)(a3 + 11) = v18;
      v17 = *(_DWORD *)(a3 + 12);
      *(_BYTE *)(a3 + 12) = HIBYTE(v17);
      *(_BYTE *)(a3 + 13) = BYTE2(v17);
      *(_BYTE *)(a3 + 14) = BYTE1(v17);
      *(_BYTE *)(a3 + 15) = v17;
      v16 = *(_WORD *)(a3 + 16);
      *(_BYTE *)(a3 + 16) = HIBYTE(v16);
      *(_BYTE *)(a3 + 17) = v16;
      v15 = *(_WORD *)(a3 + 18);
      *(_BYTE *)(a3 + 18) = HIBYTE(v15);
      *(_BYTE *)(a3 + 19) = v15;
      v29 = ((unint64_t)*(unsigned __int16 *)(a3 + 16) - 20) / 2;
      if ((*(_DWORD *)(a3 + 12) & 0x1F) == 1)
      {
        for (i = 0; i < (int)v29; ++i)
        {
          v14 = *(_WORD *)(a3 + 20 + 2 * i);
          *(_BYTE *)(a3 + 20 + 2 * i) = HIBYTE(v14);
          *(_BYTE *)(a3 + 20 + 2 * i + 1) = v14;
          v21 = (int *)(a3 + *(unsigned __int16 *)(a3 + 20 + 2 * i));
          v13 = *v21;
          *(_BYTE *)v21 = HIBYTE(*v21);
          *((_BYTE *)v21 + 1) = BYTE2(v13);
          *((_BYTE *)v21 + 2) = BYTE1(v13);
          *((_BYTE *)v21++ + 3) = v13;
          v12 = *v21;
          *(_BYTE *)v21 = HIBYTE(*v21);
          *((_BYTE *)v21 + 1) = BYTE2(v12);
          *((_BYTE *)v21 + 2) = BYTE1(v12);
          *((_BYTE *)v21 + 3) = v12;
          v22 = v21 + 1;
          if ((*v22 & 2) != 0)
          {
            v23 = v22 + 1;
            v11 = *(_DWORD *)v23;
            *v23 = HIBYTE(*(_DWORD *)v23);
            v23[1] = BYTE2(v11);
            v23[2] = BYTE1(v11);
            v23[3] = v11;
            v23 += 4;
            v10 = *(_DWORD *)v23;
            *v23 = HIBYTE(*(_DWORD *)v23);
            v23[1] = BYTE2(v10);
            v23[2] = BYTE1(v10);
            v23[3] = v10;
          }
        }
      }
      else if ((*(_DWORD *)(a3 + 12) & 0x1F) == 2)
      {
        for (j = 0; j < (int)v29; ++j)
        {
          v9 = *(_WORD *)(a3 + 20 + 2 * j);
          *(_BYTE *)(a3 + 20 + 2 * j) = HIBYTE(v9);
          *(_BYTE *)(a3 + 20 + 2 * j + 1) = v9;
          v24 = (int *)(a3 + *(unsigned __int16 *)(a3 + 20 + 2 * j));
          v8 = *v24;
          *(_BYTE *)v24 = HIBYTE(*v24);
          *((_BYTE *)v24 + 1) = BYTE2(v8);
          *((_BYTE *)v24 + 2) = BYTE1(v8);
          *((_BYTE *)v24++ + 3) = v8;
          v7 = *v24;
          *(_BYTE *)v24 = HIBYTE(*v24);
          *((_BYTE *)v24 + 1) = BYTE2(v7);
          *((_BYTE *)v24 + 2) = BYTE1(v7);
          *((_BYTE *)v24 + 3) = v7;
          v25 = (char *)(v24 + 1);
          v28 = *v25;
          if ((*v25 & 3) != 0)
          {
            v26 = v25 + 1;
            if ((v28 & 2) != 0)
            {
              v6 = *(_DWORD *)v26;
              *v26 = HIBYTE(*(_DWORD *)v26);
              v26[1] = BYTE2(v6);
              v26[2] = BYTE1(v6);
              v26[3] = v6;
              v26 += 4;
              v5 = *(_DWORD *)v26;
              *v26 = HIBYTE(*(_DWORD *)v26);
              v26[1] = BYTE2(v5);
              v26[2] = BYTE1(v5);
              v26[3] = v5;
            }
            if ((v28 & 1) != 0)
            {
              v27 = v26 + 4;
              v4 = *(_DWORD *)v27;
              *v27 = HIBYTE(*(_DWORD *)v27);
              v27[1] = BYTE2(v4);
              v27[2] = BYTE1(v4);
              v27[3] = v4;
              v27 += 4;
              v3 = *(_DWORD *)v27;
              *v27 = HIBYTE(*(_DWORD *)v27);
              v27[1] = BYTE2(v3);
              v27[2] = BYTE1(v3);
              v27[3] = v3;
            }
          }
        }
      }
    }
    else
    {
      return mswap((unsigned int *)a3);
    }
  }
  return result;
}

unsigned int *mswap(unsigned int *result)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  unsigned int v6;

  v6 = *result;
  *(_BYTE *)result = HIBYTE(*result);
  *((_BYTE *)result + 1) = BYTE2(v6);
  *((_BYTE *)result + 2) = BYTE1(v6);
  *((_BYTE *)result + 3) = v6;
  v5 = result[1];
  *((_BYTE *)result + 4) = HIBYTE(v5);
  *((_BYTE *)result + 5) = BYTE2(v5);
  *((_BYTE *)result + 6) = BYTE1(v5);
  *((_BYTE *)result + 7) = v5;
  v4 = result[2];
  *((_BYTE *)result + 8) = HIBYTE(v4);
  *((_BYTE *)result + 9) = BYTE2(v4);
  *((_BYTE *)result + 10) = BYTE1(v4);
  *((_BYTE *)result + 11) = v4;
  v3 = result[3];
  *((_BYTE *)result + 12) = HIBYTE(v3);
  *((_BYTE *)result + 13) = BYTE2(v3);
  *((_BYTE *)result + 14) = BYTE1(v3);
  *((_BYTE *)result + 15) = v3;
  v2 = result[4];
  *((_BYTE *)result + 16) = HIBYTE(v2);
  *((_BYTE *)result + 17) = BYTE2(v2);
  *((_BYTE *)result + 18) = BYTE1(v2);
  *((_BYTE *)result + 19) = v2;
  v1 = result[5];
  *((_BYTE *)result + 20) = HIBYTE(v1);
  *((_BYTE *)result + 21) = BYTE2(v1);
  *((_BYTE *)result + 22) = BYTE1(v1);
  *((_BYTE *)result + 23) = v1;
  return result;
}

unsigned int *__bt_pgout(unsigned int *result, int a2, uint64_t a3)
{
  __int16 v3;
  __int16 v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  __int16 v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  __int16 v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  int *v21;
  _BYTE *v22;
  _BYTE *v23;
  int *v24;
  char *v25;
  _BYTE *v26;
  _BYTE *v27;
  char v28;
  unsigned __int16 v29;
  unsigned __int16 i;
  unsigned __int16 j;

  if ((result[159] & 8) != 0)
  {
    if (a2)
    {
      v29 = ((unint64_t)*(unsigned __int16 *)(a3 + 16) - 20) / 2;
      if ((*(_DWORD *)(a3 + 12) & 0x1F) == 1)
      {
        for (i = 0; i < (int)v29; ++i)
        {
          v21 = (int *)(a3 + *(unsigned __int16 *)(a3 + 20 + 2 * i));
          v20 = *v21;
          *(_BYTE *)v21 = HIBYTE(*v21);
          *((_BYTE *)v21 + 1) = BYTE2(v20);
          *((_BYTE *)v21 + 2) = BYTE1(v20);
          *((_BYTE *)v21++ + 3) = v20;
          v19 = *v21;
          *(_BYTE *)v21 = HIBYTE(*v21);
          *((_BYTE *)v21 + 1) = BYTE2(v19);
          *((_BYTE *)v21 + 2) = BYTE1(v19);
          *((_BYTE *)v21 + 3) = v19;
          v22 = v21 + 1;
          if ((*v22 & 2) != 0)
          {
            v23 = v22 + 1;
            v18 = *(_DWORD *)v23;
            *v23 = HIBYTE(*(_DWORD *)v23);
            v23[1] = BYTE2(v18);
            v23[2] = BYTE1(v18);
            v23[3] = v18;
            v23 += 4;
            v17 = *(_DWORD *)v23;
            *v23 = HIBYTE(*(_DWORD *)v23);
            v23[1] = BYTE2(v17);
            v23[2] = BYTE1(v17);
            v23[3] = v17;
          }
          v16 = *(_WORD *)(a3 + 20 + 2 * i);
          *(_BYTE *)(a3 + 20 + 2 * i) = HIBYTE(v16);
          *(_BYTE *)(a3 + 20 + 2 * i + 1) = v16;
        }
      }
      else if ((*(_DWORD *)(a3 + 12) & 0x1F) == 2)
      {
        for (j = 0; j < (int)v29; ++j)
        {
          v24 = (int *)(a3 + *(unsigned __int16 *)(a3 + 20 + 2 * j));
          v15 = *v24;
          *(_BYTE *)v24 = HIBYTE(*v24);
          *((_BYTE *)v24 + 1) = BYTE2(v15);
          *((_BYTE *)v24 + 2) = BYTE1(v15);
          *((_BYTE *)v24++ + 3) = v15;
          v14 = *v24;
          *(_BYTE *)v24 = HIBYTE(*v24);
          *((_BYTE *)v24 + 1) = BYTE2(v14);
          *((_BYTE *)v24 + 2) = BYTE1(v14);
          *((_BYTE *)v24 + 3) = v14;
          v25 = (char *)(v24 + 1);
          v28 = *v25;
          if ((*v25 & 3) != 0)
          {
            v26 = v25 + 1;
            if ((v28 & 2) != 0)
            {
              v13 = *(_DWORD *)v26;
              *v26 = HIBYTE(*(_DWORD *)v26);
              v26[1] = BYTE2(v13);
              v26[2] = BYTE1(v13);
              v26[3] = v13;
              v26 += 4;
              v12 = *(_DWORD *)v26;
              *v26 = HIBYTE(*(_DWORD *)v26);
              v26[1] = BYTE2(v12);
              v26[2] = BYTE1(v12);
              v26[3] = v12;
            }
            if ((v28 & 1) != 0)
            {
              v27 = v26 + 4;
              v11 = *(_DWORD *)v27;
              *v27 = HIBYTE(*(_DWORD *)v27);
              v27[1] = BYTE2(v11);
              v27[2] = BYTE1(v11);
              v27[3] = v11;
              v27 += 4;
              v10 = *(_DWORD *)v27;
              *v27 = HIBYTE(*(_DWORD *)v27);
              v27[1] = BYTE2(v10);
              v27[2] = BYTE1(v10);
              v27[3] = v10;
            }
          }
          v9 = *(_WORD *)(a3 + 20 + 2 * j);
          *(_BYTE *)(a3 + 20 + 2 * j) = HIBYTE(v9);
          *(_BYTE *)(a3 + 20 + 2 * j + 1) = v9;
        }
      }
      v8 = *(_DWORD *)a3;
      *(_BYTE *)a3 = HIBYTE(*(_DWORD *)a3);
      *(_BYTE *)(a3 + 1) = BYTE2(v8);
      *(_BYTE *)(a3 + 2) = BYTE1(v8);
      *(_BYTE *)(a3 + 3) = v8;
      v7 = *(_DWORD *)(a3 + 4);
      *(_BYTE *)(a3 + 4) = HIBYTE(v7);
      *(_BYTE *)(a3 + 5) = BYTE2(v7);
      *(_BYTE *)(a3 + 6) = BYTE1(v7);
      *(_BYTE *)(a3 + 7) = v7;
      v6 = *(_DWORD *)(a3 + 8);
      *(_BYTE *)(a3 + 8) = HIBYTE(v6);
      *(_BYTE *)(a3 + 9) = BYTE2(v6);
      *(_BYTE *)(a3 + 10) = BYTE1(v6);
      *(_BYTE *)(a3 + 11) = v6;
      v5 = *(_DWORD *)(a3 + 12);
      *(_BYTE *)(a3 + 12) = HIBYTE(v5);
      *(_BYTE *)(a3 + 13) = BYTE2(v5);
      *(_BYTE *)(a3 + 14) = BYTE1(v5);
      *(_BYTE *)(a3 + 15) = v5;
      v4 = *(_WORD *)(a3 + 16);
      *(_BYTE *)(a3 + 16) = HIBYTE(v4);
      *(_BYTE *)(a3 + 17) = v4;
      v3 = *(_WORD *)(a3 + 18);
      *(_BYTE *)(a3 + 18) = HIBYTE(v3);
      *(_BYTE *)(a3 + 19) = v3;
    }
    else
    {
      return mswap((unsigned int *)a3);
    }
  }
  return result;
}

void *__bt_dump(uint64_t a1)
{
  const char *v1;
  void *result;
  const char *v3;
  pgno_t i;
  void *v5;
  uint64_t v6;

  v6 = *(_QWORD *)(a1 + 56);
  if ((*(_DWORD *)(v6 + 636) & 1) != 0)
    v1 = "memory";
  else
    v1 = "disk";
  fprintf(__stderrp, "%s: pgsz %u", v1, *(_DWORD *)(v6 + 520));
  if ((*(_DWORD *)(v6 + 636) & 0x80) != 0)
    fprintf(__stderrp, " keys %u", *(_DWORD *)(v6 + 616));
  if (*(_DWORD *)(v6 + 636))
  {
    v3 = " flags (";
    if ((*(_DWORD *)(v6 + 636) & 0x200) != 0)
    {
      fprintf(__stderrp, "%s%s", " flags (", "FIXLEN");
      v3 = ", ";
    }
    if ((*(_DWORD *)(v6 + 636) & 1) != 0)
    {
      fprintf(__stderrp, "%s%s", v3, "INMEM");
      v3 = ", ";
    }
    if ((*(_DWORD *)(v6 + 636) & 0x20) != 0)
    {
      fprintf(__stderrp, "%s%s", v3, "NODUPS");
      v3 = ", ";
    }
    if ((*(_DWORD *)(v6 + 636) & 0x10) != 0)
    {
      fprintf(__stderrp, "%s%s", v3, "RDONLY");
      v3 = ", ";
    }
    if ((*(_DWORD *)(v6 + 636) & 0x80) != 0)
    {
      fprintf(__stderrp, "%s%s", v3, "RECNO");
      v3 = ", ";
    }
    if ((*(_DWORD *)(v6 + 636) & 2) != 0)
      fprintf(__stderrp, "%s%s", v3, "METADIRTY");
    fprintf(__stderrp, ")\n");
  }
  for (i = 1; ; ++i)
  {
    result = mpool_get(*(MPOOL **)v6, i, 0);
    v5 = result;
    if (!result)
      break;
    __bt_dpage((uint64_t)result);
    mpool_put(*(MPOOL **)v6, v5, 0);
  }
  return result;
}

uint64_t __bt_dpage(uint64_t a1)
{
  uint64_t result;
  unint64_t v2;
  const char *v3;
  unsigned __int16 v4;
  unsigned __int16 i;

  fprintf(__stderrp, "    page %u: (", *(_DWORD *)a1);
  v3 = (const char *)&unk_D495D;
  if ((*(_DWORD *)(a1 + 12) & 1) != 0)
  {
    fprintf(__stderrp, "%s%s", (const char *)&unk_D495D, "BINTERNAL");
    v3 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 2) != 0)
  {
    fprintf(__stderrp, "%s%s", v3, "BLEAF");
    v3 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 8) != 0)
  {
    fprintf(__stderrp, "%s%s", v3, "RINTERNAL");
    v3 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 0x10) != 0)
  {
    fprintf(__stderrp, "%s%s", v3, "RLEAF");
    v3 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 4) != 0)
  {
    fprintf(__stderrp, "%s%s", v3, "OVERFLOW");
    v3 = ", ";
  }
  if ((*(_DWORD *)(a1 + 12) & 0x20) != 0)
    fprintf(__stderrp, "%s%s", v3, "PRESERVE");
  fprintf(__stderrp, ")\n");
  result = fprintf(__stderrp, "\tprev %2u next %2u", *(_DWORD *)(a1 + 4), *(_DWORD *)(a1 + 8));
  if ((*(_DWORD *)(a1 + 12) & 4) == 0)
  {
    v4 = ((unint64_t)*(unsigned __int16 *)(a1 + 16) - 20) / 2;
    result = fprintf(__stderrp, " lower %3d upper %3d nextind %d\n", *(unsigned __int16 *)(a1 + 16), *(unsigned __int16 *)(a1 + 18), v4);
    for (i = 0; i < (int)v4; ++i)
    {
      fprintf(__stderrp, "\t[%03d] %4d ", i, *(unsigned __int16 *)(a1 + 20 + 2 * i));
      v2 = (*(_DWORD *)(a1 + 12) & 0x1Fu) - 1;
      if (v2 <= 0xF)
        __asm { BR              X8 }
      result = fprintf(__stderrp, "\n");
    }
  }
  return result;
}

uint64_t __bt_dmpage(_DWORD *a1)
{
  uint64_t result;
  const char *v2;

  fprintf(__stderrp, "magic %x\n", *a1);
  fprintf(__stderrp, "version %u\n", a1[1]);
  fprintf(__stderrp, "psize %u\n", a1[2]);
  fprintf(__stderrp, "free %u\n", a1[3]);
  fprintf(__stderrp, "nrecs %u\n", a1[4]);
  result = fprintf(__stderrp, "flags %u", a1[5]);
  if (a1[5])
  {
    v2 = " (";
    if ((a1[5] & 0x20) != 0)
    {
      fprintf(__stderrp, "%s%s", " (", "NODUPS");
      v2 = ", ";
    }
    if ((a1[5] & 0x80) != 0)
      fprintf(__stderrp, "%s%s", v2, "RECNO");
    return fprintf(__stderrp, ")");
  }
  return result;
}

void *__bt_dnpage(uint64_t a1, pgno_t a2)
{
  void *result;
  void *v3;
  MPOOL **v4;

  v4 = *(MPOOL ***)(a1 + 56);
  result = mpool_get(*v4, a2, 0);
  v3 = result;
  if (result)
  {
    __bt_dpage((uint64_t)result);
    return (void *)mpool_put(*v4, v3, 0);
  }
  return result;
}

uint64_t __bt_delete(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4;
  void *v5;
  MPOOL **v6;
  MPOOL **v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  v7 = *(MPOOL ***)(a1 + 56);
  if (v7[4])
  {
    mpool_put(*v7, v7[4], 0);
    v7[4] = 0;
  }
  if ((*((_DWORD *)v7 + 159) & 0x10) != 0)
  {
    *__error() = 1;
    return -1;
  }
  else
  {
    if (v8)
    {
      if (v8 != 1 || (v6 = v7 + 5, (*((_BYTE *)v7 + 68) & 8) == 0))
      {
        *__error() = 22;
        return -1;
      }
      if ((*((_BYTE *)v6 + 28) & 7) != 0)
        return 1;
      v5 = mpool_get(*v7, *(_DWORD *)v6, 0);
      if (!v5)
        return -1;
      if (((unint64_t)*((unsigned __int16 *)v5 + 8) - 20) / 2 == 1
        && __bt_stkacq(v7, (pgno_t **)&v5, (pgno_t *)v7 + 10))
      {
        return -1;
      }
      v4 = __bt_dleaf((uint64_t)v7, 0, (unsigned __int16 *)v5, *((unsigned __int16 *)v6 + 2));
      if (((unint64_t)*((unsigned __int16 *)v5 + 8) - 20) / 2 || v4)
      {
        mpool_put(*v7, v5, v4 == 0);
      }
      else if (__bt_pdelete((uint64_t)v7, v5))
      {
        return -1;
      }
    }
    else
    {
      v4 = __bt_bdelete((uint64_t)v7, v9);
    }
    if (!v4)
      *((_DWORD *)v7 + 159) |= 4u;
    return v4;
  }
}

uint64_t __bt_bdelete(uint64_t a1, uint64_t a2)
{
  int v3;
  BOOL v5;
  int v6;
  int v7;
  int v8;
  void *v9;
  void **v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a1;
  v11 = a2;
  v10 = 0;
  v9 = 0;
  v7 = 0;
  v8 = 0;
  while (2)
  {
    v10 = (void **)__bt_search(v12, v11, &v7);
    if (v10)
    {
      if (v7)
      {
        v6 = 0;
        v9 = *v10;
        do
        {
          if (__bt_dleaf(v12, v11, (unsigned __int16 *)v9, *((unsigned __int16 *)v10 + 4)))
          {
LABEL_11:
            mpool_put(*(MPOOL **)v12, v9, 0);
            return -1;
          }
          if ((*(_DWORD *)(v12 + 636) & 0x20) != 0)
          {
            if (((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2)
            {
              mpool_put(*(MPOOL **)v12, v9, 1u);
            }
            else if (__bt_pdelete(v12, v9))
            {
              return -1;
            }
            return 0;
          }
          v8 = 1;
          v5 = 0;
          if (*((unsigned __int16 *)v10 + 4) < ((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2)
            v5 = __bt_cmp(v12, v11, (uint64_t *)v10) == 0;
        }
        while (v5);
        if (*((unsigned __int16 *)v10 + 4) == ((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2)
          v6 = 1;
        while (1)
        {
          v3 = *((unsigned __int16 *)v10 + 4);
          *((_WORD *)v10 + 4) = v3 - 1;
          if (v3 <= 0 || __bt_cmp(v12, v11, (uint64_t *)v10))
            break;
          if (__bt_dleaf(v12, v11, (unsigned __int16 *)v9, *((unsigned __int16 *)v10 + 4)) == -1)
            goto LABEL_11;
          if (!*((_WORD *)v10 + 4))
            v6 = 1;
        }
        if (((unint64_t)*((unsigned __int16 *)v9 + 8) - 20) / 2)
        {
          mpool_put(*(MPOOL **)v12, v9, 1u);
          if (v6)
            continue;
          return 0;
        }
        else
        {
          if (!__bt_pdelete(v12, v9))
            continue;
          return -1;
        }
      }
      else
      {
        mpool_put(*(MPOOL **)v12, *v10, 0);
        return v8 == 0;
      }
    }
    else if (v8)
    {
      return 0;
    }
    else
    {
      return -1;
    }
  }
}

BOOL __bt_stkacq(MPOOL **a1, pgno_t **a2, pgno_t *a3)
{
  uint64_t p_pgcookie;
  uint64_t v5;
  pgno_t *v7;
  uint64_t v9;
  uint64_t v10;
  int i;
  int j;
  int v13;
  pgno_t v14;
  pgno_t v15;
  pgno_t v16;
  unsigned __int16 v17;
  pgno_t *v18;
  uint64_t v19;
  pgno_t **v20;
  char *v21;
  pgno_t *v22;
  pgno_t **v23;
  MPOOL **v24;

  v24 = a1;
  v23 = a2;
  v22 = a3;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v18 = *a2;
  mpool_put(*a1, v18, 0);
  v20 = (pgno_t **)__bt_search((uint64_t)v24, (uint64_t)(v22 + 2), &v13);
  if (v20)
  {
    v18 = *v20;
    if (*v18 != *v22)
    {
      while (*v18 != *v22)
      {
        v15 = v18[2];
        if (!v15)
          break;
        mpool_put(*v24, v18, 0);
        for (i = 0; ; ++i)
        {
          if (v24[59] == (MPOOL *)(v24 + 9))
          {
            v10 = 0;
          }
          else
          {
            p_pgcookie = (uint64_t)&v24[59][-1].pgcookie;
            v24[59] = (MPOOL *)p_pgcookie;
            v10 = p_pgcookie;
          }
          v19 = v10;
          if (!v10)
            break;
          v18 = (pgno_t *)mpool_get(*v24, *(_DWORD *)v19, 0);
          if (!v18)
            return 1;
          if (*(unsigned __int16 *)(v19 + 4) != ((unint64_t)*((unsigned __int16 *)v18 + 8) - 20) / 2 - 1)
          {
            v17 = *(_WORD *)(v19 + 4) + 1;
            LODWORD(v24[59]->lqh.tqh_first) = *v18;
            WORD2(v24[59]->lqh.tqh_first) = v17;
            v24[59] = (MPOOL *)((char *)v24[59] + 8);
            break;
          }
          mpool_put(*v24, v18, 0);
        }
        while (i--)
        {
          v21 = (char *)v18 + *((unsigned __int16 *)v18 + v17 + 10);
          v16 = *((_DWORD *)v21 + 1);
          LODWORD(v24[59]->lqh.tqh_first) = v16;
          WORD2(v24[59]->lqh.tqh_first) = 0;
          v24[59] = (MPOOL *)((char *)v24[59] + 8);
          mpool_put(*v24, v18, 0);
          v18 = (pgno_t *)mpool_get(*v24, v16, 0);
          if (!v18)
            return 1;
          v17 = 0;
        }
        mpool_put(*v24, v18, 0);
        v18 = (pgno_t *)mpool_get(*v24, v15, 0);
        if (!v18)
          return 1;
      }
      if (*v18 != *v22)
      {
        mpool_put(*v24, v18, 0);
        v20 = (pgno_t **)__bt_search((uint64_t)v24, (uint64_t)(v22 + 2), &v13);
        if (!v20)
          return 1;
        v18 = *v20;
        while (*v18 != *v22)
        {
          v14 = v18[1];
          if (!v14)
            break;
          mpool_put(*v24, v18, 0);
          for (j = 0; ; ++j)
          {
            if (v24[59] == (MPOOL *)(v24 + 9))
            {
              v9 = 0;
            }
            else
            {
              v5 = (uint64_t)&v24[59][-1].pgcookie;
              v24[59] = (MPOOL *)v5;
              v9 = v5;
            }
            v19 = v9;
            if (!v9)
              break;
            v18 = (pgno_t *)mpool_get(*v24, *(_DWORD *)v19, 0);
            if (!v18)
              return 1;
            if (*(_WORD *)(v19 + 4))
            {
              v17 = *(_WORD *)(v19 + 4) - 1;
              LODWORD(v24[59]->lqh.tqh_first) = *v18;
              WORD2(v24[59]->lqh.tqh_first) = v17;
              v24[59] = (MPOOL *)((char *)v24[59] + 8);
              break;
            }
            mpool_put(*v24, v18, 0);
          }
          while (j--)
          {
            v21 = (char *)v18 + *((unsigned __int16 *)v18 + v17 + 10);
            v16 = *((_DWORD *)v21 + 1);
            mpool_put(*v24, v18, 0);
            v18 = (pgno_t *)mpool_get(*v24, v16, 0);
            if (!v18)
              return 1;
            v17 = ((unint64_t)*((unsigned __int16 *)v18 + 8) - 20) / 2 - 1;
            LODWORD(v24[59]->lqh.tqh_first) = v16;
            WORD2(v24[59]->lqh.tqh_first) = v17;
            v24[59] = (MPOOL *)((char *)v24[59] + 8);
          }
          mpool_put(*v24, v18, 0);
          v18 = (pgno_t *)mpool_get(*v24, v14, 0);
          if (!v18)
            return 1;
        }
      }
    }
    mpool_put(*v24, v18, 0);
    v7 = (pgno_t *)mpool_get(*v24, *v22, 0);
    *v23 = v7;
    return v7 == 0;
  }
  return 1;
}

uint64_t __bt_dleaf(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned int a4)
{
  unsigned __int16 v6;
  unsigned int v7;
  unsigned __int16 v8;
  unsigned __int16 *i;
  __int16 v10;
  __int16 v11;
  unsigned int *v12;

  if ((*(_BYTE *)(a1 + 68) & 8) != 0
    && (*(_BYTE *)(a1 + 68) & 1) == 0
    && *(_DWORD *)(a1 + 40) == *(_DWORD *)a3
    && *(unsigned __int16 *)(a1 + 44) == a4
    && __bt_curdel(a1, a2, a3, a4))
  {
    return -1;
  }
  else
  {
    v12 = (unsigned int *)((char *)a3 + a3[a4 + 10]);
    if ((v12[2] & 2) != 0 && __ovfl_delete(a1, (unsigned int *)((char *)v12 + 9)) == -1)
    {
      return -1;
    }
    else if ((v12[2] & 1) != 0 && __ovfl_delete(a1, (unsigned int *)((char *)v12 + *v12 + 9)) == -1)
    {
      return -1;
    }
    else
    {
      v7 = (*v12 + 9 + v12[1] + 3) & 0xFFFFFFFC;
      _platform_memmove((char *)a3 + a3[9] + v7, (char *)a3 + a3[9], (char *)v12 - ((char *)a3 + a3[9]));
      a3[9] += v7;
      v8 = a3[a4 + 10];
      v10 = a4;
      for (i = a3 + 10; v10--; ++i)
      {
        if (*i < (int)v8)
          *i += v7;
      }
      v11 = ((unint64_t)a3[8] - 20) / 2 - a4;
      while (--v11)
      {
        if (i[1] >= (int)v8)
          v6 = i[1];
        else
          v6 = i[1] + v7;
        *i++ = v6;
      }
      a3[8] -= 2;
      if ((*(_BYTE *)(a1 + 68) & 8) != 0
        && (*(_BYTE *)(a1 + 68) & 1) == 0
        && *(_DWORD *)(a1 + 40) == *(_DWORD *)a3
        && *(unsigned __int16 *)(a1 + 44) > a4)
      {
        --*(_WORD *)(a1 + 44);
      }
      return 0;
    }
  }
}

uint64_t __bt_pdelete(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;
  BOOL v5;
  unsigned __int16 v6;
  uint64_t v7;
  unsigned int v8;
  unsigned __int16 v9;
  unsigned __int16 *i;
  unsigned __int16 v11;
  unsigned __int16 v12;
  __int16 v13;
  unsigned __int16 *v14;
  char *v15;

  while (1)
  {
    if (*(_QWORD *)(a1 + 472) == a1 + 72)
    {
      v7 = 0;
    }
    else
    {
      v2 = *(_QWORD *)(a1 + 472) - 8;
      *(_QWORD *)(a1 + 472) = v2;
      v7 = v2;
    }
    if (!v7)
      break;
    v14 = (unsigned __int16 *)mpool_get(*(MPOOL **)a1, *(_DWORD *)v7, 0);
    if (!v14)
      return -1;
    v11 = *(_WORD *)(v7 + 4);
    v15 = (char *)v14 + v14[v11 + 10];
    if ((v15[8] & 2) != 0 && __ovfl_delete(a1, (pgno_t *)(v15 + 9)) == -1)
    {
      mpool_put(*(MPOOL **)a1, v14, 0);
      return -1;
    }
    if (((unint64_t)v14[8] - 20) / 2 != 1)
    {
      v8 = (*(_DWORD *)v15 + 12) & 0xFFFFFFFC;
      _platform_memmove((char *)v14 + v14[9] + v8, (char *)v14 + v14[9], v15 - ((char *)v14 + v14[9]));
      v14[9] += v8;
      v9 = v14[v11 + 10];
      v12 = v11;
      for (i = v14 + 10; v12--; ++i)
      {
        if (*i < (int)v9)
          *i += v8;
      }
      v13 = ((unint64_t)v14[8] - 20) / 2 - v11;
      while (--v13)
      {
        if (i[1] >= (int)v9)
          v6 = i[1];
        else
          v6 = i[1] + v8;
        *i++ = v6;
      }
      v14[8] -= 2;
      goto LABEL_29;
    }
    if (*(_DWORD *)v14 == 1)
    {
      v14[8] = 20;
      v14[9] = *(_DWORD *)(a1 + 520);
      *((_DWORD *)v14 + 3) = 2;
LABEL_29:
      mpool_put(*(MPOOL **)a1, v14, 1u);
      break;
    }
    if (__bt_relink((MPOOL **)a1, (uint64_t)v14) || __bt_free(a1, v14))
      return -1;
  }
  if (*a2 == 1)
  {
    mpool_put(*(MPOOL **)a1, a2, 1u);
    return 0;
  }
  else
  {
    v5 = 1;
    if (!__bt_relink((MPOOL **)a1, (uint64_t)a2))
      return __bt_free(a1, a2) != 0;
    return v5;
  }
}

uint64_t __bt_curdel(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned int a4)
{
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned __int16 *v13;
  uint64_t v14;
  uint64_t v15;

  v15 = a1;
  v14 = a2;
  v13 = a3;
  v12 = a4;
  v9 = 0;
  v10 = 0;
  v11 = a1 + 40;
  *(_BYTE *)(a1 + 68) &= 0xF8u;
  v7 = 0;
  if ((*(_DWORD *)(v15 + 636) & 0x20) == 0)
  {
    if (!v14)
    {
      v9 = v13;
      LOWORD(v10) = v12;
      v5 = __bt_ret(v15, (uint64_t)&v9, (uint64_t *)(v11 + 8), (uint64_t *)(v11 + 8), 0, 0, 1);
      if (v5)
        return v5;
      v7 = 1;
      v14 = v11 + 8;
    }
    if (v12)
    {
      v9 = v13;
      LOWORD(v10) = v12 - 1;
      if (!__bt_cmp(v15, v14, (uint64_t *)&v9))
      {
        *(_BYTE *)(v11 + 28) |= 4u;
LABEL_26:
        *(_DWORD *)v11 = *(_DWORD *)v9;
        *(_WORD *)(v11 + 4) = v10;
        return 0;
      }
    }
    if (v12 < ((unint64_t)v13[8] - 20) / 2 - 1)
    {
      v9 = v13;
      LOWORD(v10) = v12 + 1;
      if (!__bt_cmp(v15, v14, (uint64_t *)&v9))
      {
        *(_BYTE *)(v11 + 28) |= 2u;
        goto LABEL_26;
      }
    }
    if (!v12 && *((_DWORD *)v13 + 1))
    {
      v8 = (unsigned __int16 *)mpool_get(*(MPOOL **)v15, *((_DWORD *)v13 + 1), 0);
      if (!v8)
        return -1;
      v9 = v8;
      LOWORD(v10) = ((unint64_t)v8[8] - 20) / 2 - 1;
      if (!__bt_cmp(v15, v14, (uint64_t *)&v9))
      {
        *(_BYTE *)(v11 + 28) |= 4u;
LABEL_25:
        mpool_put(*(MPOOL **)v15, v8, 0);
        goto LABEL_26;
      }
      mpool_put(*(MPOOL **)v15, v8, 0);
    }
    if (v12 == ((unint64_t)v13[8] - 20) / 2 - 1 && *((_DWORD *)v13 + 2))
    {
      v8 = (unsigned __int16 *)mpool_get(*(MPOOL **)v15, *((_DWORD *)v13 + 2), 0);
      if (!v8)
        return -1;
      v9 = v8;
      LOWORD(v10) = 0;
      if (!__bt_cmp(v15, v14, (uint64_t *)&v9))
      {
        *(_BYTE *)(v11 + 28) |= 2u;
        goto LABEL_25;
      }
      mpool_put(*(MPOOL **)v15, v8, 0);
    }
  }
  v9 = v13;
  LOWORD(v10) = v12;
  if (!v7 && (v6 = __bt_ret(v15, (uint64_t)&v9, (uint64_t *)(v11 + 8), (uint64_t *)(v11 + 8), 0, 0, 1)) != 0)
  {
    return v6;
  }
  else
  {
    *(_BYTE *)(v11 + 28) |= 1u;
    return 0;
  }
}

uint64_t __bt_relink(MPOOL **a1, uint64_t a2)
{
  _DWORD *v3;
  _DWORD *v4;

  if (!*(_DWORD *)(a2 + 8))
  {
LABEL_5:
    if (*(_DWORD *)(a2 + 4))
    {
      v4 = mpool_get(*a1, *(_DWORD *)(a2 + 4), 0);
      if (!v4)
        return -1;
      v4[2] = *(_DWORD *)(a2 + 8);
      mpool_put(*a1, v4, 1u);
    }
    return 0;
  }
  v3 = mpool_get(*a1, *(_DWORD *)(a2 + 8), 0);
  if (v3)
  {
    v3[1] = *(_DWORD *)(a2 + 4);
    mpool_put(*a1, v3, 1u);
    goto LABEL_5;
  }
  return -1;
}

uint64_t __bt_get(uint64_t a1, uint64_t a2, uint64_t *a3, int a4)
{
  unsigned int v5;
  int v6;
  void **v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = a4;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v8 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v8 + 32))
  {
    mpool_put(*(MPOOL **)v8, *(void **)(v8 + 32), 0);
    *(_QWORD *)(v8 + 32) = 0;
  }
  if (v9)
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    v7 = (void **)__bt_search(v8, v11, &v6);
    if (v7)
    {
      if (v6)
      {
        v5 = __bt_ret(v8, (uint64_t)v7, 0, 0, v10, (uint64_t *)(v8 + 496), 0);
        if ((*(_DWORD *)(v8 + 636) & 0x4000) != 0)
          mpool_put(*(MPOOL **)v8, *v7, 0);
        else
          *(_QWORD *)(v8 + 32) = *v7;
        return v5;
      }
      else
      {
        mpool_put(*(MPOOL **)v8, *v7, 0);
        return 1;
      }
    }
    else
    {
      return -1;
    }
  }
}

uint64_t __bt_open(uint64_t a1, unsigned int a2, int a3, uint64_t a4, int a5)
{
  int v5;
  int v6;
  MPOOL *v7;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unsigned int st_blksize;
  uint64_t (*v24)(unsigned __int8 **, unsigned __int8 **);
  uint64_t (*v25)(unsigned __int8 **, unsigned __int8 **);
  int v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  stat v31;
  int v32;
  uint64_t v33;
  int v34;
  unsigned int v35;
  uint64_t v36;

  v36 = a1;
  v35 = a2;
  v34 = a3;
  v33 = a4;
  v32 = a5;
  _platform_memset(&v31, 0, 144);
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v27 = 0;
  _platform_memset(&v20, 0, 48);
  v27 = 0;
  v16 = byteorder();
  if (v33)
  {
    j___platform_memmove(&v20, v33, 48);
    if ((v20 & 0xFFFFFFFFFFFFFFFELL) != 0
      || st_blksize && (st_blksize < 0x200 || st_blksize > 0x10000 || (st_blksize & 1) != 0))
    {
      goto LABEL_76;
    }
    if (v22)
    {
      if (v22 < 2)
        goto LABEL_76;
    }
    else
    {
      v22 = 2;
    }
    if (!v24)
    {
      v24 = __bt_defcmp;
      if (!v25)
        v25 = __bt_defpfx;
    }
    if (!v26)
      v26 = v16;
  }
  else
  {
    v24 = __bt_defcmp;
    v21 = 0;
    v20 = 0;
    v26 = v16;
    v22 = 2;
    v25 = __bt_defpfx;
    st_blksize = 0;
  }
  if (v26 != 4321 && v26 != 1234)
    goto LABEL_76;
  v27 = (void *)malloc_type_calloc(1, 640, 0x10B004045B545B8);
  if (!v27)
    goto LABEL_78;
  *((_DWORD *)v27 + 128) = -1;
  *((_DWORD *)v27 + 132) = v26;
  *((_DWORD *)v27 + 133) = 0;
  *((_QWORD *)v27 + 68) = v24;
  *((_QWORD *)v27 + 69) = v25;
  *((_DWORD *)v27 + 144) = -1;
  v19 = malloc_type_calloc(1, 72, 0x10800406ECF7772);
  *((_QWORD *)v27 + 1) = v19;
  if (!v19)
    goto LABEL_78;
  if (*((_DWORD *)v27 + 132) != (_DWORD)v16)
    *((_DWORD *)v27 + 159) |= 8u;
  *(_DWORD *)v19 = 0;
  *(_QWORD *)(v19 + 56) = v27;
  *(_QWORD *)(v19 + 8) = __bt_close;
  *(_QWORD *)(v19 + 16) = __bt_delete;
  *(_QWORD *)(v19 + 64) = __bt_fd;
  *(_QWORD *)(v19 + 24) = __bt_get;
  *(_QWORD *)(v19 + 32) = __bt_put;
  *(_QWORD *)(v19 + 40) = __bt_seq;
  *(_QWORD *)(v19 + 48) = __bt_sync;
  if (!v36)
  {
    if ((v35 & 3) == 2)
    {
      v6 = tmp();
      *((_DWORD *)v27 + 128) = v6;
      if (v6 == -1)
        goto LABEL_78;
      *((_DWORD *)v27 + 159) |= 1u;
      goto LABEL_35;
    }
LABEL_76:
    *__error() = 22;
    goto LABEL_78;
  }
  if ((v35 & 3) != 0)
  {
    if ((v35 & 3) != 2)
      goto LABEL_76;
  }
  else
  {
    *((_DWORD *)v27 + 159) |= 0x10u;
  }
  v5 = open_NOCANCEL(v36, v35);
  *((_DWORD *)v27 + 128) = v5;
  if (v5 < 0)
    goto LABEL_78;
LABEL_35:
  if (fcntl_NOCANCEL(*((unsigned int *)v27 + 128), 2) == -1 || fstat(*((_DWORD *)v27 + 128), &v31))
    goto LABEL_78;
  if (!v31.st_size)
  {
    if (!st_blksize)
    {
      st_blksize = v31.st_blksize;
      if (v31.st_blksize < 0x200u)
        st_blksize = 512;
      if (st_blksize > 0x10000)
        st_blksize = 0x10000;
    }
    if ((v20 & 1) == 0)
      *((_DWORD *)v27 + 159) |= 0x20u;
    *((_DWORD *)v27 + 129) = 0;
    *((_DWORD *)v27 + 154) = 0;
    *((_DWORD *)v27 + 159) |= 2u;
    goto LABEL_58;
  }
  v17 = read_NOCANCEL(*((unsigned int *)v27 + 128), &v28, 24);
  if (v17 < 0)
  {
LABEL_78:
    v15 = *__error();
    if (v27)
    {
      if (*((_QWORD *)v27 + 1))
        free(*((void **)v27 + 1));
      if (*((_DWORD *)v27 + 128) != -1)
        close_NOCANCEL(*((unsigned int *)v27 + 128));
      free(v27);
    }
    *__error() = v15;
    return 0;
  }
  if (v17 != 24)
    goto LABEL_77;
  if ((_DWORD)v28 == 340322)
  {
    *((_DWORD *)v27 + 159) &= ~8u;
  }
  else
  {
    *((_DWORD *)v27 + 159) |= 8u;
    v14 = v28;
    LOBYTE(v28) = BYTE3(v28);
    BYTE1(v28) = BYTE2(v14);
    BYTE2(v28) = BYTE1(v14);
    BYTE3(v28) = v14;
    v13 = HIDWORD(v28);
    BYTE4(v28) = HIBYTE(v28);
    BYTE5(v28) = BYTE2(v13);
    BYTE6(v28) = BYTE1(v13);
    HIBYTE(v28) = v13;
    v12 = v29;
    LOBYTE(v29) = BYTE3(v29);
    BYTE1(v29) = BYTE2(v12);
    BYTE2(v29) = BYTE1(v12);
    BYTE3(v29) = v12;
    v11 = HIDWORD(v29);
    BYTE4(v29) = HIBYTE(v29);
    BYTE5(v29) = BYTE2(v11);
    BYTE6(v29) = BYTE1(v11);
    HIBYTE(v29) = v11;
    v10 = v30;
    LOBYTE(v30) = BYTE3(v30);
    BYTE1(v30) = BYTE2(v10);
    BYTE2(v30) = BYTE1(v10);
    BYTE3(v30) = v10;
    v9 = HIDWORD(v30);
    BYTE4(v30) = HIBYTE(v30);
    BYTE5(v30) = BYTE2(v9);
    BYTE6(v30) = BYTE1(v9);
    HIBYTE(v30) = v9;
  }
  if (v28 != 0x300053162
    || v29 < 0x200
    || v29 > 0x10000
    || (v29 & 1) != 0
    || (v30 & 0xFFFFFF5F00000000) != 0)
  {
LABEL_77:
    *__error() = 79;
    goto LABEL_78;
  }
  st_blksize = v29;
  *((_DWORD *)v27 + 159) |= HIDWORD(v30);
  *((_DWORD *)v27 + 129) = HIDWORD(v29);
  *((_DWORD *)v27 + 154) = v30;
LABEL_58:
  *((_DWORD *)v27 + 130) = st_blksize;
  if (v21 && (v21 & (st_blksize - 1)) != 0)
    v21 += ((st_blksize - 1) & ~v21) + 1;
  if (v21 < 5 * st_blksize)
    v21 = 5 * st_blksize;
  v18 = (v21 + *((_DWORD *)v27 + 130) - 1) / *((_DWORD *)v27 + 130);
  *((_WORD *)v27 + 262) = ((unint64_t)*((unsigned int *)v27 + 130) - 20) / v22 - 14;
  if (*((unsigned __int16 *)v27 + 262) < 0x1EuLL)
    *((_WORD *)v27 + 262) = 30;
  v7 = mpool_open(0, *((_DWORD *)v27 + 128), *((_DWORD *)v27 + 130), v18);
  *(_QWORD *)v27 = v7;
  if (!v7)
    goto LABEL_78;
  if ((*((_DWORD *)v27 + 159) & 1) == 0)
    mpool_filter(*(MPOOL **)v27, (void (__cdecl *)(void *, pgno_t, void *))__bt_pgin, (void (__cdecl *)(void *, pgno_t, void *))__bt_pgout, v27);
  if (nroot((MPOOL **)v27) == -1)
    goto LABEL_78;
  if ((v32 & 0x20000000) != 0)
    *((_DWORD *)v27 + 159) |= 0x4000u;
  if ((v32 & 0x40000000) != 0)
    *((_DWORD *)v27 + 159) |= 0x8000u;
  if (v32 < 0)
    *((_DWORD *)v27 + 159) |= 0x10000u;
  return v19;
}

uint64_t byteorder()
{
  return 1234;
}

uint64_t __bt_fd(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v2 + 32))
  {
    mpool_put(*(MPOOL **)v2, *(void **)(v2 + 32), 0);
    *(_QWORD *)(v2 + 32) = 0;
  }
  if ((*(_DWORD *)(v2 + 636) & 1) != 0)
  {
    *__error() = 2;
    return -1;
  }
  else
  {
    return *(unsigned int *)(v2 + 512);
  }
}

uint64_t tmp()
{
  unsigned int v0;
  char *v2;
  unsigned int v3;
  sigset_t v4;
  sigset_t v5;
  char __str[1024];

  v5 = 0;
  v4 = 0;
  v2 = 0;
  if (!issetugid())
    v2 = getenv("TMPDIR");
  if (v2)
    v0 = snprintf(__str, 0x400uLL, "%s/bt.XXXXXXXXXX", v2);
  else
    v0 = snprintf(__str, 0x400uLL, "%s/bt.XXXXXXXXXX", "/tmp");
  if (v0 < 0x400)
  {
    v5 = -1;
    sigprocmask(1, &v5, &v4);
    v3 = mkstemp(__str);
    if (v3 != -1)
      unlink(__str);
    sigprocmask(3, &v4, 0);
    return v3;
  }
  else
  {
    *__error() = 63;
    return -1;
  }
}

uint64_t nroot(MPOOL **a1)
{
  pgno_t v2;
  void *v3;
  void *v4;
  MPOOL **v5;

  v5 = a1;
  v4 = 0;
  v3 = 0;
  v2 = 0;
  v4 = mpool_get(*a1, 0, 0);
  if (v4)
  {
    mpool_put(*v5, v4, 0);
    return 0;
  }
  else if (*__error() == 22)
  {
    *__error() = 0;
    v4 = mpool_new(*v5, &v2);
    if (v4)
    {
      v3 = mpool_new(*v5, &v2);
      if (v3)
      {
        if (v2 == 1)
        {
          *(_DWORD *)v3 = 1;
          *((_DWORD *)v3 + 2) = 0;
          *((_DWORD *)v3 + 1) = 0;
          *((_WORD *)v3 + 8) = 20;
          *((_WORD *)v3 + 9) = *((_DWORD *)v5 + 130);
          *((_DWORD *)v3 + 3) = 2;
          _platform_bzero(v4, *((unsigned int *)v5 + 130));
          mpool_put(*v5, v4, 1u);
          mpool_put(*v5, v3, 1u);
          return 0;
        }
        else
        {
          return -1;
        }
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __ovfl_get(uint64_t a1, pgno_t *a2, _QWORD *a3, void **a4, _QWORD *a5)
{
  pgno_t *i;
  size_t v7;
  pgno_t __size;
  size_t __size_4;
  pgno_t v10;
  pgno_t *v11;
  char *v14;

  v10 = *a2;
  __size = a2[1];
  *a3 = __size;
  if (*a5 < (unint64_t)__size)
  {
    *a4 = reallocf(*a4, __size);
    if (!*a4)
      return -1;
    *a5 = __size;
  }
  __size_4 = *(unsigned int *)(a1 + 520) - 20;
  v14 = (char *)*a4;
  for (i = (pgno_t *)mpool_get(*(MPOOL **)a1, v10, 0); ; i = (pgno_t *)mpool_get(*(MPOOL **)a1, v11[2], 0))
  {
    v11 = i;
    if (!i)
      return -1;
    v7 = __size >= __size_4 ? __size_4 : __size;
    _platform_memmove(v14, i + 5, v7);
    mpool_put(*(MPOOL **)a1, v11, 0);
    __size -= v7;
    if (!__size)
      break;
    v14 += v7;
  }
  return 0;
}

uint64_t __ovfl_put(MPOOL **a1, _QWORD *a2, _DWORD *a3)
{
  unint64_t v4;
  unsigned int v5;
  unint64_t v6;
  pgno_t v7;
  uint64_t v8;
  void *v9;
  _DWORD *v10;
  _DWORD *v11;
  _QWORD *v12;
  MPOOL **v13;

  v13 = a1;
  v12 = a2;
  v11 = a3;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = *((unsigned int *)a1 + 130) - 20;
  v9 = 0;
  v8 = *a2;
  v5 = a2[1];
  while (1)
  {
    v10 = __bt_new((uint64_t)v13, &v7);
    if (!v10)
      return -1;
    *v10 = v7;
    v10[1] = 0;
    v10[2] = 0;
    v10[3] = 4;
    *((_WORD *)v10 + 9) = 0;
    *((_WORD *)v10 + 8) = 0;
    v4 = v5 >= v6 ? v6 : v5;
    _platform_memmove(v10 + 5, v8, v4);
    if (v9)
    {
      *((_DWORD *)v9 + 2) = *v10;
      mpool_put(*v13, v9, 1u);
    }
    else
    {
      *v11 = *v10;
    }
    v5 -= v4;
    if (!v5)
      break;
    v8 += v6;
    v9 = v10;
  }
  mpool_put(*v13, v10, 1u);
  return 0;
}

uint64_t __ovfl_delete(uint64_t a1, pgno_t *a2)
{
  pgno_t v3;
  unint64_t i;
  pgno_t v5;
  _DWORD *v6;

  v3 = a2[1];
  v6 = mpool_get(*(MPOOL **)a1, *a2, 0);
  if (v6)
  {
    if ((v6[3] & 0x20) != 0)
    {
      mpool_put(*(MPOOL **)a1, v6, 0);
      return 0;
    }
    else
    {
      for (i = *(unsigned int *)(a1 + 520) - 20; ; v3 -= i)
      {
        v5 = v6[2];
        __bt_free(a1, v6);
        if (v3 <= i)
          return 0;
        v6 = mpool_get(*(MPOOL **)a1, v5, 0);
        if (!v6)
          break;
      }
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __bt_free(uint64_t a1, _DWORD *a2)
{
  a2[1] = 0;
  a2[2] = *(_DWORD *)(a1 + 516);
  *(_DWORD *)(a1 + 516) = *a2;
  *(_DWORD *)(a1 + 636) |= 2u;
  return mpool_put(*(MPOOL **)a1, a2, 1u);
}

_DWORD *__bt_new(uint64_t a1, pgno_t *a2)
{
  _DWORD *v3;

  if (!*(_DWORD *)(a1 + 516))
    return mpool_new(*(MPOOL **)a1, a2);
  v3 = mpool_get(*(MPOOL **)a1, *(_DWORD *)(a1 + 516), 0);
  if (!v3)
    return mpool_new(*(MPOOL **)a1, a2);
  *a2 = *(_DWORD *)(a1 + 516);
  *(_DWORD *)(a1 + 516) = v3[2];
  *(_DWORD *)(a1 + 636) |= 2u;
  return v3;
}

uint64_t __bt_put(uint64_t a1, _QWORD *a2, _QWORD *a3, int a4)
{
  unint64_t v4;
  __int16 v5;
  char *v7;
  unsigned int v8;
  int v9;
  int v10;
  int v11;
  unsigned int v12;
  int v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  void *v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  MPOOL **v22;
  int v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  _DWORD v28[2];
  _DWORD v29[2];

  v26 = a1;
  v25 = a2;
  v24 = a3;
  v23 = a4;
  v22 = 0;
  v20 = 0;
  v21 = 0;
  v18 = 0;
  v19 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v22 = *(MPOOL ***)(a1 + 56);
  if (v22[4])
  {
    mpool_put(*v22, v22[4], 0);
    v22[4] = 0;
  }
  if ((*((_DWORD *)v22 + 159) & 0x10) != 0)
  {
    *__error() = 1;
    return -1;
  }
  if (v23)
  {
    if (v23 != 1)
    {
      if (v23 == 8)
        goto LABEL_12;
LABEL_11:
      *__error() = 22;
      return -1;
    }
    if ((*((_BYTE *)v22 + 68) & 8) == 0 || (*((_BYTE *)v22 + 68) & 7) != 0)
      goto LABEL_11;
  }
LABEL_12:
  v10 = 0;
  if (v25[1] + v24[1] > (unint64_t)*((unsigned __int16 *)v22 + 262))
  {
    if (v25[1] <= (unint64_t)*((unsigned __int16 *)v22 + 262))
      goto LABEL_17;
    do
    {
      if (__ovfl_put(v22, v25, &v13) == -1)
        return -1;
      v20 = v28;
      v21 = 8;
      v28[0] = v13;
      v11 = v25[1];
      v28[1] = v11;
      v10 |= 2u;
      v25 = &v20;
LABEL_17:
      if (v25[1] + v24[1] > (unint64_t)*((unsigned __int16 *)v22 + 262))
      {
        if (__ovfl_put(v22, v24, &v13) == -1)
          return -1;
        v18 = v29;
        v19 = 8;
        v29[0] = v13;
        v11 = v24[1];
        v29[1] = v11;
        v10 |= 1u;
        v24 = &v18;
      }
    }
    while (v25[1] + v24[1] > (unint64_t)*((unsigned __int16 *)v22 + 262));
  }
  if (v23 == 1)
  {
    v16 = mpool_get(*v22, *((_DWORD *)v22 + 10), 0);
    if (!v16)
      return -1;
    v15 = *((_WORD *)v22 + 22);
LABEL_36:
    if (__bt_dleaf((uint64_t)v22, (uint64_t)v25, (unsigned __int16 *)v16, v15) == -1)
    {
      mpool_put(*v22, v16, 0);
      return -1;
    }
    goto LABEL_38;
  }
  if (!*((_DWORD *)v22 + 133) || (v17 = bt_fast((uint64_t)v22, (uint64_t)v25, (uint64_t)v24, &v9)) == 0)
  {
    v17 = __bt_search((uint64_t)v22, (uint64_t)v25, &v9);
    if (!v17)
      return -1;
  }
  v16 = *(void **)v17;
  v15 = *(_WORD *)(v17 + 8);
  if (v23 == 8)
  {
    if (v9)
    {
      mpool_put(*v22, v16, 0);
      return 1;
    }
    goto LABEL_38;
  }
  if (v9 && (*((_DWORD *)v22 + 159) & 0x20) != 0)
    goto LABEL_36;
LABEL_38:
  v12 = (v25[1] + 9 + v24[1] + 3) & 0xFFFFFFFC;
  if (*((unsigned __int16 *)v16 + 9) - *((unsigned __int16 *)v16 + 8) >= (unint64_t)v12 + 2)
  {
    v4 = ((unint64_t)*((unsigned __int16 *)v16 + 8) - 20) / 2;
    v14 = v4;
    if (v15 < (int)(unsigned __int16)v4)
      _platform_memmove((char *)v16 + 2 * v15 + 22, (char *)v16 + 2 * v15 + 20, 2 * (v14 - v15));
    *((_WORD *)v16 + 8) += 2;
    v5 = *((_WORD *)v16 + 9) - v12;
    *((_WORD *)v16 + 9) = v5;
    *((_WORD *)v16 + v15 + 10) = v5;
    v7 = (char *)v16 + *((unsigned __int16 *)v16 + 9);
    *(_DWORD *)v7 = v25[1];
    v7 += 4;
    *(_DWORD *)v7 = v24[1];
    v7[4] = v10;
    v7 += 5;
    _platform_memmove(v7, *v25, v25[1]);
    _platform_memmove(&v7[v25[1]], *v24, v24[1]);
    if ((*((_BYTE *)v22 + 68) & 8) != 0
      && (*((_BYTE *)v22 + 68) & 1) == 0
      && *((_DWORD *)v22 + 10) == *(_DWORD *)v16
      && *((unsigned __int16 *)v22 + 22) >= (int)v15)
    {
      ++*((_WORD *)v22 + 22);
    }
    if (!*((_DWORD *)v22 + 133))
    {
      if (*((_DWORD *)v16 + 2))
      {
        if (!*((_DWORD *)v16 + 1) && !v15)
        {
          *((_DWORD *)v22 + 133) = 1;
          *((_WORD *)v22 + 270) = 0;
          *((_DWORD *)v22 + 134) = *(_DWORD *)v16;
        }
      }
      else if (v15 == ((unint64_t)*((unsigned __int16 *)v16 + 8) - 20) / 2 - 1)
      {
        *((_DWORD *)v22 + 133) = 2;
        *((_WORD *)v22 + 270) = v15;
        *((_DWORD *)v22 + 134) = *(_DWORD *)v16;
      }
    }
    mpool_put(*v22, v16, 1u);
  }
  else
  {
    v8 = __bt_split((uint64_t)v22, v16, v25, v24, v10, v12, v15);
    if (v8)
      return v8;
  }
  if (v23 == 10)
    __bt_setcur((uint64_t)v22, **(_DWORD **)v17, *(_WORD *)(v17 + 8));
  *((_DWORD *)v22 + 159) |= 4u;
  return 0;
}

uint64_t bt_fast(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4)
{
  __int16 v4;
  __int16 v6;
  int v7;
  unsigned __int16 *v8;

  v8 = (unsigned __int16 *)mpool_get(*(MPOOL **)a1, *(_DWORD *)(a1 + 536), 0);
  if (v8)
  {
    *(_QWORD *)(a1 + 16) = v8;
    *(_WORD *)(a1 + 24) = *(_WORD *)(a1 + 540);
    if (v8[9] - v8[8] >= (unint64_t)((*(_QWORD *)(a2 + 8)
                                                          + 9
                                                          + *(_QWORD *)(a3 + 8)
                                                          + 3) & 0xFFFFFFFC)
                                      + 2)
    {
      if (*(_DWORD *)(a1 + 532) == 2)
      {
        if (!*(_DWORD *)(*(_QWORD *)(a1 + 16) + 8)
          && *(unsigned __int16 *)(a1 + 24) == ((unint64_t)v8[8] - 20) / 2 - 1)
        {
          v7 = __bt_cmp(a1, a2, (uint64_t *)(a1 + 16));
          if (v7 >= 0)
          {
            if (v7)
            {
              v4 = *(_WORD *)(a1 + 24) + 1;
              *(_WORD *)(a1 + 24) = v4;
              v6 = v4;
            }
            else
            {
              v6 = *(_WORD *)(a1 + 24);
            }
            *(_WORD *)(a1 + 540) = v6;
            goto LABEL_16;
          }
        }
      }
      else if (!*(_DWORD *)(*(_QWORD *)(a1 + 16) + 4) && !*(_WORD *)(a1 + 24))
      {
        v7 = __bt_cmp(a1, a2, (uint64_t *)(a1 + 16));
        if (v7 <= 0)
        {
          *(_WORD *)(a1 + 540) = 0;
LABEL_16:
          *a4 = v7 == 0;
          return a1 + 16;
        }
      }
    }
    *(_DWORD *)(a1 + 532) = 0;
    mpool_put(*(MPOOL **)a1, v8, 0);
    return 0;
  }
  *(_DWORD *)(a1 + 532) = 0;
  return 0;
}

uint64_t __bt_search(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  unsigned __int16 v4;
  int v5;
  pgno_t v6;
  unsigned __int16 i;
  unsigned __int16 v8;
  unsigned __int16 v9;
  _DWORD *v10;

  *(_QWORD *)(a1 + 472) = a1 + 72;
  v6 = 1;
  while (2)
  {
    v10 = mpool_get(*(MPOOL **)a1, v6, 0);
    if (!v10)
      return 0;
    *(_QWORD *)(a1 + 16) = v10;
    v9 = 0;
    for (i = ((unint64_t)*((unsigned __int16 *)v10 + 8) - 20) / 2; i; i = (int)i >> 1)
    {
      v8 = v9 + ((int)i >> 1);
      *(_WORD *)(a1 + 24) = v8;
      v5 = __bt_cmp(a1, a2, (uint64_t *)(a1 + 16));
      if (!v5)
      {
        if ((v10[3] & 2) != 0)
        {
          *a3 = 1;
          return a1 + 16;
        }
        goto LABEL_28;
      }
      if (v5 > 0)
      {
        v9 = v8 + 1;
        --i;
      }
    }
    if ((v10[3] & 2) == 0)
    {
      if (v9)
        v4 = v9 - 1;
      else
        v4 = 0;
      v8 = v4;
LABEL_28:
      **(_DWORD **)(a1 + 472) = *v10;
      *(_WORD *)(*(_QWORD *)(a1 + 472) + 4) = v8;
      *(_QWORD *)(a1 + 472) += 8;
      v6 = *(_DWORD *)((char *)v10 + *((unsigned __int16 *)v10 + v8 + 10) + 4);
      mpool_put(*(MPOOL **)a1, v10, 0);
      continue;
    }
    break;
  }
  if ((*(_DWORD *)(a1 + 636) & 0x20) != 0)
    goto LABEL_23;
  if (!v9 && v10[1] && __bt_sprev((MPOOL **)a1, v10, a2, a3))
    return a1 + 16;
  if (v9 == ((unint64_t)*((unsigned __int16 *)v10 + 8) - 20) / 2
    && v10[2]
    && __bt_snext((MPOOL **)a1, v10, a2, a3))
  {
    return a1 + 16;
  }
LABEL_23:
  *a3 = 0;
  *(_WORD *)(a1 + 24) = v9;
  return a1 + 16;
}

uint64_t __bt_sprev(MPOOL **a1, pgno_t *a2, uint64_t a3, _DWORD *a4)
{
  void *v5[2];
  _DWORD *v6;
  uint64_t v7;
  pgno_t *v8;
  MPOOL **v9;

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  v5[0] = 0;
  v5[1] = 0;
  v5[0] = mpool_get(*a1, a2[1], 0);
  if (v5[0])
  {
    LOWORD(v5[1]) = ((unint64_t)*((unsigned __int16 *)v5[0] + 8) - 20) / 2 - 1;
    if (__bt_cmp((uint64_t)v9, v7, (uint64_t *)v5))
    {
      mpool_put(*v9, v5[0], 0);
      return 0;
    }
    else
    {
      mpool_put(*v9, v8, 0);
      *((_OWORD *)v9 + 1) = *(_OWORD *)v5;
      *v6 = 1;
      return 1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __bt_snext(MPOOL **a1, pgno_t *a2, uint64_t a3, _DWORD *a4)
{
  void *v5[2];
  _DWORD *v6;
  uint64_t v7;
  pgno_t *v8;
  MPOOL **v9;

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  v5[0] = 0;
  v5[1] = 0;
  v5[0] = mpool_get(*a1, a2[2], 0);
  if (v5[0])
  {
    LOWORD(v5[1]) = 0;
    if (__bt_cmp((uint64_t)v9, v7, (uint64_t *)v5))
    {
      mpool_put(*v9, v5[0], 0);
      return 0;
    }
    else
    {
      mpool_put(*v9, v8, 0);
      *((_OWORD *)v9 + 1) = *(_OWORD *)v5;
      *v6 = 1;
      return 1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __bt_seq(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4)
{
  unsigned int v5;
  __int128 v6;
  MPOOL **v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  v7 = 0;
  v6 = 0uLL;
  v7 = *(MPOOL ***)(a1 + 56);
  if (v7[4])
  {
    mpool_put(*v7, v7[4], 0);
    v7[4] = 0;
  }
  if (v8 == 1 || v8 == 3 || v8 == 6)
    goto LABEL_10;
  if (v8 != 7 && v8 != 9)
  {
    *__error() = 22;
    return -1;
  }
  if ((*((_BYTE *)v7 + 68) & 8) == 0)
LABEL_10:
    v5 = __bt_seqset((uint64_t)v7, (uint64_t)&v6, (uint64_t)v10, v8);
  else
    v5 = __bt_seqadv(v7, &v6, v8);
  if (!v5)
  {
    __bt_setcur((uint64_t)v7, *(_DWORD *)v6, SWORD4(v6));
    v5 = __bt_ret((uint64_t)v7, (uint64_t)&v6, v10, (uint64_t *)v7 + 60, v9, (uint64_t *)v7 + 62, 0);
    if ((*((_DWORD *)v7 + 159) & 0x4000) != 0)
      mpool_put(*v7, (void *)v6, 0);
    else
      v7[4] = (MPOOL *)v6;
  }
  return v5;
}

uint64_t __bt_seqadv(MPOOL **a1, _OWORD *a2, int a3)
{
  int v4;
  pgno_t v5;
  unsigned __int16 v6;
  void *v7;
  MPOOL **v8;
  int v9;
  _OWORD *v10;
  MPOOL **v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  v8 = a1 + 5;
  if ((*((_BYTE *)a1 + 68) & 1) == 0)
  {
    v7 = mpool_get(*v11, *(_DWORD *)v8, 0);
    if (!v7)
      return -1;
    if (v9 == 7)
    {
      if ((*((_BYTE *)v8 + 28) & 2) != 0)
        goto LABEL_17;
      v6 = *((_WORD *)v8 + 2) + 1;
      if (((unint64_t)*((unsigned __int16 *)v7 + 8) - 20) / 2 == v6)
      {
        v5 = *((_DWORD *)v7 + 2);
        mpool_put(*v11, v7, 0);
        if (!v5)
          return 1;
        v7 = mpool_get(*v11, v5, 0);
        if (!v7)
          return -1;
        v6 = 0;
      }
    }
    else
    {
      if (v9 != 9)
        goto LABEL_25;
      if ((*((_BYTE *)v8 + 28) & 4) != 0)
      {
LABEL_17:
        *((_BYTE *)v8 + 28) &= 0xF9u;
        *(_QWORD *)v10 = v7;
        *((_WORD *)v10 + 4) = *((_WORD *)v8 + 2);
        return 0;
      }
      v6 = *((_WORD *)v8 + 2);
      if (v6)
      {
        --v6;
      }
      else
      {
        v5 = *((_DWORD *)v7 + 1);
        mpool_put(*v11, v7, 0);
        if (!v5)
          return 1;
        v7 = mpool_get(*v11, v5, 0);
        if (!v7)
          return -1;
        v6 = ((unint64_t)*((unsigned __int16 *)v7 + 8) - 20) / 2 - 1;
      }
    }
LABEL_25:
    *(_QWORD *)v10 = v7;
    *((_WORD *)v10 + 4) = v6;
    return 0;
  }
  return __bt_first((uint64_t)v11, (uint64_t)(v8 + 1), v10, &v4);
}

uint64_t __bt_seqset(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t v5;

  v5 = (a4 - 1);
  if (v5 <= 8)
    __asm { BR              X8 }
  return 0;
}

void __bt_setcur(uint64_t a1, int a2, __int16 a3)
{
  if (*(_QWORD *)(a1 + 48))
  {
    free(*(void **)(a1 + 48));
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 48) = 0;
  }
  *(_BYTE *)(a1 + 68) &= 0xF8u;
  *(_DWORD *)(a1 + 40) = a2;
  *(_WORD *)(a1 + 44) = a3;
  *(_BYTE *)(a1 + 68) |= 8u;
}

uint64_t __bt_first(uint64_t a1, uint64_t a2, _OWORD *a3, _DWORD *a4)
{
  pgno_t *v5;
  pgno_t v6;
  void *v7[2];
  uint64_t v8;
  pgno_t *v9;
  void *v10;

  v8 = __bt_search(a1, a2, a4);
  if (v8)
  {
    if (!*a4)
    {
      if (*(unsigned __int16 *)(v8 + 8) == ((unint64_t)*(unsigned __int16 *)(*(_QWORD *)v8 + 16) - 20) / 2)
      {
        v6 = *(_DWORD *)(*(_QWORD *)v8 + 8);
        mpool_put(*(MPOOL **)a1, *(void **)v8, 0);
        if (!v6)
          return 1;
        v10 = mpool_get(*(MPOOL **)a1, v6, 0);
        if (!v10)
          return -1;
        *(_WORD *)(v8 + 8) = 0;
        *(_QWORD *)v8 = v10;
      }
      *a3 = *(_OWORD *)v8;
      return 0;
    }
    if ((*(_DWORD *)(a1 + 636) & 0x20) != 0)
    {
      *a3 = *(_OWORD *)v8;
      return 0;
    }
    else
    {
      *(_OWORD *)v7 = *(_OWORD *)v8;
      v9 = *(pgno_t **)v8;
      do
      {
        if (*(_DWORD *)v7[0] == **(_DWORD **)v8)
        {
          LOWORD(v7[1]) = *(_WORD *)(v8 + 8);
        }
        else
        {
          mpool_put(*(MPOOL **)a1, v7[0], 0);
          *(_OWORD *)v7 = *(_OWORD *)v8;
        }
        if (!*(_WORD *)(v8 + 8))
        {
          if (!v9[1])
            break;
          if (*v9 != *(_DWORD *)v7[0])
            mpool_put(*(MPOOL **)a1, v9, 0);
          v5 = (pgno_t *)mpool_get(*(MPOOL **)a1, v9[1], 0);
          if (!v5)
          {
            if (*v9 == *(_DWORD *)v7[0])
              mpool_put(*(MPOOL **)a1, v7[0], 0);
            return -1;
          }
          v9 = v5;
          *(_QWORD *)v8 = v5;
          *(_WORD *)(v8 + 8) = ((unint64_t)*((unsigned __int16 *)v5 + 8) - 20) / 2;
        }
        --*(_WORD *)(v8 + 8);
      }
      while (!__bt_cmp(a1, a2, (uint64_t *)v8));
      if (*v9 != *(_DWORD *)v7[0])
        mpool_put(*(MPOOL **)a1, v9, 0);
      *a3 = *(_OWORD *)v7;
      return 0;
    }
  }
  else
  {
    return 1;
  }
}

uint64_t __bt_split(uint64_t a1, _DWORD *a2, _QWORD *a3, _QWORD *a4, int a5, uint64_t a6, int a7)
{
  __int16 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  char *v25;
  char *v26;
  unsigned __int16 v27[2];
  void *v28;
  void *v29;
  void *v30;
  _DWORD *v31;
  _WORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int v43;
  _QWORD *v44;
  _QWORD *v45;
  _DWORD *v46;
  uint64_t v47;

  v47 = a1;
  v46 = a2;
  v45 = a3;
  v44 = a4;
  v43 = a5;
  v42 = a6;
  v41 = a7;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  v36 = 0;
  v37 = 0;
  v34 = 0;
  v35 = 0;
  v33 = 0;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27[1] = 0;
  v27[0] = a7;
  if (*a2 == 1)
    v24 = bt_root(v47, (uint64_t)v46, &v31, &v30, v27, v42);
  else
    v24 = (uint64_t)bt_page(v47, v46, &v31, &v30, v27, v42);
  v32 = (_WORD *)v24;
  if (v24)
  {
    v7 = v32[9] - v42;
    v32[9] = v7;
    v32[v27[0] + 10] = v7;
    v25 = (char *)v32 + (unsigned __int16)v32[9];
    if ((*(_DWORD *)(v47 + 636) & 0x80) != 0)
    {
      *(_DWORD *)v25 = v44[1];
      v25[4] = v43;
      _platform_memmove(v25 + 5, *v44, v44[1]);
    }
    else
    {
      *(_DWORD *)v25 = v45[1];
      v26 = v25 + 4;
      *(_DWORD *)v26 = v44[1];
      v26[4] = v43;
      v26 += 5;
      _platform_memmove(v26, *v45, v45[1]);
      _platform_memmove(&v26[v45[1]], *v44, v44[1]);
    }
    if (*v46 != 1
      || ((*(_DWORD *)(v47 + 636) & 0x80) == 0
        ? (v23 = bt_broot(v47, (uint64_t)v46, v31, (uint64_t)v30, v8, v9, v10, v11))
        : (v23 = bt_rroot(v47, (uint64_t)v46, (uint64_t)v31, (uint64_t)v30)),
          v23 != -1))
    {
      if (*(_QWORD *)(v47 + 472) == v47 + 72)
      {
        v22 = 0;
      }
      else
      {
        v12 = *(_QWORD *)(v47 + 472) - 8;
        *(_QWORD *)(v47 + 472) = v12;
        v22 = v12;
      }
      v33 = v22;
      if (!v22)
      {
        mpool_put(*(MPOOL **)v47, v31, 1u);
        mpool_put(*(MPOOL **)v47, v30, 1u);
        return 0;
      }
      v29 = v31;
      v28 = v30;
      v32 = mpool_get(*(MPOOL **)v47, *(_DWORD *)v33, 0);
      if (v32)
      {
        v27[0] = *(_WORD *)(v33 + 4) + 1;
        v21 = (*((_DWORD *)v28 + 3) & 0x1Fu) - 1;
        if (v21 <= 0xF)
          __asm { BR              X8 }
        abort_report_np((uint64_t)"%s:%s:%u: illegal rchild->flags & P_TYPE (0x%x)", v13, v14, v15, v16, v17, v18, v19, (uint64_t)"bt_split.c");
      }
    }
    mpool_put(*(MPOOL **)v47, v31, 0);
    mpool_put(*(MPOOL **)v47, v30, 0);
    __dbpanic(*(_QWORD **)(v47 + 8));
    return -1;
  }
  return -1;
}

uint64_t bt_root(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4, unsigned __int16 *a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  __int16 v8;
  int v9;
  pgno_t v11;
  pgno_t v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  uint64_t v16;
  unsigned __int16 *v17;
  _QWORD *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = a5;
  v16 = a6;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v15 = __bt_new(a1, &v12);
  if (!v15)
    return 0;
  v14 = __bt_new(v21, &v11);
  if (!v14)
    return 0;
  *v15 = v12;
  *v14 = v11;
  v15[2] = *v14;
  v14[1] = *v15;
  v14[2] = 0;
  v15[1] = 0;
  *((_WORD *)v14 + 8) = 20;
  *((_WORD *)v15 + 8) = 20;
  v8 = *(_DWORD *)(v21 + 520);
  *((_WORD *)v14 + 9) = v8;
  *((_WORD *)v15 + 9) = v8;
  v9 = *(_DWORD *)(v20 + 12) & 0x1F;
  v14[3] = v9;
  v15[3] = v9;
  v13 = bt_psplit(v21, v20, (uint64_t)v15, (uint64_t)v14, v17, v16, v6, v7);
  *v19 = v15;
  *v18 = v14;
  return v13;
}

void *bt_page(uint64_t a1, _DWORD *a2, _QWORD *a3, void **a4, unsigned __int16 *a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  pgno_t v9;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  unsigned __int16 *v14;
  void **v15;
  _QWORD *v16;
  _DWORD *v17;
  uint64_t v18;

  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a4;
  v14 = a5;
  v13 = a6;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v11 = __bt_new(a1, &v9);
  if (!v11)
    return 0;
  *(_DWORD *)v11 = v9;
  *((_WORD *)v11 + 8) = 20;
  *((_WORD *)v11 + 9) = *(_DWORD *)(v18 + 520);
  *((_DWORD *)v11 + 2) = v17[2];
  *((_DWORD *)v11 + 1) = *v17;
  *((_DWORD *)v11 + 3) = v17[3] & 0x1F;
  if (v17[2] || *v14 != ((unint64_t)*((unsigned __int16 *)v17 + 8) - 20) / 2)
  {
    v12 = (void *)malloc_type_calloc(1, *(unsigned int *)(v18 + 520), 629395855);
    if (v12)
    {
      *(_DWORD *)v12 = *v17;
      *((_DWORD *)v12 + 2) = *(_DWORD *)v11;
      *((_DWORD *)v12 + 1) = v17[1];
      *((_WORD *)v12 + 8) = 20;
      *((_WORD *)v12 + 9) = *(_DWORD *)(v18 + 520);
      *((_DWORD *)v12 + 3) = v17[3] & 0x1F;
      if (v17[2])
      {
        v10 = mpool_get(*(MPOOL **)v18, v17[2], 0);
        if (!v10)
        {
          free(v12);
          return 0;
        }
        *((_DWORD *)v10 + 1) = *(_DWORD *)v11;
        mpool_put(*(MPOOL **)v18, v10, 1u);
      }
      v10 = (void *)bt_psplit(v18, (uint64_t)v17, (uint64_t)v12, (uint64_t)v11, v14, v13, v6, v7);
      _platform_memmove(v17, v12, *(unsigned int *)(v18 + 520));
      if (v10 == v12)
        v10 = v17;
      free(v12);
      *v16 = v17;
      *v15 = v11;
      return v10;
    }
    else
    {
      mpool_put(*(MPOOL **)v18, v11, 0);
      return 0;
    }
  }
  else
  {
    v17[2] = *(_DWORD *)v11;
    *((_WORD *)v11 + 8) = 22;
    *v14 = 0;
    *v16 = v17;
    *v15 = v11;
    return v11;
  }
}

uint64_t bt_rroot(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int16 v4;
  __int16 v5;
  unint64_t v7;
  unint64_t v8;
  _DWORD *v9;
  _DWORD *v10;

  v4 = *(_DWORD *)(a1 + 520) - 8;
  *(_WORD *)(a2 + 18) = v4;
  *(_WORD *)(a2 + 20) = v4;
  v9 = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 18));
  if ((*(_DWORD *)(a3 + 12) & 0x10) != 0)
    v8 = ((unint64_t)*(unsigned __int16 *)(a3 + 16) - 20) / 2;
  else
    LODWORD(v8) = rec_total(a3);
  *v9 = v8;
  v9[1] = *(_DWORD *)a3;
  v5 = *(_WORD *)(a2 + 18) - 8;
  *(_WORD *)(a2 + 18) = v5;
  *(_WORD *)(a2 + 22) = v5;
  v10 = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 18));
  if ((*(_DWORD *)(a4 + 12) & 0x10) != 0)
    v7 = ((unint64_t)*(unsigned __int16 *)(a4 + 16) - 20) / 2;
  else
    LODWORD(v7) = rec_total(a4);
  *v10 = v7;
  v10[1] = *(_DWORD *)a4;
  *(_WORD *)(a2 + 16) = 24;
  *(_DWORD *)(a2 + 12) &= 0xFFFFFFE0;
  *(_DWORD *)(a2 + 12) |= 8u;
  mpool_put(*(MPOOL **)a1, (void *)a2, 1u);
  return 0;
}

uint64_t bt_broot(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8;
  __int16 v9;
  __int16 v10;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int *v17;
  _DWORD *v18;

  v8 = *(_DWORD *)(a1 + 520) - 12;
  *(_WORD *)(a2 + 18) = v8;
  *(_WORD *)(a2 + 20) = v8;
  v13 = a2 + *(unsigned __int16 *)(a2 + 18);
  *(_DWORD *)v13 = 0;
  *(_DWORD *)(v13 + 4) = *a3;
  *(_BYTE *)(v13 + 8) = 0;
  v12 = *(_DWORD *)(a2 + 12) & 0x1F;
  if (v12 == 1)
  {
    v18 = (_DWORD *)(a4 + *(unsigned __int16 *)(a4 + 20));
    v16 = (*v18 + 12) & 0xFFFFFFFC;
    v10 = *(_WORD *)(a2 + 18) - v16;
    *(_WORD *)(a2 + 18) = v10;
    *(_WORD *)(a2 + 22) = v10;
    v15 = a2 + *(unsigned __int16 *)(a2 + 18);
    _platform_memmove(v15, v18, v16);
    *(_DWORD *)(v15 + 4) = *(_DWORD *)a4;
LABEL_9:
    *(_WORD *)(a2 + 16) = 24;
    *(_DWORD *)(a2 + 12) &= 0xFFFFFFE0;
    *(_DWORD *)(a2 + 12) |= 1u;
    mpool_put(*(MPOOL **)a1, (void *)a2, 1u);
    return 0;
  }
  if (v12 != 2)
    abort_report_np((uint64_t)"%s:%s:%u: illegal h->flags & P_TYPE (0x%x)", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (uint64_t)"bt_split.c");
  v17 = (unsigned int *)(a4 + *(unsigned __int16 *)(a4 + 20));
  v9 = *(_WORD *)(a2 + 18) - ((*(_WORD *)v17 + 12) & 0xFFFC);
  *(_WORD *)(a2 + 18) = v9;
  *(_WORD *)(a2 + 22) = v9;
  v14 = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 18));
  *v14 = *v17;
  v14[1] = *(_DWORD *)a4;
  v14 += 2;
  *(_BYTE *)v14 = 0;
  _platform_memmove((char *)v14 + 1, (char *)v17 + 9, *v17);
  if ((v17[2] & 2) == 0 || bt_preserve((MPOOL **)a1, *(unsigned int *)((char *)v17 + 9)) != -1)
    goto LABEL_9;
  return -1;
}

uint64_t bt_preserve(MPOOL **a1, pgno_t a2)
{
  _DWORD *v3;

  v3 = mpool_get(*a1, a2, 0);
  if (v3)
  {
    v3[3] |= 0x20u;
    mpool_put(*a1, v3, 1u);
    return 0;
  }
  else
  {
    return -1;
  }
}

uint64_t rec_total(uint64_t a1)
{
  unsigned __int16 i;
  unsigned int v3;

  v3 = 0;
  for (i = 0; i < (int)(unsigned __int16)(((unint64_t)*(unsigned __int16 *)(a1 + 16) - 20) / 2); ++i)
    v3 += *(_DWORD *)(a1 + *(unsigned __int16 *)(a1 + 20 + 2 * i));
  return v3;
}

uint64_t bt_psplit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned __int16 *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8;
  unint64_t v10;
  unint64_t v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  _BYTE v17[10];
  uint64_t v18;
  _DWORD *v19;
  unsigned int v20;

  v20 = a6;
  *(_WORD *)&v17[8] = 0;
  v14 = *a5;
  *(_QWORD *)v17 = (unsigned __int16)(*(_DWORD *)(a1 + 520) - 20);
  v12 = 0;
  v15 = 0;
  v16 = 0;
  v13 = ((unint64_t)*(unsigned __int16 *)(a2 + 16) - 20) / 2;
  while (v16 < (int)v13)
  {
    if (v14 != v15)
    {
      v11 = (*(_DWORD *)(a2 + 12) & 0x1Fu) - 1;
      if (v11 <= 0xF)
        __asm { BR              X8 }
      abort_report_np((uint64_t)"%s:%s:%u: illegal h->flags & P_TYPE (0x%x)", a2, a3, a4, (uint64_t)a5, a6, a7, a8, (uint64_t)"bt_split.c");
    }
    if (v14 <= (int)v15 && (unint64_t)(v12 + v20) + 2 >= *(unsigned __int16 *)v17 || v16 == v13 - 1)
    {
      --v15;
      break;
    }
    if (v14 != v15)
    {
      ++v16;
      v8 = *(_WORD *)(a3 + 18) - v20;
      *(_WORD *)(a3 + 18) = v8;
      *(_WORD *)(a3 + 20 + 2 * v15) = v8;
      _platform_memmove(a3 + *(unsigned __int16 *)(a3 + 18), *(_QWORD *)&v17[2], v20);
    }
    v12 += v20 + 2;
    if (v12 >= *(unsigned __int16 *)v17 / 2)
      break;
    ++v15;
  }
  *(_WORD *)(a3 + 16) += 2 * (v15 + 1);
  v19 = (_DWORD *)(a1 + 40);
  if ((*(_BYTE *)(a1 + 68) & 8) != 0 && *v19 == *(_DWORD *)a2)
  {
    if (*(unsigned __int16 *)(a1 + 44) >= (int)v14)
      ++*(_WORD *)(a1 + 44);
    if (*(unsigned __int16 *)(a1 + 44) >= (int)v16)
    {
      *v19 = *(_DWORD *)a4;
      *(_WORD *)(a1 + 44) -= v16;
    }
    else
    {
      *v19 = *(_DWORD *)a3;
    }
  }
  if (v14 > (int)v15)
  {
    v18 = a4;
    *a5 -= v16;
  }
  else
  {
    v14 = -1;
    v18 = a3;
  }
  if (v16 < (int)v13)
  {
    v10 = (*(_DWORD *)(a2 + 12) & 0x1Fu) - 1;
    if (v10 <= 0xF)
      __asm { BR              X8 }
    abort_report_np((uint64_t)"%s:%s:%u: illegal h->flags & P_TYPE (0x%x)", a2, a3, a4, (uint64_t)a5, a6, a7, a8, (uint64_t)"bt_split.c");
  }
  *(_WORD *)(a4 + 16) = *(_WORD *)(a4 + 16);
  if (v14 == v13)
    *(_WORD *)(a4 + 16) += 2;
  return v18;
}

uint64_t __bt_ret(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, int a7)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;

  v10 = (unsigned int *)(*(_QWORD *)a2
                       + *(unsigned __int16 *)(*(_QWORD *)a2 + 20 + 2 * *(unsigned __int16 *)(a2 + 8)));
  if (a3)
  {
    if ((v10[2] & 2) != 0)
    {
      if (__ovfl_get(a1, (unsigned int *)((char *)v10 + 9), a3 + 1, (void **)a4, a4 + 1))
        return -1;
      *a3 = *a4;
    }
    else if (a7 || (*(_DWORD *)(a1 + 636) & 0x4000) != 0)
    {
      if (*v10 > (unint64_t)a4[1])
      {
        v8 = malloc_type_realloc(*a4, *v10, 658813223);
        if (!v8)
          return -1;
        *a4 = v8;
        a4[1] = *v10;
      }
      _platform_memmove(*a4, (char *)v10 + 9, *v10);
      a3[1] = *v10;
      *a3 = *a4;
    }
    else
    {
      a3[1] = *v10;
      *a3 = (uint64_t)v10 + 9;
    }
  }
  if (a5)
  {
    if ((v10[2] & 1) != 0)
    {
      if (__ovfl_get(a1, (unsigned int *)((char *)v10 + *v10 + 9), a5 + 1, (void **)a6, a6 + 1))
        return -1;
      *a5 = *a6;
    }
    else if (a7 || (*(_DWORD *)(a1 + 636) & 0x4000) != 0)
    {
      if (v10[1] + 1 > (unint64_t)a6[1])
      {
        v9 = malloc_type_realloc(*a6, v10[1] + 1, 2282441685);
        if (!v9)
          return -1;
        *a6 = v9;
        a6[1] = v10[1] + 1;
      }
      _platform_memmove(*a6, (char *)v10 + *v10 + 9, v10[1]);
      a5[1] = v10[1];
      *a5 = *a6;
    }
    else
    {
      a5[1] = v10[1];
      *a5 = (uint64_t)v10 + *v10 + 9;
    }
    return 0;
  }
  return 0;
}

uint64_t __bt_cmp(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  pgno_t *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = 0;
  v8 = 0;
  v6 = 0;
  v7 = 0;
  v5 = *a3;
  if (*((_WORD *)a3 + 4) || *(_DWORD *)(v5 + 4) || (*(_DWORD *)(v5 + 12) & 2) != 0)
  {
    v4 = 0;
    if ((*(_DWORD *)(v5 + 12) & 2) != 0)
    {
      v8 = (unsigned int *)(v5 + *(unsigned __int16 *)(v5 + 20 + 2 * *((unsigned __int16 *)v10 + 4)));
      if ((v8[2] & 2) != 0)
      {
        v4 = (unsigned int *)((char *)v8 + 9);
      }
      else
      {
        v6 = (char *)v8 + 9;
        v7 = *v8;
      }
    }
    else
    {
      v9 = (unsigned int *)(v5 + *(unsigned __int16 *)(v5 + 20 + 2 * *((unsigned __int16 *)v10 + 4)));
      if ((v9[2] & 2) != 0)
      {
        v4 = (unsigned int *)((char *)v9 + 9);
      }
      else
      {
        v6 = (char *)v9 + 9;
        v7 = *v9;
      }
    }
    if (v4)
    {
      if (__ovfl_get(v12, v4, &v7, (void **)(v12 + 496), (_QWORD *)(v12 + 504)))
        return -1;
      v6 = *(char **)(v12 + 496);
    }
    return (*(uint64_t (**)(uint64_t, char **))(v12 + 544))(v11, &v6);
  }
  return 1;
}

uint64_t __bt_defcmp(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned __int8 *v4;
  unsigned __int8 *i;
  unsigned __int8 *v6;
  unsigned __int8 *v7;

  if (a1[1] >= a2[1])
    v4 = a2[1];
  else
    v4 = a1[1];
  v7 = v4;
  v6 = *a1;
  for (i = *a2; v7--; ++i)
  {
    if (*v6 != *i)
      return (*v6 - *i);
    ++v6;
  }
  return a1[1] - a2[1];
}

uint64_t __bt_defpfx(unsigned __int8 **a1, unsigned __int8 **a2)
{
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned __int8 *i;
  unsigned __int8 *v9;

  v7 = 1;
  if (a1[1] >= a2[1])
    v5 = a2[1];
  else
    v5 = a1[1];
  v6 = v5;
  v9 = *a1;
  for (i = *a2; v6--; ++i)
  {
    if (*v9 != *i)
      return v7;
    ++v9;
    ++v7;
  }
  if (a1[1] >= a2[1])
    return (uint64_t)a1[1];
  else
    return (uint64_t)(a1[1] + 1);
}

DB *__cdecl dbopen(const char *a1, int a2, int a3, DBTYPE a4, const void *a5)
{
  if ((a2 & 0x1FFFF1C9) != 0)
    goto LABEL_9;
  if (a4 == DB_BTREE)
    return (DB *)__bt_open((uint64_t)a1, a2 & 0xE36, a3, (uint64_t)a5, a2 & 0xE0000000);
  if (a4 == DB_HASH)
    return (DB *)__hash_open(a1, a2 & 0xE36, a3, (uint64_t)a5, a2 & 0xE0000000);
  if (a4 != DB_RECNO)
  {
LABEL_9:
    *__error() = 22;
    return 0;
  }
  return (DB *)__rec_open((uint64_t)a1, a2 & 0xE36, a3, (uint64_t)a5, a2 & 0xE0000000);
}

_QWORD *__dbpanic(_QWORD *result)
{
  result[2] = __dberr;
  result[8] = __dberr;
  result[3] = __dberr;
  result[4] = __dberr;
  result[5] = __dberr;
  result[6] = __dberr;
  return result;
}

uint64_t __dberr()
{
  return 0xFFFFFFFFLL;
}

uint64_t __hash_open(const char *a1, unsigned int a2, int a3, uint64_t a4, int a5)
{
  int v5;
  uint64_t v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  int v11;
  int v12;
  int v13;
  int NOCANCEL;
  int v15;
  uint64_t v16;
  stat v17;
  _DWORD *inited;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  const char *v23;

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v19 = a5;
  inited = 0;
  _platform_memset(&v17, 0, 144);
  if ((v22 & 3) == 1)
    ++v22;
  inited = (_DWORD *)malloc_type_calloc(1, 664, 0x10B00404C34C173);
  if (!inited)
    return 0;
  inited[71] = -1;
  inited[70] = v22;
  if (v23)
  {
    v5 = open_NOCANCEL(v23, v22);
    inited[71] = v5;
    if (v5 == -1)
    {
      v11 = *__error();
LABEL_47:
      free(inited);
      *__error() = v11;
      return 0;
    }
    v7 = 1;
    fcntl_NOCANCEL(inited[71], 2);
    v10 = 0;
    if (!fstat(inited[71], &v17))
    {
      v10 = 0;
      if (!v17.st_size)
      {
        v9 = 1;
        if ((v22 & 3) == 0)
          v9 = (v22 & 0x200) != 0;
        v10 = v9;
      }
    }
    v13 = v10;
  }
  else
  {
    v13 = 1;
  }
  if (!v13)
  {
    if (v20 && *(_QWORD *)(v20 + 16))
      *((_QWORD *)inited + 34) = *(_QWORD *)(v20 + 16);
    else
      *((_QWORD *)inited + 34) = __default_hash;
    NOCANCEL = read_NOCANCEL(inited[71], inited, 260);
    swap_header(inited);
    if (NOCANCEL == -1)
      goto LABEL_17;
    if (NOCANCEL == 260)
    {
      if (*inited == 398689)
      {
        if (inited[1] == 2 || inited[1] == 1)
        {
          if ((*((unsigned int (**)(const char *, ...))inited + 34))("%$sniglet^&", 12, v7) == inited[16])
          {
            if (alloc_segs((uint64_t)inited, (inited[10] + inited[6]) / inited[6]))
              return 0;
            v15 = (inited[inited[8] + 17] + 8 * inited[3] - 1) >> (inited[4] + 3);
            inited[148] = v15;
            _platform_bzero(inited + 84, 8 * v15);
            goto LABEL_36;
          }
          v11 = 79;
        }
        else
        {
          v11 = 79;
        }
      }
      else
      {
        v11 = 79;
      }
    }
    else
    {
      v11 = 79;
    }
LABEL_45:
    if (inited)
      close_NOCANCEL(inited[71]);
    goto LABEL_47;
  }
  inited = init_hash(inited, v23, v20);
  if (!inited)
  {
LABEL_17:
    v11 = *__error();
    goto LABEL_45;
  }
LABEL_36:
  if (v20 && *(_DWORD *)(v20 + 12))
    __buf_init((uint64_t)inited, *(_DWORD *)(v20 + 12));
  else
    __buf_init((uint64_t)inited, 0x10000);
  inited[81] = v13;
  v8 = 0;
  if (v23)
    v8 = (inited[70] & 2) != 0;
  inited[82] = v8;
  inited[78] = -1;
  v16 = malloc_type_malloc(72, 0x10800406ECF7772);
  if (v16)
  {
    *(_QWORD *)(v16 + 56) = inited;
    *(_QWORD *)(v16 + 8) = hash_close;
    *(_QWORD *)(v16 + 16) = hash_delete;
    *(_QWORD *)(v16 + 64) = hash_fd;
    *(_QWORD *)(v16 + 24) = hash_get;
    *(_QWORD *)(v16 + 32) = hash_put;
    *(_QWORD *)(v16 + 40) = hash_seq;
    *(_QWORD *)(v16 + 48) = hash_sync;
    *(_DWORD *)v16 = 1;
    return v16;
  }
  else
  {
    v12 = *__error();
    hdestroy();
    *__error() = v12;
    return 0;
  }
}

_DWORD *init_hash(_DWORD *a1, const char *a2, uint64_t a3)
{
  int v4;
  stat v5;
  uint64_t v6;
  const char *v7;
  _DWORD *v8;

  v8 = a1;
  v7 = a2;
  v6 = a3;
  _platform_memset(&v5, 0, 144);
  v4 = 1;
  v8[14] = 0;
  v8[2] = 1234;
  v8[3] = 4096;
  v8[4] = 12;
  v8[6] = 256;
  v8[7] = 8;
  v8[5] = 256;
  v8[13] = 0x10000;
  *((_QWORD *)v8 + 34) = __default_hash;
  _platform_memset(v8 + 17, 0, 128);
  _platform_memset(v8 + 49, 0, 64);
  if (v7)
  {
    if (stat(v7, &v5))
      return 0;
    v8[3] = v5.st_blksize;
    v8[4] = __log2(v8[3]);
  }
  if (v6)
  {
    if (*(_DWORD *)v6)
    {
      v8[4] = __log2(*(_DWORD *)v6);
      v8[3] = 1 << v8[4];
      if ((int)v8[3] > 0x10000)
        goto LABEL_8;
    }
    if (*(_DWORD *)(v6 + 4))
      v8[13] = *(_DWORD *)(v6 + 4);
    if (*(_QWORD *)(v6 + 16))
      *((_QWORD *)v8 + 34) = *(_QWORD *)(v6 + 16);
    if (*(_DWORD *)(v6 + 8))
      v4 = *(_DWORD *)(v6 + 8);
    if (*(_DWORD *)(v6 + 24))
    {
      if (*(_DWORD *)(v6 + 24) != 4321 && *(_DWORD *)(v6 + 24) != 1234)
      {
LABEL_8:
        *__error() = 22;
        return 0;
      }
      v8[2] = *(_DWORD *)(v6 + 24);
    }
  }
  if (init_htab(v8, v4))
    return 0;
  else
    return v8;
}

unsigned int *swap_header(unsigned int *result)
{
  __int16 v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int i;

  v19 = *result;
  *(_BYTE *)result = HIBYTE(*result);
  *((_BYTE *)result + 1) = BYTE2(v19);
  *((_BYTE *)result + 2) = BYTE1(v19);
  *((_BYTE *)result + 3) = v19;
  v18 = result[1];
  *((_BYTE *)result + 4) = HIBYTE(v18);
  *((_BYTE *)result + 5) = BYTE2(v18);
  *((_BYTE *)result + 6) = BYTE1(v18);
  *((_BYTE *)result + 7) = v18;
  v17 = result[2];
  *((_BYTE *)result + 8) = HIBYTE(v17);
  *((_BYTE *)result + 9) = BYTE2(v17);
  *((_BYTE *)result + 10) = BYTE1(v17);
  *((_BYTE *)result + 11) = v17;
  v16 = result[3];
  *((_BYTE *)result + 12) = HIBYTE(v16);
  *((_BYTE *)result + 13) = BYTE2(v16);
  *((_BYTE *)result + 14) = BYTE1(v16);
  *((_BYTE *)result + 15) = v16;
  v15 = result[4];
  *((_BYTE *)result + 16) = HIBYTE(v15);
  *((_BYTE *)result + 17) = BYTE2(v15);
  *((_BYTE *)result + 18) = BYTE1(v15);
  *((_BYTE *)result + 19) = v15;
  v14 = result[5];
  *((_BYTE *)result + 20) = HIBYTE(v14);
  *((_BYTE *)result + 21) = BYTE2(v14);
  *((_BYTE *)result + 22) = BYTE1(v14);
  *((_BYTE *)result + 23) = v14;
  v13 = result[6];
  *((_BYTE *)result + 24) = HIBYTE(v13);
  *((_BYTE *)result + 25) = BYTE2(v13);
  *((_BYTE *)result + 26) = BYTE1(v13);
  *((_BYTE *)result + 27) = v13;
  v12 = result[7];
  *((_BYTE *)result + 28) = HIBYTE(v12);
  *((_BYTE *)result + 29) = BYTE2(v12);
  *((_BYTE *)result + 30) = BYTE1(v12);
  *((_BYTE *)result + 31) = v12;
  v11 = result[8];
  *((_BYTE *)result + 32) = HIBYTE(v11);
  *((_BYTE *)result + 33) = BYTE2(v11);
  *((_BYTE *)result + 34) = BYTE1(v11);
  *((_BYTE *)result + 35) = v11;
  v10 = result[9];
  *((_BYTE *)result + 36) = HIBYTE(v10);
  *((_BYTE *)result + 37) = BYTE2(v10);
  *((_BYTE *)result + 38) = BYTE1(v10);
  *((_BYTE *)result + 39) = v10;
  v9 = result[10];
  *((_BYTE *)result + 40) = HIBYTE(v9);
  *((_BYTE *)result + 41) = BYTE2(v9);
  *((_BYTE *)result + 42) = BYTE1(v9);
  *((_BYTE *)result + 43) = v9;
  v8 = result[11];
  *((_BYTE *)result + 44) = HIBYTE(v8);
  *((_BYTE *)result + 45) = BYTE2(v8);
  *((_BYTE *)result + 46) = BYTE1(v8);
  *((_BYTE *)result + 47) = v8;
  v7 = result[12];
  *((_BYTE *)result + 48) = HIBYTE(v7);
  *((_BYTE *)result + 49) = BYTE2(v7);
  *((_BYTE *)result + 50) = BYTE1(v7);
  *((_BYTE *)result + 51) = v7;
  v6 = result[13];
  *((_BYTE *)result + 52) = HIBYTE(v6);
  *((_BYTE *)result + 53) = BYTE2(v6);
  *((_BYTE *)result + 54) = BYTE1(v6);
  *((_BYTE *)result + 55) = v6;
  v5 = result[14];
  *((_BYTE *)result + 56) = HIBYTE(v5);
  *((_BYTE *)result + 57) = BYTE2(v5);
  *((_BYTE *)result + 58) = BYTE1(v5);
  *((_BYTE *)result + 59) = v5;
  v4 = result[15];
  *((_BYTE *)result + 60) = HIBYTE(v4);
  *((_BYTE *)result + 61) = BYTE2(v4);
  *((_BYTE *)result + 62) = BYTE1(v4);
  *((_BYTE *)result + 63) = v4;
  v3 = result[16];
  *((_BYTE *)result + 64) = HIBYTE(v3);
  *((_BYTE *)result + 65) = BYTE2(v3);
  *((_BYTE *)result + 66) = BYTE1(v3);
  *((_BYTE *)result + 67) = v3;
  for (i = 0; i < 32; ++i)
  {
    v2 = result[i + 17];
    LOBYTE(result[i + 17]) = HIBYTE(v2);
    BYTE1(result[i + 17]) = BYTE2(v2);
    BYTE2(result[i + 17]) = BYTE1(v2);
    HIBYTE(result[i + 17]) = v2;
    v1 = *((_WORD *)result + i + 98);
    *((_BYTE *)result + 2 * i + 196) = HIBYTE(v1);
    *((_BYTE *)result + 2 * i + 197) = v1;
  }
  return result;
}

uint64_t alloc_segs(uint64_t a1, int a2)
{
  uint64_t v2;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int i;

  v2 = malloc_type_calloc(*(int *)(a1 + 20), 8, 0x80040B8603338);
  *(_QWORD *)(a1 + 648) = v2;
  if (v2)
  {
    *(_DWORD *)(a1 + 260) = a2;
    if (a2)
    {
      v6 = malloc_type_calloc(a2 << *(_DWORD *)(a1 + 28), 8, 0x80040B8603338);
      if (v6)
      {
        for (i = 0; i < a2; ++i)
          *(_QWORD *)(*(_QWORD *)(a1 + 648) + 8 * i) = v6 + 8 * (i << *(_DWORD *)(a1 + 28));
        return 0;
      }
      else
      {
        v5 = *__error();
        hdestroy();
        *__error() = v5;
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v4 = *__error();
    hdestroy();
    *__error() = v4;
    return -1;
  }
}

void hdestroy(void)
{
  uint64_t v0;
  unsigned int v1;
  uint64_t v2;
  int v3;
  int v4;
  signed int i;
  unsigned int *v6;

  v6 = (unsigned int *)v0;
  v4 = 0;
  if (__buf_free(v0, 1, *(_DWORD *)(v0 + 328)))
    v4 = *__error();
  if (*((_QWORD *)v6 + 81))
  {
    free(**((void ***)v6 + 81));
    while (1)
    {
      v1 = v6[66];
      v6[66] = v1 - 1;
      if (!v1)
        break;
      v2 = *((_QWORD *)v6 + 81);
      v3 = v6[65] - 1;
      v6[65] = v3;
      free(*(void **)(v2 + 8 * v3));
    }
    free(*((void **)v6 + 81));
  }
  if (flush_meta(v6) && !v4)
    v4 = *__error();
  for (i = 0; i < (int)v6[148]; ++i)
  {
    if (*(_QWORD *)&v6[2 * i + 84])
      free(*(void **)&v6[2 * i + 84]);
  }
  if (*((_QWORD *)v6 + 37))
    free(*((void **)v6 + 37));
  if (*((_QWORD *)v6 + 36))
    free(*((void **)v6 + 36));
  if (v6[71] != -1)
    close_NOCANCEL(v6[71]);
  free(v6);
  if (v4)
    *__error() = v4;
}

uint64_t hash_close(void *a1)
{
  unsigned int v1;
  unsigned int v3;

  if (a1)
  {
    hdestroy();
    v3 = v1;
    free(a1);
    return v3;
  }
  else
  {
    return -1;
  }
}

uint64_t hash_delete(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  _DWORD *v4;

  v4 = *(_DWORD **)(a1 + 56);
  if (a3 < 2)
  {
    if ((v4[70] & 3) != 0)
    {
      return hash_access(v4, 3u, a2, 0);
    }
    else
    {
      *__error() = 1;
      v4[80] = 1;
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    v4[80] = 22;
    return -1;
  }
}

uint64_t hash_fd(uint64_t a1)
{
  uint64_t v2;

  if (a1)
  {
    v2 = *(_QWORD *)(a1 + 56);
    if (*(_DWORD *)(v2 + 284) == -1)
    {
      *__error() = 2;
      return -1;
    }
    else
    {
      return *(unsigned int *)(v2 + 284);
    }
  }
  else
  {
    return -1;
  }
}

uint64_t hash_get(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4)
{
  _DWORD *v5;

  v5 = *(_DWORD **)(a1 + 56);
  if (a4)
  {
    *__error() = 22;
    v5[80] = 22;
    return -1;
  }
  else
  {
    return hash_access(v5, 0, a2, a3);
  }
}

uint64_t hash_put(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4)
{
  unsigned int v4;
  _DWORD *v6;

  v6 = *(_DWORD **)(a1 + 56);
  if (!a4 || a4 == 8)
  {
    if ((v6[70] & 3) != 0)
    {
      if (a4 == 8)
        v4 = 2;
      else
        v4 = 1;
      return hash_access(v6, v4, a2, a3);
    }
    else
    {
      *__error() = 1;
      v6[80] = 1;
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    v6[80] = 22;
    return -1;
  }
}

uint64_t hash_seq(uint64_t a1, _QWORD *a2, _QWORD *a3, int a4)
{
  unint64_t v4;
  int v6;
  BOOL v7;
  unsigned __int16 v8;
  _WORD *v9;
  uint64_t v10;
  unint64_t buf;
  unsigned int i;

  buf = 0;
  v10 = *(_QWORD *)(a1 + 56);
  if (!a4 || a4 == 3 || a4 == 7)
  {
    if (*(int *)(v10 + 312) < 0 || a4 == 3)
    {
      *(_DWORD *)(v10 + 312) = 0;
      *(_DWORD *)(v10 + 316) = 1;
      *(_QWORD *)(v10 + 304) = 0;
    }
LABEL_8:
    v9 = 0;
    while (1)
    {
      v7 = 1;
      if (v9)
        v7 = *v9 == 0;
      if (!v7)
        break;
      buf = *(_QWORD *)(v10 + 304);
      if (!buf)
      {
        for (i = *(_DWORD *)(v10 + 312); i <= *(_DWORD *)(v10 + 40); ++i)
        {
          buf = __get_buf(v10, i, 0, 0);
          if (!buf)
            return -1;
          *(_QWORD *)(v10 + 304) = buf;
          v9 = *(_WORD **)(buf + 32);
          if (*v9)
            break;
          *(_DWORD *)(v10 + 316) = 1;
        }
        *(_DWORD *)(v10 + 312) = i;
        if (*(_DWORD *)(v10 + 312) <= *(_DWORD *)(v10 + 40))
          goto LABEL_25;
        *(_DWORD *)(v10 + 312) = -1;
        return 1;
      }
      v9 = *(_WORD **)(*(_QWORD *)(v10 + 304) + 32);
      if (a4 == 7)
      {
        *(_DWORD *)(v10 + 316) += 2;
        if (*(_DWORD *)(v10 + 316) > (int)(unsigned __int16)*v9)
        {
          *(_QWORD *)(v10 + 304) = 0;
          ++*(_DWORD *)(v10 + 312);
          *(_DWORD *)(v10 + 316) = 1;
          goto LABEL_8;
        }
      }
LABEL_25:
      while (!v9[*(_DWORD *)(v10 + 316) + 1])
      {
        v4 = __get_buf(v10, (unsigned __int16)v9[*(int *)(v10 + 316)], buf, 0);
        *(_QWORD *)(v10 + 304) = v4;
        buf = v4;
        if (!v4)
          return -1;
        v9 = *(_WORD **)(v4 + 32);
        *(_DWORD *)(v10 + 316) = 1;
      }
      if (!*v9)
      {
        *(_QWORD *)(v10 + 304) = 0;
        ++*(_DWORD *)(v10 + 312);
      }
    }
    v8 = *(_DWORD *)(v10 + 316);
    if ((unsigned __int16)v9[v8 + 1] >= 4u)
    {
      if (!*(_QWORD *)(v10 + 304))
        return -1;
      *a2 = *(_QWORD *)(*(_QWORD *)(v10 + 304) + 32) + (unsigned __int16)v9[v8];
      if (v8 <= 1u)
        v6 = *(_DWORD *)(v10 + 12);
      else
        v6 = (unsigned __int16)v9[v8 - 1];
      a2[1] = v6 - (unsigned __int16)v9[v8];
      *a3 = *(_QWORD *)(*(_QWORD *)(v10 + 304) + 32) + (unsigned __int16)v9[v8 + 1];
      a3[1] = (unsigned __int16)v9[v8] - (unsigned __int16)v9[v8 + 1];
    }
    else if (__big_keydata(v10, buf, a2, a3, 1u))
    {
      return -1;
    }
    return 0;
  }
  else
  {
    *__error() = 22;
    *(_DWORD *)(v10 + 320) = 22;
    return -1;
  }
}

uint64_t hash_sync(uint64_t a1, int a2)
{
  uint64_t v3;

  if (a2)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    v3 = *(_QWORD *)(a1 + 56);
    if (*(_DWORD *)(v3 + 328))
    {
      if (__buf_free(v3, 0, 1) || flush_meta((_BYTE *)v3))
      {
        return -1;
      }
      else
      {
        *(_DWORD *)(v3 + 324) = 0;
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __expand_table(uint64_t a1)
{
  unsigned int v1;
  uint64_t v2;
  int v4;
  signed int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;

  v1 = *(_DWORD *)(a1 + 40) + 1;
  *(_DWORD *)(a1 + 40) = v1;
  v7 = v1;
  v8 = *(_DWORD *)(a1 + 40) & *(_DWORD *)(a1 + 48);
  v5 = v1 >> *(_DWORD *)(a1 + 28);
  if (v5 >= *(_DWORD *)(a1 + 260))
  {
    if (v5 >= *(_DWORD *)(a1 + 20))
    {
      v6 = 8 * *(_DWORD *)(a1 + 20);
      if (!hash_realloc((void **)(a1 + 648), v6, 16 * *(_DWORD *)(a1 + 20)))
        return -1;
      *(_DWORD *)(a1 + 20) = 2 * v6;
    }
    v2 = malloc_type_calloc(*(int *)(a1 + 24), 8, 0x80040B8603338);
    *(_QWORD *)(*(_QWORD *)(a1 + 648) + 8 * v5) = v2;
    if (!v2)
      return -1;
    ++*(_DWORD *)(a1 + 264);
    ++*(_DWORD *)(a1 + 260);
  }
  v4 = __log2(*(_DWORD *)(a1 + 40) + 1);
  if (v4 > *(_DWORD *)(a1 + 32))
  {
    *(_DWORD *)(a1 + 68 + 4 * v4) = *(_DWORD *)(a1 + 68 + 4 * *(int *)(a1 + 32));
    *(_DWORD *)(a1 + 32) = v4;
  }
  if (v7 > *(_DWORD *)(a1 + 44))
  {
    *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 44);
    *(_DWORD *)(a1 + 44) = v7 | *(_DWORD *)(a1 + 48);
  }
  return __split_page((_DWORD *)a1, v8, v7);
}

uint64_t hash_realloc(void **a1, int a2, int a3)
{
  uint64_t v4;

  v4 = malloc_type_malloc(a3, 4033553863);
  if (v4)
  {
    _platform_memmove(v4, *a1, a2);
    _platform_bzero(v4 + a2, a3 - a2);
    free(*a1);
    *a1 = (void *)v4;
  }
  return v4;
}

uint64_t __call_hash(uint64_t a1, uint64_t a2, int a3)
{
  unsigned int v4;

  v4 = (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 272))(a2, a3) & *(_DWORD *)(a1 + 44);
  if (v4 > *(_DWORD *)(a1 + 40))
    v4 &= *(_DWORD *)(a1 + 48);
  return v4;
}

uint64_t init_htab(_DWORD *a1, int a2)
{
  int v2;
  int v4;
  int v5;
  signed int v6;

  v6 = (a2 - 1) / a1[13] + 1;
  if (v6 <= 2)
    v2 = __log2(2u);
  else
    v2 = __log2(v6);
  v5 = 1 << v2;
  a1[v2 + 17] = v2 + 1;
  a1[v2 + 18] = v2 + 1;
  a1[8] = v2;
  a1[9] = 2;
  if (__ibitmap((uint64_t)a1, ((_WORD)v2 << 11) + 1, v2 + 1, 0))
  {
    return -1;
  }
  else
  {
    a1[12] = v5 - 1;
    a1[10] = v5 - 1;
    a1[11] = 2 * v5 - 1;
    a1[15] = (0x1FFuLL >> a1[4]) + 1;
    v4 = 1 << __log2((v5 - 1) / a1[6] + 1);
    if (v4 > a1[5])
      a1[5] = v4;
    return alloc_segs((uint64_t)a1, v4);
  }
}

uint64_t flush_meta(_BYTE *a1)
{
  int v1;
  int v3;
  int i;
  unsigned int v5;
  _BYTE v6[260];
  _BYTE *v7;
  _BYTE *v8;

  v8 = a1;
  v7 = 0;
  _platform_bzero(v6, 260);
  if (*((_DWORD *)v8 + 82))
  {
    *(_DWORD *)v8 = 398689;
    *((_DWORD *)v8 + 1) = 2;
    v1 = (*((uint64_t (**)(const char *, ...))v8 + 34))("%$sniglet^&", 12);
    *((_DWORD *)v8 + 16) = v1;
    v5 = *((_DWORD *)v8 + 71);
    v7 = v6;
    swap_header_copy(v8, v6);
    v3 = pwrite_NOCANCEL(v5, v7, 260, 0);
    if (v3 == -1)
    {
      return -1;
    }
    else if (v3 == 260)
    {
      for (i = 0; i < 32; ++i)
      {
        if (*(_QWORD *)&v8[8 * i + 336]
          && __put_page(v8, *(unsigned __int16 **)&v8[8 * i + 336], *(unsigned __int16 *)&v8[2 * i + 196], 0, 1))
        {
          return -1;
        }
      }
      return 0;
    }
    else
    {
      *__error() = 79;
      *((_DWORD *)v8 + 80) = *__error();
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

_BYTE *swap_header_copy(_BYTE *result, _BYTE *a2)
{
  int i;

  *a2 = result[3];
  a2[1] = result[2];
  a2[2] = result[1];
  a2[3] = *result;
  a2[4] = result[7];
  a2[5] = result[6];
  a2[6] = result[5];
  a2[7] = result[4];
  a2[8] = result[11];
  a2[9] = result[10];
  a2[10] = result[9];
  a2[11] = result[8];
  a2[12] = result[15];
  a2[13] = result[14];
  a2[14] = result[13];
  a2[15] = result[12];
  a2[16] = result[19];
  a2[17] = result[18];
  a2[18] = result[17];
  a2[19] = result[16];
  a2[20] = result[23];
  a2[21] = result[22];
  a2[22] = result[21];
  a2[23] = result[20];
  a2[24] = result[27];
  a2[25] = result[26];
  a2[26] = result[25];
  a2[27] = result[24];
  a2[28] = result[31];
  a2[29] = result[30];
  a2[30] = result[29];
  a2[31] = result[28];
  a2[32] = result[35];
  a2[33] = result[34];
  a2[34] = result[33];
  a2[35] = result[32];
  a2[36] = result[39];
  a2[37] = result[38];
  a2[38] = result[37];
  a2[39] = result[36];
  a2[40] = result[43];
  a2[41] = result[42];
  a2[42] = result[41];
  a2[43] = result[40];
  a2[44] = result[47];
  a2[45] = result[46];
  a2[46] = result[45];
  a2[47] = result[44];
  a2[48] = result[51];
  a2[49] = result[50];
  a2[50] = result[49];
  a2[51] = result[48];
  a2[52] = result[55];
  a2[53] = result[54];
  a2[54] = result[53];
  a2[55] = result[52];
  a2[56] = result[59];
  a2[57] = result[58];
  a2[58] = result[57];
  a2[59] = result[56];
  a2[60] = result[63];
  a2[61] = result[62];
  a2[62] = result[61];
  a2[63] = result[60];
  a2[64] = result[67];
  a2[65] = result[66];
  a2[66] = result[65];
  a2[67] = result[64];
  for (i = 0; i < 32; ++i)
  {
    a2[4 * i + 68] = result[4 * i + 71];
    a2[4 * i + 69] = result[4 * i + 70];
    a2[4 * i + 70] = result[4 * i + 69];
    a2[4 * i + 71] = result[4 * i + 68];
    a2[2 * i + 196] = result[2 * i + 197];
    a2[2 * i + 197] = result[2 * i + 196];
  }
  return result;
}

uint64_t hash_access(_DWORD *a1, unsigned int a2, uint64_t *a3, uint64_t *a4)
{
  unsigned int v4;
  unsigned __int16 *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned __int16 last_page;
  unsigned __int16 *v15;
  char v16;
  uint64_t v19;
  int v20;
  int v21;
  signed int v22;
  int bigpair;
  signed int v24;
  unsigned __int16 *v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t buf;
  uint64_t *v29;
  uint64_t *v30;
  unsigned int v31;
  _DWORD *v32;

  v32 = a1;
  v31 = a2;
  v30 = a3;
  v29 = a4;
  buf = 0;
  v27 = 0;
  v21 = a1[3];
  v20 = a3[1];
  v19 = *a3;
  v4 = __call_hash((uint64_t)a1, *a3, v20);
  buf = __get_buf((uint64_t)a1, v4, 0, 0);
  if (buf)
  {
    v26 = buf;
    *(_BYTE *)(buf + 40) |= 8u;
    v5 = *(unsigned __int16 **)(buf + 32);
    v25 = v5 + 1;
    v24 = *v5;
    v22 = 1;
    while (v22 < v24)
    {
      if (v25[1] < 4u)
      {
        if (v25[1])
        {
          if (v25[1] < 4u)
          {
            bigpair = __find_bigpair((uint64_t)v32, buf, v22, v19, v20);
            if (bigpair > 0)
              goto LABEL_32;
            if (bigpair != -2)
            {
              *(_BYTE *)(v26 + 40) &= ~8u;
              return -1;
            }
            v27 = buf;
            last_page = __find_last_page((uint64_t)v32, (unint64_t *)&v27);
            if (!last_page)
            {
              buf = v27;
              break;
            }
            buf = __get_buf((uint64_t)v32, last_page, v27, 0);
            if (!buf)
            {
              *(_BYTE *)(v26 + 40) &= ~8u;
              return -1;
            }
            v15 = *(unsigned __int16 **)(buf + 32);
            v25 = v15 + 1;
            v24 = *v15;
            v22 = 1;
            v21 = v32[3];
          }
        }
        else
        {
          buf = __get_buf((uint64_t)v32, *v25, buf, 0);
          if (!buf)
          {
            *(_BYTE *)(v26 + 40) &= ~8u;
            return -1;
          }
          v13 = *(unsigned __int16 **)(buf + 32);
          v25 = v13 + 1;
          v24 = *v13;
          v22 = 1;
          v21 = v32[3];
        }
      }
      else
      {
        if (v20 == v21 - *v25 && !_platform_memcmp(v19, *(_QWORD *)(buf + 32) + *v25, v20))
        {
LABEL_32:
          if (v31 <= 3uLL)
            __asm { BR              X8 }
          abort_report_np((uint64_t)"%s:%s:%u: illegal action (%d)", v6, v7, v8, v9, v10, v11, v12, (uint64_t)"hash.c");
        }
        v21 = v25[1];
        v25 += 2;
        v22 += 2;
      }
    }
    if (v31 && (v31 != 2 && v31 != 1 ? (v16 = 0) : (v16 = 1), (v16 & 1) != 0))
    {
      if (__addel(v32, buf, v30, v29))
      {
        *(_BYTE *)(v26 + 40) &= ~8u;
        return -1;
      }
      else
      {
        *(_BYTE *)(v26 + 40) &= ~8u;
        return 0;
      }
    }
    else
    {
      *(_BYTE *)(v26 + 40) &= ~8u;
      return 1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __big_insert(_DWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  unsigned __int16 v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  uint64_t v8;
  uint64_t v9;
  unsigned __int16 *v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  unsigned __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  unsigned __int16 v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned __int16 *v24;
  uint64_t v26;

  v26 = a2;
  v10 = *(unsigned __int16 **)(a2 + 32);
  v24 = v10;
  v9 = *a3;
  v23 = a3[1];
  v8 = *a4;
  v18 = a4[1];
  v15 = v10[*v10 + 1] - 8;
  while (v23)
  {
    if (v15 >= v23)
      v7 = v23;
    else
      v7 = v15;
    v11 = v24[*v24 + 2] - v7;
    _platform_memmove((char *)v10 + v11, v9, v7);
    v23 -= v7;
    v9 += v7;
    v19 = *v24 + 1;
    v24[v19++] = v11;
    *v24 = v19;
    v24[*v24 + 1] = v11 - 2 * (v19 + 3);
    v24[*v24 + 2] = v11;
    v24[v19] = 1;
    v26 = __add_ovflpage(a1, v26);
    if (!v26)
      return -1;
    v20 = *v24;
    if (!v23)
    {
      v16 = v24[*v24 + 1];
      if (!v16 || (v16 >= v18 ? (v6 = v18) : (v6 = v24[*v24 + 1]), v16 == v18 && v18 == a4[1]))
      {
        v24[v20 - 2] = 2;
      }
      else
      {
        v12 = v24[*v24 + 2] - v6;
        _platform_memmove((char *)v10 + v12, v8, v6);
        v8 += v6;
        v18 -= v6;
        v24[v20] = v12;
        v24[v20 - 2] = 3;
        v24[*v24 + 1] -= v6;
        v24[*v24 + 2] = v12;
      }
    }
    v24 = *(unsigned __int16 **)(v26 + 32);
    v10 = v24;
    *(_BYTE *)(v26 + 40) |= 1u;
    v15 = v24[*v24 + 1] - 8;
  }
  v17 = v24[*v24 + 1] - 8;
  while (v18)
  {
    if (v17 >= v18)
      v5 = v18;
    else
      v5 = v17;
    v14 = v5;
    if (v17 == v18 && v18 == a4[1])
      v14 = v5 - 1;
    v13 = v24[*v24 + 2] - v14;
    _platform_memmove((char *)v10 + v13, v8, v14);
    v18 -= v14;
    v8 += v14;
    v21 = *v24 + 1;
    v24[v21] = v13;
    v22 = v21 + 1;
    *v24 = v22;
    v24[*v24 + 1] = v13 - 2 * (v22 + 3);
    v24[*v24 + 2] = v13;
    if (v18)
    {
      v24[v22] = 2;
      v26 = __add_ovflpage(a1, v26);
      if (!v26)
        return -1;
      v10 = *(unsigned __int16 **)(v26 + 32);
      v24 = v10;
    }
    else
    {
      v24[v22] = 3;
    }
    *(_BYTE *)(v26 + 40) |= 1u;
    v17 = v24[*v24 + 1] - 8;
  }
  return 0;
}

uint64_t __big_delete(_DWORD *a1, unint64_t a2)
{
  BOOL v3;
  int v4;
  unsigned __int16 v5;
  int v6;
  unsigned __int16 v7;
  unsigned __int16 v8;
  unsigned __int16 *v9;
  unsigned __int16 *v10;
  unint64_t buf;
  uint64_t v12;

  buf = a2;
  v12 = 0;
  v9 = *(unsigned __int16 **)(a2 + 32);
  v6 = 0;
  while (1)
  {
    v3 = 1;
    if (v6)
      v3 = v9[2] != 3;
    if (!v3)
      break;
    if (v9[2] == 2 || v9[2] == 3)
      v6 = 1;
    if (v9[2] == 3 && v9[*v9 + 1])
      break;
    v7 = v9[*v9 - 1];
    *(_BYTE *)(buf + 40) |= 1u;
    buf = __get_buf((uint64_t)a1, v7, buf, 0);
    if (v12)
      __free_ovflpage(a1, v12);
    v12 = buf;
    if (!buf)
      return -1;
    v9 = *(unsigned __int16 **)(buf + 32);
  }
  v4 = *v9;
  v8 = v9[v4 - 1];
  v10 = *(unsigned __int16 **)(a2 + 32);
  if (v4 <= 2)
  {
    *(_QWORD *)(a2 + 16) = 0;
  }
  else
  {
    v10[1] = v8;
    v10[2] = 0;
    *(_QWORD *)(a2 + 16) = *(_QWORD *)(buf + 16);
  }
  v5 = v4 - 2;
  *v10 = v5;
  v10[*v10 + 1] = a1[3] - 2 * (v5 + 3);
  v10[*v10 + 2] = a1[3];
  *(_BYTE *)(a2 + 40) |= 1u;
  if (buf)
    __free_ovflpage(a1, buf);
  if (v12 && v12 != buf)
    __free_ovflpage(a1, v12);
  --a1[14];
  return 0;
}

uint64_t __find_bigpair(uint64_t a1, unint64_t a2, unsigned int a3, uint64_t a4, int a5)
{
  BOOL v6;
  unsigned __int16 i;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v13;
  unint64_t buf;

  buf = a2;
  v13 = a3;
  v11 = *(_QWORD *)(a2 + 32);
  v10 = v11;
  v9 = a5;
  for (i = *(_DWORD *)(a1 + 12) - *(_WORD *)(v11 + 2 * (int)a3); ; i = *(_DWORD *)(a1 + 12) - *(_WORD *)(v10 + 2))
  {
    v6 = 0;
    if (i <= a5)
      v6 = *(unsigned __int16 *)(v11 + 2 * (int)(v13 + 1)) == 1;
    if (!v6)
      break;
    if (_platform_memcmp(v10 + *(unsigned __int16 *)(v11 + 2 * (int)v13), a4, i))
      return -2;
    a4 += i;
    v9 -= i;
    buf = __get_buf(a1, *(unsigned __int16 *)(v11 + 2 * (int)(v13 + 2)), buf, 0);
    if (!buf)
      return -3;
    v10 = *(_QWORD *)(buf + 32);
    v11 = v10;
    v13 = 1;
  }
  if (i == v9 && !_platform_memcmp(v10 + *(unsigned __int16 *)(v11 + 2 * (int)v13), a4, i))
    return v13;
  else
    return -2;
}

uint64_t __find_last_page(uint64_t a1, unint64_t *a2)
{
  int v3;
  unsigned __int16 *i;
  unint64_t buf;

  buf = *a2;
  for (i = *(unsigned __int16 **)(*a2 + 32); ; i = *(unsigned __int16 **)(buf + 32))
  {
    v3 = *i;
    if (i[2] == 3 && (v3 == 2 || !i[*i] || i[*i + 1]))
      break;
    buf = __get_buf(a1, i[v3 - 1], buf, 0);
    if (!buf)
      return 0;
  }
  *a2 = buf;
  if (*i <= 2u)
    return 0;
  else
    return i[3];
}

uint64_t __big_return(uint64_t a1, unint64_t a2, int a3, _QWORD *a4, unsigned int a5)
{
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  unsigned __int16 *v10;
  unint64_t v11;
  unint64_t buf;
  unint64_t v16;

  buf = a2;
  v10 = *(unsigned __int16 **)(a2 + 32);
  while (v10[a3 + 1] == 1)
  {
    buf = __get_buf(a1, v10[*v10 - 1], buf, 0);
    if (!buf)
      return -1;
    v10 = *(unsigned __int16 **)(buf + 32);
    a3 = 1;
  }
  if (v10[a3 + 1] == 2)
  {
    v16 = __get_buf(a1, v10[*v10 - 1], buf, 0);
    if (!v16)
      return -1;
    v11 = v16;
    v6 = *(_DWORD *)(v16 + 24);
    v7 = *(_WORD *)(*(_QWORD *)(v16 + 32) + 2);
    v9 = 0;
  }
  else
  {
    if (v10[*v10 + 1])
    {
      v8 = v10[*v10];
      *a4 = (char *)v10 + v8;
      a4[1] = v10[1] - v8;
      if (a5)
      {
        if (*v10 == 2)
        {
          *(_QWORD *)(a1 + 304) = 0;
          ++*(_DWORD *)(a1 + 312);
          *(_DWORD *)(a1 + 316) = 1;
        }
        else
        {
          *(_QWORD *)(a1 + 304) = __get_buf(a1, v10[*v10 - 1], buf, 0);
          if (!*(_QWORD *)(a1 + 304))
            return -1;
          *(_DWORD *)(a1 + 316) = 1;
          if (!**(_WORD **)(*(_QWORD *)(a1 + 304) + 32))
          {
            ++*(_DWORD *)(a1 + 312);
            *(_QWORD *)(a1 + 304) = 0;
          }
        }
      }
      return 0;
    }
    v7 = v10[*v10];
    v9 = v10[1] - v7;
    v11 = buf;
    v6 = *(_DWORD *)(buf + 24);
    v16 = __get_buf(a1, v10[*v10 - 1], buf, 0);
    if (!v16)
      return -1;
  }
  a4[1] = (int)collect_data(a1, v16, v9, a5);
  if (a4[1] == -1)
  {
    return -1;
  }
  else if (*(_DWORD *)(v11 + 24) == v6)
  {
    _platform_memmove(*(_QWORD *)(a1 + 288), *(_QWORD *)(v11 + 32) + v7, v9);
    *a4 = *(_QWORD *)(a1 + 288);
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t collect_data(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v4;
  int v6;
  int v7;
  unsigned __int16 v8;
  unint64_t buf;
  unsigned __int16 *v10;

  v10 = *(unsigned __int16 **)(a2 + 32);
  v7 = *(_DWORD *)(a1 + 12) - v10[1];
  v8 = *(_DWORD *)(a2 + 24);
  if (v10[2] == 3)
  {
    v6 = a3 + v7;
    if (*(_QWORD *)(a1 + 288))
      free(*(void **)(a1 + 288));
    v4 = malloc_type_malloc(v6, 4292760454);
    *(_QWORD *)(a1 + 288) = v4;
    if (!v4)
      return -1;
    if (a4)
    {
      *(_DWORD *)(a1 + 316) = 1;
      if (*v10 == 2)
      {
        *(_QWORD *)(a1 + 304) = 0;
        ++*(_DWORD *)(a1 + 312);
      }
      else
      {
        *(_QWORD *)(a1 + 304) = __get_buf(a1, v10[*v10 - 1], a2, 0);
        if (!*(_QWORD *)(a1 + 304))
          return -1;
        if (!**(_WORD **)(*(_QWORD *)(a1 + 304) + 32))
        {
          ++*(_DWORD *)(a1 + 312);
          *(_QWORD *)(a1 + 304) = 0;
        }
      }
    }
  }
  else
  {
    buf = __get_buf(a1, v10[*v10 - 1], a2, 0);
    if (!buf)
      return -1;
    v6 = collect_data(a1, buf, (a3 + v7), a4);
    if (v6 < 1)
      return -1;
  }
  if (*(_DWORD *)(a2 + 24) == v8)
  {
    _platform_memmove(*(_QWORD *)(a1 + 288) + a3, *(_QWORD *)(a2 + 32) + v10[1], v7);
    return v6;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t __big_keydata(uint64_t a1, unint64_t a2, _QWORD *a3, _QWORD *a4, unsigned int a5)
{
  a3[1] = (int)collect_key(a1, a2, 0, a4, a5);
  if (a3[1] == -1)
  {
    return -1;
  }
  else
  {
    *a3 = *(_QWORD *)(a1 + 296);
    return 0;
  }
}

uint64_t collect_key(uint64_t a1, unint64_t a2, int a3, _QWORD *a4, unsigned int a5)
{
  uint64_t v5;
  unsigned __int16 v7;
  unsigned __int16 *v8;
  int v9;
  int v10;
  unint64_t buf;

  v8 = *(unsigned __int16 **)(a2 + 32);
  v10 = *(_DWORD *)(a1 + 12) - v8[1];
  v7 = *(_DWORD *)(a2 + 24);
  v9 = a3 + v10;
  if (v8[2] == 2 || v8[2] == 3)
  {
    if (*(_QWORD *)(a1 + 296))
      free(*(void **)(a1 + 296));
    v5 = malloc_type_malloc(v9, 1118084117);
    *(_QWORD *)(a1 + 296) = v5;
    if (!v5)
      return -1;
    if (__big_return(a1, a2, 1, a4, a5))
      return -1;
  }
  else
  {
    buf = __get_buf(a1, v8[*v8 - 1], a2, 0);
    if (!buf)
      return -1;
    v9 = collect_key(a1, buf, v9, a4, a5);
    if (v9 < 1)
      return -1;
  }
  if (*(_DWORD *)(a2 + 24) == v7)
  {
    _platform_memmove(*(_QWORD *)(a1 + 296) + a3, *(_QWORD *)(a2 + 32) + v8[1], v10);
    return v9;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t __big_split(_DWORD *a1, uint64_t a2, uint64_t a3, unint64_t a4, int a5, int a6, uint64_t a7)
{
  int v7;
  __int16 last_page;
  unint64_t buf;
  _WORD *v11;
  unsigned __int16 *v12;
  __int16 v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  unsigned __int16 v16;
  __int16 v17;
  unsigned __int16 v18;
  _BOOL4 v19;
  _QWORD v20[2];
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _DWORD *v31;

  v31 = a1;
  v30 = a2;
  v29 = a3;
  v28 = a4;
  v27 = a5;
  v26 = a6;
  v25 = a7;
  v23 = 0;
  v21 = 0;
  v22 = 0;
  v20[0] = 0;
  v20[1] = 0;
  v24 = a4;
  if (__big_keydata((uint64_t)a1, a4, &v21, v20, 0))
  {
    return -1;
  }
  else
  {
    v7 = __call_hash((uint64_t)v31, v21, v22);
    v19 = v7 != v26;
    last_page = __find_last_page((uint64_t)v31, (unint64_t *)&v28);
    *(_WORD *)(v25 + 24) = last_page;
    if (last_page)
    {
      buf = __get_buf((uint64_t)v31, *(unsigned __int16 *)(v25 + 24), v28, 0);
      *(_QWORD *)(v25 + 16) = buf;
      if (!buf)
        return -1;
    }
    else
    {
      *(_QWORD *)(v25 + 16) = 0;
    }
    if (v19)
      v23 = v29;
    else
      v23 = v30;
    *(_BYTE *)(v23 + 40) |= 1u;
    *(_QWORD *)(v23 + 16) = v24;
    v11 = *(_WORD **)(v23 + 32);
    v13 = v11[(unsigned __int16)*v11 + 2];
    v17 = v11[(unsigned __int16)*v11 + 1];
    v15 = *v11 + 1;
    v11[v15] = v27;
    v11[(unsigned __int16)(v15 + 1)] = 0;
    *v11 = v15 + 1;
    v11[(unsigned __int16)*v11 + 2] = v13;
    v11[(unsigned __int16)*v11 + 1] = v17 - 4;
    *(_QWORD *)v25 = v29;
    *(_QWORD *)(v25 + 8) = v30;
    v12 = *(unsigned __int16 **)(v28 + 32);
    *(_BYTE *)(v28 + 40) |= 1u;
    if (*v12 <= 2u)
    {
      v23 = v28;
    }
    else
    {
      v16 = v12[4];
      v18 = v12[*v12 + 1];
      v14 = v12[*v12 + 2];
      *v12 -= 2;
      v12[*v12 + 1] = v18 + 4;
      v12[*v12 + 2] = v14;
      v23 = __add_ovflpage(v31, v28);
      if (!v23)
        return -1;
      v12[4] = v16;
    }
    if (v19)
      *(_QWORD *)v25 = v23;
    else
      *(_QWORD *)(v25 + 8) = v23;
    return 0;
  }
}

unint64_t __get_buf(uint64_t a1, unsigned int a2, uint64_t a3, int a4)
{
  BOOL v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  unint64_t v10;

  v7 = 0;
  v6 = 0;
  v8 = 0;
  v9 = 0;
  if (a3)
  {
    v10 = *(_QWORD *)(a3 + 16);
    if (!v10 || *(_DWORD *)(v10 + 24) != a2)
      v10 = 0;
    if (!a4)
      v8 = 2;
  }
  else
  {
    v7 = a2 & (*(_DWORD *)(a1 + 24) - 1);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 648) + 8 * (a2 >> *(_DWORD *)(a1 + 28)));
    v10 = *(_QWORD *)(v6 + 8 * v7) & 0xFFFFFFFFFFFFFFFCLL;
    v9 = *(_QWORD *)(v6 + 8 * v7) & 2;
    v5 = 1;
    if (!v9)
      v5 = *(_DWORD *)(a1 + 324) == 0;
    v8 = v5;
  }
  if (v10)
  {
    *(_QWORD *)(*(_QWORD *)v10 + 8) = *(_QWORD *)(v10 + 8);
    **(_QWORD **)(v10 + 8) = *(_QWORD *)v10;
    *(_QWORD *)(v10 + 8) = *(_QWORD *)(a1 + 608);
    *(_QWORD *)v10 = a1 + 600;
    *(_QWORD *)(a1 + 608) = v10;
    **(_QWORD **)(v10 + 8) = v10;
    return v10;
  }
  v10 = (unint64_t)newbuf(a1, a2, a3);
  if (v10 && !__get_page((_DWORD *)a1, *(unsigned __int16 **)(v10 + 32), a2, a3 == 0, v8, 0))
  {
    if (!a3)
      *(_QWORD *)(v6 + 8 * v7) = v10 | v9;
    return v10;
  }
  return 0;
}

unsigned int *newbuf(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t i;
  _WORD *v6;
  _WORD *v7;
  unsigned __int16 v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int *v12;
  unsigned int *v13;

  v8 = 0;
  v13 = *(unsigned int **)(a1 + 600);
  if (v13 == *(unsigned int **)(a1 + 304))
  {
    *(_QWORD *)(*(_QWORD *)v13 + 8) = *((_QWORD *)v13 + 1);
    **((_QWORD **)v13 + 1) = *(_QWORD *)v13;
    *((_QWORD *)v13 + 1) = *(_QWORD *)(a1 + 608);
    *(_QWORD *)v13 = a1 + 600;
    *(_QWORD *)(a1 + 608) = v13;
    **((_QWORD **)v13 + 1) = v13;
    v13 = *(unsigned int **)(a1 + 600);
  }
  if (!*(_DWORD *)(a1 + 596) && a3 && *((_QWORD *)v13 + 2))
  {
    for (i = *((_QWORD *)v13 + 2); i; i = *(_QWORD *)(i + 16))
    {
      if (i == a3)
      {
        ++*(_DWORD *)(a1 + 596);
        break;
      }
    }
  }
  if (*(_DWORD *)(a1 + 596) || (v13[10] & 8) != 0 || v13 == *(unsigned int **)(a1 + 304))
  {
    v13 = (unsigned int *)malloc_type_calloc(1, 48, 0x1030040DD04DACBLL);
    if (!v13)
      return 0;
    v3 = malloc_type_calloc(1, *(int *)(a1 + 12), 2412348560);
    *((_QWORD *)v13 + 4) = v3;
    if (!v3)
    {
      free(v13);
      return 0;
    }
    if (*(_DWORD *)(a1 + 596))
      --*(_DWORD *)(a1 + 596);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)v13 + 8) = *((_QWORD *)v13 + 1);
    **((_QWORD **)v13 + 1) = *(_QWORD *)v13;
    if (v13[6] || (v13[10] & 4) != 0)
    {
      v6 = (_WORD *)*((_QWORD *)v13 + 4);
      if (*v6)
        v8 = v6[(unsigned __int16)*v6 - 1];
      if ((v13[10] & 1) != 0
        && __put_page((_DWORD *)a1, *((unsigned __int16 **)v13 + 4), v13[6], v13[10] & 4, 0))
      {
        return 0;
      }
      if ((v13[10] & 4) != 0)
      {
        v9 = v13[6] & (*(_DWORD *)(a1 + 24) - 1);
        v10 = *(_QWORD *)(*(_QWORD *)(a1 + 648) + 8 * (v13[6] >> *(_DWORD *)(a1 + 28)));
        if (*(_DWORD *)(a1 + 324) && ((v13[10] & 1) != 0 || (*(_DWORD *)(v10 + 8 * v9) & 2) != 0))
          *(_QWORD *)(v10 + 8 * v9) = 2;
        else
          *(_QWORD *)(v10 + 8 * v9) = 0;
      }
      v12 = v13;
      while (*((_QWORD *)v12 + 2))
      {
        v11 = *((_QWORD *)v12 + 2);
        *((_QWORD *)v12 + 2) = 0;
        v12 = (unsigned int *)v11;
        if ((*(_BYTE *)(v11 + 40) & 4) != 0 || v8 != *(_DWORD *)(v11 + 24))
          break;
        v7 = *(_WORD **)(v11 + 32);
        if (*v7)
          v8 = v7[(unsigned __int16)*v7 - 1];
        if ((*(_BYTE *)(v11 + 40) & 1) != 0
          && __put_page((_DWORD *)a1, *(unsigned __int16 **)(v11 + 32), *(_DWORD *)(v11 + 24), 0, 0))
        {
          return 0;
        }
        *(_DWORD *)(v11 + 24) = 0;
        *(_BYTE *)(v11 + 40) = 0;
        *(_QWORD *)(*(_QWORD *)v11 + 8) = *(_QWORD *)(v11 + 8);
        **(_QWORD **)(v11 + 8) = *(_QWORD *)v11;
        *(_QWORD *)(v11 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 600) + 8);
        *(_QWORD *)v11 = *(_QWORD *)(a1 + 600);
        *(_QWORD *)(*(_QWORD *)(a1 + 600) + 8) = v11;
        **(_QWORD **)(v11 + 8) = v11;
      }
    }
  }
  v13[6] = a2;
  *((_QWORD *)v13 + 2) = 0;
  if (a3)
  {
    *(_QWORD *)(a3 + 16) = v13;
    *((_BYTE *)v13 + 40) = 0;
  }
  else
  {
    *((_BYTE *)v13 + 40) = 4;
  }
  *((_QWORD *)v13 + 1) = *(_QWORD *)(a1 + 608);
  *(_QWORD *)v13 = a1 + 600;
  *(_QWORD *)(a1 + 608) = v13;
  **((_QWORD **)v13 + 1) = v13;
  return v13;
}

uint64_t __buf_init(uint64_t result, int a2)
{
  int v2;

  if ((a2 + *(_DWORD *)(result + 12) - 1) >> *(_DWORD *)(result + 16) <= 6)
    v2 = 6;
  else
    v2 = (a2 + *(_DWORD *)(result + 12) - 1) >> *(_DWORD *)(result + 16);
  *(_DWORD *)(result + 596) = v2;
  *(_QWORD *)(result + 608) = result + 600;
  *(_QWORD *)(result + 600) = result + 600;
  return result;
}

uint64_t __buf_free(uint64_t a1, int a2, int a3)
{
  void *v4;

  if (*(_QWORD *)(a1 + 600))
  {
    v4 = *(void **)(a1 + 600);
    while (v4 != (void *)(a1 + 600))
    {
      if ((*((_DWORD *)v4 + 6) || (*((_BYTE *)v4 + 40) & 4) != 0)
        && a3
        && (*((_BYTE *)v4 + 40) & 1) != 0
        && __put_page((_DWORD *)a1, *((unsigned __int16 **)v4 + 4), *((_DWORD *)v4 + 6), *((_BYTE *)v4 + 40) & 4, 0))
      {
        return -1;
      }
      if (a2)
      {
        if (*((_QWORD *)v4 + 4))
        {
          _platform_bzero(*((_QWORD *)v4 + 4), *(int *)(a1 + 12));
          free(*((void **)v4 + 4));
        }
        *(_QWORD *)(*(_QWORD *)v4 + 8) = *((_QWORD *)v4 + 1);
        **((_QWORD **)v4 + 1) = *(_QWORD *)v4;
        free(v4);
        v4 = *(void **)(a1 + 600);
      }
      else
      {
        v4 = *(void **)v4;
      }
    }
    return 0;
  }
  else
  {
    return 0;
  }
}

uint64_t __reclaim_buf(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(_BYTE *)(a2 + 40) = 0;
  *(_QWORD *)(*(_QWORD *)a2 + 8) = *(_QWORD *)(a2 + 8);
  **(_QWORD **)(a2 + 8) = *(_QWORD *)a2;
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(*(_QWORD *)(result + 600) + 8);
  *(_QWORD *)a2 = *(_QWORD *)(result + 600);
  *(_QWORD *)(*(_QWORD *)(result + 600) + 8) = a2;
  **(_QWORD **)(a2 + 8) = a2;
  return result;
}

uint64_t hash4(uint64_t a1, uint64_t a2)
{
  unint64_t v3;

  if (a2)
  {
    v3 = a2 & 7;
    if (v3 <= 7)
      __asm { BR              X8 }
  }
  return 0;
}

uint64_t __log2(unsigned int a1)
{
  unsigned int v2;
  unsigned int v3;

  v2 = 1;
  v3 = 0;
  while (v2 < a1)
  {
    v2 *= 2;
    ++v3;
  }
  return v3;
}

uint64_t __delpair(_DWORD *a1, unint64_t a2, int a3)
{
  int i;
  int v5;
  unsigned __int16 v6;
  __int16 v7;
  _WORD *v8;

  v8 = *(_WORD **)(a2 + 32);
  v5 = (unsigned __int16)*v8;
  if ((unsigned __int16)v8[a3 + 1] >= 4u)
  {
    if (a3 == 1)
      v7 = a1[3];
    else
      v7 = v8[a3 - 1];
    v6 = v7 - v8[a3 + 1];
    if (a3 != v5 - 1)
    {
      _platform_memmove(*(_QWORD *)(a2 + 32) + (unsigned __int16)v8[(unsigned __int16)*v8 + 2] + v6, *(_QWORD *)(a2 + 32) + (unsigned __int16)v8[(unsigned __int16)*v8 + 2], (unsigned __int16)v8[a3 + 1] - (unsigned __int16)v8[(unsigned __int16)*v8 + 2]);
      for (i = a3 + 2; i <= v5; i += 2)
      {
        if (v8[i + 1])
        {
          v8[i - 2] = v8[i] + v6;
          v8[i - 1] = v8[i + 1] + v6;
        }
        else
        {
          v8[i - 2] = v8[i];
          v8[i - 1] = v8[i + 1];
        }
      }
      if (a3 == a1[79])
        a1[79] -= 2;
    }
    v8[v5] = v8[(unsigned __int16)*v8 + 2] + v6;
    v8[v5 - 1] = v8[v5 + 1] + v6 + 4;
    *v8 = v5 - 2;
    --a1[14];
    *(_BYTE *)(a2 + 40) |= 1u;
    return 0;
  }
  else
  {
    return __big_delete(a1, a2);
  }
}

uint64_t __split_page(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3;
  int v4;
  int v5;
  _WORD *v7;
  unsigned __int16 v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  int v11;
  int v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 *v17;
  _WORD *v18;
  unint64_t buf;
  unint64_t v20;
  unsigned int v21;
  unsigned int v22;
  _DWORD *v23;

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = 0;
  buf = 0;
  v18 = 0;
  v17 = 0;
  v15 = 0;
  v16 = 0;
  v13 = 0;
  v14 = 0;
  v10 = a1[3];
  v9 = v10;
  buf = __get_buf((uint64_t)a1, a2, 0, 0);
  if (buf)
  {
    v20 = __get_buf((uint64_t)v23, v21, 0, 0);
    if (v20)
    {
      *(_BYTE *)(buf + 40) |= 9u;
      *(_BYTE *)(v20 + 40) |= 9u;
      v7 = *(_WORD **)(buf + 32);
      v18 = v7;
      v17 = *(unsigned __int16 **)(v20 + 32);
      v8 = 0;
      v12 = 1;
      v11 = 1;
      while (v12 < (unsigned __int16)*v18)
      {
        if ((unsigned __int16)v18[v12 + 1] < 4u)
        {
          v3 = ugly_split(v23, v22, buf, v20, v10, v8);
          *(_BYTE *)(buf + 40) &= ~8u;
          *(_BYTE *)(v20 + 40) &= ~8u;
          return v3;
        }
        v15 = (uint64_t)v7 + (unsigned __int16)v18[v12];
        v4 = v9 - (unsigned __int16)v18[v12];
        v16 = v4;
        v5 = __call_hash((uint64_t)v23, v15, v4);
        if (v5 == v22)
        {
          if (v10 == v9)
          {
            v10 = v18[v12 + 1];
          }
          else
          {
            v10 = v18[v12 + 1] + v10 - v9;
            _platform_memmove((char *)v7 + v10, (char *)v7 + (unsigned __int16)v18[v12 + 1], v9 - (unsigned __int16)v18[v12 + 1]);
            v18[v11] = v10 + v18[v12] - v18[v12 + 1];
            v18[v11 + 1] = v10;
          }
          v11 += 2;
        }
        else
        {
          v13 = (char *)v7 + (unsigned __int16)v18[v12 + 1];
          v14 = (unsigned __int16)v18[v12] - (unsigned __int16)v18[v12 + 1];
          putpair(v17, &v15, &v13);
          v8 += 2;
        }
        v9 = v18[v12 + 1];
        v12 += 2;
      }
      *v18 -= v8;
      v18[(unsigned __int16)*v18 + 1] = v10 - 2 * (*v18 + 3);
      v18[(unsigned __int16)*v18 + 2] = v10;
      *(_BYTE *)(buf + 40) &= ~8u;
      *(_BYTE *)(v20 + 40) &= ~8u;
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t ugly_split(_DWORD *a1, int a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v6;
  BOOL v8;
  unsigned __int16 v9;
  unsigned __int16 v10;
  unsigned __int16 v11;
  unsigned __int16 i;
  __int128 v13;
  __int128 v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int16 *v20;
  unsigned __int16 *v21;
  unsigned __int16 *v22;
  uint64_t buf;
  int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  _DWORD *v29;

  v29 = a1;
  v28 = a2;
  v27 = a3;
  v26 = a4;
  v25 = a5;
  v24 = a6;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  v17 = 0;
  v18 = 0;
  v15 = 0;
  v16 = 0;
  v13 = 0u;
  v14 = 0u;
  buf = a3;
  v22 = *(unsigned __int16 **)(a3 + 32);
  v21 = *(unsigned __int16 **)(a4 + 32);
  v20 = *(unsigned __int16 **)(a3 + 32);
  v19 = 0;
  v9 = a5;
  i = *v22 - 1;
  while (i < (int)*v22)
  {
    if (v22[2] < 4u && v22[2])
    {
      if (__big_split(v29, v27, v26, buf, *(_DWORD *)(buf + 24), v28, (uint64_t)&v13))
        return -1;
      v27 = *((_QWORD *)&v13 + 1);
      if (!*((_QWORD *)&v13 + 1))
        return -1;
      v20 = *(unsigned __int16 **)(v27 + 32);
      v26 = v13;
      if (!(_QWORD)v13)
        return -1;
      v21 = *(unsigned __int16 **)(v26 + 32);
      buf = v14;
      if (!(_QWORD)v14)
        return 0;
      v22 = *(unsigned __int16 **)(buf + 32);
      v19 = v14;
    }
    else if (!v22[i + 1])
    {
      v10 = v22[i];
      *v22 -= v24 + 2;
      v22[*v22 + 1] = v9 - 2 * (*v22 + 3);
      v22[*v22 + 2] = v9;
      buf = __get_buf((uint64_t)v29, v10, buf, 0);
      if (!buf)
        return -1;
      v22 = *(unsigned __int16 **)(buf + 32);
      v9 = v29[3];
      v24 = 0;
      if (v19)
        __free_ovflpage(v29, v19);
      v19 = buf;
    }
    v11 = v29[3];
    for (i = 1; ; i += 2)
    {
      v8 = 0;
      if (i < (int)*v22)
        v8 = v22[i + 1] >= 4u;
      if (!v8)
        break;
      v17 = (uint64_t)v22 + v22[i];
      v18 = v11 - v22[i];
      v15 = (char *)v22 + v22[i + 1];
      v16 = v22[i] - v22[i + 1];
      v11 = v22[i + 1];
      v6 = __call_hash((uint64_t)v29, v17, v18);
      if (v6 == v28)
      {
        if (v20[2] < 4u || v18 + 4 + v16 + 4 > (unint64_t)v20[*v20 + 1])
        {
          v27 = __add_ovflpage(v29, v27);
          if (!v27)
            return -1;
          v20 = *(unsigned __int16 **)(v27 + 32);
          putpair(v20, &v17, &v15);
        }
        else
        {
          putpair(v20, &v17, &v15);
        }
        *(_BYTE *)(v27 + 40) |= 1u;
      }
      else
      {
        if (v21[2] < 4u || v18 + 4 + v16 + 4 > (unint64_t)v21[*v21 + 1])
        {
          v26 = __add_ovflpage(v29, v26);
          if (!v26)
            return -1;
          v21 = *(unsigned __int16 **)(v26 + 32);
          putpair(v21, &v17, &v15);
        }
        else
        {
          putpair(v21, &v17, &v15);
        }
        *(_BYTE *)(v26 + 40) |= 1u;
      }
    }
  }
  if (v19)
    __free_ovflpage(v29, v19);
  return 0;
}

uint64_t putpair(unsigned __int16 *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t result;
  unsigned __int16 v5;
  unsigned __int16 v6;
  unsigned __int16 v7;

  v7 = *a1;
  v5 = a1[*a1 + 2] - a2[1];
  _platform_memmove((char *)a1 + v5, *a2, a2[1]);
  a1[++v7] = v5;
  v6 = v5 - a3[1];
  _platform_memmove((char *)a1 + v6, *a3, a3[1]);
  v3 = v7++ + 1;
  result = v3;
  a1[(unsigned __int16)v3] = v6;
  *a1 = v7;
  a1[v7 + 1] = v6 - 2 * (v7 + 3);
  a1[v7 + 2] = v6;
  return result;
}

uint64_t __addel(_DWORD *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  BOOL v5;
  BOOL v6;
  int v7;
  unsigned __int16 *v8;
  unsigned __int16 *v9;
  uint64_t buf;

  buf = a2;
  v9 = *(unsigned __int16 **)(a2 + 32);
  v7 = 0;
  while (1)
  {
    v6 = 0;
    if (*v9)
    {
      v5 = 1;
      if (v9[2] >= 4u)
        v5 = v9[*v9] < 4u;
      v6 = v5;
    }
    if (!v6 || v9[2] == 3 && *v9 == 2)
      break;
    if (v9[2] < 4u && v9[*v9])
    {
      buf = __get_buf((uint64_t)a1, v9[*v9 - 1], buf, 0);
      if (!buf)
        return -1;
      v9 = *(unsigned __int16 **)(buf + 32);
    }
    else
    {
      if (v9[*v9])
        break;
      if (v9[2] >= 4u && v9[*v9 + 1] >= (unint64_t)(a3[1] + 4 + a4[1]))
      {
        squeeze_key(v9, a3, a4);
        goto LABEL_31;
      }
      buf = __get_buf((uint64_t)a1, v9[*v9 - 1], buf, 0);
      if (!buf)
        return -1;
      v9 = *(unsigned __int16 **)(buf + 32);
    }
  }
  if (v9[2] < 4u || a3[1] + 4 + a4[1] + 4 > (unint64_t)v9[*v9 + 1])
  {
    v7 = 1;
    buf = __add_ovflpage(a1, buf);
    if (!buf)
      return -1;
    v8 = *(unsigned __int16 **)(buf + 32);
    if (v8[2] < 4u || a3[1] + 4 + a4[1] + 4 > (unint64_t)v8[*v8 + 1])
    {
      if (__big_insert(a1, buf, a3, a4))
        return -1;
    }
    else
    {
      putpair(v8, a3, a4);
    }
  }
  else
  {
    putpair(*(unsigned __int16 **)(buf + 32), a3, a4);
  }
LABEL_31:
  *(_BYTE *)(buf + 40) |= 1u;
  ++a1[14];
  if (v7 || a1[14] / (a1[10] + 1) > a1[13])
    return __expand_table((uint64_t)a1);
  else
    return 0;
}

uint64_t squeeze_key(unsigned __int16 *a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  unsigned __int16 v4;
  unsigned __int16 v5;
  unsigned __int16 v6;
  unsigned __int16 v7;
  unsigned __int16 v8;

  v7 = *a1;
  v8 = a1[*a1 + 1];
  v4 = a1[*a1 - 1];
  v5 = a1[*a1 + 2] - a2[1];
  a1[*a1 - 1] = v5;
  _platform_memmove((char *)a1 + v5, *a2, a2[1]);
  v6 = v5 - a3[1];
  a1[v7] = v6;
  result = _platform_memmove((char *)a1 + v6, *a3, a3[1]);
  *a1 = v7 + 2;
  a1[v7 + 1] = v4;
  a1[v7 + 2] = 0;
  a1[*a1 + 1] = v8 - (*((_WORD *)a2 + 4) + 4 + *((_WORD *)a3 + 4));
  a1[*a1 + 2] = v6;
  return result;
}

uint64_t __add_ovflpage(_DWORD *a1, uint64_t a2)
{
  unint64_t buf;
  unsigned __int16 v4;
  unsigned __int16 v5;
  unsigned __int16 *v6;

  v6 = *(unsigned __int16 **)(a2 + 32);
  if (a1[13] == 0x10000)
  {
    a1[13] = (int)*v6 >> 1;
    if (a1[13] < 4u)
      a1[13] = 4;
  }
  *(_BYTE *)(a2 + 40) |= 1u;
  v4 = overflow_page(a1);
  if (!v4)
    return 0;
  buf = __get_buf((uint64_t)a1, v4, a2, 1);
  *(_QWORD *)(a2 + 16) = buf;
  if (!buf)
    return 0;
  *(_BYTE *)(*(_QWORD *)(a2 + 16) + 40) |= 1u;
  v5 = *v6;
  v6[v5 + 4] = v6[*v6 + 2];
  v6[v5 + 3] = v6[*v6 + 1] - 4;
  v6[v5 + 1] = v4;
  v6[v5 + 2] = 0;
  *v6 = v5 + 2;
  return *(_QWORD *)(a2 + 16);
}

uint64_t overflow_page(_DWORD *a1)
{
  _DWORD *v1;
  _DWORD *v2;
  int free;
  _DWORD *v4;
  int v6;
  BOOL v7;
  signed int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int i;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  signed int v20;
  int v21;
  int v22;
  int v23;
  _BYTE v24[12];

  *(_DWORD *)&v24[8] = 0;
  v22 = a1[8];
  *(_QWORD *)v24 = a1[v22 + 17];
  v15 = (*(_DWORD *)v24 - 1) >> (a1[4] + 3);
  v17 = (*(_DWORD *)v24 - 1) & (8 * a1[3] - 1);
  v18 = (int)a1[9] >> (*((_BYTE *)a1 + 16) + 3);
  v13 = v18;
LABEL_2:
  if (v13 > v15)
  {
    a1[9] = a1[v22 + 17]++;
    v10 = a1[v22 + 17];
    if (v22)
      v9 = a1[v22 + 16];
    else
      v9 = 0;
    v23 = v10 - v9;
    if (v10 - v9 > 2047)
    {
      if (++v22 >= 32)
        goto LABEL_45;
      a1[8] = v22;
      a1[v22 + 17] = a1[v22 + 16];
      v1 = &a1[v22 + 16];
      --*v1;
      v23 = 1;
    }
    if (v17 == 8 * a1[3] - 1)
    {
      v16 = v15 + 1;
      if (v16 >= 32)
        goto LABEL_45;
      if (__ibitmap((uint64_t)a1, v23 + ((_WORD)v22 << 11), 1, v16))
        return 0;
      ++a1[v22 + 17];
      if (++v23 > 2047)
      {
        if (++v22 >= 32)
        {
LABEL_45:
          write_NOCANCEL(2, "HASH: Out of overflow pages.  Increase page size\n", 49);
          *__error() = 27;
          return 0;
        }
        a1[8] = v22;
        a1[v22 + 17] = a1[v22 + 16];
        v2 = &a1[v22 + 16];
        --*v2;
        LOWORD(v23) = 0;
      }
    }
    else
    {
      *(_DWORD *)(*(_QWORD *)&v24[4] + 4 * ((v17 + 1) / 32)) |= 1 << ((v17 + 1) % 32);
    }
    return (unsigned __int16)(v23 + ((_WORD)v22 << 11));
  }
  *(_QWORD *)&v24[4] = *(_QWORD *)&a1[2 * v13 + 84];
  if (*(_QWORD *)&v24[4] || (*(_QWORD *)&v24[4] = fetch_bitmap(a1, v13)) != 0)
  {
    if (v13 == v15)
      v12 = v17;
    else
      v12 = 8 * a1[3] - 1;
    if (v13 == v18)
    {
      v19 = a1[9] & (8 * a1[3] - 1);
      v11 = v19 / 32;
      v20 = v19 & 0xFFFFFFE0;
    }
    else
    {
      v20 = 0;
      v11 = 0;
    }
    while (1)
    {
      if (v20 > v12)
      {
        ++v13;
        goto LABEL_2;
      }
      if (*(_DWORD *)(*(_QWORD *)&v24[4] + 4 * v11) != -1)
        break;
      ++v11;
      v20 += 32;
    }
    v8 = v20;
    free = first_free(*(_DWORD *)(*(_QWORD *)&v24[4] + 4 * v11));
    v4 = (_DWORD *)(*(_QWORD *)&v24[4] + 4 * ((v20 + free) / 32));
    *v4 |= 1 << ((v20 + free) % 32);
    v21 = v20 + free + 1 + v13 * 8 * a1[3];
    if (v8 + free + 1 + v13 * 8 * a1[3] >= a1[9])
      a1[9] = v21 - 1;
    for (i = 0; ; ++i)
    {
      v7 = 0;
      if (i < v22)
        v7 = v21 > a1[i + 17];
      if (!v7)
        break;
    }
    if (i)
      v6 = v21 - a1[i + 16];
    else
      v6 = v21;
    if (v6 < 2047)
      return (unsigned __int16)(v6 + ((_WORD)i << 11));
    goto LABEL_45;
  }
  return 0;
}

uint64_t __get_page(_DWORD *a1, unsigned __int16 *a2, unsigned int a3, int a4, int a5, int a6)
{
  int v7;
  int v8;
  int v9;
  unsigned int v10;
  unsigned __int16 v11;
  unsigned __int16 v12;
  int v13;
  int v14;
  int v15;
  int i;
  int j;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  __int16 v23;

  v23 = a3;
  v21 = a1[71];
  v19 = a1[3];
  if (v21 != -1 && a5)
  {
    if (a4)
    {
      v10 = a3 + a1[15];
      if (a3)
        v9 = a1[__log2(a3 + 1) + 16];
      else
        v9 = 0;
      v20 = v10 + v9;
    }
    else
    {
      v8 = (1 << (a3 >> 11)) - 1 + a1[15];
      if (1 << (a3 >> 11) == 1)
        v7 = 0;
      else
        v7 = a1[__log2(1 << (a3 >> 11)) + 16];
      v20 = v8 + v7 + (v23 & 0x7FF);
    }
    v18 = pread_NOCANCEL(v21, a2, v19, (uint64_t)v20 << a1[4]);
    if (v18 == -1)
    {
      return -1;
    }
    else
    {
      if (v18)
      {
        if (v18 != v19)
        {
          *__error() = 79;
          return -1;
        }
      }
      else
      {
        *a2 = 0;
      }
      if (a6 || *a2)
      {
        if (a1[2] != 1234)
        {
          if (a6)
          {
            v14 = (int)a1[3] >> 2;
            for (i = 0; i < v14; ++i)
            {
              v13 = *(_DWORD *)&a2[2 * i];
              LOBYTE(a2[2 * i]) = HIBYTE(v13);
              HIBYTE(a2[2 * i]) = BYTE2(v13);
              LOBYTE(a2[2 * i + 1]) = BYTE1(v13);
              HIBYTE(a2[2 * i + 1]) = v13;
            }
          }
          else
          {
            v12 = *a2;
            *(_BYTE *)a2 = HIBYTE(*a2);
            *((_BYTE *)a2 + 1) = v12;
            v15 = *a2 + 2;
            for (j = 1; j <= v15; ++j)
            {
              v11 = a2[j];
              LOBYTE(a2[j]) = HIBYTE(v11);
              HIBYTE(a2[j]) = v11;
            }
          }
        }
      }
      else
      {
        *a2 = 0;
        a2[1] = a1[3] - 6;
        a2[2] = a1[3];
      }
      return 0;
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = a1[3] - 6;
    a2[2] = a1[3];
    return 0;
  }
}

uint64_t __put_page(_DWORD *a1, unsigned __int16 *a2, unsigned int a3, int a4, int a5)
{
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned __int16 v10;
  int v11;
  int k;
  int m;
  unsigned __int16 v14;
  int v15;
  int i;
  int j;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned int v22;

  v18 = 0;
  v20 = a1[3];
  if (a1[71] == -1 && open_temp((uint64_t)a1))
  {
    return -1;
  }
  else
  {
    v22 = a1[71];
    if (a1[2] != 1234)
    {
      if (a5)
      {
        v18 = (int)a1[3] >> 2;
        for (i = 0; i < v18; ++i)
        {
          v15 = *(_DWORD *)&a2[2 * i];
          LOBYTE(a2[2 * i]) = HIBYTE(v15);
          HIBYTE(a2[2 * i]) = BYTE2(v15);
          LOBYTE(a2[2 * i + 1]) = BYTE1(v15);
          HIBYTE(a2[2 * i + 1]) = v15;
        }
      }
      else
      {
        v18 = *a2 + 2;
        for (j = 0; j <= v18; ++j)
        {
          v14 = a2[j];
          LOBYTE(a2[j]) = HIBYTE(v14);
          HIBYTE(a2[j]) = v14;
        }
      }
    }
    if (a4)
    {
      v9 = a3 + a1[15];
      if (a3)
        v8 = a1[__log2(a3 + 1) + 16];
      else
        v8 = 0;
      v21 = v9 + v8;
    }
    else
    {
      v7 = (1 << (a3 >> 11)) - 1 + a1[15];
      if (1 << (a3 >> 11) == 1)
        v6 = 0;
      else
        v6 = a1[__log2(1 << (a3 >> 11)) + 16];
      v21 = v7 + v6 + (a3 & 0x7FF);
    }
    v19 = pwrite_NOCANCEL(v22, a2, v20, (uint64_t)v21 << a1[4]);
    if (v19 == -1)
    {
      return -1;
    }
    else if (v19 == v20)
    {
      if (a1[2] != 1234)
      {
        if (a5)
        {
          for (k = 0; k < v18; ++k)
          {
            v11 = *(_DWORD *)&a2[2 * k];
            LOBYTE(a2[2 * k]) = HIBYTE(v11);
            HIBYTE(a2[2 * k]) = BYTE2(v11);
            LOBYTE(a2[2 * k + 1]) = BYTE1(v11);
            HIBYTE(a2[2 * k + 1]) = v11;
          }
        }
        else
        {
          for (m = 0; m <= v18; ++m)
          {
            v10 = a2[m];
            LOBYTE(a2[m]) = HIBYTE(v10);
            HIBYTE(a2[m]) = v10;
          }
        }
      }
      return 0;
    }
    else
    {
      *__error() = 79;
      return -1;
    }
  }
}

uint64_t open_temp(uint64_t a1)
{
  int v1;
  int v2;
  char *v5;
  sigset_t v6;
  sigset_t v7;
  uint64_t v8;
  char __str[1024];

  v8 = a1;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  if (!issetugid())
    v5 = getenv("TMPDIR");
  if (v5)
    v1 = snprintf(__str, 0x400uLL, "%s/_hash.XXXXXX", v5);
  else
    v1 = snprintf(__str, 0x400uLL, "%s/_hash.XXXXXX", "/tmp");
  if (v1 >= 0 && (unint64_t)v1 < 0x400)
  {
    v7 = -1;
    sigprocmask(1, &v7, &v6);
    v2 = mkstemp(__str);
    *(_DWORD *)(v8 + 284) = v2;
    if (v2 != -1)
    {
      unlink(__str);
      fcntl_NOCANCEL(*(unsigned int *)(v8 + 284), 2);
    }
    sigprocmask(3, &v6, 0);
    if (*(_DWORD *)(v8 + 284) == -1)
      return -1;
    else
      return 0;
  }
  else
  {
    *__error() = 63;
    return -1;
  }
}

uint64_t __ibitmap(uint64_t a1, __int16 a2, int a3, int a4)
{
  int v5;
  _DWORD *v6;

  v6 = (_DWORD *)malloc_type_malloc(*(int *)(a1 + 12), 2696649989);
  if (v6)
  {
    ++*(_DWORD *)(a1 + 592);
    v5 = ((a3 - 1) >> 5) + 1;
    _platform_bzero(v6, 4 * v5);
    _platform_memset(&v6[v5], 0xFFFFFFFFLL, *(_DWORD *)(a1 + 12) - 4 * v5);
    v6[v5 - 1] = -1 << (a3 & 0x1F);
    *v6 |= 1u;
    *(_WORD *)(a1 + 196 + 2 * a4) = a2;
    *(_QWORD *)(a1 + 336 + 8 * a4) = v6;
    return 0;
  }
  else
  {
    return 1;
  }
}

uint64_t __free_ovflpage(_DWORD *a1, uint64_t a2)
{
  int v3;
  unsigned __int16 v4;
  int v5;
  int v6;
  int v7;
  uint64_t bitmap;

  v4 = (int)(unsigned __int16)*(_DWORD *)(a2 + 24) >> 11;
  if (v4)
    v3 = a1[v4 + 16];
  else
    v3 = 0;
  v7 = v3 + (*(_DWORD *)(a2 + 24) & 0x7FF) - 1;
  if (v7 < a1[9])
    a1[9] = v7;
  v6 = v7 >> (a1[4] + 3);
  v5 = v7 & (8 * a1[3] - 1);
  bitmap = *(_QWORD *)&a1[2 * v6 + 84];
  if (!bitmap)
    bitmap = fetch_bitmap(a1, v6);
  *(_DWORD *)(bitmap + 4 * (v5 / 32)) &= ~(1 << (v5 % 32));
  return __reclaim_buf((uint64_t)a1, a2);
}

uint64_t fetch_bitmap(_DWORD *a1, int a2)
{
  uint64_t v2;

  if (a2 >= a1[148])
    return 0;
  v2 = malloc_type_malloc((int)a1[3], 757184937);
  *(_QWORD *)&a1[2 * a2 + 84] = v2;
  if (!v2)
    return 0;
  if (!__get_page(a1, *(unsigned __int16 **)&a1[2 * a2 + 84], *((unsigned __int16 *)a1 + a2 + 98), 0, 1, 1))return *(_QWORD *)&a1[2 * a2 + 84];
  free(*(void **)&a1[2 * a2 + 84]);
  return 0;
}

uint64_t first_free(int a1)
{
  int v2;
  unsigned int i;

  v2 = 1;
  for (i = 0; i < 0x20; ++i)
  {
    if ((v2 & a1) == 0)
      return i;
    v2 *= 2;
  }
  return i;
}

DBM *__cdecl dbm_open(const char *a1, int a2, mode_t a3)
{
  _QWORD v4[2];
  __int128 v5;
  mode_t v6;
  unsigned int v7;
  const char *v8;
  char v10[1024];

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v4[0] = 0x2800001000;
  v4[1] = 1;
  v5 = 0uLL;
  if ((unint64_t)_platform_strlen(a1) < 0x3FD)
  {
    _platform_strcpy(v10, v8);
    strcat(v10, ".db");
    return (DBM *)__hash_open(v10, v7, v6, (uint64_t)v4, 0);
  }
  else
  {
    *__error() = 63;
    return 0;
  }
}

void dbm_close(DBM *a1)
{
  (*(void (**)(DBM *))&a1->__opaque[8])(a1);
}

datum dbm_fetch(DBM *a1, datum a2)
{
  void *v2;
  size_t v3;
  void *v4;
  size_t v5;
  datum v6;
  int v7;
  DBM *v8;
  datum v9;
  uint64_t v10;
  uint64_t v11;
  datum result;

  v9 = a2;
  v8 = a1;
  v10 = 0;
  v11 = 0;
  v7 = 0;
  v4 = 0;
  v5 = 0;
  v6 = a2;
  v7 = (*(uint64_t (**)(DBM *, datum *, void **, _QWORD))&a1->__opaque[24])(a1, &v6, &v4, 0);
  if (v7)
  {
    v4 = 0;
    v5 = 0;
  }
  v2 = v4;
  v3 = v5;
  result.dsize = v3;
  result.dptr = v2;
  return result;
}

datum dbm_firstkey(DBM *a1)
{
  void *v1;
  size_t v2;
  uint64_t v3;
  _QWORD v4[2];
  void *v5;
  size_t v6;
  int v7;
  DBM *v8;
  uint64_t v9;
  uint64_t v10;
  datum result;

  v8 = a1;
  v7 = 0;
  v9 = 0;
  v10 = 0;
  v5 = 0;
  v6 = 0;
  v4[0] = 0;
  v4[1] = 0;
  v3 = *(_QWORD *)&a1->__opaque[56];
  v7 = (*(uint64_t (**)(DBM *, void **, _QWORD *, uint64_t))&a1->__opaque[40])(a1, &v5, v4, 3);
  if (v7)
  {
    v5 = 0;
    *(_BYTE *)(v3 + 656) = *(_BYTE *)(v3 + 656) & 0xFE | 1;
  }
  else
  {
    *(_BYTE *)(v3 + 656) &= ~1u;
  }
  v1 = v5;
  v2 = v6;
  result.dsize = v2;
  result.dptr = v1;
  return result;
}

datum dbm_nextkey(DBM *a1)
{
  void *v1;
  size_t v2;
  uint64_t v3;
  _QWORD v4[2];
  void *v5;
  size_t v6;
  int v7;
  DBM *v8;
  uint64_t v9;
  uint64_t v10;
  datum result;

  v8 = a1;
  v7 = 1;
  v9 = 0;
  v10 = 0;
  v5 = 0;
  v6 = 0;
  v4[0] = 0;
  v4[1] = 0;
  v3 = *(_QWORD *)&a1->__opaque[56];
  if ((*(_BYTE *)(v3 + 656) & 1) != 0)
  {
    v5 = 0;
  }
  else
  {
    v7 = (*(uint64_t (**)(DBM *, void **, _QWORD *, uint64_t))&v8->__opaque[40])(v8, &v5, v4, 7);
    if (v7)
    {
      v5 = 0;
      *(_BYTE *)(v3 + 656) = *(_BYTE *)(v3 + 656) & 0xFE | 1;
    }
  }
  v1 = v5;
  v2 = v6;
  result.dsize = v2;
  result.dptr = v1;
  return result;
}

int dbm_delete(DBM *a1, datum a2)
{
  datum v3;
  int v4;
  DBM *v5;
  datum v6;

  v6 = a2;
  v5 = a1;
  v4 = 0;
  v3 = a2;
  v4 = (*(uint64_t (**)(DBM *, datum *, _QWORD))&a1->__opaque[16])(a1, &v3, 0);
  if (v4)
    return -1;
  else
    return 0;
}

int dbm_store(DBM *a1, datum a2, datum a3, int a4)
{
  uint64_t v4;
  datum v6;
  datum v7;
  int v8;
  DBM *v9;
  datum v10;
  datum v11;

  v11 = a2;
  v10 = a3;
  v9 = a1;
  v8 = a4;
  v7 = a2;
  v6 = a3;
  if (a4)
    v4 = 0;
  else
    v4 = 8;
  return (*(uint64_t (**)(DBM *, datum *, datum *, uint64_t))&a1->__opaque[32])(a1, &v7, &v6, v4);
}

int dbm_error(DBM *a1)
{
  return *(_DWORD *)(*(_QWORD *)&a1->__opaque[56] + 320);
}

int dbm_clearerr(DBM *a1)
{
  uint64_t v1;
  int result;

  v1 = *(_QWORD *)&a1->__opaque[56];
  result = 0;
  *(_DWORD *)(v1 + 320) = 0;
  return result;
}

int dbm_dirfno(DBM *a1)
{
  return *(_DWORD *)(*(_QWORD *)&a1->__opaque[56] + 284);
}

MPOOL *__cdecl mpool_open(void *a1, int a2, pgno_t a3, pgno_t a4)
{
  int i;
  MPOOL *v6;
  stat v7;
  pgno_t v8;
  pgno_t v9;
  int v10;
  void *v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v8 = a4;
  _platform_memset(&v7, 0, 144);
  if (fstat(v10, &v7))
    return 0;
  if ((v7.st_mode & 0xF000) == 0x8000)
  {
    v6 = (MPOOL *)malloc_type_calloc(1, 2120, 0x10A004011CD96E6);
    if (v6)
    {
      v6->lqh.tqh_first = 0;
      v6->lqh.tqh_last = &v6->lqh.tqh_first;
      for (i = 0; i < 128; ++i)
      {
        v6->hqh[i].tqh_first = 0;
        v6->hqh[i].tqh_last = &v6->hqh[i].tqh_first;
      }
      v6->maxcache = v8;
      v6->npages = v7.st_size / v9;
      v6->pagesize = v9;
      v6->fd = v10;
      return v6;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 29;
    return 0;
  }
}

void mpool_filter(MPOOL *a1, void (__cdecl *a2)(void *, pgno_t, void *), void (__cdecl *a3)(void *, pgno_t, void *), void *a4)
{
  a1->pgin = a2;
  a1->pgout = a3;
  a1->pgcookie = a4;
}

void *__cdecl mpool_new(MPOOL *a1, pgno_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  pgno_t npages;
  _bkt *tqh_first;
  _bkt *v12;
  MPOOL::_hqh *v13;

  if (a1->npages == -1)
  {
    fprintf(__stderrp, "mpool_new: page allocation overflow.\n");
    abort_report_np((uint64_t)"%s:%s:%u: page allocation overflow", v2, v3, v4, v5, v6, v7, v8, (uint64_t)"mpool.c");
  }
  v12 = (_bkt *)mpool_bkt((uint64_t)a1);
  if (!v12)
    return 0;
  npages = a1->npages;
  a1->npages = npages + 1;
  v12->pgno = npages;
  *a2 = npages;
  v12->flags = 2;
  v13 = &a1->hqh[(v12->pgno - 1) % 0x80];
  tqh_first = v13->tqh_first;
  v12->hq.tqe_next = v13->tqh_first;
  if (tqh_first)
    v13->tqh_first->hq.tqe_prev = &v12->hq.tqe_next;
  else
    v13->tqh_last = &v12->hq.tqe_next;
  v13->tqh_first = v12;
  v12->hq.tqe_prev = &v13->tqh_first;
  v12->q.tqe_next = 0;
  v12->q.tqe_prev = a1->lqh.tqh_last;
  *a1->lqh.tqh_last = v12;
  a1->lqh.tqh_last = &v12->q.tqe_next;
  return v12->page;
}

uint64_t mpool_bkt(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  if (*(_DWORD *)(a1 + 2064) >= *(_DWORD *)(a1 + 2068))
  {
    for (i = *(_QWORD *)a1; i; i = *(_QWORD *)(i + 16))
    {
      if ((*(_BYTE *)(i + 44) & 2) == 0)
      {
        if ((*(_BYTE *)(i + 44) & 1) != 0 && mpool_write(a1, i) == -1)
          return 0;
        if (*(_QWORD *)i)
          *(_QWORD *)(*(_QWORD *)i + 8) = *(_QWORD *)(i + 8);
        else
          *(_QWORD *)(a1 + 16 + 16 * ((*(_DWORD *)(i + 40) - 1) % 0x80u) + 8) = *(_QWORD *)(i + 8);
        **(_QWORD **)(i + 8) = *(_QWORD *)i;
        if (*(_QWORD *)(i + 16))
          *(_QWORD *)(*(_QWORD *)(i + 16) + 24) = *(_QWORD *)(i + 24);
        else
          *(_QWORD *)(a1 + 8) = *(_QWORD *)(i + 24);
        **(_QWORD **)(i + 24) = *(_QWORD *)(i + 16);
        return i;
      }
    }
  }
  v3 = malloc_type_calloc(1, *(_QWORD *)(a1 + 2080) + 48, 1331392585);
  if (!v3)
    return 0;
  *(_QWORD *)(v3 + 32) = v3 + 48;
  ++*(_DWORD *)(a1 + 2064);
  return v3;
}

void *__cdecl mpool_get(MPOOL *a1, pgno_t a2, unsigned int a3)
{
  _bkt *tqh_first;
  _bkt *v4;
  int v6;
  _bkt *v7;
  _bkt *v8;
  MPOOL::_hqh *v9;
  MPOOL::_hqh *v10;

  if (a2 < a1->npages)
  {
    v7 = (_bkt *)mpool_look((uint64_t)a1, a2);
    if (v7)
    {
      v9 = &a1->hqh[(v7->pgno - 1) % 0x80];
      if (v7->hq.tqe_next)
        v7->hq.tqe_next->hq.tqe_prev = v7->hq.tqe_prev;
      else
        v9->tqh_last = v7->hq.tqe_prev;
      *v7->hq.tqe_prev = v7->hq.tqe_next;
      tqh_first = v9->tqh_first;
      v7->hq.tqe_next = v9->tqh_first;
      if (tqh_first)
        v9->tqh_first->hq.tqe_prev = &v7->hq.tqe_next;
      else
        v9->tqh_last = &v7->hq.tqe_next;
      v9->tqh_first = v7;
      v7->hq.tqe_prev = &v9->tqh_first;
      if (v7->q.tqe_next)
        v7->q.tqe_next->q.tqe_prev = v7->q.tqe_prev;
      else
        a1->lqh.tqh_last = v7->q.tqe_prev;
      *v7->q.tqe_prev = v7->q.tqe_next;
      v7->q.tqe_next = 0;
      v7->q.tqe_prev = a1->lqh.tqh_last;
      *a1->lqh.tqh_last = v7;
      a1->lqh.tqh_last = &v7->q.tqe_next;
      v7->flags |= 2u;
      return v7->page;
    }
    else
    {
      v8 = (_bkt *)mpool_bkt((uint64_t)a1);
      if (v8)
      {
        v6 = pread_NOCANCEL(a1->fd, v8->page, a1->pagesize, a1->pagesize * a2);
        if (v6 == a1->pagesize)
        {
          v8->pgno = a2;
          v8->flags = 2;
          v10 = &a1->hqh[(v8->pgno - 1) % 0x80];
          v4 = v10->tqh_first;
          v8->hq.tqe_next = v10->tqh_first;
          if (v4)
            v10->tqh_first->hq.tqe_prev = &v8->hq.tqe_next;
          else
            v10->tqh_last = &v8->hq.tqe_next;
          v10->tqh_first = v8;
          v8->hq.tqe_prev = &v10->tqh_first;
          v8->q.tqe_next = 0;
          v8->q.tqe_prev = a1->lqh.tqh_last;
          *a1->lqh.tqh_last = v8;
          a1->lqh.tqh_last = &v8->q.tqe_next;
          if (a1->pgin)
            ((void (*)(void *, _QWORD, void *))a1->pgin)(a1->pgcookie, v8->pgno, v8->page);
          return v8->page;
        }
        else
        {
          if (v6 >= 0)
            *__error() = 79;
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

uint64_t *mpool_look(uint64_t a1, int a2)
{
  uint64_t *i;

  for (i = *(uint64_t **)(a1 + 16 + 16 * ((a2 - 1) % 0x80u)); i; i = (uint64_t *)*i)
  {
    if (*((_DWORD *)i + 10) == a2)
      return i;
  }
  return 0;
}

int mpool_put(MPOOL *a1, void *a2, unsigned int a3)
{
  *((char *)a2 - 4) &= ~2u;
  *((char *)a2 - 4) |= a3 & 1;
  return 0;
}

int mpool_close(MPOOL *a1)
{
  _bkt *tqh_first;

  while (a1->lqh.tqh_first)
  {
    tqh_first = a1->lqh.tqh_first;
    if (a1->lqh.tqh_first->q.tqe_next)
      tqh_first->q.tqe_next->q.tqe_prev = tqh_first->q.tqe_prev;
    else
      a1->lqh.tqh_last = tqh_first->q.tqe_prev;
    *tqh_first->q.tqe_prev = tqh_first->q.tqe_next;
    free(tqh_first);
  }
  free(a1);
  return 0;
}

int mpool_sync(MPOOL *a1)
{
  _bkt *i;

  for (i = a1->lqh.tqh_first; i; i = i->q.tqe_next)
  {
    if ((i->flags & 1) != 0)
    {
      if (mpool_write((uint64_t)a1, (uint64_t)i) == -1)
        return -1;
      if (a1->pgin)
        ((void (*)(void *, _QWORD, void *))a1->pgin)(a1->pgcookie, i->pgno, i->page);
    }
  }
  if (fsync_NOCANCEL(a1->fd))
    return -1;
  else
    return 0;
}

uint64_t mpool_write(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a1 + 2104))
    (*(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 2104))(*(_QWORD *)(a1 + 2112), *(unsigned int *)(a2 + 40), *(_QWORD *)(a2 + 32));
  if (pwrite_NOCANCEL(*(unsigned int *)(a1 + 2088), *(_QWORD *)(a2 + 32), *(_QWORD *)(a1 + 2080), *(_QWORD *)(a1 + 2080) * *(unsigned int *)(a2 + 40)) == *(_QWORD *)(a1 + 2080))
  {
    *(_BYTE *)(a2 + 44) &= ~1u;
    return 0;
  }
  else
  {
    return -1;
  }
}

uint64_t __rec_close(_QWORD *a1)
{
  unsigned int v2;
  uint64_t v3;

  v3 = a1[7];
  if (*(_QWORD *)(v3 + 32))
  {
    mpool_put(*(MPOOL **)v3, *(void **)(v3 + 32), 0);
    *(_QWORD *)(v3 + 32) = 0;
  }
  if (__rec_sync((uint64_t)a1, 0) == -1)
  {
    return -1;
  }
  else
  {
    v2 = 0;
    if ((*(_DWORD *)(v3 + 636) & 0x400) != 0 && munmap(*(void **)(v3 + 592), *(_QWORD *)(v3 + 608)))
      v2 = -1;
    if ((*(_DWORD *)(v3 + 636) & 0x800) == 0)
    {
      if ((*(_DWORD *)(v3 + 636) & 0x40) != 0)
      {
        if (fclose(*(FILE **)(v3 + 568)))
          v2 = -1;
      }
      else if (close_NOCANCEL(*(unsigned int *)(v3 + 576)))
      {
        v2 = -1;
      }
    }
    if (__bt_close(a1) == -1)
      return -1;
    return v2;
  }
}

uint64_t __rec_sync(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  int i;
  int v6;
  int v7;
  off_t v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  _QWORD v17[4];

  v15 = a1;
  v14 = a2;
  v13 = 0;
  v11 = 0;
  v12 = 0;
  v9 = 0;
  v10 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v13 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v13 + 32))
  {
    mpool_put(*(MPOOL **)v13, *(void **)(v13 + 32), 0);
    *(_QWORD *)(v13 + 32) = 0;
  }
  if (v14 == 11)
  {
    return __bt_sync(v15, 0);
  }
  else if ((*(_DWORD *)(v13 + 636) & 0x2800) == 0 && (*(_DWORD *)(v13 + 636) & 0x1000) != 0)
  {
    if ((*(_DWORD *)(v13 + 636) & 0x100) != 0
      || (*(unsigned int (**)(uint64_t, uint64_t))(v13 + 560))(v13, 0xFFFFFFFFLL) != -1)
    {
      if (lseek(*(_DWORD *)(v13 + 576), 0, 0))
      {
        return -1;
      }
      else
      {
        v7 = *(_DWORD *)(v13 + 64);
        v10 = 4;
        v9 = &v6;
        if ((*(_DWORD *)(v13 + 636) & 0x200) != 0)
        {
          for (i = (*(uint64_t (**)(uint64_t, int **, uint64_t *, uint64_t))(v15 + 40))(v15, &v9, &v11, 3);
                !i;
                i = (*(uint64_t (**)(uint64_t, int **, uint64_t *, uint64_t))(v15 + 40))(v15, &v9, &v11, 7))
          {
            v2 = write_NOCANCEL(*(unsigned int *)(v13 + 576), v11, v12);
            if (v2 != v12)
              return -1;
          }
        }
        else
        {
          v17[2] = v13 + 632;
          v17[3] = 1;
          for (i = (*(uint64_t (**)(uint64_t, int **, uint64_t *, uint64_t))(v15 + 40))(v15, &v9, &v11, 3);
                !i;
                i = (*(uint64_t (**)(uint64_t, int **, uint64_t *, uint64_t))(v15 + 40))(v15, &v9, &v11, 7))
          {
            v17[0] = v11;
            v17[1] = v12;
            v3 = writev_NOCANCEL(*(unsigned int *)(v13 + 576), v17, 2);
            if (v3 != v12 + 1)
              return -1;
          }
        }
        *(_DWORD *)(v13 + 64) = v7;
        if (i == -1)
        {
          return -1;
        }
        else
        {
          v8 = lseek(*(_DWORD *)(v13 + 576), 0, 1);
          if (v8 == -1)
          {
            return -1;
          }
          else if (ftruncate(*(_DWORD *)(v13 + 576), v8))
          {
            return -1;
          }
          else
          {
            *(_DWORD *)(v13 + 636) &= ~0x1000u;
            return 0;
          }
        }
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __rec_delete(uint64_t a1, unsigned int **a2, int a3)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;

  v6 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v6 + 32))
  {
    mpool_put(*(MPOOL **)v6, *(void **)(v6 + 32), 0);
    *(_QWORD *)(v6 + 32) = 0;
  }
  if (a3)
  {
    if (a3 == 1 && (*(_BYTE *)(v6 + 68) & 8) != 0)
    {
      if (!*(_DWORD *)(v6 + 616))
        return 1;
      v4 = rec_rdelete((MPOOL **)v6, *(_DWORD *)(v6 + 64) - 1);
      if (!v4)
        --*(_DWORD *)(v6 + 64);
      goto LABEL_17;
    }
LABEL_16:
    *__error() = 22;
    return -1;
  }
  v5 = **a2;
  if (!v5)
    goto LABEL_16;
  if (v5 > *(_DWORD *)(v6 + 616))
    return 1;
  v4 = rec_rdelete((MPOOL **)v6, v5 - 1);
LABEL_17:
  if (!v4)
    *(_DWORD *)(v6 + 636) |= 0x1004u;
  return v4;
}

uint64_t rec_rdelete(MPOOL **a1, unsigned int a2)
{
  unsigned int v3;
  unsigned __int16 *v4;
  uint64_t v5;

  v5 = __rec_search((uint64_t)a1, a2, 0);
  if (v5)
  {
    v4 = *(unsigned __int16 **)v5;
    v3 = __rec_dleaf((uint64_t)a1, *(unsigned __int16 **)v5, *(unsigned __int16 *)(v5 + 8));
    if (v3)
    {
      mpool_put(*a1, v4, 0);
      return v3;
    }
    else
    {
      mpool_put(*a1, v4, 1u);
      return 0;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __rec_dleaf(uint64_t a1, unsigned __int16 *a2, unsigned int a3)
{
  unsigned __int16 v5;
  unsigned int v6;
  unsigned __int16 v7;
  __int16 v8;
  __int16 v9;
  unsigned __int16 *v10;
  char *v11;

  v11 = (char *)a2 + a2[a3 + 10];
  if ((v11[4] & 1) != 0 && __ovfl_delete(a1, (pgno_t *)(v11 + 5)) == -1)
  {
    return -1;
  }
  else
  {
    v6 = (*(_DWORD *)v11 + 8) & 0xFFFFFFFC;
    _platform_memmove((char *)a2 + a2[9] + v6, (char *)a2 + a2[9], v11 - ((char *)a2 + a2[9]));
    a2[9] += v6;
    v7 = a2[a3 + 10];
    v10 = a2 + 10;
    v8 = 2 * a3 / 2;
    while (v8--)
    {
      if (*v10 < (int)v7)
        *v10 += v6;
      ++v10;
    }
    v9 = &a2[((unint64_t)a2[8] - 20) / 2 + 10] - v10;
    while (--v9)
    {
      if (v10[1] >= (int)v7)
        v5 = v10[1];
      else
        v5 = v10[1] + v6;
      *v10++ = v5;
    }
    a2[8] -= 2;
    --*(_DWORD *)(a1 + 616);
    return 0;
  }
}

uint64_t __rec_get(uint64_t a1, unsigned int **a2, _QWORD *a3, int a4)
{
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  void **v8;
  uint64_t v9;

  v9 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v9 + 32))
  {
    mpool_put(*(MPOOL **)v9, *(void **)(v9 + 32), 0);
    *(_QWORD *)(v9 + 32) = 0;
  }
  if (!a4 && (v7 = **a2) != 0)
  {
    if (v7 > *(_DWORD *)(v9 + 616))
    {
      if ((*(_DWORD *)(v9 + 636) & 0x900) != 0)
        return 1;
      v5 = (*(uint64_t (**)(uint64_t, _QWORD))(v9 + 560))(v9, v7);
      if (v5)
        return v5;
    }
    v8 = (void **)__rec_search(v9, v7 - 1, 2);
    if (v8)
    {
      v6 = __rec_ret(v9, (uint64_t)v8, 0, 0, a3);
      if ((*(_DWORD *)(v9 + 636) & 0x4000) != 0)
        mpool_put(*(MPOOL **)v9, *v8, 0);
      else
        *(_QWORD *)(v9 + 32) = *v8;
      return v6;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t __rec_fpipe(uint64_t a1, unsigned int a2)
{
  _BYTE *v2;
  _BYTE *i;
  int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v8 = 0;
  v9 = 0;
  if (*(_QWORD *)(a1 + 504) < *(_QWORD *)(a1 + 624))
  {
    *(_QWORD *)(v11 + 496) = reallocf(*(void **)(v11 + 496), *(_QWORD *)(v11 + 624));
    if (!*(_QWORD *)(v11 + 496))
      return -1;
    *(_QWORD *)(v11 + 504) = *(_QWORD *)(v11 + 624);
  }
  v8 = *(_QWORD *)(v11 + 496);
  v9 = *(_QWORD *)(v11 + 624);
  v7 = *(_DWORD *)(v11 + 616);
  do
  {
    if (v7 >= v10)
      break;
    v6 = *(_QWORD *)(v11 + 624);
    for (i = *(_BYTE **)(v11 + 496); ; ++i)
    {
      v5 = getc(*(FILE **)(v11 + 568));
      if (v5 == -1)
        break;
      if (!--v6)
        break;
      v2 = i;
      *v2 = v5;
    }
    if (v5 != -1)
      *i = v5;
    if (v6)
      _platform_memset(i, *(unsigned __int8 *)(v11 + 632), v6);
    if (__rec_iput(v11, v7, &v8, 0))
      return -1;
    ++v7;
  }
  while (v5 != -1);
  if (v7 >= v10)
  {
    return 0;
  }
  else
  {
    *(_DWORD *)(v11 + 636) |= 0x100u;
    return 1;
  }
}

uint64_t __rec_vpipe(uint64_t a1, unsigned int a2)
{
  void *v2;
  _BYTE *v3;
  _BYTE *v5;
  int v6;
  int v7;
  uint64_t j;
  _BYTE *v9;
  unsigned int i;
  uint64_t v11;
  _BYTE *v12;
  unsigned int v13;
  uint64_t v14;

  v14 = a1;
  v13 = a2;
  v11 = 0;
  v12 = 0;
  v7 = *(unsigned __int8 *)(a1 + 632);
  for (i = *(_DWORD *)(a1 + 616); i < v13; ++i)
  {
    v5 = *(_BYTE **)(v14 + 496);
    for (j = *(_QWORD *)(v14 + 504); ; --j)
    {
      v6 = getc(*(FILE **)(v14 + 568));
      if (v6 == -1 || v6 == v7)
        break;
      if (!j)
      {
        v9 = &v5[-*(_QWORD *)(v14 + 496)];
        j = 256;
        *(_QWORD *)(v14 + 504) += 256;
        v2 = reallocf(*(void **)(v14 + 496), *(_QWORD *)(v14 + 504));
        *(_QWORD *)(v14 + 496) = v2;
        if (!*(_QWORD *)(v14 + 496))
          return -1;
        v5 = &v9[*(_QWORD *)(v14 + 496)];
      }
      v3 = v5++;
      *v3 = v6;
    }
    v11 = *(_QWORD *)(v14 + 496);
    v12 = &v5[-*(_QWORD *)(v14 + 496)];
    if ((v6 != -1 || v12) && __rec_iput(v14, i, &v11, 0))
      return -1;
    if (v6 == -1)
      break;
  }
  if (i >= v13)
  {
    return 0;
  }
  else
  {
    *(_DWORD *)(v14 + 636) |= 0x100u;
    return 1;
  }
}

uint64_t __rec_fmap(uint64_t a1, unsigned int a2)
{
  _BYTE *v2;
  _BYTE *v3;
  BOOL v5;
  uint64_t v6;
  _BYTE *j;
  unint64_t v8;
  _BYTE *v9;
  unsigned int i;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;

  v14 = a1;
  v13 = a2;
  v11 = 0;
  v12 = 0;
  if (*(_QWORD *)(a1 + 504) < *(_QWORD *)(a1 + 624))
  {
    *(_QWORD *)(v14 + 496) = reallocf(*(void **)(v14 + 496), *(_QWORD *)(v14 + 624));
    if (!*(_QWORD *)(v14 + 496))
      return -1;
    *(_QWORD *)(v14 + 504) = *(_QWORD *)(v14 + 624);
  }
  v11 = *(_QWORD *)(v14 + 496);
  v12 = *(_QWORD *)(v14 + 624);
  v9 = *(_BYTE **)(v14 + 584);
  v8 = *(_QWORD *)(v14 + 600);
  for (i = *(_DWORD *)(v14 + 616); i < v13; ++i)
  {
    if ((unint64_t)v9 >= v8)
    {
      *(_DWORD *)(v14 + 636) |= 0x100u;
      return 1;
    }
    v6 = *(_QWORD *)(v14 + 624);
    for (j = *(_BYTE **)(v14 + 496); ; ++j)
    {
      v5 = 0;
      if ((unint64_t)v9 < v8)
        v5 = v6 != 0;
      if (!v5)
        break;
      v2 = v9++;
      v3 = j;
      *v3 = *v2;
      --v6;
    }
    if (v6)
      _platform_memset(j, *(unsigned __int8 *)(v14 + 632), v6);
    if (__rec_iput(v14, i, &v11, 0))
      return -1;
  }
  *(_QWORD *)(v14 + 584) = v9;
  return 0;
}

uint64_t __rec_vmap(uint64_t a1, unsigned int a2)
{
  BOOL v3;
  int v4;
  unsigned int i;
  unint64_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned int v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v8 = 0;
  v9 = 0;
  v7 = *(unsigned __int8 **)(a1 + 584);
  v6 = *(_QWORD *)(a1 + 600);
  v4 = *(unsigned __int8 *)(a1 + 632);
  for (i = *(_DWORD *)(a1 + 616); i < v10; ++i)
  {
    if ((unint64_t)v7 >= v6)
    {
      *(_DWORD *)(v11 + 636) |= 0x100u;
      return 1;
    }
    v8 = v7;
    while (1)
    {
      v3 = 0;
      if ((unint64_t)v7 < v6)
        v3 = *v7 != v4;
      if (!v3)
        break;
      ++v7;
    }
    v9 = (unsigned __int8 *)(v7 - v8);
    if (__rec_iput(v11, i, &v8, 0))
      return -1;
    ++v7;
  }
  *(_QWORD *)(v11 + 584) = v7;
  return 0;
}

_QWORD *__rec_open(uint64_t a1, unsigned int a2, int a3, uint64_t a4, int a5)
{
  uint64_t *v5;
  uint64_t (*v6)(uint64_t, unsigned int);
  int v8;
  int v9;
  stat v10;
  _DWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  uint64_t v26;

  v26 = a1;
  v25 = a2;
  v24 = a3;
  v23 = a4;
  v22 = a5;
  v21 = 0;
  _platform_memset(&v13, 0, 48);
  v12 = 0;
  v11 = 0;
  _platform_memset(&v10, 0, 144);
  v9 = 0;
  if (v26)
  {
    v9 = open_NOCANCEL(v26, v25);
    if (v9 < 0)
      return 0;
  }
  v12 = 0;
  if (v23)
  {
    if ((*(_QWORD *)v23 & 0xFFFFFFFFFFFFFFF8) != 0)
      goto LABEL_44;
    v13 = 0;
    v14 = *(_DWORD *)(v23 + 8);
    v15 = 0;
    v16 = 0;
    v17 = *(_DWORD *)(v23 + 12);
    v18 = 0;
    v19 = 0;
    v20 = *(_DWORD *)(v23 + 16);
    v12 = (_QWORD *)__bt_open(*(_QWORD *)(v23 + 40), 2u, 384, (uint64_t)&v13, v22);
  }
  else
  {
    v12 = (_QWORD *)__bt_open(0, 2u, 384, 0, v22);
  }
  if (!v12)
    goto LABEL_45;
  v21 = v12[7];
  if (v23)
  {
    if ((*(_QWORD *)v23 & 1) != 0)
    {
      *(_DWORD *)(v21 + 636) |= 0x200u;
      *(_QWORD *)(v21 + 624) = *(_QWORD *)(v23 + 24);
      if (!*(_QWORD *)(v21 + 624))
        goto LABEL_44;
    }
    *(_BYTE *)(v21 + 632) = *(_BYTE *)(v23 + 32);
  }
  else
  {
    *(_BYTE *)(v21 + 632) = 10;
  }
  *(_DWORD *)(v21 + 636) |= 0x80u;
  if (v26)
    *(_DWORD *)(v21 + 576) = v9;
  else
    *(_DWORD *)(v21 + 636) |= 0x900u;
  if (!v26)
    goto LABEL_35;
  *__error() = 0;
  if (lseek(v9, 0, 1) != -1 || *__error() != 29)
  {
    if ((v25 & 3) != 0)
    {
      if ((v25 & 3) != 2)
        goto LABEL_44;
    }
    else
    {
      *(_DWORD *)(v21 + 636) |= 0x2000u;
    }
    if (fstat(v9, &v10))
      goto LABEL_45;
    if (!v10.st_size)
    {
      *(_DWORD *)(v21 + 636) |= 0x100u;
      goto LABEL_35;
    }
    goto LABEL_23;
  }
  if ((v25 & 3) != 0)
  {
LABEL_44:
    *__error() = 22;
    goto LABEL_45;
  }
  *(_DWORD *)(v21 + 636) |= 0x2000u;
LABEL_23:
  v5 = fdopen_DARWIN_EXTSN(v9, "r");
  *(_QWORD *)(v21 + 568) = v5;
  if (v5)
  {
    *(_DWORD *)(v21 + 636) |= 0x40u;
    v6 = __rec_fpipe;
    if ((*(_DWORD *)(v21 + 636) & 0x200) == 0)
      v6 = __rec_vpipe;
    *(_QWORD *)(v21 + 560) = v6;
LABEL_35:
    v12[1] = __rec_close;
    v12[2] = __rec_delete;
    v12[8] = __rec_fd;
    v12[3] = __rec_get;
    v12[4] = __rec_put;
    v12[5] = __rec_seq;
    v12[6] = __rec_sync;
    v11 = mpool_get(*(MPOOL **)v21, 1u, 0);
    if (v11)
    {
      if ((v11[3] & 0x1F) == 2)
      {
        v11[3] &= 0xFFFFFFE0;
        v11[3] |= 0x10u;
        mpool_put(*(MPOOL **)v21, v11, 1u);
      }
      else
      {
        mpool_put(*(MPOOL **)v21, v11, 0);
      }
      if (!v23
        || (*(_QWORD *)v23 & 4) == 0
        || (*(_DWORD *)(v21 + 636) & 0x900) != 0
        || (*(unsigned int (**)(uint64_t, uint64_t))(v21 + 560))(v21, 0xFFFFFFFFLL) != -1)
      {
        return v12;
      }
    }
  }
LABEL_45:
  v8 = *__error();
  if (v12)
    __bt_close(v12);
  if (v26)
    close_NOCANCEL(v9);
  *__error() = v8;
  return 0;
}

uint64_t __rec_fd(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v2 + 32))
  {
    mpool_put(*(MPOOL **)v2, *(void **)(v2 + 32), 0);
    *(_QWORD *)(v2 + 32) = 0;
  }
  if ((*(_DWORD *)(v2 + 636) & 0x800) != 0)
  {
    *__error() = 2;
    return -1;
  }
  else
  {
    return *(unsigned int *)(v2 + 576);
  }
}

uint64_t __rec_put(uint64_t a1, uint64_t a2, _QWORD *a3, unsigned int a4)
{
  uint64_t v5;

  v5 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v5 + 32))
  {
    mpool_put(*(MPOOL **)v5, *(void **)(v5 + 32), 0);
    *(_QWORD *)(v5 + 32) = 0;
  }
  if ((*(_DWORD *)(v5 + 636) & 0x200) == 0 || a3[1] == *(_QWORD *)(v5 + 624))
    goto LABEL_10;
  if (a3[1] > *(_QWORD *)(v5 + 624))
  {
LABEL_12:
    *__error() = 22;
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)(v5 + 504) >= *(_QWORD *)(v5 + 624))
  {
LABEL_9:
    _platform_memmove(*(_QWORD *)(v5 + 496), *a3, a3[1]);
    _platform_memset(*(_QWORD *)(v5 + 496) + a3[1], *(unsigned __int8 *)(v5 + 632), *(_QWORD *)(v5 + 624) - a3[1]);
LABEL_10:
    if (a4 <= 0xAuLL)
      __asm { BR              X8 }
    goto LABEL_12;
  }
  *(_QWORD *)(v5 + 496) = reallocf(*(void **)(v5 + 496), *(_QWORD *)(v5 + 624));
  if (*(_QWORD *)(v5 + 496))
  {
    *(_QWORD *)(v5 + 504) = *(_QWORD *)(v5 + 624);
    goto LABEL_9;
  }
  return 0xFFFFFFFFLL;
}

uint64_t __rec_iput(uint64_t a1, unsigned int a2, _QWORD *a3, int a4)
{
  int v4;
  unint64_t v5;
  __int16 v6;
  BOOL v8;
  char *v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  int v13;
  unsigned __int16 v14;
  unsigned __int16 v15;
  void *v16;
  uint64_t v17;
  _DWORD *v18;
  uint64_t v19;
  int v20;
  _QWORD *v21;
  unsigned int v22;
  MPOOL **v23;
  _DWORD v25[2];

  v23 = (MPOOL **)a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v18 = 0;
  v19 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  if (a3[1] <= (unint64_t)*(unsigned __int16 *)(a1 + 524))
  {
    v11 = 0;
  }
  else
  {
    if (__ovfl_put(v23, v21, &v13) == -1)
      return -1;
    v18 = v25;
    v19 = 8;
    v25[0] = v13;
    v25[1] = v21[1];
    v11 = 1;
    v21 = &v18;
  }
  v8 = 1;
  if (v22 <= *((_DWORD *)v23 + 154))
  {
    v8 = 1;
    if (v20 != 4)
      v8 = v20 == 5;
  }
  if (v8)
    v4 = 1;
  else
    v4 = 2;
  v17 = __rec_search((uint64_t)v23, v22, v4);
  if (v17)
  {
    v16 = *(void **)v17;
    v15 = *(_WORD *)(v17 + 8);
    if (v20 == 4)
    {
      ++v15;
    }
    else if (v20 != 5
           && v22 < *((_DWORD *)v23 + 154)
           && __rec_dleaf((uint64_t)v23, (unsigned __int16 *)v16, v15) == -1)
    {
      mpool_put(*v23, v16, 0);
      return -1;
    }
    v12 = (v21[1] + 8) & 0xFFFFFFFC;
    if (*((unsigned __int16 *)v16 + 9) - *((unsigned __int16 *)v16 + 8) >= (unint64_t)v12 + 2)
    {
      v5 = ((unint64_t)*((unsigned __int16 *)v16 + 8) - 20) / 2;
      v14 = v5;
      if (v15 < (int)(unsigned __int16)v5)
        _platform_memmove((char *)v16 + 2 * v15 + 22, (char *)v16 + 2 * v15 + 20, 2 * (v14 - v15));
      *((_WORD *)v16 + 8) += 2;
      v6 = *((_WORD *)v16 + 9) - v12;
      *((_WORD *)v16 + 9) = v6;
      *((_WORD *)v16 + v15 + 10) = v6;
      v9 = (char *)v16 + *((unsigned __int16 *)v16 + 9);
      *(_DWORD *)v9 = v21[1];
      v9[4] = v11;
      _platform_memmove(v9 + 5, *v21, v21[1]);
      ++*((_DWORD *)v23 + 154);
      *((_DWORD *)v23 + 159) |= 4u;
      mpool_put(*v23, v16, 1u);
      return 0;
    }
    else
    {
      v10 = __bt_split((uint64_t)v23, v16, 0, v21, v11, v12, v15);
      if (!v10)
        ++*((_DWORD *)v23 + 154);
      return v10;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t __rec_search(uint64_t a1, unsigned int a2, int a3)
{
  _DWORD *v3;
  _DWORD *v4;
  uint64_t v5;
  char *v6;
  uint64_t v8;
  int v9;
  int v10;
  pgno_t v11;
  _DWORD *v12;
  _DWORD *v13;
  char *v14;
  unsigned __int16 v15;

  *(_QWORD *)(a1 + 472) = a1 + 72;
  v11 = 1;
  v10 = 0;
  while (1)
  {
    v13 = mpool_get(*(MPOOL **)a1, v11, 0);
    if (!v13)
      break;
    if ((v13[3] & 0x10) != 0)
    {
      *(_QWORD *)(a1 + 16) = v13;
      *(_WORD *)(a1 + 24) = a2 - v10;
      return a1 + 16;
    }
    v15 = 0;
    while (1)
    {
      v12 = (_DWORD *)((char *)v13 + *((unsigned __int16 *)v13 + v15 + 10));
      if ((unsigned __int16)(((unint64_t)*((unsigned __int16 *)v13 + 8) - 20) / 2) == ++v15 || v10 + *v12 > a2)
        break;
      v10 += *v12;
    }
    **(_DWORD **)(a1 + 472) = v11;
    *(_WORD *)(*(_QWORD *)(a1 + 472) + 4) = v15 - 1;
    *(_QWORD *)(a1 + 472) += 8;
    v11 = v12[1];
    if (a3)
    {
      if (a3 == 1)
      {
        v4 = (_DWORD *)((char *)v13 + *((unsigned __int16 *)v13 + v15 + 9));
        ++*v4;
        mpool_put(*(MPOOL **)a1, v13, 1u);
      }
      else if (a3 == 2)
      {
        mpool_put(*(MPOOL **)a1, v13, 0);
      }
    }
    else
    {
      v3 = (_DWORD *)((char *)v13 + *((unsigned __int16 *)v13 + v15 + 9));
      --*v3;
      mpool_put(*(MPOOL **)a1, v13, 1u);
    }
  }
  v9 = *__error();
  if (a3 != 2)
  {
    while (1)
    {
      if (*(_QWORD *)(a1 + 472) == a1 + 72)
      {
        v8 = 0;
      }
      else
      {
        v5 = *(_QWORD *)(a1 + 472) - 8;
        *(_QWORD *)(a1 + 472) = v5;
        v8 = v5;
      }
      if (!v8)
        break;
      v14 = (char *)mpool_get(*(MPOOL **)a1, *(_DWORD *)v8, 0);
      if (!v14)
        break;
      v6 = &v14[*(unsigned __int16 *)&v14[2 * *(unsigned __int16 *)(v8 + 4) + 20]];
      if (a3 == 1)
        --*(_DWORD *)v6;
      else
        ++*(_DWORD *)v6;
      mpool_put(*(MPOOL **)a1, v14, 1u);
    }
  }
  *__error() = v9;
  return 0;
}

uint64_t __rec_seq(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unint64_t v5;
  uint64_t v6;

  v6 = *(_QWORD *)(a1 + 56);
  if (*(_QWORD *)(v6 + 32))
  {
    mpool_put(*(MPOOL **)v6, *(void **)(v6 + 32), 0);
    *(_QWORD *)(v6 + 32) = 0;
  }
  v5 = (a4 - 1);
  if (v5 <= 8)
    __asm { BR              X8 }
  *__error() = 22;
  return 0xFFFFFFFFLL;
}

uint64_t __rec_ret(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, _QWORD *a5)
{
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;

  if (a4)
  {
    if (*(_QWORD *)(a1 + 488) < 4uLL)
    {
      v6 = malloc_type_realloc(*(_QWORD *)(a1 + 480), 4, 0x100004052888210);
      if (!v6)
        return -1;
      *(_QWORD *)(a1 + 480) = v6;
      *(_QWORD *)(a1 + 488) = 4;
    }
    **(_DWORD **)(a1 + 480) = a3;
    a4[1] = 4;
    *a4 = *(_QWORD *)(a1 + 480);
  }
  if (a5)
  {
    v8 = (unsigned int *)(*(_QWORD *)a2
                        + *(unsigned __int16 *)(*(_QWORD *)a2 + 20 + 2 * *(unsigned __int16 *)(a2 + 8)));
    if ((v8[1] & 1) != 0)
    {
      if (__ovfl_get(a1, (unsigned int *)((char *)v8 + 5), a5 + 1, (void **)(a1 + 496), (_QWORD *)(a1 + 504)))return -1;
      *a5 = *(_QWORD *)(a1 + 496);
    }
    else if ((*(_DWORD *)(a1 + 636) & 0x4000) != 0)
    {
      if ((unint64_t)(*v8 + 1) > *(_QWORD *)(a1 + 504))
      {
        v7 = malloc_type_realloc(*(_QWORD *)(a1 + 496), *v8 + 1, 2924667949);
        if (!v7)
          return -1;
        *(_QWORD *)(a1 + 496) = v7;
        *(_QWORD *)(a1 + 504) = *v8 + 1;
      }
      _platform_memmove(*(_QWORD *)(a1 + 496), (char *)v8 + 5, *v8);
      a5[1] = *v8;
      *a5 = *(_QWORD *)(a1 + 496);
    }
    else
    {
      a5[1] = *v8;
      *a5 = (char *)v8 + 5;
    }
    return 0;
  }
  return 0;
}

int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
{
  _BYTE *v3;
  _BYTE *v4;
  unsigned __int8 v6;

  v6 = 0;
  while (__len)
  {
    v3 = __b1;
    __b1 = (char *)__b1 + 1;
    v4 = __b2;
    __b2 = (char *)__b2 + 1;
    v6 |= *v3 ^ *v4;
    --__len;
  }
  return (v6 + 255) >> 8;
}

void __hdtoa(double a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;

  *a5 = *(_QWORD *)&a1 >> 63;
  v12 = (__fpclassifyd(a1) - 1);
  if (v12 <= 4)
    __asm { BR              X8 }
  abort_report_np((uint64_t)"%s:%s:%u: fpclassify returned %d", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"_hdtoa.c");
}

_BYTE *dorounding(_BYTE *result, int a2, int a3, _DWORD *a4)
{
  int v4;

  v4 = 0;
  switch(((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0)) + 0x400000) >> 22) & 3)
  {
    case 1u:
      if ((char)result[a2] > 8 || result[a2] == 8 && (result[a2 + 1] & 1) != 0)
      {
        result = (_BYTE *)roundup(result, a2);
        v4 = (int)result;
      }
      break;
    case 2u:
      if (!a3)
      {
        result = (_BYTE *)roundup(result, a2);
        v4 = (int)result;
      }
      break;
    case 3u:
      if (a3)
      {
        result = (_BYTE *)roundup(result, a2);
        v4 = (int)result;
      }
      break;
    default:
      break;
  }
  if (v4)
    *a4 += 4;
  return result;
}

void __hldtoa(uint64_t a1, unsigned int a2, uint64_t a3, _DWORD *a4, double a5)
{
  __hdtoa(a5, a1, a2, a3, a4);
}

uint64_t roundup(_BYTE *a1, int a2)
{
  _BYTE *i;

  for (i = &a1[a2 - 1]; *i == 15; --i)
  {
    if (i == a1)
    {
      *i = 1;
      return 1;
    }
    *i = 0;
  }
  ++*i;
  return 0;
}

_DWORD *__rv_alloc_D2A(int a1)
{
  _DWORD *v1;
  int v3;
  int v4;

  v4 = 4;
  v3 = 0;
  while (v4 + 24 <= (unint64_t)a1)
  {
    ++v3;
    v4 *= 2;
  }
  v1 = (_DWORD *)__Balloc_D2A(v3);
  *v1 = v3;
  return v1 + 1;
}

_DWORD *__nrv_alloc_D2A(char *a1, _QWORD *a2, int a3)
{
  char *v3;
  _BYTE *i;
  _DWORD *v6;

  v6 = __rv_alloc_D2A(a3);
  for (i = v6; ; ++i)
  {
    v3 = a1++;
    LODWORD(v3) = *v3;
    *i = (_BYTE)v3;
    if (!(_DWORD)v3)
      break;
  }
  if (a2)
    *a2 = i;
  return v6;
}

void __freedtoa(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 - 4);
  *(_DWORD *)(a1 + 4) = v1;
  *(_DWORD *)(a1 + 8) = 1 << v1;
  __Bfree_D2A((int *)(a1 - 4));
}

uint64_t __quorem_D2A(uint64_t a1, uint64_t a2)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int *v5;
  BOOL v7;
  BOOL v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  _DWORD *v21;
  _DWORD *v22;
  unsigned int *v23;
  unsigned int *v24;
  int v25;
  int v26;

  v25 = *(_DWORD *)(a2 + 20);
  if (*(_DWORD *)(a1 + 20) > v25)
  {
    fprintf(__stderrp, "%s\n", "oversize b in quorem");
    exit(1);
  }
  if (*(_DWORD *)(a1 + 20) >= v25)
  {
    v18 = (unsigned int *)(a2 + 24);
    v26 = v25 - 1;
    v17 = (unsigned int *)(a2 + 24 + 4 * v26);
    v23 = (unsigned int *)(a1 + 24);
    v21 = (_DWORD *)(a1 + 24 + 4 * v26);
    v20 = *v21 / (*v17 + 1);
    if (v20 > 9)
    {
      fprintf(__stderrp, "%s\n", "oversized quotient in quorem");
      exit(1);
    }
    if (v20)
    {
      v15 = 0;
      v13 = 0;
      do
      {
        v2 = v18++;
        v9 = *v2 * (unint64_t)v20 + v13;
        v13 = HIDWORD(v9);
        v11 = *v23 - (unint64_t)v9 - v15;
        v15 = HIDWORD(v11) & 1;
        v3 = v23++;
        *v3 = v11;
      }
      while (v18 <= v17);
      if (!*v21)
      {
        while (1)
        {
          --v21;
          v8 = 0;
          if ((unint64_t)v21 > a1 + 24)
            v8 = *v21 == 0;
          if (!v8)
            break;
          --v26;
        }
        *(_DWORD *)(a1 + 20) = v26;
      }
    }
    if ((int)__cmp_D2A(a1, a2) >= 0)
    {
      ++v20;
      v16 = 0;
      v14 = 0;
      v24 = (unsigned int *)(a1 + 24);
      v19 = (unsigned int *)(a2 + 24);
      do
      {
        v4 = v19++;
        v10 = *v4 + v14;
        v14 = HIDWORD(v10);
        v12 = *v24 - (unint64_t)v10 - v16;
        v16 = HIDWORD(v12) & 1;
        v5 = v24++;
        *v5 = v12;
      }
      while (v19 <= v17);
      v22 = (_DWORD *)(a1 + 24 + 4 * v26);
      if (!*v22)
      {
        while (1)
        {
          --v22;
          v7 = 0;
          if ((unint64_t)v22 > a1 + 24)
            v7 = *v22 == 0;
          if (!v7)
            break;
          --v26;
        }
        *(_DWORD *)(a1 + 20) = v26;
      }
    }
    return v20;
  }
  else
  {
    return 0;
  }
}

_DWORD *__dtoa(int a1, int a2, _DWORD *a3, _DWORD *a4, _QWORD *a5, double a6)
{
  unint64_t v6;
  double v7;
  _DWORD *v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  _BYTE *v14;
  int v15;
  _BYTE *v16;
  _BYTE *v17;
  _BYTE *v18;
  _BYTE *v19;
  _BYTE *v20;
  int v21;
  _BYTE *v22;
  _BYTE *v23;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  signed int v30;
  _BYTE *v31;
  _BYTE *v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  double v45;
  double v46;
  int *v47;
  int *v48;
  int *v49;
  int *v50;
  int *v51;
  uint64_t v52;
  int *v53;
  int v54;
  int v55;
  int v56;
  int v57;
  _BOOL4 v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v70;
  int v71;
  int m;
  int v73;
  int v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  char v80;
  int v81;
  int v82;
  int n;
  int k;
  int v85;
  int v86;
  int v87;
  int i;
  int j;
  int v90;
  int v91;
  int v92;
  int v93;
  int v94;
  _QWORD *v95;
  _DWORD *v96;
  _DWORD *v97;
  int v98;
  int v99;
  double v100;

  v100 = a6;
  v99 = a1;
  v98 = a2;
  v97 = a3;
  v96 = a4;
  v95 = a5;
  v94 = 0;
  v93 = 0;
  v92 = 0;
  v91 = 0;
  v50 = 0;
  v30 = ((_ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0)) + 0x400000) >> 22) & 3;
  v41 = a6;
  if ((HIBYTE(a6) & 0x80) != 0)
  {
    *v96 = 1;
    HIDWORD(v41) = HIDWORD(a6) & 0x7FFFFFFF;
  }
  else
  {
    *v96 = 0;
  }
  if ((~HIDWORD(v41) & 0x7FF00000) == 0)
  {
    *v97 = 9999;
    if (LODWORD(a6) || (HIDWORD(v41) & 0xFFFFF) != 0)
      return __nrv_alloc_D2A("NaN", v95, 3);
    else
      return __nrv_alloc_D2A("Infinity", v95, 8);
  }
  if (v41 == 0.0)
  {
    *v97 = 1;
    return __nrv_alloc_D2A("0", v95, 1);
  }
  if (v30 >= 2)
  {
    if (*v96)
    {
      v30 = 2 * (v30 != 2);
    }
    else if (v30 != 2)
    {
      v30 = 0;
    }
  }
  v53 = (int *)__d2b_D2A(&v91, &v94, v41);
  v78 = (HIDWORD(v41) >> 20) & 0x7FF;
  if (v78)
  {
    LODWORD(v39) = LODWORD(v41);
    HIDWORD(v39) = HIDWORD(v41) & 0xFFFFF | 0x3FF00000;
    v79 = v78 - 1023;
    v54 = 0;
  }
  else
  {
    v80 = v94 + v91 + 50;
    if (v94 + v91 + 1074 < 33)
      v29 = LODWORD(v41) << -v80;
    else
      v29 = (HIDWORD(v41) << -v80) | (LODWORD(v41) >> v80);
    LODWORD(v6) = v29;
    v7 = (double)v6;
    LODWORD(v39) = LODWORD(v7);
    HIDWORD(v39) = HIDWORD(v7) - 32505856;
    v79 = v94 + v91 - 1;
    v54 = 1;
  }
  v33 = (v39 + -1.5) * 0.289529655 + 0.176091259 + (double)v79 * 0.301029996;
  v67 = (int)v33;
  if (v33 < 0.0 && v33 != (double)v67)
    --v67;
  v65 = 1;
  if ((v67 & 0x80000000) == 0 && v67 <= 22)
  {
    if (v41 < __tens_D2A[v67])
      --v67;
    v65 = 0;
  }
  v70 = ~v79 + v94;
  if (v70 < 0)
  {
    v93 = -v70;
    v61 = 0;
  }
  else
  {
    v93 = 0;
    v61 = ~v79 + v94;
  }
  if (v67 < 0)
  {
    v93 -= v67;
    v92 = -v67;
    v60 = 0;
  }
  else
  {
    v92 = 0;
    v60 = v67;
    v61 += v67;
  }
  if (v99 < 0 || v99 >= 10)
    v99 = 0;
  v58 = v30 == 1;
  if (v99 >= 6)
  {
    v99 -= 4;
    v58 = 0;
  }
  v64 = 1;
  v74 = -1;
  v76 = -1;
  switch(v99)
  {
    case 0:
    case 1:
      v98 = 0;
      v8 = __rv_alloc_D2A(18);
      goto LABEL_51;
    case 2:
      v64 = 0;
      goto LABEL_44;
    case 3:
      v64 = 0;
      goto LABEL_48;
    case 4:
LABEL_44:
      if (v98 <= 0)
        v98 = 1;
      v74 = v98;
      v76 = v98;
      v8 = __rv_alloc_D2A(v98);
      goto LABEL_51;
    case 5:
LABEL_48:
      v79 = v98 + v67 + 1;
      v76 = v79;
      v74 = v98 + v67;
      if (v79 <= 0)
        v79 = 1;
      break;
    default:
      break;
  }
  v8 = __rv_alloc_D2A(v79);
LABEL_51:
  v31 = v8;
  v32 = v8;
  if (v99 >= 2 && v30 != 1)
    v64 = 0;
  if (v76 < 0 || v76 > 14 || !v58)
  {
LABEL_97:
    if (v91 < 0 || v67 > 14)
    {
      v63 = v93;
      v62 = v92;
      v50 = 0;
      v48 = 0;
      if (v64)
      {
        if (v54)
          v28 = v91 + 1075;
        else
          v28 = 54 - v94;
        v93 += v28;
        v61 += v28;
        v48 = (int *)__i2b_D2A(1);
      }
      if (v63 >= 1 && v61 >= 1)
      {
        if (v63 < v61)
          v27 = v63;
        else
          v27 = v61;
        v93 -= v27;
        v63 -= v27;
        v61 -= v27;
      }
      if (v92 >= 1)
      {
        if (v64)
        {
          if (v62 >= 1)
          {
            v48 = __pow5mult_D2A(v48, v62);
            v52 = __mult_D2A(v48, v53);
            __Bfree_D2A(v53);
            v53 = (int *)v52;
          }
          if (v92 != v62)
            v53 = __pow5mult_D2A(v53, v92 - v62);
        }
        else
        {
          v53 = __pow5mult_D2A(v53, v92);
        }
      }
      v47 = (int *)__i2b_D2A(1);
      if (v60 >= 1)
        v47 = __pow5mult_D2A(v47, v60);
      v59 = 0;
      if ((v99 < 2 || v64) && v30 == 1 && !LODWORD(v41) && (HIDWORD(v41) & 0xFFFFF) == 0 && (HIWORD(v41) & 0x7FE0) != 0)
      {
        ++v93;
        ++v61;
        v59 = 1;
      }
      if (v60)
        v26 = 32 - __hi0bits_D2A(v47[v47[5] + 5]);
      else
        LOBYTE(v26) = 1;
      v85 = ((_BYTE)v26 + (_BYTE)v61) & 0x1F;
      if ((((_BYTE)v26 + (_BYTE)v61) & 0x1F) != 0)
        v85 = 32 - v85;
      if (v85 < 5)
      {
        if (v85 <= 3)
        {
          v87 = v85 + 28;
          v93 += v87;
          v63 += v87;
          v61 += v87;
        }
      }
      else
      {
        v86 = v85 - 4;
        v93 += v86;
        v63 += v86;
        v61 += v86;
      }
      if (v93 >= 1)
        v53 = (int *)__lshift_D2A(v53, v93);
      if (v61 >= 1)
        v47 = (int *)__lshift_D2A(v47, v61);
      if (v65 && (__cmp_D2A((uint64_t)v53, (uint64_t)v47) & 0x80000000) != 0)
      {
        --v67;
        v53 = __multadd_D2A(v53, 10, 0);
        if (v64)
          v48 = __multadd_D2A(v48, 10, 0);
        v76 = v74;
      }
      if (v76 > 0 || v99 != 3 && v99 != 5)
      {
        if (v64)
        {
          if (v63 >= 1)
            v48 = (int *)__lshift_D2A(v48, v63);
          v50 = v48;
          if (v59)
          {
            v49 = (int *)__Balloc_D2A(v48[2]);
            j___platform_memmove(v49 + 4, v50 + 4, 4 * v50[5] + 8);
            v48 = (int *)__lshift_D2A(v49, 1);
          }
          for (i = 1; ; ++i)
          {
            v90 = __quorem_D2A((uint64_t)v53, (uint64_t)v47) + 48;
            v73 = __cmp_D2A((uint64_t)v53, (uint64_t)v50);
            v51 = (int *)__diff_D2A((uint64_t)v47, (uint64_t)v48);
            v25 = v51[4] ? 1 : __cmp_D2A((uint64_t)v53, (uint64_t)v51);
            __Bfree_D2A(v51);
            if (!v25 && v99 != 1 && (LOBYTE(v41) & 1) == 0 && v30 >= 1)
              break;
            if ((v73 & 0x80000000) == 0 && (v73 || v99 == 1 || (LOBYTE(v41) & 1) != 0))
            {
              if (v25 >= 1)
              {
                if (!v30)
                  goto LABEL_213;
                if (v90 != 57)
                {
                  v18 = v32++;
                  *v18 = v90 + 1;
                  goto LABEL_244;
                }
                goto LABEL_217;
              }
            }
            else
            {
              if (!v53[6] && v53[5] <= 1)
                goto LABEL_213;
              if (v99 < 2)
                goto LABEL_208;
              if (!v30)
                goto LABEL_213;
              if (v30 != 2)
              {
LABEL_208:
                if (v25 < 1
                  || (v53 = (int *)__lshift_D2A(v53, 1), v69 = __cmp_D2A((uint64_t)v53, (uint64_t)v47), v69 <= 0)
                  && (v69 || (v90 & 1) == 0)
                  || (v15 = v90, LOBYTE(v90) = v90 + 1, v15 != 57))
                {
LABEL_213:
                  v16 = v32++;
                  *v16 = v90;
                  goto LABEL_244;
                }
LABEL_217:
                v17 = v32++;
                *v17 = 57;
                goto LABEL_237;
              }
            }
            v19 = v32++;
            *v19 = v90;
            if (i == v76)
              goto LABEL_229;
            v53 = __multadd_D2A(v53, 10, 0);
            if (v50 == v48)
            {
              v48 = __multadd_D2A(v48, 10, 0);
              v50 = v48;
            }
            else
            {
              v50 = __multadd_D2A(v50, 10, 0);
              v48 = __multadd_D2A(v48, 10, 0);
            }
          }
          if (v90 == 57)
            goto LABEL_217;
          if (v73 >= 1)
            LOBYTE(v90) = v90 + 1;
          v14 = v32++;
          *v14 = v90;
        }
        else
        {
          for (j = 1; ; ++j)
          {
            LOBYTE(v90) = __quorem_D2A((uint64_t)v53, (uint64_t)v47) + 48;
            v20 = v32++;
            *v20 = v90;
            if (!v53[6] && v53[5] <= 1)
              goto LABEL_244;
            if (j >= v76)
              break;
            v53 = __multadd_D2A(v53, 10, 0);
          }
LABEL_229:
          if (v30
            && (v30 == 2
             || (v53 = (int *)__lshift_D2A(v53, 1),
                 v21 = __cmp_D2A((uint64_t)v53, (uint64_t)v47),
                 v21 > 0 || !v21 && (v90 & 1) != 0)))
          {
LABEL_237:
            while (*--v32 == 57)
            {
              if (v32 == v31)
              {
                ++v67;
                v22 = v32++;
                *v22 = 49;
                goto LABEL_244;
              }
            }
            v23 = v32++;
            ++*v23;
          }
          else
          {
            do
              --v32;
            while (*v32 == 48);
            ++v32;
          }
        }
        goto LABEL_244;
      }
      if (v76 < 0)
        goto LABEL_177;
      v47 = __multadd_D2A(v47, 5, 0);
      if ((int)__cmp_D2A((uint64_t)v53, (uint64_t)v47) <= 0)
        goto LABEL_177;
    }
    else
    {
      v35 = __tens_D2A[v67];
      if ((v98 & 0x80000000) == 0 || v76 > 0)
      {
        for (k = 1; ; ++k)
        {
          v57 = (int)(v41 / v35);
          v45 = v41 - (double)v57 * v35;
          if (v45 < 0.0)
          {
            LOBYTE(v57) = v57 - 1;
            v45 = v45 + v35;
          }
          v11 = v32++;
          *v11 = v57 + 48;
          if (v45 == 0.0)
            break;
          if (k == v76)
          {
            if (v99 >= 2)
            {
              if (!v30)
                goto LABEL_249;
              if (v30 == 2)
                goto LABEL_119;
            }
            v46 = v45 + v45;
            if (v46 > v35 || v46 == v35 && (v57 & 1) != 0)
              goto LABEL_119;
            goto LABEL_249;
          }
          v41 = v45 * 10.0;
        }
        goto LABEL_249;
      }
      v48 = 0;
      v47 = 0;
      if (v76 < 0 || v41 <= v35 * 5.0)
        goto LABEL_177;
    }
LABEL_178:
    v13 = v32++;
    *v13 = 49;
    ++v67;
LABEL_244:
    __Bfree_D2A(v47);
    if (v48)
    {
      if (v50 && v50 != v48)
        __Bfree_D2A(v50);
      __Bfree_D2A(v48);
    }
    goto LABEL_249;
  }
  v81 = 0;
  v40 = v41;
  v66 = v67;
  v75 = v76;
  v77 = 2;
  if (v67 < 1)
  {
    v68 = -v67;
    if (v67)
    {
      v41 = v41 * __tens_D2A[v68 & 0xF];
      for (m = v68 >> 4; m; m >>= 1)
      {
        if ((m & 1) != 0)
        {
          ++v77;
          v41 = v41 * __bigtens_D2A[v81];
        }
        ++v81;
      }
    }
  }
  else
  {
    v34 = __tens_D2A[v67 & 0xF];
    v71 = v67 >> 4;
    if (((v67 >> 4) & 0x10) != 0)
    {
      v71 = (v67 >> 4) & 0xF;
      v41 = v41 / 1.0e256;
      v77 = 3;
    }
    while (v71)
    {
      if ((v71 & 1) != 0)
      {
        ++v77;
        v34 = v34 * __bigtens_D2A[v81];
      }
      v71 >>= 1;
      ++v81;
    }
    v41 = v41 / v34;
  }
  if (v65 && v41 < 1.0 && v76 >= 1)
  {
    if (v74 <= 0)
      goto LABEL_96;
    v76 = v74;
    --v67;
    v41 = v41 * 10.0;
    ++v77;
  }
  v36 = (double)v77 * v41 + 7.0;
  HIDWORD(v36) -= 54525952;
  if (!v76)
  {
    v48 = 0;
    v47 = 0;
    v42 = v41 + -5.0;
    if (v42 > v36)
      goto LABEL_178;
    if (v42 < -v36)
    {
LABEL_177:
      v67 = ~v98;
      goto LABEL_244;
    }
    goto LABEL_96;
  }
  if (v64)
  {
    v37 = 0.5 / __tens_D2A[v76 - 1] - v36;
    v82 = 0;
    while (1)
    {
      v55 = (int)v41;
      v43 = v41 - (double)(int)v41;
      v9 = v32++;
      *v9 = v55 + 48;
      if (v43 < v37)
        goto LABEL_249;
      if (1.0 - v43 < v37)
        goto LABEL_119;
      if (++v82 >= v76)
        goto LABEL_96;
      v37 = v37 * 10.0;
      v41 = v43 * 10.0;
    }
  }
  v38 = v36 * __tens_D2A[v76 - 1];
  for (n = 1; ; ++n)
  {
    v56 = (int)v41;
    v44 = v41 - (double)(int)v41;
    if (v44 == 0.0)
      v76 = n;
    v10 = v32++;
    *v10 = v56 + 48;
    if (n == v76)
      break;
    v41 = v44 * 10.0;
  }
  if (v44 > v38 + 0.5)
  {
LABEL_119:
    while (*--v32 == 57)
    {
      if (v32 == (_BYTE *)v8)
      {
        ++v67;
        *v32 = 48;
        break;
      }
    }
    v12 = v32++;
    ++*v12;
    goto LABEL_249;
  }
  if (v44 >= 0.5 - v38)
  {
LABEL_96:
    v32 = v8;
    v41 = v40;
    v67 = v66;
    v76 = v75;
    goto LABEL_97;
  }
  do
    --v32;
  while (*v32 == 48);
  ++v32;
LABEL_249:
  __Bfree_D2A(v53);
  *v32 = 0;
  *v97 = v67 + 1;
  if (v95)
    *v95 = v32;
  return v31;
}

uint64_t __gdtoa(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  unsigned int v4;
  unint64_t v6;

  v4 = *a4 & 0xFFFFFFCF;
  *a4 = v4;
  v6 = v4 & 7;
  if (v6 <= 4)
    __asm { BR              X8 }
  return 0;
}

uint64_t bitstob(_DWORD *a1, int a2, _DWORD *a3)
{
  _DWORD *v3;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;

  v10 = 32;
  v9 = 0;
  while (v10 < a2)
  {
    v10 *= 2;
    ++v9;
  }
  v8 = __Balloc_D2A(v9);
  v7 = &a1[(a2 - 1) >> 5];
  v5 = v8 + 24;
  v6 = (_DWORD *)(v8 + 24);
  do
  {
    v3 = v6++;
    *v3 = *a1++;
  }
  while (a1 <= v7);
  v11 = ((uint64_t)v6 - v5) / 4;
  while (!*(_DWORD *)(v5 + 4 * --v11))
  {
    if (!v11)
    {
      *(_DWORD *)(v8 + 20) = 0;
      *a3 = 0;
      return v8;
    }
  }
  *(_DWORD *)(v8 + 20) = v11 + 1;
  *a3 = 32 * v11 + 32 - __hi0bits_D2A(*(_DWORD *)(v8 + 24 + 4 * v11));
  return v8;
}

uint64_t __rshift_D2A(uint64_t result, int a2)
{
  int *v2;
  int *v3;
  _DWORD *v4;
  int *v5;
  int *v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  int *v10;
  uint64_t v11;
  int *v12;
  _DWORD *v13;
  char v14;

  v10 = (int *)(result + 24);
  v11 = result + 24;
  if (a2 >> 5 < *(_DWORD *)(result + 20))
  {
    v9 = v11 + 4 * *(int *)(result + 20);
    v12 = (int *)(v11 + 4 * (a2 >> 5));
    v14 = a2 & 0x1F;
    if ((a2 & 0x1F) != 0)
    {
      v2 = v12;
      v13 = v12 + 1;
      v8 = *v2 >> v14;
      while ((unint64_t)v13 < v9)
      {
        v3 = v10++;
        *v3 = v8 | (*v13 << (32 - v14));
        v4 = v13++;
        v8 = *v4 >> v14;
      }
      *v10 = v8;
      if (v8)
        ++v10;
    }
    else
    {
      while ((unint64_t)v12 < v9)
      {
        v5 = v12++;
        v6 = v10++;
        *v6 = *v5;
      }
    }
  }
  v7 = ((uint64_t)v10 - result - 24) / 4;
  *(_DWORD *)(result + 20) = v7;
  if (!(_DWORD)v7)
    *(_DWORD *)(result + 24) = 0;
  return result;
}

uint64_t __trailz_D2A(uint64_t a1)
{
  BOOL v2;
  unsigned int i;
  unint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;

  v7 = a1;
  v6 = 0;
  v5 = (unsigned int *)(a1 + 24);
  v4 = v7 + 24 + 4 * *(int *)(v7 + 20);
  for (i = 0; ; i += 32)
  {
    v2 = 0;
    if ((unint64_t)v5 < v4)
      v2 = *v5 == 0;
    if (!v2)
      break;
    ++v5;
  }
  if ((unint64_t)v5 < v4)
  {
    v6 = *v5;
    i += __lo0bits_D2A(&v6);
  }
  return i;
}

uint64_t __Balloc_D2A(int a1)
{
  const void *v2;
  uint64_t v3;

  if (gdtoa_tsd_key == -1)
  {
    pthread_mutex_lock(&gdtoa_tsd_lock);
    if (gdtoa_tsd_key == -1)
    {
      gdtoa_tsd_key = 14;
      pthread_key_init_np(14, gdtoa_freelist_free);
    }
    pthread_mutex_unlock(&gdtoa_tsd_lock);
  }
  v2 = pthread_getspecific(gdtoa_tsd_key);
  if (!v2)
  {
    v2 = (const void *)malloc_type_malloc(80, 0x2004093837F09);
    _platform_memset(v2, 0, 80);
    pthread_setspecific(gdtoa_tsd_key, v2);
  }
  if (a1 <= 9 && (v3 = *((_QWORD *)v2 + a1)) != 0)
  {
    *((_QWORD *)v2 + a1) = *(_QWORD *)v3;
  }
  else
  {
    v3 = malloc_type_malloc(4 * ((1 << a1) - 1) + 32, 2330185210);
    *(_DWORD *)(v3 + 8) = a1;
    *(_DWORD *)(v3 + 12) = 1 << a1;
  }
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  return v3;
}

void gdtoa_freelist_free(_QWORD **a1)
{
  _QWORD **v1;
  _QWORD *v2;
  _QWORD *j;
  int i;

  v1 = a1;
  if (a1)
  {
    for (i = 0; i < 10; ++i)
    {
      if (*v1)
      {
        for (j = *v1; j; j = v2)
        {
          v2 = (_QWORD *)*j;
          free(j);
        }
      }
      ++v1;
    }
    free(a1);
  }
}

void __Bfree_D2A(int *a1)
{
  _QWORD *v1;

  if (a1)
  {
    if (a1[2] <= 9)
    {
      v1 = pthread_getspecific(gdtoa_tsd_key);
      *(_QWORD *)a1 = v1[a1[2]];
      v1[a1[2]] = a1;
    }
    else
    {
      free(a1);
    }
  }
}

uint64_t __lo0bits_D2A(unsigned int *a1)
{
  unsigned int v2;
  unsigned int v3;

  v2 = *a1;
  if ((*a1 & 7) != 0)
  {
    if ((v2 & 1) != 0)
    {
      return 0;
    }
    else if ((v2 & 2) != 0)
    {
      *a1 = v2 >> 1;
      return 1;
    }
    else
    {
      *a1 = v2 >> 2;
      return 2;
    }
  }
  else
  {
    v3 = 0;
    if (!(_WORD)v2)
    {
      v3 = 16;
      v2 >>= 16;
    }
    if (!(_BYTE)v2)
    {
      v3 += 8;
      v2 >>= 8;
    }
    if ((v2 & 0xF) == 0)
    {
      v3 += 4;
      v2 >>= 4;
    }
    if ((v2 & 3) == 0)
    {
      v3 += 2;
      v2 >>= 2;
    }
    if ((v2 & 1) != 0 || (++v3, (v2 >>= 1) != 0))
    {
      *a1 = v2;
      return v3;
    }
    else
    {
      return 32;
    }
  }
}

int *__multadd_D2A(_DWORD *a1, int a2, int a3)
{
  unsigned int *v3;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int *v8;
  int v9;
  int v10;
  int *v11;

  v11 = a1;
  v9 = a1[5];
  v8 = a1 + 6;
  v10 = 0;
  v7 = a3;
  do
  {
    v6 = *v8 * (uint64_t)a2 + v7;
    v7 = HIDWORD(v6);
    v3 = v8++;
    *v3 = v6;
    ++v10;
  }
  while (v10 < v9);
  if (v7)
  {
    if (v9 >= a1[3])
    {
      v5 = __Balloc_D2A(a1[2] + 1);
      j___platform_memmove(v5 + 16, v11 + 4, 4 * v11[5] + 8);
      __Bfree_D2A(v11);
      v11 = (int *)v5;
    }
    v11[v9 + 6] = HIDWORD(v6);
    v11[5] = v9 + 1;
  }
  return v11;
}

uint64_t __hi0bits_D2A(int a1)
{
  unsigned int v2;
  int v3;

  v3 = a1;
  v2 = 0;
  if ((a1 & 0xFFFF0000) == 0)
  {
    v2 = 16;
    v3 = a1 << 16;
  }
  if ((v3 & 0xFF000000) == 0)
  {
    v2 += 8;
    v3 <<= 8;
  }
  if ((v3 & 0xF0000000) == 0)
  {
    v2 += 4;
    v3 *= 16;
  }
  if ((v3 & 0xC0000000) == 0)
  {
    v2 += 2;
    v3 *= 4;
  }
  if (v3 < 0)
    return v2;
  ++v2;
  if ((v3 & 0x40000000) != 0)
    return v2;
  else
    return 32;
}

uint64_t __i2b_D2A(int a1)
{
  uint64_t result;

  result = __Balloc_D2A(1);
  *(_DWORD *)(result + 24) = a1;
  *(_DWORD *)(result + 20) = 1;
  return result;
}

uint64_t __mult_D2A(_DWORD *a1, _DWORD *a2)
{
  unsigned int *v2;
  unsigned int *v3;
  _DWORD *v4;
  BOOL v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  _DWORD *v10;
  _DWORD *v11;
  _DWORD *v12;
  unint64_t v13;
  _DWORD *i;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  _DWORD *v21;
  _DWORD *v22;

  v22 = a1;
  v21 = a2;
  if (a1[5] < a2[5])
  {
    v22 = a2;
    v21 = a1;
  }
  v19 = v22[2];
  v18 = v22[5];
  v17 = v21[5];
  v16 = v18 + v17;
  if (v18 + v17 > v22[3])
    ++v19;
  v20 = __Balloc_D2A(v19);
  for (i = (_DWORD *)(v20 + 24); (unint64_t)i < v20 + 24 + 4 * v16; ++i)
    *i = 0;
  v13 = (unint64_t)(v21 + 6);
  v10 = (_DWORD *)(v20 + 24);
  while (v13 < (unint64_t)&v21[v17 + 6])
  {
    v2 = (unsigned int *)v13;
    v13 += 4;
    v9 = *v2;
    if (*v2)
    {
      v15 = (unint64_t)(v22 + 6);
      v11 = v10;
      v8 = 0;
      do
      {
        v3 = (unsigned int *)v15;
        v15 += 4;
        v7 = *v3 * (unint64_t)v9 + *v11 + v8;
        v8 = HIDWORD(v7);
        v4 = v11++;
        *v4 = v7;
      }
      while (v15 < (unint64_t)&v22[v18 + 6]);
      *v11 = HIDWORD(v7);
    }
    ++v10;
  }
  v12 = (_DWORD *)(v20 + 24 + 4 * v16);
  while (1)
  {
    v6 = 0;
    if (v16 > 0)
      v6 = *--v12 == 0;
    if (!v6)
      break;
    --v16;
  }
  *(_DWORD *)(v20 + 20) = v16;
  return v20;
}

int *__pow5mult_D2A(int *a1, int a2)
{
  _QWORD *v2;
  _DWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  int v8;
  int *v9;

  v9 = a1;
  if ((a2 & 3) != 0)
    v9 = __multadd_D2A(a1, __pow5mult_D2A_p05[(a2 & 3) - 1], 0);
  v8 = a2 >> 2;
  if (!v8)
    return v9;
  v5 = (_DWORD *)p5s;
  if (!p5s)
  {
    os_unfair_lock_lock(&stru_E9754);
    v5 = (_DWORD *)p5s;
    if (!p5s)
    {
      p5s = __i2b_D2A(625);
      v5 = (_DWORD *)p5s;
      *(_QWORD *)p5s = 0;
    }
    os_unfair_lock_unlock(&stru_E9754);
  }
  while (1)
  {
    if ((v8 & 1) != 0)
    {
      v6 = __mult_D2A(v9, v5);
      __Bfree_D2A(v9);
      v9 = (int *)v6;
    }
    v8 >>= 1;
    if (!v8)
      break;
    v4 = *(_DWORD **)v5;
    if (!*(_QWORD *)v5)
    {
      os_unfair_lock_lock(&stru_E9754);
      v4 = *(_DWORD **)v5;
      if (!*(_QWORD *)v5)
      {
        v2 = (_QWORD *)__mult_D2A(v5, v5);
        *(_QWORD *)v5 = v2;
        v4 = v2;
        *v2 = 0;
      }
      os_unfair_lock_unlock(&stru_E9754);
    }
    v5 = v4;
  }
  return v9;
}

uint64_t __lshift_D2A(int *a1, int a2)
{
  int *v2;
  int *v3;
  int *v4;
  int *v5;
  int *v6;
  int v8;
  unint64_t v9;
  int *v10;
  int *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int i;
  int j;
  char v18;
  char v19;

  v18 = a2;
  v14 = a2 >> 5;
  v15 = a1[2];
  v13 = (a2 >> 5) + a1[5] + 1;
  for (i = a1[3]; v13 > i; i *= 2)
    ++v15;
  v12 = __Balloc_D2A(v15);
  v10 = (int *)(v12 + 24);
  for (j = 0; j < v14; ++j)
  {
    v2 = v10++;
    *v2 = 0;
  }
  v11 = a1 + 6;
  v9 = (unint64_t)&a1[a1[5] + 6];
  v19 = v18 & 0x1F;
  if (v19)
  {
    v8 = 0;
    do
    {
      v3 = v10++;
      *v3 = (*v11 << v19) | v8;
      v4 = v11++;
      v8 = *v4 >> (32 - v19);
    }
    while ((unint64_t)v11 < v9);
    *v10 = v8;
    if (v8)
      ++v13;
  }
  else
  {
    do
    {
      v5 = v11++;
      v6 = v10++;
      *v6 = *v5;
    }
    while ((unint64_t)v11 < v9);
  }
  *(_DWORD *)(v12 + 20) = v13 - 1;
  __Bfree_D2A(a1);
  return v12;
}

uint64_t __cmp_D2A(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  unsigned int v6;
  _DWORD *v7;
  _DWORD *v8;

  v5 = *(_DWORD *)(a1 + 20);
  v4 = *(_DWORD *)(a2 + 20);
  if (v5 > 1 && !*(_DWORD *)(a1 + 24 + 4 * (v5 - 1)))
  {
    fprintf(__stderrp, "%s\n", "cmp called with a->x[a->wds-1] == 0");
    exit(1);
  }
  if (v4 > 1 && !*(_DWORD *)(a2 + 24 + 4 * (v4 - 1)))
  {
    fprintf(__stderrp, "%s\n", "cmp called with b->x[b->wds-1] == 0");
    exit(1);
  }
  v6 = v5 - v4;
  if (v6)
  {
    return v6;
  }
  else
  {
    v8 = (_DWORD *)(a1 + 24 + 4 * v4);
    v7 = (_DWORD *)(a2 + 24 + 4 * v4);
    while (*--v8 == *--v7)
    {
      if ((unint64_t)v8 <= a1 + 24)
        return 0;
    }
    if (*v8 < *v7)
      return -1;
    else
      return 1;
  }
}

uint64_t __diff_D2A(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int *v4;
  _DWORD *v5;
  unsigned int *v6;
  _DWORD *v7;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  unint64_t v13;
  unsigned int *v14;
  unint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v22 = a1;
  v21 = a2;
  v17 = __cmp_D2A(a1, a2);
  if ((_DWORD)v17)
  {
    if ((int)v17 >= 0)
    {
      v18 = 0;
    }
    else
    {
      v19 = v22;
      v22 = v21;
      v21 = v19;
      v18 = 1;
    }
    v20 = __Balloc_D2A(*(_DWORD *)(v22 + 8));
    *(_DWORD *)(v20 + 16) = v18;
    v16 = *(_DWORD *)(v22 + 20);
    v15 = v22 + 24;
    v14 = (unsigned int *)(v21 + 24);
    v13 = v21 + 24 + 4 * *(int *)(v21 + 20);
    v12 = (_DWORD *)(v20 + 24);
    v11 = 0;
    do
    {
      v3 = (unsigned int *)v15;
      v15 += 4;
      v4 = v14++;
      v9 = *v3 - (unint64_t)*v4 - v11;
      v11 = HIDWORD(v9) & 1;
      v5 = v12++;
      *v5 = v9;
    }
    while ((unint64_t)v14 < v13);
    while (v15 < v22 + 24 + 4 * v16)
    {
      v6 = (unsigned int *)v15;
      v15 += 4;
      v10 = *v6 - v11;
      v11 = HIDWORD(v10) & 1;
      v7 = v12++;
      *v7 = v10;
    }
    while (!*--v12)
      --v16;
    *(_DWORD *)(v20 + 20) = v16;
    return v20;
  }
  else
  {
    v2 = __Balloc_D2A(0);
    *(_DWORD *)(v2 + 20) = 1;
    *(_DWORD *)(v2 + 24) = 0;
    return v2;
  }
}

double __b2d_D2A(uint64_t a1, _DWORD *a2)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  int v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  _DWORD *v11;

  v10 = a1 + 24;
  v11 = (_DWORD *)(a1 + 24 + 4 * *(int *)(a1 + 20) - 4);
  HIDWORD(v9) = *v11;
  if (!*v11)
  {
    fprintf(__stderrp, "%s\n", "zero y in b2d");
    exit(1);
  }
  v7 = __hi0bits_D2A(SHIDWORD(v9));
  *a2 = 32 - v7;
  if (v7 >= 11)
  {
    if ((unint64_t)v11 <= v10)
      v4 = 0;
    else
      v4 = *--v11;
    LODWORD(v9) = v4;
    v8 = v7 - 11;
    if (v8)
    {
      HIDWORD(v6) = (HIDWORD(v9) << v8) | 0x3FF00000 | (v4 >> (32 - v8));
      if ((unint64_t)v11 <= v10)
        v3 = 0;
      else
        v3 = *(v11 - 1);
      LODWORD(v6) = (v4 << v8) | (v3 >> (32 - v8));
    }
    else
    {
      v6 = v9 | 0x3FF0000000000000;
    }
  }
  else
  {
    HIDWORD(v6) = (HIDWORD(v9) >> (11 - v7)) | 0x3FF00000;
    if ((unint64_t)v11 <= v10)
      v5 = 0;
    else
      v5 = *(v11 - 1);
    LODWORD(v6) = (HIDWORD(v9) << (v7 + 21)) | (v5 >> (11 - v7));
  }
  return *(double *)&v6;
}

uint64_t __d2b_D2A(_DWORD *a1, _DWORD *a2, double a3)
{
  unsigned int v3;
  int v4;
  int v5;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  int v11;
  int v12;
  int v13;
  double v14;
  uint64_t v15;
  _DWORD *v16;
  _DWORD *v17;
  double v18;

  v18 = a3;
  v17 = a1;
  v16 = a2;
  v13 = 0;
  v11 = 0;
  v9 = 0;
  v14 = a3;
  v15 = __Balloc_D2A(1);
  v10 = (unsigned int *)(v15 + 24);
  v8 = HIDWORD(v14) & 0xFFFFF;
  HIDWORD(v14) &= ~0x80000000;
  v12 = HIDWORD(v14) >> 20;
  if (HIDWORD(v14) >> 20)
    v8 |= 0x100000u;
  v9 = LODWORD(v14);
  if (LODWORD(v14))
  {
    v11 = __lo0bits_D2A(&v9);
    if (v11)
    {
      *v10 = v9 | (v8 << (32 - v11));
      v8 >>= v11;
    }
    else
    {
      *v10 = v9;
    }
    v3 = v8;
    v10[1] = v8;
    if (v3)
      v4 = 2;
    else
      v4 = 1;
    *(_DWORD *)(v15 + 20) = v4;
    v13 = v4;
  }
  else
  {
    v11 = __lo0bits_D2A(&v8);
    *v10 = v8;
    *(_DWORD *)(v15 + 20) = 1;
    v13 = 1;
    v11 += 32;
  }
  if (v12)
  {
    *v17 = v12 - 1075 + v11;
    *v16 = 53 - v11;
  }
  else
  {
    *v17 = v11 - 1074;
    v7 = 32 * v13;
    v5 = __hi0bits_D2A(v10[v13 - 1]);
    *v16 = v7 - v5;
  }
  return v15;
}

_BYTE *__strcp_D2A(_BYTE *a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;

  while (1)
  {
    v2 = a2++;
    LODWORD(v2) = *v2;
    *a1 = (_BYTE)v2;
    if (!(_DWORD)v2)
      break;
    ++a1;
  }
  return a1;
}

_DWORD *__s2b_D2A(uint64_t a1, int a2, int a3, int a4, int a5)
{
  char *v5;
  char *v6;
  int i;
  int v9;
  int v10;
  _DWORD *v11;
  char *v17;
  char *v18;

  v9 = 0;
  for (i = 1; (a3 + 8) / 9 > i; i *= 2)
    ++v9;
  v11 = (_DWORD *)__Balloc_D2A(v9);
  v11[6] = a4;
  v11[5] = 1;
  v10 = 9;
  if (a2 <= 9)
  {
    v18 = (char *)(a1 + a5 + 9);
  }
  else
  {
    v17 = (char *)(a1 + 9);
    do
    {
      v5 = v17++;
      v11 = __multadd_D2A(v11, 10, *v5 - 48);
      ++v10;
    }
    while (v10 < a2);
    v18 = &v17[a5];
  }
  while (v10 < a3)
  {
    v6 = v18++;
    v11 = __multadd_D2A(v11, 10, *v6 - 48);
    ++v10;
  }
  return v11;
}

double __ratio_D2A(uint64_t a1, uint64_t a2)
{
  int v3;
  int v4;
  int v5;
  double v6;
  double v7;
  uint64_t v8;
  uint64_t v9;

  v9 = a1;
  v8 = a2;
  v7 = 0.0;
  v6 = 0.0;
  v5 = 0;
  v4 = 0;
  v3 = 0;
  v7 = __b2d_D2A(a1, &v4);
  v6 = __b2d_D2A(v8, &v3);
  v5 = v4 - v3 + 32 * (*(_DWORD *)(v9 + 20) - *(_DWORD *)(v8 + 20));
  if (v5 <= 0)
  {
    v5 = -v5;
    HIDWORD(v6) += v5 << 20;
  }
  else
  {
    HIDWORD(v7) += v5 << 20;
  }
  return v7 / v6;
}

uint64_t __match_D2A(uint64_t *a1, _BYTE *a2)
{
  _BYTE *v2;
  uint64_t v4;
  int v5;

  v4 = *a1;
  while (1)
  {
    v2 = a2++;
    if (!*v2)
      break;
    v5 = *(char *)++v4;
    if (v5 >= 65 && v5 <= 90)
      v5 += 32;
    if (v5 != (char)*v2)
      return 0;
  }
  *a1 = v4 + 1;
  return 1;
}

unint64_t __copybits_D2A(unint64_t result, int a2, uint64_t a3)
{
  _DWORD *v3;
  _DWORD *v4;
  _DWORD *v5;
  unint64_t v6;
  _DWORD *v7;
  unint64_t v8;

  v8 = result;
  v7 = (_DWORD *)(a3 + 24);
  v6 = a3 + 24 + 4 * *(int *)(a3 + 20);
  while ((unint64_t)v7 < v6)
  {
    v3 = v7++;
    v4 = (_DWORD *)v8;
    v8 += 4;
    *v4 = *v3;
  }
  while (v8 < result + 4 * ((a2 - 1) >> 5) + 4)
  {
    v5 = (_DWORD *)v8;
    v8 += 4;
    *v5 = 0;
  }
  return result;
}

uint64_t __any_on_D2A(uint64_t a1, int a2)
{
  uint64_t v3;
  _DWORD *v4;
  int v5;
  int v6;

  v3 = a1 + 24;
  v5 = *(_DWORD *)(a1 + 20);
  v6 = a2 >> 5;
  if (a2 >> 5 <= v5)
  {
    if (v6 < v5
      && (a2 & 0x1F) != 0
      && *(_DWORD *)(v3 + 4 * v6) >> (a2 & 0x1F) << (a2 & 0x1F) != *(_DWORD *)(v3 + 4 * v6))
    {
      return 1;
    }
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 20);
  }
  v4 = (_DWORD *)(v3 + 4 * v6);
  while ((unint64_t)v4 > a1 + 24)
  {
    if (*--v4)
      return 1;
  }
  return 0;
}

int *__sum_D2A(_DWORD *a1, _DWORD *a2)
{
  unsigned int *v2;
  unsigned int v3;
  _DWORD *v4;
  unsigned int *v5;
  uint64_t v6;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unint64_t v12;
  unint64_t v13;
  unsigned __int16 *v14;
  unsigned int *v15;
  _WORD *v16;
  unsigned int v17;
  int *v18;
  _DWORD *v19;
  uint64_t v20;
  _DWORD *v21;

  v21 = a1;
  v19 = a2;
  if (a1[5] < a2[5])
  {
    v19 = a1;
    v21 = a2;
  }
  v18 = (int *)__Balloc_D2A(v21[2]);
  v18[5] = v21[5];
  v17 = 0;
  v15 = v21 + 6;
  v14 = (unsigned __int16 *)(v19 + 6);
  v16 = v18 + 6;
  v12 = (unint64_t)&v18[v19[5] + 6];
  do
  {
    v10 = *(unsigned __int16 *)v15 + *v14 + v17;
    v2 = v15++;
    v3 = *v2;
    v4 = v14;
    v14 += 2;
    v8 = HIWORD(*v4) + HIWORD(v3) + ((v10 & 0x10000) >> 16);
    v17 = (v8 & 0x10000) >> 16;
    v16[1] = v8;
    *v16 = v10;
    v16 += 2;
  }
  while ((unint64_t)v16 < v12);
  v13 = v12 + 4 * (v21[5] - v19[5]);
  while ((unint64_t)v16 < v13)
  {
    v11 = *(unsigned __int16 *)v15 + v17;
    v5 = v15++;
    v9 = ((v11 & 0x10000) >> 16) + HIWORD(*v5);
    v17 = (v9 & 0x10000) >> 16;
    v16[1] = v9;
    *v16 = v11;
    v16 += 2;
  }
  if (v17)
  {
    if (v18[5] == v18[3])
    {
      v20 = __Balloc_D2A(v18[2] + 1);
      j___platform_memmove(v20 + 16, v18 + 4, 4 * v18[5] + 8);
      __Bfree_D2A(v18);
      v18 = (int *)v20;
    }
    v6 = v18[5]++;
    v18[v6 + 6] = 1;
  }
  return v18;
}

double __ulp_D2A(uint64_t a1)
{
  int v2;
  double v3;
  int v4;
  int v5;

  if ((*(_DWORD *)(a1 + 4) & 0x7FF00000) - 54525952 <= 0)
  {
    v4 = (54525952 - (*(_DWORD *)(a1 + 4) & 0x7FF00000)) >> 20;
    if (v4 >= 20)
    {
      HIDWORD(v3) = 0;
      v5 = v4 - 20;
      if (v5 < 31)
        v2 = 1 << (31 - v5);
      else
        v2 = 1;
      LODWORD(v3) = v2;
    }
    else
    {
      HIDWORD(v3) = 0x80000 >> v4;
      LODWORD(v3) = 0;
    }
  }
  else
  {
    HIDWORD(v3) = (*(_DWORD *)(a1 + 4) & 0x7FF00000) - 54525952;
    LODWORD(v3) = 0;
  }
  return v3;
}

unsigned int alarm(unsigned int a1)
{
  itimerval v2;
  itimerval v3;
  unsigned int v4;

  v4 = a1;
  memset(&v3, 0, sizeof(v3));
  memset(&v2, 0, sizeof(v2));
  v3.it_interval.tv_usec = 0;
  v3.it_interval.tv_sec = 0;
  v3.it_value.tv_sec = a1;
  v3.it_value.tv_usec = 0;
  if (setitimer(0, &v3, &v2) < 0)
    return -1;
  if (v2.it_value.tv_usec)
    ++v2.it_value.tv_sec;
  return v2.it_value.tv_sec;
}

uint32_t arc4random(void)
{
  uint32_t __buf;

  __buf = 0;
  arc4random_buf(&__buf, 4uLL);
  return __buf;
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
  arc4_init();
  (*(void (**)(uint64_t, size_t, void *))rng)(rng, __nbytes, __buf);
}

void arc4_init()
{
  int v0;

  v0 = 0;
  if (!rng)
  {
    rng = ccrng(&v0);
    if (!rng)
    {
      _os_crash((uint64_t)"arc4random: unable to get ccrng() handle");
      __break(1u);
      JUMPOUT(0x38A40);
    }
  }
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  uint64_t v2;
  uint32_t v3;

  v3 = __upper_bound;
  v2 = 0;
  arc4_init();
  ccrng_uniform(rng, v3, &v2);
  return v2;
}

char *__cdecl basename_r(const char *a1, char *a2)
{
  BOOL v3;
  BOOL v4;
  unint64_t v5;
  unint64_t j;
  const char *i;

  if (a1 && *a1)
  {
    for (i = &a1[_platform_strlen(a1) - 1]; ; --i)
    {
      v4 = 0;
      if (i > a1)
        v4 = *i == 47;
      if (!v4)
        break;
    }
    if (i == a1 && *i == 47)
    {
      *a2 = 47;
      a2[1] = 0;
      return a2;
    }
    else
    {
      for (j = (unint64_t)i; ; --j)
      {
        v3 = 0;
        if (j > (unint64_t)a1)
          v3 = *(_BYTE *)(j - 1) != 47;
        if (!v3)
          break;
      }
      v5 = (unint64_t)&i[-j + 1];
      if (v5 < 0x400)
      {
        j___platform_memmove(a2, j, v5);
        a2[v5] = 0;
        return a2;
      }
      else
      {
        *__error() = 63;
        return 0;
      }
    }
  }
  else
  {
    *a2 = 46;
    a2[1] = 0;
    return a2;
  }
}

char *__cdecl basename(char *a1)
{
  if (basename_bname)
    return basename_r(a1, (char *)basename_bname);
  basename_bname = malloc_type_malloc(1024, 2181698011);
  if (basename_bname)
    return basename_r(a1, (char *)basename_bname);
  else
    return 0;
}

clock_t clock(void)
{
  rusage v1;

  _platform_memset(&v1, 0, 144);
  if (getrusage(0, &v1))
    return -1;
  else
    return 1000000 * v1.ru_utime.tv_sec + v1.ru_utime.tv_usec + 1000000 * v1.ru_stime.tv_sec + v1.ru_stime.tv_usec;
}

int closedir(DIR *a1)
{
  uint64_t v1;

  v1 = _fdclosedir((uint64_t)a1);
  return close_NOCANCEL(v1);
}

uint64_t _fdclosedir(uint64_t a1)
{
  unsigned int v2;

  pthread_mutex_lock((pthread_mutex_t *)(a1 + 64));
  v2 = *(_DWORD *)a1;
  *(_DWORD *)a1 = -1;
  *(_QWORD *)(a1 + 8) = 0;
  free(*(void **)(a1 + 24));
  _reclaim_telldir(a1);
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 64));
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 64));
  free((void *)a1);
  return v2;
}

char *__cdecl ctermid(char *a1)
{
  if (!a1)
    return ctermid_def;
  bcopy(ctermid_def, a1, 9uLL);
  return a1;
}

char *__cdecl ctermid_r(char *a1)
{
  if (a1)
    return ctermid(a1);
  else
    return 0;
}

char *__cdecl dirname_r(const char *a1, char *a2)
{
  char v2;
  BOOL v4;
  BOOL v5;
  BOOL v6;
  unint64_t v7;
  const char *i;

  if (a1 && *a1)
  {
    for (i = &a1[_platform_strlen(a1) - 1]; ; --i)
    {
      v6 = 0;
      if (i > a1)
        v6 = *i == 47;
      if (!v6)
        break;
    }
    while (1)
    {
      v5 = 0;
      if (i > a1)
        v5 = *i != 47;
      if (!v5)
        break;
      --i;
    }
    if (i == a1)
    {
      if (*i == 47)
        v2 = 47;
      else
        v2 = 46;
      *a2 = v2;
      a2[1] = 0;
      return a2;
    }
    else
    {
      do
      {
        --i;
        v4 = 0;
        if (i > a1)
          v4 = *i == 47;
      }
      while (v4);
      v7 = i - a1 + 1;
      if (v7 < 0x400)
      {
        _platform_memmove(a2, a1, v7);
        a2[v7] = 0;
        return a2;
      }
      else
      {
        *__error() = 63;
        return 0;
      }
    }
  }
  else
  {
    *a2 = 46;
    a2[1] = 0;
    return a2;
  }
}

char *__cdecl dirname(char *a1)
{
  if (dirname_dname)
    return dirname_r(a1, (char *)dirname_dname);
  dirname_dname = malloc_type_malloc(1024, 3466320316);
  if (dirname_dname)
    return dirname_r(a1, (char *)dirname_dname);
  else
    return 0;
}

double drand48(void)
{
  int v1;
  uint64_t v2;
  double v3;

  _rand48_seed = _rand48_seed * _rand48_mult + _rand48_add;
  if ((_rand48_seed & 0xFFFFFFFFFFFFLL) == 0)
    return 0.0;
  v2 = 32 * (_rand48_seed & 0xFFFFFFFFFFFFLL);
  v1 = 0;
  while ((v2 & 0x10000000000000) == 0)
  {
    ++v1;
    v2 *= 2;
  }
  *(_QWORD *)&v3 = v2 & 0x800FFFFFFFFFFFFFLL | (((1022 - v1) & 0x7FFLL) << 52);
  return v3;
}

double erand48(unsigned __int16 a1[3])
{
  int v2;
  uint64_t v3;
  unint64_t v4;
  double v5;

  v4 = (*a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32)) * _rand48_mult + _rand48_add;
  *(_DWORD *)a1 = (*a1 + (a1[1] << 16)) * _rand48_mult + _rand48_add;
  a1[2] = WORD2(v4);
  if ((v4 & 0xFFFFFFFFFFFFLL) == 0)
    return 0.0;
  v3 = 32 * (v4 & 0xFFFFFFFFFFFFLL);
  v2 = 0;
  while ((v3 & 0x10000000000000) == 0)
  {
    ++v2;
    v3 *= 2;
  }
  *(_QWORD *)&v5 = v3 & 0x800FFFFFFFFFFFFFLL | (((1022 - v2) & 0x7FFLL) << 52);
  return v5;
}

void _e_visprintf(FILE *a1, const char *a2, va_list a3)
{
  uint64_t v3;
  char *v4;
  _BYTE *v5;
  char *v6;
  char *v7;
  char *v9;
  char *v10;
  int v11;
  va_list v12;
  const char *v13;
  FILE *v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = 0;
  v10 = 0;
  vasprintf(&v10, a2, a3);
  if (v10)
  {
    v3 = _platform_strlen(v10);
    v9 = (char *)malloc_type_malloc(4 * v3 + 1, 515968872);
    if (v9)
    {
      v7 = v10;
      v6 = v9;
      while (*v7)
      {
        if (escape[*v7])
        {
          if (escape[*v7] == 255)
          {
            sprintf(v6, "\\%03o", *v7);
            v6 += 4;
          }
          else
          {
            *v6 = 92;
            v5 = v6 + 1;
            v6 += 2;
            *v5 = escape[*v7];
          }
        }
        else
        {
          v4 = v6++;
          *v4 = *v7;
        }
        ++v7;
      }
      *v6 = 0;
      fputs(v9, v14);
      free(v9);
    }
    else
    {
      v11 = 1;
    }
    free(v10);
  }
  else
  {
    v11 = 1;
  }
  if (v11)
    vfprintf(v14, v13, a3);
}

void err_set_file(void *a1)
{
  if (a1)
    _e_err_file = (uint64_t)a1;
  else
    _e_err_file = (uint64_t)__stderrp;
}

void err_set_exit(void (__cdecl *a1)(int))
{
  int v1;

  if (_e_err_exit == 1)
  {
    _Block_release(off_E9768);
    off_E9768 = 0;
  }
  if (a1)
    v1 = 2;
  else
    v1 = 0;
  _e_err_exit = v1;
  off_E9768 = a1;
}

void err_set_exit_b(void *a1)
{
  if (_e_err_exit == 1)
    _Block_release(off_E9768);
  _e_err_exit = a1 != 0;
  off_E9768 = _Block_copy(a1);
}

int execl(const char *__path, const char *__arg0, ...)
{
  char *v2;
  char *v3;
  char ***v4;
  uint64_t v6;
  char **v7;
  const char *v8;
  char **v9;
  char *v10;
  char *v11;
  int i;
  char **v13;
  va_list v14;
  const char *v15;
  const char *v16;
  va_list va;

  va_start(va, __arg0);
  v16 = __path;
  v15 = __arg0;
  v13 = 0;
  va_copy(v14, va);
  for (i = 1; ; ++i)
  {
    v2 = *(char **)v14;
    v14 += 8;
    v11 = v2;
    if (!v2)
      break;
  }
  v9 = (char **)((char *)&v6 - ((8 * (i + 1) + 15) & 0xFFFFFFFFFFFFFFF0));
  _platform_bzero(v9, 8 * (i + 1));
  v13 = v9;
  if (v9)
  {
    va_copy(v14, va);
    i = 1;
    *v13 = (char *)v15;
    while (1)
    {
      v3 = *(char **)v14;
      v14 += 8;
      v10 = v3;
      v13[i] = v3;
      if (!v3)
        break;
      ++i;
    }
    v8 = v16;
    v7 = v13;
    v4 = _NSGetEnviron();
    return execve(v8, v7, *v4);
  }
  else
  {
    *__error() = 12;
    return -1;
  }
}

int execle(const char *__path, const char *__arg0, ...)
{
  char *v2;
  char *v3;
  char *const *v4;
  uint64_t v6;
  char *const *v7;
  char *const *v8;
  char *v9;
  char *v10;
  int i;
  char *const *v12;
  char **v13;
  va_list v14;
  char *v15;
  const char *v16;
  va_list va;

  va_start(va, __arg0);
  v16 = __path;
  v15 = (char *)__arg0;
  v13 = 0;
  v12 = 0;
  va_copy(v14, va);
  for (i = 1; ; ++i)
  {
    v2 = *(char **)v14;
    v14 += 8;
    v10 = v2;
    if (!v2)
      break;
  }
  v7 = (char *const *)((char *)&v6 - ((8 * (i + 1) + 15) & 0xFFFFFFFFFFFFFFF0));
  _platform_bzero(v7, 8 * (i + 1));
  v13 = (char **)v7;
  if (v7)
  {
    va_copy(v14, va);
    i = 1;
    *v13 = v15;
    while (1)
    {
      v3 = *(char **)v14;
      v14 += 8;
      v9 = v3;
      v13[i] = v3;
      if (!v3)
        break;
      ++i;
    }
    v4 = *(char *const **)v14;
    v14 += 8;
    v8 = v4;
    v12 = v4;
    return execve(v16, v13, v4);
  }
  else
  {
    *__error() = 12;
    return -1;
  }
}

int execlp(const char *__file, const char *__arg0, ...)
{
  char *v2;
  char *v3;
  uint64_t v5;
  char *const *v6;
  char *v7;
  char *v8;
  int i;
  char **v10;
  va_list v11;
  char *v12;
  const char *v13;
  va_list va;

  va_start(va, __arg0);
  v13 = __file;
  v12 = (char *)__arg0;
  v10 = 0;
  va_copy(v11, va);
  for (i = 1; ; ++i)
  {
    v2 = *(char **)v11;
    v11 += 8;
    v8 = v2;
    if (!v2)
      break;
  }
  v6 = (char *const *)((char *)&v5 - ((8 * (i + 1) + 15) & 0xFFFFFFFFFFFFFFF0));
  _platform_bzero(v6, 8 * (i + 1));
  v10 = (char **)v6;
  if (v6)
  {
    va_copy(v11, va);
    i = 1;
    *v10 = v12;
    while (1)
    {
      v3 = *(char **)v11;
      v11 += 8;
      v7 = v3;
      v10[i] = v3;
      if (!v3)
        break;
      ++i;
    }
    return execvp(v13, v10);
  }
  else
  {
    *__error() = 12;
    return -1;
  }
}

int execvp(const char *__file, char *const *__argv)
{
  char ***v2;

  v2 = _NSGetEnviron();
  return _execvpe(__file, __argv, *v2);
}

int execv(const char *__path, char *const *__argv)
{
  char ***v2;

  v2 = _NSGetEnviron();
  execve(__path, __argv, *v2);
  return -1;
}

uint64_t _execvpe(const char *a1, char *const *a2, char *const *a3)
{
  char *v4;

  v4 = getenv("PATH");
  if (!v4)
    v4 = "/usr/bin:/bin";
  return execvPe(a1, (uint64_t)v4, a2, a3);
}

int execvP(const char *__file, const char *__searchpath, char *const *__argv)
{
  char ***v3;

  v3 = _NSGetEnviron();
  return execvPe(__file, (uint64_t)__searchpath, __argv, *v3);
}

uint64_t execvPe(const char *a1, uint64_t a2, char *const *a3, char *const *a4)
{
  uint64_t v4;
  _BYTE *v5;
  uint64_t v7;
  int v8;
  unint64_t v9;
  _BYTE *v10;
  unsigned int v11;
  char *v12;
  stat v13;
  const char *v14;
  char *v15;
  char *v16;
  int v17;
  int v18;
  size_t v19;
  size_t v20;
  uint64_t v21;
  uint64_t v22;
  char *const *v23;
  char *const *v24;
  uint64_t v25;
  const char *v26;
  _BYTE v28[1024];

  v26 = a1;
  v25 = a2;
  v24 = a3;
  v23 = a4;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  _platform_memset(&v13, 0, 144);
  v18 = 0;
  if (_platform_strchr(v26, 47))
  {
    v14 = v26;
    v16 = 0;
LABEL_15:
    execve(v14, v24, v23);
    v9 = (*__error() - 2);
    if (v9 <= 0x3D)
      __asm { BR              X8 }
    v17 = *__error();
    if (stat(v14, &v13))
    {
LABEL_8:
      while (1)
      {
        v15 = strsep(&v16, ":");
        if (!v15)
          break;
        if (*v15)
        {
          v20 = _platform_strlen(v15);
        }
        else
        {
          v15 = ".";
          v20 = 1;
        }
        v19 = _platform_strlen(v26);
        if (v20 + v19 + 2 <= 0x400)
        {
          v10 = v28;
          bcopy(v15, v28, v20);
          v5 = v10;
          v10[v20] = 47;
          bcopy(v26, &v5[v20 + 1], v19);
          v10[v20 + 1 + v19] = 0;
          goto LABEL_15;
        }
        v11 = 2;
        write_NOCANCEL(2, "execvP: ", 8);
        write_NOCANCEL(v11, v15, v20);
        write_NOCANCEL(v11, ": path too long\n", 16);
      }
      if (v18)
      {
        *__error() = 13;
      }
      else if (v16)
      {
        *__error() = 2;
      }
    }
    else
    {
      if (v17 == 13)
      {
        v18 = 1;
        goto LABEL_8;
      }
      v8 = v17;
      *__error() = v8;
    }
    return -1;
  }
  else
  {
    v14 = v28;
    if (*v26)
    {
      v4 = _platform_strlen(v25);
      v12 = (char *)&v7 - ((v4 + 16) & 0xFFFFFFFFFFFFFFF0);
      _platform_bzero(v12, v4 + 1);
      v16 = v12;
      if (v12)
      {
        _platform_strcpy(v16, v25);
        goto LABEL_8;
      }
      *__error() = 12;
      return -1;
    }
    else
    {
      *__error() = 2;
      return -1;
    }
  }
}

const char *__cdecl fmtcheck(const char *a1, const char *a2)
{
  int v3;
  int next_format;
  char *v5;
  char *v6;
  const char *v7;
  char *v8;

  v8 = (char *)a1;
  v7 = a2;
  v6 = 0;
  v5 = 0;
  if (!a1)
    return v7;
  v6 = v8;
  next_format = 0;
  v5 = (char *)v7;
  v3 = 0;
  while (1)
  {
    next_format = get_next_format(&v6, next_format);
    if (next_format == 23)
      break;
    if (next_format == 24)
      return v7;
    v3 = get_next_format(&v5, v3);
    if (next_format != v3)
      return v7;
  }
  return v8;
}

uint64_t get_next_format(char **a1, int a2)
{
  BOOL v3;
  char *v4;
  uint64_t v5;
  int v6;

  if (a2 == 21)
  {
    ++*a1;
    return get_next_format_from_width(a1);
  }
  else if (a2 == 22)
  {
    ++*a1;
    return get_next_format_from_precision(a1);
  }
  else
  {
    v4 = *a1;
    v6 = 0;
    while (!v6)
    {
      v5 = _platform_strchr(v4, 37);
      if (!v5)
      {
        *a1 = 0;
        return 23;
      }
      v4 = (char *)(v5 + 1);
      if (!*v4)
      {
        *a1 = v4;
        return 24;
      }
      if (*v4 == 37)
        ++v4;
      else
        v6 = 1;
    }
    while (1)
    {
      v3 = 0;
      if (*v4)
        v3 = _platform_strchr("#'0- +", *v4) != 0;
      if (!v3)
        break;
      ++v4;
    }
    if (*v4 == 42)
    {
      *a1 = v4;
      return 21;
    }
    else
    {
      while (isdigit(*v4))
        ++v4;
      if (*v4)
      {
        *a1 = v4;
        return get_next_format_from_width(a1);
      }
      else
      {
        *a1 = v4;
        return 24;
      }
    }
  }
}

uint64_t get_next_format_from_width(char **a1)
{
  char *v2;

  v2 = *a1;
  if (**a1 != 46)
    goto LABEL_8;
  if (*++v2 != 42)
  {
    while (isdigit(*v2))
      ++v2;
    if (!*v2)
    {
      *a1 = v2;
      return 24;
    }
LABEL_8:
    *a1 = v2;
    return get_next_format_from_precision(a1);
  }
  *a1 = v2;
  return 22;
}

uint64_t get_next_format_from_precision(char **a1)
{
  unint64_t v2;
  char *v3;

  v3 = *a1;
  v2 = (**a1 - 76);
  if (v2 <= 0x2E)
    __asm { BR              X8 }
  if (*v3)
  {
    if (_platform_strchr("diouxX", *v3))
      JUMPOUT(0x3AC28);
    if (*v3 == 110)
      JUMPOUT(0x3AD74);
    if (_platform_strchr("DOU", *v3))
    {
      *a1 = v3;
      return 4;
    }
    else if (_platform_strchr("aAeEfFgG", *v3))
    {
      *a1 = v3;
      return 17;
    }
    else
    {
      switch(*v3)
      {
        case 'c':
          *a1 = v3;
          return 2;
        case 'C':
          *a1 = v3;
          return 3;
        case 's':
          *a1 = v3;
          return 19;
        case 'S':
          *a1 = v3;
          return 20;
        case 'p':
          *a1 = v3;
          return 4;
        default:
          *a1 = v3;
          return 24;
      }
    }
  }
  else
  {
    *a1 = v3;
    return 24;
  }
}

int fmtmsg(uint64_t a1, const char *a2, int a3, const char *a4, const char *a5, const char *a6)
{
  char *__filename;
  stat v8;
  int v9;
  char *v10;
  char *v11;
  char *v12;
  FILE *v13;
  const char *v14;
  const char *v15;
  const char *v16;
  int v17;
  const char *v18;
  uint64_t v19;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  if (!a5)
    v15 = (const char *)&unk_D495D;
  if ((v19 & 0x100) == 0)
    goto LABEL_20;
  v12 = getenv("MSGVERB");
  if (!v12 || !*v12 || (unint64_t)_platform_strlen(v12) > 0x1E)
    goto LABEL_12;
  v11 = strdup(v12);
  if (v11)
  {
    if (validmsgverb((uint64_t)v11))
    {
LABEL_14:
      v10 = printfmt((uint64_t)v11, v19, (uint64_t)v18, v17, (uint64_t)v16, (uint64_t)v15, (uint64_t)v14);
      if (!v10)
      {
        free(v11);
        return 3;
      }
      if (*v10 && fprintf(__stderrp, "%s", v10) < 0)
        v9 = 1;
      free(v11);
      free(v10);
LABEL_20:
      if ((v19 & 0x200) != 0)
      {
        v10 = printfmt((uint64_t)"label:severity:text:action:tag", v19, (uint64_t)v18, v17, (uint64_t)v16, (uint64_t)v15, (uint64_t)v14);
        if (!v10)
          return 2;
        if (*v10)
        {
          _platform_memset(&v8, 0, 144);
          __filename = "/dev/console";
          if (!stat("/var/log/console", &v8) && (v8.st_mode & 0xF000) == 0x4000)
            __filename = "/var/log/console";
          v13 = fopen(__filename, "a");
          if (v13)
          {
            fprintf(v13, "%s", v10);
            fclose(v13);
          }
          else if (v9)
          {
            v9 = 3;
          }
          else
          {
            v9 = 2;
          }
        }
        free(v10);
      }
      return v9;
    }
    free(v11);
LABEL_12:
    v11 = strdup("label:severity:text:action:tag");
    if (!v11)
      return 3;
    goto LABEL_14;
  }
  return 3;
}

BOOL validmsgverb(uint64_t a1)
{
  int v2;
  int i;
  char *v4;

  v2 = 0;
  while (1)
  {
    v4 = nextcomp(a1);
    if (!v4)
      break;
    --v2;
    for (i = 0; validlist[i]; ++i)
    {
      if (!_platform_strcmp(v4, validlist[i]))
        ++v2;
    }
  }
  return v2 == 0;
}

_BYTE *printfmt(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  _BYTE *v10;
  char *v11;
  uint64_t v12;

  v12 = 32;
  if (a3)
    v12 = _platform_strlen(a3) + 32;
  v9 = sevinfo(a4);
  if (v9)
    v12 += _platform_strlen(v9);
  if (a5)
    v12 += _platform_strlen(a5);
  if (a6)
    v12 += _platform_strlen(a6);
  if (a7)
    v12 += _platform_strlen(a7);
  v10 = (_BYTE *)malloc_type_malloc(v12, 2524615413);
  if (!v10)
    return 0;
  *v10 = 0;
  while (1)
  {
    v11 = nextcomp(a1);
    if (!v11)
      break;
    if (_platform_strcmp(v11, "label") || !a3)
    {
      if (_platform_strcmp(v11, "severity") || !v9)
      {
        if (_platform_strcmp(v11, "text") || !a5)
        {
          if (_platform_strcmp(v11, "action") || !a6)
          {
            if (!_platform_strcmp(v11, "tag") && a7)
            {
              if (*v10)
                _platform_strlcat(v10, " ", v12);
              _platform_strlcat(v10, a7, v12);
            }
          }
          else
          {
            if (*v10)
              _platform_strlcat(v10, "\n", v12);
            _platform_strlcat(v10, "TO FIX: ", v12);
            _platform_strlcat(v10, a6, v12);
          }
        }
        else
        {
          if (*v10)
            _platform_strlcat(v10, ": ", v12);
          _platform_strlcat(v10, a5, v12);
        }
      }
      else
      {
        if (*v10)
          _platform_strlcat(v10, ": ", v12);
        v7 = sevinfo(a4);
        _platform_strlcat(v10, v7, v12);
      }
    }
    else
    {
      if (*v10)
        _platform_strlcat(v10, ": ", v12);
      _platform_strlcat(v10, a3, v12);
    }
  }
  if (*v10)
    _platform_strlcat(v10, "\n", v12);
  return v10;
}

uint64_t sevinfo(int a1)
{
  unint64_t v2;

  v2 = (a1 - 1);
  if (v2 <= 3)
    __asm { BR              X8 }
  return 0;
}

char *nextcomp(uint64_t a1)
{
  char *v2;

  if (nextcomp_lmsgverb)
  {
    v2 = strtok_r(0, ":", &nextcomp_state);
  }
  else
  {
    _platform_strlcpy(&nextcomp_lmsgverb, a1, 31);
    v2 = strtok_r(&nextcomp_lmsgverb, ":", &nextcomp_state);
  }
  if (!v2)
    nextcomp_lmsgverb = 0;
  return v2;
}

int fnmatch(const char *a1, const char *a2, int a3)
{
  char v3;
  char v4;
  uint64_t v5;
  _xlocale *v7;
  _xlocale *v12;
  mbstate_t v13;
  mbstate_t v14;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v12 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v5 = __locale_key;
    v12 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
  }
  if (v12)
    v7 = v12;
  else
    v7 = (_xlocale *)__global_locale;
  j___platform_memmove(&v14, &fnmatch_initial, 128);
  j___platform_memmove(&v13, &fnmatch_initial, 128);
  return fnmatch1((char *)a1, (char *)a2, (char *)a2, a3, &v14, &v13, v7, 64);
}

uint64_t fnmatch1(char *a1, char *a2, char *a3, int a4, mbstate_t *a5, mbstate_t *a6, _xlocale *a7, int a8)
{
  int v8;
  wint_t v10;
  int v11;
  BOOL v12;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  wint_t v19;
  wint_t v20;
  char i;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  int v26;
  locale_t v27;
  mbstate_t *v28;
  mbstate_t *v29;
  int v30;
  char *v31;
  char *v32;
  char *v33;
  mbstate_t v35;
  _BYTE v36[128];

  v33 = a1;
  v32 = a2;
  v31 = a3;
  v30 = a4;
  v29 = a5;
  v28 = a6;
  v27 = a7;
  v26 = a8;
  _platform_memset(v36, 0, 128);
  _platform_memset(&v35, 0, 128);
  v23 = 0;
  v22 = 0;
  i = 0;
  v20 = 0;
  v19 = 0;
  v24 = 0;
  v25 = 0;
  v8 = v26--;
  if (v8 <= 0)
    return 2;
  while (1)
  {
    while (1)
    {
      v17 = mbrtowc_l(&v20, v33, 6uLL, a5, v27);
      if (v17 >= 0xFFFFFFFFFFFFFFFELL)
        return 2;
      v33 += v17;
      v15 = mbrtowc_l(&v19, v32, 6uLL, a6, v27);
      if (v15 >= 0xFFFFFFFFFFFFFFFELL)
      {
        v19 = *v32;
        v15 = 1;
        _platform_memset(a6, 0, 128);
      }
      if (!v20)
      {
        if ((v30 & 8) != 0 && v19 == 47)
          return 0;
        if (!v19)
          return 0;
        goto LABEL_77;
      }
      if (v20 == 42)
        break;
      if (v20 == 63)
      {
        if (!v19)
          return 1;
        if (v19 == 47 && (v30 & 2) != 0
          || v19 == 46 && (v30 & 4) != 0 && (v32 == v31 || (v30 & 2) != 0 && *(v32 - 1) == 47))
        {
          goto LABEL_77;
        }
        v32 += v15;
      }
      else if (v20 == 91)
      {
        if (!v19)
          return 1;
        if (v19 == 47 && (v30 & 2) != 0
          || v19 == 46 && (v30 & 4) != 0 && (v32 == v31 || (v30 & 2) != 0 && *(v32 - 1) == 47))
        {
          goto LABEL_77;
        }
        v11 = rangematch(v33, v19, &v32[v15], v30, &v23, &v22, a5, a6, v27);
        switch(v11)
        {
          case -1:
            return 2;
          case 0:
            goto LABEL_77;
          case 1:
            v33 = v23;
            v32 = v22;
            break;
        }
      }
      else
      {
        if (v20 == 92 && (v30 & 1) == 0)
        {
          v18 = mbrtowc_l(&v20, v33, 6uLL, a5, v27);
          if (v18 >= 0xFFFFFFFFFFFFFFFELL)
            return 2;
          if (!v18)
            v20 = 92;
          v33 += v18;
        }
        v32 += v15;
        if (v20 != v19)
        {
          if ((v30 & 0x10) == 0 || (v10 = towlower_l(v20, v27), v10 != towlower_l(v19, v27)))
          {
LABEL_77:
            if (!v25)
              return 1;
            v16 = mbrtowc(&v19, v24, 6uLL, &v35);
            if (v16 >= 0xFFFFFFFFFFFFFFFELL)
            {
              v19 = *v24;
              v16 = 1;
              _platform_memset(&v35, 0, 128);
            }
            if (!v19)
              return 1;
            if (v19 == 47 && (v30 & 2) != 0)
              return 1;
            v24 += v16;
            v33 = v25;
            j___platform_memmove(a5, v36, 128);
            v32 = v24;
            j___platform_memmove(a6, &v35, 128);
          }
        }
      }
    }
    for (i = *v33; i == 42; i = *v33)
      ++v33;
    if (v19 == 46 && (v30 & 4) != 0 && (v32 == v31 || (v30 & 2) != 0 && *(v32 - 1) == 47))
      goto LABEL_77;
    if (!i)
      break;
    if (i == 47 && (v30 & 2) != 0)
    {
      v32 = (char *)_platform_strchr(v32, 47);
      if (!v32)
        return 1;
    }
    else
    {
      v25 = v33;
      j___platform_memmove(v36, a5, 128);
      v24 = v32;
      j___platform_memmove(&v35, a6, 128);
    }
  }
  if ((v30 & 2) != 0)
  {
    v12 = 1;
    if ((v30 & 8) == 0)
      v12 = _platform_strchr(v32, 47) == 0;
    return !v12;
  }
  else
  {
    return 0;
  }
}

uint64_t rangematch(char *a1, wint_t a2, const char *a3, int a4, _QWORD *a5, char **a6, mbstate_t *a7, mbstate_t *a8, _xlocale *a9)
{
  int *v9;
  size_t v10;
  wint_t v12;
  char *v13;
  _BOOL4 v14;
  wctype_t v15;
  int v16;
  __int32 v17;
  int *v18;
  const char *v19;
  char *i;
  char *v21;
  unint64_t v22;
  size_t v23;
  size_t v24;
  wint_t v25;
  wint_t v26;
  unsigned int v27;
  int v28;
  int v29;
  locale_t v30;
  mbstate_t *v31;
  mbstate_t *v32;
  char **v33;
  _QWORD *v34;
  int v35;
  char *v36;
  wint_t v37;
  char *v38;
  char v40[15];
  _BYTE v41[128];
  wint_t v42;
  int v43;

  v38 = a1;
  v37 = a2;
  v36 = (char *)a3;
  v35 = a4;
  v34 = a5;
  v33 = a6;
  v32 = a7;
  v31 = a8;
  v30 = a9;
  v29 = 0;
  v28 = 0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  i = 0;
  v19 = 0;
  _platform_memset(v41, 0, 128);
  v14 = 1;
  if (*v38 != 33)
    v14 = *v38 == 94;
  v29 = v14;
  if (v14)
    ++v38;
  if ((v35 & 0x10) != 0)
    v37 = towlower_l(v37, v30);
  v28 = 0;
  v21 = v38;
  while (1)
  {
    v26 = 0;
    if (*v38 == 93 && v38 > v21)
      break;
    if (!*v38)
      return -1;
    if (*v38 == 47 && (v35 & 2) != 0)
      return 0;
    if (*v38 != 92 || (v35 & 1) != 0)
    {
      if (*v38 != 91)
        goto LABEL_74;
      v27 = v38[1];
      if (v27 != 46 && v27 != 61 && v27 != 58)
        goto LABEL_74;
      v38 += 2;
      for (i = v38; ; ++i)
      {
        i = (char *)_platform_strchr(i, v27);
        if (!i || i[1] == 93)
          break;
      }
      if (!i)
        return -1;
      if (v27 == 46)
      {
LABEL_29:
        v22 = __collate_collating_symbol(&v42, 0x18uLL, v38, i - v38, v32, v30);
        if (v22 == -1 || !v22)
          return -1;
        v38 = i + 2;
        if (v22 <= 1)
        {
          v26 = v42;
          goto LABEL_74;
        }
        v18 = 0;
        v17 = 0;
        if (i[2] == 45 && i[3] && i[3] != 93)
          return -1;
        v18 = &v43;
        if (v37 == v42)
        {
          j___platform_memmove(v41, v31, 128);
          v19 = v36;
          while (--v22)
          {
            v23 = mbrtowc_l(&v17, v36, 6uLL, v31, v30);
            if (v23 >= 0xFFFFFFFFFFFFFFFELL)
            {
              v17 = *v36;
              v23 = 1;
              v31 = 0;
            }
            v9 = v18++;
            if (v17 != *v9)
            {
              j___platform_memmove(v31, v41, 128);
              v36 = (char *)v19;
              break;
            }
            v36 += v23;
          }
          if (!v22)
          {
            v28 = 1;
            break;
          }
        }
      }
      else if (v27 == 61)
      {
        j___platform_memmove(v41, v32, 128);
        v16 = __collate_equiv_class(v38, i - v38, v32, v30);
        if (v16 < 0)
          return -1;
        if (!v16)
        {
          j___platform_memmove(v32, v41, 128);
          goto LABEL_29;
        }
        v38 = i + 2;
        if (i[2] == 45 && i[3] && i[3] != 93)
          return -1;
        v12 = v37;
        v13 = v36;
        v10 = _platform_strlen(v36);
        v22 = __collate_equiv_match(v16, 0, 0, v12, v13, v10, v31, &v23, v30);
        if (v22 == -1)
          return -1;
        if (v22)
        {
          v28 = 1;
          v36 += v23;
          break;
        }
      }
      else
      {
        if (i[2] == 45 && i[3] && i[3] != 93)
          return -1;
        if (i - v38 > 14)
          return -1;
        _platform_strlcpy(v40, v38, i - v38 + 1);
        v38 = i + 2;
        v15 = wctype(v40);
        if (!v15)
          return -1;
        if (iswctype_l(v37, v15, v30))
        {
          v28 = 1;
          break;
        }
      }
    }
    else
    {
      ++v38;
LABEL_74:
      if (!v26)
      {
        v24 = mbrtowc_l(&v26, v38, 6uLL, v32, v30);
        if (v24 >= 0xFFFFFFFFFFFFFFFELL)
          return -1;
        v38 += v24;
      }
      if ((v35 & 0x10) != 0)
        v26 = towlower_l(v26, v30);
      if (*v38 == 45 && v38[1] && v38[1] != 93)
      {
        if (*++v38 == 92 && (v35 & 1) == 0 && *v38)
          ++v38;
        v24 = mbrtowc_l(&v25, v38, 6uLL, v32, v30);
        if (v24 >= 0xFFFFFFFFFFFFFFFELL)
          return -1;
        v38 += v24;
        if (!v25)
          return -1;
        if (v25 == 91 && (v27 = *v38, v27 == 46) || v27 == 61 || v27 == 58)
        {
          if (v27 == 61 || v27 == 58)
            return -1;
          for (i = ++v38; ; ++i)
          {
            i = (char *)_platform_strchr(i, v27);
            if (!i || i[1] == 93)
              break;
          }
          if (!i)
            return -1;
          v22 = __collate_collating_symbol(&v42, 0x18uLL, v38, i - v38, v32, v30);
          if (v22 != 1)
            return -1;
          v38 = i + 2;
          v25 = v42;
        }
        if ((v35 & 0x10) != 0)
          v25 = towlower_l(v25, v30);
        if (*(_BYTE *)(*((_QWORD *)v30 + 165) + 64))
        {
          if (v26 <= v37 && v37 <= v25)
            goto LABEL_115;
        }
        else if ((int)__collate_range_cmp(v26, v37, v30) <= 0 && (int)__collate_range_cmp(v37, v25, v30) <= 0)
        {
LABEL_115:
          v28 = 1;
          break;
        }
      }
      else if (v26 == v37)
      {
        v28 = 1;
        break;
      }
    }
  }
  v27 = 0;
  while (*v38 != 93)
  {
    if (!*v38)
      return -1;
    if (*v38 == v27)
    {
      if (*++v38 == 93)
      {
        v27 = 0;
        ++v38;
      }
    }
    else if (v27 || *v38 != 91)
    {
      v24 = mbrtowc_l(&v26, v38, 6uLL, v32, v30);
      if (v24 >= 0xFFFFFFFFFFFFFFFELL)
        return -1;
      v38 += v24;
    }
    else
    {
      v27 = *++v38;
      if (v27 == 46 || v27 == 61 || v27 == 58)
        ++v38;
      else
        v27 = 0;
    }
  }
  *v34 = ++v38;
  *v33 = v36;
  return v28 != v29;
}

key_t ftok(const char *a1, int a2)
{
  stat v3;
  int v4;
  const char *v5;

  v5 = a1;
  v4 = a2;
  _platform_memset(&v3, 0, 144);
  if (stat(v5, &v3) >= 0)
    return (LOBYTE(v3.st_dev) << 16) | (v4 << 24) | LOWORD(v3.st_ino);
  else
    return -1;
}

char *__cdecl getbsize(int *a1, uint64_t *a2)
{
  int v2;
  char *result;
  int v4;
  const char *v5;
  char *__str;
  char *__endptr;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  int *v13;

  v13 = a1;
  v12 = a2;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  __endptr = 0;
  v5 = (const char *)&unk_D495D;
  __str = getenv("BLOCKSIZE");
  if (!__str || !*__str)
  {
    v11 = 512;
    v8 = 512;
    goto LABEL_27;
  }
  v11 = strtol(__str, &__endptr, 10);
  if (v11 < 0)
  {
LABEL_24:
    warnx("minimum blocksize is 512");
    v5 = (const char *)&unk_D495D;
    v11 = 512;
    v8 = 512;
    goto LABEL_27;
  }
  if (!v11)
    v11 = 1;
  if (*__endptr && __endptr[1])
    goto LABEL_20;
  v4 = *__endptr;
  if (!*__endptr)
  {
    v10 = 0x40000000;
    v9 = 1;
    goto LABEL_21;
  }
  switch(v4)
  {
    case 'G':
      goto LABEL_16;
    case 'K':
LABEL_17:
      v5 = "K";
      v10 = 0x100000;
      v9 = 1024;
      goto LABEL_21;
    case 'M':
LABEL_18:
      v5 = "M";
      v10 = 1024;
      v9 = 0x100000;
      goto LABEL_21;
    case 'g':
LABEL_16:
      v5 = "G";
      v10 = 1;
      v9 = 0x40000000;
      goto LABEL_21;
    case 'k':
      goto LABEL_17;
    case 'm':
      goto LABEL_18;
  }
LABEL_20:
  warnx("%s: unknown blocksize", __str);
  v11 = 512;
  v10 = 0x40000000;
  v9 = 1;
LABEL_21:
  if (v11 > v10)
  {
    warnx("maximum blocksize is %ldG", 1);
    v11 = v10;
  }
  v8 = v11 * v9;
  if (v11 * v9 < 512)
    goto LABEL_24;
LABEL_27:
  snprintf(getbsize_header, 0x14uLL, "%ld%s-blocks", v11, v5);
  v2 = _platform_strlen(getbsize_header);
  result = getbsize_header;
  *v13 = v2;
  *v12 = v8;
  return result;
}

int cgetset(const char *a1)
{
  if (a1)
  {
    topreclen = _platform_strlen(a1);
    toprec = malloc_type_malloc(topreclen + 1, 3559635578);
    if (toprec)
    {
      gottoprec = 0;
      _platform_strcpy(toprec, a1);
      return 0;
    }
    else
    {
      *__error() = 12;
      return -1;
    }
  }
  else
  {
    if (toprec)
      free((void *)toprec);
    toprec = 0;
    topreclen = 0;
    return 0;
  }
}

char *__cdecl cgetcap(char *a1, const char *a2, int a3)
{
  char *v3;
  BOOL v6;
  const char *i;
  char *v9;

  do
  {
    while (1)
    {
      while (1)
      {
        if (!*a1)
          return 0;
        v3 = a1++;
        if (*v3 == 58)
        {
          for (i = a2; ; ++i)
          {
            v6 = 0;
            if (*i == *a1)
              v6 = *a1 != 0;
            if (!v6)
              break;
            ++a1;
          }
          if (!*i)
            break;
        }
      }
      if (*a1 == 64)
        return 0;
      if (a3 != 58)
        break;
      if (!*a1 || *a1 == 58)
        return a1;
    }
  }
  while (*a1 != a3);
  v9 = a1 + 1;
  if (*v9 == 64)
    return 0;
  else
    return v9;
}

int cgetent(char **a1, char **a2, const char *a3)
{
  char v3;
  char v4;
  int v9;
  const char *v10;
  char **v11;
  char **v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t StatusReg;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = 0;
  v13 = 0;
  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v13 = pthread_getspecific(__locale_key);
  }
  else
  {
    v14 = __locale_key;
    v15 = __locale_key;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v13 = *(void **)(StatusReg + 8 * v15);
  }
  if (v13)
    return getent(a1, &v9, (const char **)a2, -1, (char *)a3, 0, 0, (uint64_t)v13);
  else
    return getent(a1, &v9, (const char **)a2, -1, (char *)a3, 0, 0, (uint64_t)__global_locale);
}

uint64_t getent(_QWORD *a1, _DWORD *a2, const char **a3, int a4, char *a5, int a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  _BYTE *v13;
  _BYTE *v14;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  char *v21;
  char *v22;
  void *v23;
  int v24;
  int v25;
  int v26;
  void *v27[2];
  void *v28;
  size_t __size;
  int v30;
  int NOCANCEL;
  int v32;
  char *v33;
  char *v34;
  int v35;
  void *v36;
  char *__s1;
  int v38;
  int v39;
  int v40;
  int v41;
  const char **v42;
  char *v43;
  char *v44;
  DB *v45;
  uint64_t v46;
  uint64_t v47;
  int v48;
  char *v49;
  int v50;
  const char **v51;
  _DWORD *v52;
  _QWORD *v53;
  char v55[1024];
  char __str[256];

  v53 = a1;
  v52 = a2;
  v51 = a3;
  v50 = a4;
  v49 = a5;
  v48 = a6;
  v47 = a7;
  v46 = a8;
  v45 = 0;
  v44 = 0;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  __s1 = 0;
  v36 = 0;
  v35 = 0;
  if (a6 > 32)
    return -3;
  if (!v48 && toprec && !cgetmatch((const char *)toprec, v49))
  {
    __s1 = (char *)malloc_type_malloc(topreclen + 1024, 2967267763);
    if (__s1)
    {
      _platform_strcpy(__s1, toprec);
      v41 = 0;
      v42 = v51;
      v43 = &__s1[topreclen + 1];
      v44 = &__s1[topreclen + 1025];
LABEL_59:
      v28 = 0;
      memset(v27, 0, sizeof(v27));
      v26 = 0;
      v25 = 0;
      v24 = 0;
      v23 = 0;
      v35 = 0;
      v12 = cgetcap(__s1, "tc", 61);
      while (v12)
      {
        v27[1] = v12;
        while (*(_BYTE *)v27[1])
        {
          v13 = v27[1]++;
          if (*v13 == 58)
          {
            *((_BYTE *)v27[1] - 1) = 0;
            break;
          }
        }
        v22 = v12 - 3;
        v24 = LODWORD(v27[1]) - ((_DWORD)v12 - 3);
        v21 = (char *)v27[1];
        v25 = getent(&v23, v27, v42, v50, v12, (v48 + 1), 0, v46, v16);
        v28 = v23;
        HIDWORD(v27[0]) = v27[0];
        if (!v25)
          goto LABEL_75;
        if (v25 < -1)
        {
          if (v41)
            close_NOCANCEL(v50);
          free(__s1);
          return v25;
        }
        if (v25 == 1)
          v35 = 1;
        if (v25 == -1)
        {
          *((_BYTE *)v27[1] - 1) = 58;
          v35 = 1;
          v12 = cgetcap((char *)v27[1] - 1, "tc", 61);
        }
        else
        {
LABEL_75:
          v27[1] = v28;
          do
          {
            if (!*(_BYTE *)v27[1])
              break;
            v14 = v27[1]++;
          }
          while (*v14 != 58);
          HIDWORD(v27[0]) -= LODWORD(v27[1]) - (_DWORD)v28;
          v28 = v27[1];
          v27[1] = (char *)v27[1] + SHIDWORD(v27[0]);
          if (*((_BYTE *)v27[1] - 1) != 58)
          {
            *(_BYTE *)v27[1] = 58;
            ++HIDWORD(v27[0]);
          }
          v26 = HIDWORD(v27[0]) - v24;
          if (HIDWORD(v27[0]) - v24 >= v44 - v43)
          {
            v20 = (_DWORD)v43 - (_DWORD)__s1;
            v17 = v44 - __s1 + v26 + 1024;
            v19 = (_DWORD)v22 - (_DWORD)__s1;
            v18 = (_DWORD)v21 - (_DWORD)__s1;
            __s1 = (char *)reallocf(__s1, v17);
            if (!__s1)
            {
              *__error() = 12;
              if (v41)
                close_NOCANCEL(v50);
              free(v23);
              return -2;
            }
            v44 = &__s1[v17];
            v43 = &__s1[v20];
            v22 = &__s1[v19];
            v21 = &__s1[v18];
          }
          v27[1] = &v22[SHIDWORD(v27[0])];
          bcopy(v21, v27[1], v43 - v21);
          bcopy(v28, v22, SHIDWORD(v27[0]));
          v43 += v26;
          free(v23);
          v12 = cgetcap((char *)v27[1] - 1, "tc", 61);
        }
      }
      if (v41)
        close_NOCANCEL(v50);
      *v52 = (_DWORD)v43 - (_DWORD)__s1 - 1;
      if (v44 <= v43 || (__s1 = (char *)reallocf(__s1, v43 - __s1)) != 0)
      {
        *v53 = __s1;
        return v35 != 0;
      }
      else
      {
        *__error() = 12;
        return -2;
      }
    }
LABEL_7:
    *__error() = 12;
    return -2;
  }
  __s1 = (char *)malloc_type_malloc(1024, 2483994589);
  if (!__s1)
    goto LABEL_7;
  v44 = __s1 + 1024;
  v39 = 0;
  v42 = v51;
LABEL_11:
  if (*v42)
  {
    v40 = 0;
    if (v50 < 0)
    {
      snprintf(__str, 0x100uLL, "%s.db", *v42);
      v45 = dbopen(__str, 0, 0, DB_HASH, 0);
      if (v45)
      {
        free(__s1);
        v38 = cdbget((uint64_t)v45, &__s1, v49);
        if (v38 >= 0)
        {
          v36 = strdup(__s1);
          if (((int (*)(DB *))v45->close)(v45) >= 0)
          {
            if (v36)
            {
              v8 = _platform_strlen(v36);
              *v52 = v8;
              *v53 = v36;
              return v38;
            }
            else
            {
              *__error() = 12;
              return -2;
            }
          }
          else
          {
            free(v36);
            return -2;
          }
        }
        else
        {
          ((void (*)(DB *))v45->close)(v45);
          return v38;
        }
      }
      v16 = 0;
      v50 = open_NOCANCEL(*v42, 0);
      if (v50 < 0)
        goto LABEL_56;
      v41 = 1;
    }
    else
    {
      lseek(v50, 0, 0);
      v41 = 0;
    }
    v32 = 0;
    v34 = v55;
    v33 = v55;
LABEL_25:
    v43 = __s1;
    while (1)
    {
      if (v33 >= v34)
      {
        NOCANCEL = read_NOCANCEL(v50, v55, 1024);
        if (NOCANCEL <= 0)
        {
          if (v41)
            close_NOCANCEL(v50);
          if (NOCANCEL < 0)
          {
            free(__s1);
            return -2;
          }
          v50 = -1;
          v40 = 1;
LABEL_46:
          v11 = v43++;
          *v11 = 0;
          if (!v40)
          {
            if (!*__s1 || *__s1 == 35 || cgetmatch(__s1, v49) || v47 && nfcmp(v47, __s1))
              goto LABEL_25;
            v39 = 1;
          }
          if (v39)
            break;
LABEL_56:
          ++v42;
          goto LABEL_11;
        }
        v34 = &v55[NOCANCEL];
        v33 = v55;
      }
      v9 = v33++;
      v32 = *v9;
      if (v32 == 10)
      {
        if (v43 <= __s1 || *(v43 - 1) != 92)
          goto LABEL_46;
        --v43;
      }
      else
      {
        v10 = v43++;
        *v10 = v32;
        if (v43 >= v44)
        {
          v30 = (_DWORD)v43 - (_DWORD)__s1;
          __size = v44 - __s1 + 1024;
          __s1 = (char *)reallocf(__s1, __size);
          if (!__s1)
          {
            *__error() = 12;
            if (v41)
              close_NOCANCEL(v50);
            return -2;
          }
          v44 = &__s1[__size];
          v43 = &__s1[v30];
        }
      }
    }
  }
  if (v39)
    goto LABEL_59;
  free(__s1);
  return -1;
}

int cgetmatch(const char *a1, const char *a2)
{
  const char *v2;
  const char *v3;
  const char *v4;
  const char *v7;

  if (!a2 || !*a2)
    return -1;
LABEL_4:
  v7 = a2;
  while (*v7)
  {
    v2 = a1++;
    v3 = v7++;
    if (*v2 != *v3)
      goto LABEL_12;
  }
  if (*a1 == 124 || *a1 == 58 || !*a1)
    return 0;
LABEL_12:
  --a1;
  while (*a1 && *a1 != 58)
  {
    v4 = a1++;
    if (*v4 == 124)
      goto LABEL_4;
  }
  return -1;
}

int cgetfirst(char **a1, char **a2)
{
  cgetclose();
  return cgetnext(a1, a2);
}

int cgetclose(void)
{
  int result;

  if (pfp)
  {
    fclose((FILE *)pfp);
    pfp = 0;
  }
  dbp = 0;
  result = 0;
  gottoprec = 0;
  slash = 0;
  return result;
}

int cgetnext(char **a1, char **a2)
{
  char v2;
  char v3;
  char *v4;
  char v5;
  char *v6;
  char v7;
  char *v8;
  _xlocale *v10;
  int v11;
  char *v12;
  char *v13;
  char *v14;
  char *i;
  int v16;
  int v17;
  int v18;
  int v19;
  size_t v20;
  char **v21;
  char **v22;
  _xlocale *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t StatusReg;
  _BYTE v28[1024];
  char v29[1024];

  v22 = a1;
  v21 = a2;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  i = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v24 = 0;
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v24 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v25 = __locale_key;
    v26 = __locale_key;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v24 = *(_xlocale **)(StatusReg + 8 * v26);
  }
  if (v24)
    v10 = v24;
  else
    v10 = (_xlocale *)__global_locale;
  if (!dbp)
    dbp = (uint64_t)v21;
  if (pfp || (pfp = (uint64_t)fopen(*(const char **)dbp, "r")) != 0)
  {
    while (1)
    {
      while (1)
      {
        while (1)
        {
          if (toprec && !gottoprec)
          {
            gottoprec = 1;
            v14 = (char *)toprec;
            goto LABEL_37;
          }
          v14 = fgetln((FILE *)pfp, &v20);
          if (v14 || !pfp)
            break;
          v18 = ferror((FILE *)pfp);
          if (v18)
            v17 = *__error();
          fclose((FILE *)pfp);
          pfp = 0;
          if (v18)
          {
            cgetclose();
            *__error() = v17;
            return -1;
          }
          dbp += 8;
          if (!*(_QWORD *)dbp)
          {
            cgetclose();
            return 0;
          }
          pfp = (uint64_t)fopen(*(const char **)dbp, "r");
          if (!pfp)
          {
            cgetclose();
            return -1;
          }
        }
        v14[v20 - 1] = 0;
        if (v20 != 1)
          break;
        slash = 0;
      }
      if (!isspace_l(*v14, v10) && *v14 != 58 && *v14 != 35 && !slash)
        break;
      slash = v14[v20 - 2] == 92;
    }
    slash = v14[v20 - 2] == 92;
LABEL_37:
    v19 = 0;
    v12 = v28;
    while (1)
    {
      for (i = v14; *i; ++i)
      {
        if (*i == 58)
        {
          v4 = v12++;
          *v4 = 58;
          v19 = 1;
          break;
        }
        if (*i == 92)
          break;
        v5 = *i;
        v6 = v12++;
        *v6 = v5;
      }
      if (v19)
      {
        *v12 = 0;
        v13 = v29;
        for (i = v28; *i && *i != 124 && *i != 58; ++i)
        {
          v7 = *i;
          v8 = v13++;
          *v8 = v7;
        }
        *v13 = 0;
        v16 = getent(v22, &v11, (const char **)v21, -1, v29, 0, 0, (uint64_t)v10);
        if (v16 == -2 || v16 == -3)
          cgetclose();
        return v16 + 1;
      }
      v14 = fgetln((FILE *)pfp, &v20);
      if (!v14)
      {
        if (pfp)
          break;
      }
      v14[v20 - 1] = 0;
    }
    v18 = ferror((FILE *)pfp);
    if (v18)
      v17 = *__error();
    fclose((FILE *)pfp);
    pfp = 0;
    cgetclose();
    if (v18)
      *__error() = v17;
    return -1;
  }
  else
  {
    cgetclose();
    return -1;
  }
}

int cgetstr(char *a1, const char *a2, char **a3)
{
  char *v3;
  _BYTE *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  unint64_t v14;
  BOOL v15;
  BOOL v16;
  uint64_t v17;
  int v18;
  char v19;
  char *__ptr;
  int v21;
  char *v22;
  _BYTE *v23;
  char *v24;
  _BYTE *v25;
  int v26;

  v24 = cgetcap(a1, a2, 61);
  if (!v24)
    return -1;
  __ptr = (char *)malloc_type_malloc(100, 3241893407);
  if (__ptr)
  {
    v26 = 100;
    v22 = __ptr;
    while (1)
    {
      v16 = 0;
      if (*v24 != 58)
        v16 = *v24 != 0;
      if (!v16)
        break;
      if (*v24 == 94)
      {
        v25 = v24 + 1;
        if (*v25 == 58 || !*v25)
          break;
        if (*v25 == 63)
        {
          v3 = v22++;
          *v3 = 127;
          v24 = v25 + 1;
        }
        else
        {
          v4 = v25;
          v24 = v25 + 1;
          v5 = v22++;
          *v5 = *v4 & 0x1F;
        }
      }
      else if (*v24 == 92)
      {
        if (*++v24 == 58 || !*v24)
          break;
        if (*v24 < 48 || *v24 > 55)
        {
          v8 = v24++;
          v14 = (*v8 - 66);
          if (v14 <= 0x32)
            __asm { BR              X8 }
          v9 = v22++;
          *v9 = *(v24 - 1);
        }
        else
        {
          v19 = 0;
          v18 = 3;
          do
          {
            v6 = v24++;
            v19 = *v6 - 48 + 8 * v19;
            --v18;
            v15 = 0;
            if (v18)
            {
              v15 = 0;
              if (*v24 >= 48)
                v15 = *v24 <= 55;
            }
          }
          while (v15);
          v7 = v22++;
          *v7 = v19;
        }
      }
      else
      {
        v10 = v24++;
        v11 = v22++;
        *v11 = *v10;
      }
      if (!--v26)
      {
        v17 = v22 - __ptr;
        __ptr = (char *)reallocf(__ptr, v22 - __ptr + 100);
        if (!__ptr)
          return -2;
        v26 = 100;
        v22 = &__ptr[v17];
      }
    }
    v12 = v22;
    v23 = v22 + 1;
    *v12 = 0;
    v21 = (_DWORD)v23 - (_DWORD)__ptr - 1;
    if (v26 == 1 || (__ptr = (char *)reallocf(__ptr, v23 - __ptr)) != 0)
    {
      *a3 = __ptr;
      return v21;
    }
    else
    {
      return -2;
    }
  }
  else
  {
    *__error() = 12;
    return -2;
  }
}

int cgetustr(char *a1, const char *a2, char **a3)
{
  char *v3;
  char *v4;
  char *v5;
  BOOL v7;
  uint64_t v8;
  char *__ptr;
  int v10;
  char *v11;
  _BYTE *v12;
  char *v13;
  int v14;

  v13 = cgetcap(a1, a2, 61);
  if (!v13)
    return -1;
  __ptr = (char *)malloc_type_malloc(100, 2822664131);
  if (__ptr)
  {
    v14 = 100;
    v11 = __ptr;
    while (1)
    {
      v7 = 0;
      if (*v13 != 58)
        v7 = *v13 != 0;
      if (!v7)
        break;
      v3 = v13++;
      v4 = v11++;
      *v4 = *v3;
      if (!--v14)
      {
        v8 = v11 - __ptr;
        __ptr = (char *)reallocf(__ptr, v11 - __ptr + 100);
        if (!__ptr)
          return -2;
        v14 = 100;
        v11 = &__ptr[v8];
      }
    }
    v5 = v11;
    v12 = v11 + 1;
    *v5 = 0;
    v10 = (_DWORD)v12 - (_DWORD)__ptr - 1;
    if (v14 == 1 || (__ptr = (char *)reallocf(__ptr, v12 - __ptr)) != 0)
    {
      *a3 = __ptr;
      return v10;
    }
    else
    {
      return -2;
    }
  }
  else
  {
    *__error() = 12;
    return -2;
  }
}

int cgetnum(char *a1, const char *a2, uint64_t *a3)
{
  char *v4;
  int v5;
  int v6;
  uint64_t v7;

  v4 = cgetcap(a1, a2, 35);
  if (v4)
  {
    if (*v4 == 48)
    {
      if (*++v4 == 120 || *v4 == 88)
      {
        ++v4;
        v6 = 16;
      }
      else
      {
        v6 = 8;
      }
    }
    else
    {
      v6 = 10;
    }
    v7 = 0;
    while (1)
    {
      if (*v4 < 48 || *v4 > 57)
      {
        if (*v4 < 97 || *v4 > 102)
        {
          if (*v4 < 65 || *v4 > 70)
          {
LABEL_22:
            *a3 = v7;
            return 0;
          }
          v5 = *v4 - 55;
        }
        else
        {
          v5 = *v4 - 87;
        }
      }
      else
      {
        v5 = *v4 - 48;
      }
      if (v5 >= v6)
        goto LABEL_22;
      v7 = v7 * v6 + v5;
      ++v4;
    }
  }
  return -1;
}

uint64_t cdbget(uint64_t a1, _QWORD *a2, const char *a3)
{
  int v4;
  char *v5;
  _BYTE *v6;
  uint64_t v7;
  char *v8;
  uint64_t i;
  const char *v10;
  _QWORD *v11;
  uint64_t v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v8 = 0;
  i = 0;
  v6 = 0;
  v7 = 0;
  v5 = strdup(a3);
  if (v5)
  {
    v8 = v5;
    for (i = _platform_strlen(v5); ; i = v7 - 1)
    {
      v4 = (*(uint64_t (**)(uint64_t, char **, _BYTE **, _QWORD))(v12 + 24))(v12, &v8, &v6, 0);
      if (v4 == -1)
      {
        free(v5);
        return -2;
      }
      if (v4 == 1)
      {
        free(v5);
        return -1;
      }
      if (*v6 != 2)
        break;
      v8 = v6 + 1;
    }
    *v11 = v6 + 1;
    free(v5);
    return *v6 == 1;
  }
  else
  {
    return -2;
  }
}

uint64_t nfcmp(uint64_t a1, _BYTE *a2)
{
  uint64_t result;
  char v3;
  _BYTE *i;

  for (i = a2; *i != 58; ++i)
    ;
  v3 = i[1];
  i[1] = 0;
  LODWORD(result) = _platform_strcmp(a1, a2);
  i[1] = v3;
  return result;
}

char *__private_getcwd(char *a1, uint64_t a2, int a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v9;
  unsigned int v10;
  int64_t v11;
  size_t v12;
  unsigned int v13;
  char *v14;
  int v15;
  int v16;
  size_t v17;
  __darwin_ino64_t st_ino;
  dev_t st_dev;
  stat v20;
  char *v21;
  int v22;
  __darwin_ino64_t v23;
  dev_t v24;
  DIR *v25;
  dirent *v26;
  int v27;
  uint64_t v28;
  char *v29;

  v29 = a1;
  v28 = a2;
  v27 = a3;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  _platform_memset(&v20, 0, 144);
  if (v29)
  {
    v17 = 0;
    if (!v28)
    {
      *__error() = 22;
      return 0;
    }
    if (v28 == 1)
    {
      *__error() = 34;
      return 0;
    }
    v14 = &v29[v28];
  }
  else
  {
    v17 = 1024;
    v29 = (char *)malloc_type_malloc(1024, 2855774719);
    if (!v29)
      return 0;
    v14 = v29 + 1024;
  }
  if (v27)
  {
    if (!__getcwd(v29, v14 - v29))
      return v29;
    if (*__error() == 34)
      return 0;
  }
  v21 = v14 - 1;
  *(v14 - 1) = 0;
  if (stat("/", &v20))
    goto LABEL_80;
  st_dev = v20.st_dev;
  st_ino = v20.st_ino;
  *__error() = 0;
  v22 = 1;
LABEL_17:
  if (v25)
  {
    v3 = dirfd(v25);
    if (fstat(v3, &v20))
      goto LABEL_80;
  }
  else if (lstat(".", &v20))
  {
    goto LABEL_80;
  }
  v23 = v20.st_ino;
  v24 = v20.st_dev;
  if (st_dev == v20.st_dev && st_ino == v23)
  {
    *--v21 = 47;
    bcopy(v21, v29, v14 - v21);
    if (v25)
      closedir(v25);
    return v29;
  }
  if (v25)
    v10 = dirfd(v25);
  else
    v10 = -2;
  v13 = openat_NOCANCEL(v10, "..", 0x1000000);
  if (v13 != -1)
  {
    if (v25)
      closedir(v25);
    v25 = fdopendir(v13);
    if (v25 && (v4 = dirfd(v25), !fstat(v4, &v20)))
    {
      v15 = 0;
      if (v20.st_dev == v24)
      {
        while (1)
        {
          v26 = readdir(v25);
          if (!v26)
            break;
          if (v26->d_ino == v23)
          {
LABEL_64:
            while (1)
            {
              v7 = v22 ? 1 : 2;
              if (v21 - v29 >= v26->d_namlen + v7)
                break;
              if (!v17)
              {
                *__error() = 34;
                goto LABEL_80;
              }
              v11 = v21 - v29;
              v12 = v14 - v21;
              v17 *= 2;
              v29 = (char *)reallocf(v29, v17);
              if (!v29)
                goto LABEL_80;
              v21 = &v29[v11];
              v14 = &v29[v17];
              bcopy(&v29[v11], &v29[v17 - v12], v12);
              v21 = &v14[-v12];
            }
            if (!v22)
              *--v21 = 47;
            v21 -= v26->d_namlen;
            bcopy(v26->d_name, v21, v26->d_namlen);
            v22 = 0;
            goto LABEL_17;
          }
          if ((v26->d_name[0] != 46 || v26->d_name[1] && (v26->d_name[1] != 46 || v26->d_name[2])) && v26->d_type == 4)
          {
            v5 = dirfd(v25);
            if (fstatat(v5, v26->d_name, &v20, 32))
            {
              if (!v15)
                v15 = *__error();
              *__error() = 0;
            }
            else if (v20.st_dev == v24 && v20.st_ino == v23)
            {
              goto LABEL_64;
            }
          }
        }
      }
      else
      {
        while (1)
        {
          v26 = readdir(v25);
          if (!v26)
            break;
          if (v26->d_name[0] != 46 || v26->d_name[1] && (v26->d_name[1] != 46 || v26->d_name[2]))
          {
            v6 = dirfd(v25);
            if (fstatat(v6, v26->d_name, &v20, 32))
            {
              if (!v15)
                v15 = *__error();
              *__error() = 0;
            }
            else if (v20.st_dev == v24 && v20.st_ino == v23)
            {
              goto LABEL_64;
            }
          }
        }
      }
      if (!*__error())
      {
        if (v15)
          v9 = v15;
        else
          v9 = 2;
        *__error() = v9;
      }
    }
    else
    {
      close_NOCANCEL(v13);
    }
  }
LABEL_80:
  v16 = *__error();
  if (v17)
    free(v29);
  if (v25)
    closedir(v25);
  *__error() = v16;
  return 0;
}

uint64_t __getcwd(const char *a1, unint64_t a2)
{
  unint64_t v2;
  _BYTE v4[1036];
  int v5;
  const char *v6;
  int v7;
  int v8;
  uint64_t v9;
  const char *v10;
  stat v11;
  stat v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  unint64_t v16;
  const char *v17;

  v17 = a1;
  v16 = a2;
  v8 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v9 = 144;
  _platform_memset(&v12, 0, 144);
  _platform_memset(&v11, 0, 144);
  v10 = 0;
  v15 = open_NOCANCEL(".", 0x1000000);
  if ((v15 & 0x80000000) == 0)
  {
    if (fstat(v15, &v12) >= 0)
    {
      if (v12.st_dev && v12.st_ino)
      {
        if (v16 >= 0x400)
        {
          v10 = v17;
        }
        else
        {
          v6 = v4;
          _platform_bzero(v4, 1024);
          v10 = v6;
          if (!v6)
          {
            close_NOCANCEL(v15);
            *__error() = 12;
            return -1;
          }
        }
        v14 = fcntl_NOCANCEL(v15, 50);
        if (v14)
        {
          v13 = *__error();
          close_NOCANCEL(v15);
          v5 = v13;
          *__error() = v5;
          return v14;
        }
        else
        {
          close_NOCANCEL(v15);
          if (stat(v10, &v11) >= 0)
          {
            if (v12.st_dev == v11.st_dev && v12.st_ino == v11.st_ino)
            {
              if (v16 < 0x400)
              {
                v2 = _platform_strlen(v10);
                if (v2 >= v16)
                {
                  *__error() = 34;
                  return -1;
                }
                _platform_strcpy(v17, v10);
              }
              return 0;
            }
            *__error() = 22;
            return -1;
          }
          else
          {
            return -1;
          }
        }
      }
      else
      {
        close_NOCANCEL(v15);
        *__error() = 22;
        return -1;
      }
    }
    else
    {
      v13 = *__error();
      close_NOCANCEL(v15);
      v7 = v13;
      *__error() = v7;
      return -1;
    }
  }
  else
  {
    return -1;
  }
}

char *__cdecl getcwd(char *a1, size_t a2)
{
  return __private_getcwd(a1, a2, 1);
}

int gethostname(char *a1, size_t a2)
{
  size_t v3;
  size_t v4;
  void *v5;
  _BYTE v7[257];
  int v8[2];

  v5 = a1;
  v4 = a2;
  v8[0] = 1;
  v8[1] = 10;
  if (a2 < 0x101)
  {
    v3 = 257;
    if (sysctl(v8, 2u, v7, &v3, 0, 0) == -1)
    {
      if (*__error() == 12)
        *__error() = 63;
      return -1;
    }
    _platform_strncpy(v5, v7, v4);
    *((_BYTE *)v5 + v4 - 1) = 0;
    return 0;
  }
  if (sysctl(v8, 2u, v5, &v4, 0, 0) != -1)
    return 0;
  if (*__error() == 12)
    *__error() = 63;
  return -1;
}

int getmntinfo(statfs **a1, int a2)
{
  int result;

  result = getmntinfo_internal((uint64_t)getmntinfo_vars, a2);
  *a1 = (statfs *)getmntinfo_vars[0];
  return result;
}

uint64_t getmntinfo_internal(uint64_t a1, int a2)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;

  if (*(int *)(a1 + 8) > 0 || (v2 = getfsstat(0, 0, 2), *(_DWORD *)(a1 + 8) = v2, v2 >= 0))
  {
    if (*(uint64_t *)(a1 + 16) <= 0
      || (v3 = getfsstat(*(statfs **)a1, *(_QWORD *)(a1 + 16), a2), *(_DWORD *)(a1 + 8) = v3, v3 >= 0))
    {
      while (*(_QWORD *)(a1 + 16) <= (unint64_t)(2168 * *(int *)(a1 + 8)))
      {
        if (*(_QWORD *)a1)
          free(*(void **)a1);
        *(_QWORD *)(a1 + 16) = 2168 * (*(_DWORD *)(a1 + 8) + 1);
        v4 = malloc_type_malloc(*(_QWORD *)(a1 + 16), 155530743);
        *(_QWORD *)a1 = v4;
        if (!v4)
          return 0;
        v5 = getfsstat(*(statfs **)a1, *(_QWORD *)(a1 + 16), a2);
        *(_DWORD *)(a1 + 8) = v5;
        if (v5 < 0)
          return 0;
      }
      return *(unsigned int *)(a1 + 8);
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

int getmntinfo_r_np(statfs **a1, int a2)
{
  int v3;
  int v4;
  void *v5[3];
  int v6;
  statfs **v7;

  v7 = a1;
  v6 = a2;
  memset(v5, 0, sizeof(v5));
  v4 = getmntinfo_internal((uint64_t)v5, a2);
  if (v4)
  {
    *v7 = (statfs *)v5[0];
  }
  else
  {
    v3 = *__error();
    free(v5[0]);
    *__error() = v3;
  }
  return v4;
}

int getpagesize(void)
{
  size_t v1;
  int v3[2];

  v1 = 0;
  if (getpagesize_value)
    return getpagesize_value;
  v3[0] = 6;
  v3[1] = 7;
  v1 = 4;
  if (sysctl(v3, 2u, &getpagesize_value, &v1, 0, 0) != -1)
    return getpagesize_value;
  else
    return -1;
}

int getpeereid(int a1, uid_t *a2, gid_t *a3)
{
  int v4;
  socklen_t v5;
  _DWORD v6[19];
  gid_t *v7;
  uid_t *v8;
  int v9;

  v9 = a1;
  v8 = a2;
  v7 = a3;
  _platform_memset(v6, 0, 76);
  v5 = 76;
  v4 = getsockopt(v9, 0, 1, v6, &v5);
  if (v4)
    return v4;
  if (v6[0])
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    *v8 = v6[1];
    *v7 = v6[3];
    return 0;
  }
}

const char *getprogname(void)
{
  return *_NSGetProgname();
}

int isatty(int a1)
{
  int v2;
  _BOOL4 v3;
  int v4;
  termios v5;

  v4 = a1;
  v3 = 0;
  v2 = 0;
  _platform_memset(&v5, 0, 72);
  if (ioctl(v4, 0x4004667AuLL, &v2) == -1)
  {
    LOBYTE(v3) = tcgetattr(v4, &v5) != -1;
    return v3;
  }
  else
  {
    v3 = v2 == 3;
    if (v2 != 3)
      *__error() = 25;
  }
  return v3;
}

uint64_t jrand48(unsigned __int16 a1[3])
{
  unint64_t v2;

  v2 = (*a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32)) * _rand48_mult + _rand48_add;
  *(_DWORD *)a1 = (*a1 + (a1[1] << 16)) * _rand48_mult + _rand48_add;
  a1[2] = WORD2(v2);
  return (int)(v2 >> 16);
}

void lcong48(unsigned __int16 a1[7])
{
  _rand48_seed = *a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32);
  _rand48_mult = a1[3] + ((unint64_t)a1[4] << 16) + ((unint64_t)a1[5] << 32);
  _rand48_add = a1[6];
}

uint64_t lockf_NOCANCEL(uint64_t a1, unsigned int a2)
{
  if (a2 <= 3uLL)
    __asm { BR              X8 }
  *__error() = 22;
  return 0xFFFFFFFFLL;
}

uint64_t lrand48(void)
{
  _rand48_seed = _rand48_seed * _rand48_mult + _rand48_add;
  return ((unint64_t)_rand48_seed >> 17) & 0x7FFFFFFF;
}

uint64_t mrand48(void)
{
  _rand48_seed = _rand48_seed * _rand48_mult + _rand48_add;
  return (int)((unint64_t)_rand48_seed >> 16);
}

int nice(int a1)
{
  int v3;
  int v4;

  *__error() = 0;
  v4 = getpriority(0, 0);
  if (v4 == -1 && *__error())
    return -1;
  if (v4 + a1 > 19)
    a1 = 19 - v4;
  v3 = setpriority(0, 0, v4 + a1);
  if (v3 == -1 && *__error() == 13)
    *__error() = 1;
  if (v3 == -1)
    return -1;
  else
    return getpriority(0, 0);
}

uint64_t nrand48(unsigned __int16 a1[3])
{
  unint64_t v2;

  v2 = (*a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32)) * _rand48_mult + _rand48_add;
  *(_DWORD *)a1 = (*a1 + (a1[1] << 16)) * _rand48_mult + _rand48_add;
  a1[2] = WORD2(v2);
  return (v2 >> 17) & 0x7FFFFFFF;
}

DIR *__cdecl opendir(const char *a1)
{
  return __opendir2(a1, 3);
}

DIR *__cdecl __opendir2(const char *a1, int a2)
{
  _BYTE v3[12];
  unsigned int v4;

  if ((a2 & 0x18) != 0)
    return 0;
  v4 = open_NOCANCEL(a1, 17825796);
  if (v4 == -1)
    return 0;
  *(_QWORD *)&v3[4] = __opendir_common(v4, a2, 0);
  if (!*(_QWORD *)&v3[4])
  {
    *(_QWORD *)v3 = *__error();
    close_NOCANCEL(v4);
    *__error() = *(_DWORD *)v3;
  }
  return *(DIR **)&v3[4];
}

DIR *__cdecl fdopendir(int a1)
{
  stat v2;
  unsigned int v3;

  v3 = a1;
  _platform_memset(&v2, 0, 144);
  if (fstat(v3, &v2))
    return 0;
  if ((v2.st_mode & 0xF000) == 0x4000)
  {
    if (fcntl_NOCANCEL(v3, 2) == -1)
      return 0;
    else
      return (DIR *)__opendir_common(v3, 3u, 1);
  }
  else
  {
    *__error() = 20;
    return 0;
  }
}

int *__opendir_common(int a1, unsigned int a2, char a3)
{
  _DWORD *v4;
  int v5;
  int v6;
  int *v7;
  char v8;
  _QWORD v12[8];

  v8 = a3 & 1;
  v7 = (int *)malloc_type_malloc(160, 2059767894);
  if (v7)
  {
    *((_QWORD *)v7 + 3) = 0;
    *v7 = a1;
    v7[14] = a2;
    *((_QWORD *)v7 + 1) = 0;
    _platform_memset(v12, 0, 64);
    v12[0] = 850045863;
    j___platform_memmove(v7 + 16, v12, 64);
    *((_QWORD *)v7 + 16) = v7 + 34;
    **((_QWORD **)v7 + 16) = 0;
    *(_QWORD *)(*((_QWORD *)v7 + 16) + 8) = 0;
    if ((a2 & 2) != 0 && __kernel_supports_unionfs())
    {
      v5 = __fd_is_on_union_mount(a1);
      if (v5 < 0)
        goto LABEL_24;
    }
    else
    {
      v5 = 0;
    }
    if (v5)
    {
      if ((_filldir((unsigned int *)v7, v8 & 1) & 1) != 0)
      {
        v7[14] |= 8u;
        return v7;
      }
    }
    else
    {
      v7[8] = 2048;
      *((_QWORD *)v7 + 3) = malloc_type_malloc(v7[8], 3661047690);
      if (*((_QWORD *)v7 + 3))
      {
        if ((v8 & 1) == 0)
        {
          *((_QWORD *)v7 + 2) = 0;
          *(_QWORD *)(*((_QWORD *)v7 + 16) + 16) = 0;
          return v7;
        }
        v4 = (_DWORD *)(*((_QWORD *)v7 + 3) + v7[8] - 4);
        *v4 = 0;
        *((_QWORD *)v7 + 2) = __getdirentries64(*v7, *((_QWORD *)v7 + 3), v7[8], *((_QWORD *)v7 + 16) + 16);
        if (*((uint64_t *)v7 + 2) >= 0 && *((_QWORD *)v7 + 2) <= (unint64_t)(v7[8] - 4) && (*v4 & 1) != 0)
          v7[14] |= 0x20u;
        if (*((uint64_t *)v7 + 2) >= 0)
        {
          v7[14] |= 0x10u;
          return v7;
        }
        if (*__error() == 22)
          *__error() = 20;
      }
    }
LABEL_24:
    v6 = *__error();
    free(*((void **)v7 + 3));
    free(v7);
    *__error() = v6;
    return 0;
  }
  return 0;
}

uint64_t _filldir(unsigned int *a1, char a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  int v6;
  int v7;
  int __nel;
  int __nela;
  int __nelb;
  signed int __nel_4;
  int v12;
  unsigned int v13;
  off_t v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  _QWORD *v19;
  char v20;
  char v22;

  v20 = a2 & 1;
  __nel_4 = 0;
  v6 = 0;
  v18 = 0;
  v16 = 0;
  v12 = getpagesize();
  if (v12 % 1024)
    v12 = 1024;
  v13 = openat_NOCANCEL(*a1, ".", 0x1000000);
  if (v13 == -1)
  {
    v22 = 0;
  }
  else
  {
    if ((v20 & 1) == 0 || (v14 = lseek(*a1, 0, 1), v14 != -1) && lseek(v13, v14, 0) != -1)
    {
      while (1)
      {
        if (v6 < 1024)
        {
          v6 += v12;
          __nel_4 += v12;
          v18 = (char *)reallocf(v18, __nel_4);
          if (!v18)
            break;
          v16 = &v18[__nel_4 - v6];
        }
        __nel = __getdirentries64(v13, v16, v6, *((_QWORD *)a1 + 16) + 16);
        if (__nel > 0)
        {
          v16 += __nel;
          v6 -= __nel;
        }
        if (__nel < 0)
          break;
        if (__nel <= 0)
        {
          close_NOCANCEL(v13);
          v15 = v16;
          *((_QWORD *)a1 + 3) = v18;
          v19 = 0;
          while (1)
          {
            __nela = 0;
            v17 = v18;
            while (v17 < v15)
            {
              v5 = v17;
              if ((v17 & 3) != 0
                || !*((_WORD *)v17 + 8)
                || *((unsigned __int16 *)v17 + 8) > v15 + 1 - v17)
              {
                break;
              }
              v17 += *((unsigned __int16 *)v17 + 8);
              if (*v5)
              {
                if (v19)
                  v19[__nela] = v5;
                ++__nela;
              }
            }
            if (v19)
              break;
            v19 = (_QWORD *)malloc_type_malloc(8 * (__nela + 1), 0x2004093837F09);
            if (!v19)
              goto LABEL_42;
          }
          mergesort(v19, __nela, 8uLL, (int (__cdecl *)(const void *, const void *))opendir_compar);
          v19[__nela] = 0;
          v4 = 0;
          for (__nelb = 0; v19[__nelb]; ++__nelb)
          {
            v3 = v19[__nelb];
            if (v4 && !_platform_strcmp(v3 + 21, v4 + 21))
              *(_QWORD *)v3 = 0;
            else
              v4 = v3;
            if (*(_BYTE *)(v3 + 20) == 14 && (a1[14] & 1) != 0)
              *(_QWORD *)v3 = 0;
          }
          free(v19);
LABEL_42:
          a1[8] = __nel_4;
          *((_QWORD *)a1 + 2) = &v17[-*((_QWORD *)a1 + 3)];
          v22 = 1;
          return v22 & 1;
        }
      }
    }
    v7 = *__error();
    close_NOCANCEL(v13);
    *__error() = v7;
    v22 = 0;
  }
  return v22 & 1;
}

uint64_t opendir_compar(_QWORD *a1, _QWORD *a2)
{
  return _platform_strcmp(*a1 + 21, *a2 + 21);
}

BOOL __kernel_supports_unionfs()
{
  size_t v1;
  int v2;

  if (__kernel_supports_unionfs_kernel_supports_unionfs == -1)
  {
    v2 = 0;
    v1 = 4;
    sysctlbyname("kern.secure_kernel", &v2, &v1, 0, 0);
    __kernel_supports_unionfs_kernel_supports_unionfs = v2 == 0;
  }
  return __kernel_supports_unionfs_kernel_supports_unionfs != 0;
}

uint64_t __fd_is_on_union_mount(int a1)
{
  int v2;
  statfs v5;

  _platform_bzero(&v5, 512);
  v2 = fstatfs(a1, &v5);
  if (v2 >= 0)
    return (v5.f_flags & 0x20) != 0;
  else
    return v2;
}

uint64_t pause_NOCANCEL()
{
  sigset_t v1;

  v1 = 0;
  sigprocmask(0, 0, &v1);
  return sigsuspend_NOCANCEL(&v1);
}

FILE *__cdecl popen(const char *a1, const char *a2)
{
  char ***v2;
  int v4;
  posix_spawn_file_actions_t v5;
  uint64_t i;
  unsigned int v7;
  int v8;
  pid_t v9;
  FILE *v10;
  _QWORD *v11;
  const char *v12;
  const char *v13;
  __int128 v15;
  __int128 v16;
  int v17;
  unsigned int v18;

  v13 = a1;
  v12 = a2;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v15 = 0u;
  v16 = 0u;
  i = 0;
  v5 = 0;
  libc_hooks_will_read_cstring((uint64_t)a1);
  libc_hooks_will_read_cstring((uint64_t)v12);
  if (!v12)
  {
LABEL_2:
    *__error() = 22;
    return 0;
  }
  if (_platform_strcmp(v12, "r+"))
  {
    v8 = 0;
    if (*v12 != 114 && *v12 != 119 || v12[1])
      goto LABEL_2;
    if (pipe(&v17) < 0)
      return 0;
  }
  else
  {
    v8 = 1;
    v12 = "r+";
    if (socketpair(1, 1, 0, &v17) < 0)
      return 0;
  }
  if (*v12 == 114)
  {
    v10 = fdopen(v17, v12);
    v7 = v18;
  }
  else
  {
    v10 = fdopen(v18, v12);
    v7 = v17;
  }
  if (v10)
  {
    v11 = (_QWORD *)malloc_type_malloc(24, 0x102004062D53EE8);
    if (v11)
    {
      v4 = posix_spawn_file_actions_init(&v5);
      if (v4)
        goto LABEL_21;
      if (*v12 == 114)
      {
        posix_spawn_file_actions_addclose(&v5, v17);
        if (v18 == 1)
        {
          if (v8)
            posix_spawn_file_actions_adddup2(&v5, v18, 0);
        }
        else
        {
          posix_spawn_file_actions_adddup2(&v5, v18, 1);
          posix_spawn_file_actions_addclose(&v5, v18);
          if (v8)
            posix_spawn_file_actions_adddup2(&v5, 1, 0);
        }
      }
      else
      {
        if (v17)
        {
          posix_spawn_file_actions_adddup2(&v5, v17, 0);
          posix_spawn_file_actions_addclose(&v5, v17);
        }
        posix_spawn_file_actions_addclose(&v5, v18);
      }
      pthread_mutex_lock(&__popen_pidlist_mutex);
      for (i = __popen_pidlist; i; i = *(_QWORD *)i)
        posix_spawn_file_actions_addclose(&v5, *(_DWORD *)(i + 16));
      *(_QWORD *)&v15 = "sh";
      *((_QWORD *)&v15 + 1) = "-c";
      v16 = (unint64_t)v13;
      v2 = _NSGetEnviron();
      v4 = posix_spawn(&v9, "/bin/sh", &v5, 0, (char *const *)&v15, *v2);
      pthread_mutex_unlock(&__popen_pidlist_mutex);
      posix_spawn_file_actions_destroy(&v5);
      if (v4 == 12 || v4 == 35)
      {
LABEL_21:
        fclose(v10);
        close_NOCANCEL(v7);
        free(v11);
        *__error() = v4;
        return 0;
      }
      else
      {
        if (v4)
          v9 = -1;
        if (*v12 == 114)
        {
          *((_DWORD *)v11 + 4) = v17;
          close_NOCANCEL(v18);
        }
        else
        {
          *((_DWORD *)v11 + 4) = v18;
          close_NOCANCEL(v17);
        }
        v11[1] = v10;
        *((_DWORD *)v11 + 5) = v9;
        pthread_mutex_lock(&__popen_pidlist_mutex);
        *v11 = __popen_pidlist;
        __popen_pidlist = (uint64_t)v11;
        pthread_mutex_unlock(&__popen_pidlist_mutex);
        fwide(v10, -1);
        return v10;
      }
    }
    else
    {
      fclose(v10);
      close_NOCANCEL(v7);
      return 0;
    }
  }
  else
  {
    close_NOCANCEL(v17);
    close_NOCANCEL(v18);
    return 0;
  }
}

uint64_t libc_hooks_will_read_cstring(uint64_t result)
{
  if (off_E9730)
    return off_E9730(result);
  return result;
}

int pclose(FILE *a1)
{
  BOOL v3;
  pid_t v4;
  int v5;
  _QWORD **v6;
  void *i;
  FILE *v8;

  v8 = a1;
  v6 = 0;
  v5 = 0;
  libc_hooks_will_read((uint64_t)a1, 152);
  pthread_mutex_lock(&__popen_pidlist_mutex);
  for (i = (void *)__popen_pidlist; i && *((FILE **)i + 1) != v8; i = *(void **)i)
    v6 = (_QWORD **)i;
  if (i)
  {
    if (v6)
      *v6 = (_QWORD *)**v6;
    else
      __popen_pidlist = *(_QWORD *)__popen_pidlist;
    pthread_mutex_unlock(&__popen_pidlist_mutex);
    fclose(v8);
    if (*((int *)i + 5) >= 0)
    {
      do
      {
        v4 = wait4(*((_DWORD *)i + 5), &v5, 0, 0);
        v3 = 0;
        if (v4 == -1)
          v3 = *__error() == 4;
      }
      while (v3);
      free(i);
      if (v4 == -1)
        return -1;
      else
        return v5;
    }
    else
    {
      free(i);
      return 32512;
    }
  }
  else
  {
    pthread_mutex_unlock(&__popen_pidlist_mutex);
    return -1;
  }
}

uint64_t libc_hooks_will_read(uint64_t result, uint64_t a2)
{
  if (off_E9728)
    return off_E9728(result, a2);
  return result;
}

void psignal(unsigned int a1, const char *a2)
{
  uint64_t v2;
  const char *v3;

  if (a1 >= 0x20)
    v3 = "Unknown signal";
  else
    v3 = sys_siglist[a1];
  if (a2 && *a2)
  {
    _platform_strlen(a2);
    ((void (*)(void))write_NOCANCEL)();
    write_NOCANCEL(2, ": ", 2);
  }
  v2 = _platform_strlen(v3);
  write_NOCANCEL(2, v3, v2);
  write_NOCANCEL(2, "\n", 1);
}

uint64_t _readdir_unlocked(unsigned int *a1, int a2)
{
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v5 = 0;
  do
  {
    if (*((_QWORD *)a1 + 1) >= *((_QWORD *)a1 + 2))
    {
      if ((a1[14] & 0x28) != 0)
        return 0;
      v5 = *((_QWORD *)a1 + 1);
      a1[14] &= ~0x10u;
      *((_QWORD *)a1 + 1) = 0;
    }
    if (!*((_QWORD *)a1 + 1) && (a1[14] & 0x38) == 0)
    {
      if (a1[8] == 2048)
      {
        v4 = malloc_type_malloc(0x2000, 2946738532);
        if (v4)
        {
          free(*((void **)a1 + 3));
          *((_QWORD *)a1 + 3) = v4;
          a1[8] = 0x2000;
        }
      }
      v3 = (_DWORD *)(*((_QWORD *)a1 + 3) + (int)a1[8] - 4);
      *v3 = 0;
      v6 = *(_QWORD *)(*((_QWORD *)a1 + 16) + 16);
      *((_QWORD *)a1 + 2) = __getdirentries64(*a1, *((_QWORD *)a1 + 3), (int)a1[8], *((_QWORD *)a1 + 16) + 16);
      if (*((uint64_t *)a1 + 2) >= 0 && *((_QWORD *)a1 + 2) <= (unint64_t)((int)a1[8] - 4) && (*v3 & 1) != 0)
        a1[14] |= 0x20u;
      if (*((uint64_t *)a1 + 2) <= 0)
        return 0;
      _fixtelldir((uint64_t)a1, v6, v5);
    }
    a1[14] &= ~0x10u;
    v7 = *((_QWORD *)a1 + 3) + *((_QWORD *)a1 + 1);
    if ((v7 & 3) != 0)
      return 0;
    if (!*(_WORD *)(v7 + 16) || *(unsigned __int16 *)(v7 + 16) > (int)(a1[8] + 1) - *((_QWORD *)a1 + 1))
      return 0;
    *((_QWORD *)a1 + 1) += *(unsigned __int16 *)(v7 + 16);
  }
  while (!*(_QWORD *)v7 && a2 || *(_BYTE *)(v7 + 20) == 14 && (a1[14] & 1) != 0);
  return v7;
}

dirent *__cdecl readdir(DIR *a1)
{
  dirent *v2;

  pthread_mutex_lock(&a1->__dd_lock);
  v2 = (dirent *)_readdir_unlocked((unsigned int *)a1, 1);
  pthread_mutex_unlock(&a1->__dd_lock);
  return v2;
}

int readdir_r(DIR *a1, dirent *a2, dirent **a3)
{
  int v4;
  uint64_t v5;

  v4 = *__error();
  *__error() = 0;
  pthread_mutex_lock(&a1->__dd_lock);
  v5 = _readdir_unlocked((unsigned int *)a1, 1);
  if (v5)
    j___platform_memmove(a2, v5, (*(unsigned __int16 *)(v5 + 18) + 25) & 0xFFFFFFFFFFFFFFFCLL);
  pthread_mutex_unlock(&a1->__dd_lock);
  if (*__error())
  {
    if (!v5)
      return *__error();
  }
  else
  {
    *__error() = v4;
  }
  if (v5)
    *a3 = a2;
  else
    *a3 = 0;
  return 0;
}

void rewinddir(DIR *a1)
{
  pthread_mutex_lock(&a1->__dd_lock);
  a1->__dd_flags &= 0xFFFFFFCF;
  if ((a1->__dd_flags & 8) != 0)
  {
    _filldir((unsigned int *)a1, 0);
  }
  else
  {
    lseek(a1->__dd_fd, 0, 0);
    *((_QWORD *)a1->__dd_td + 2) = 0;
  }
  a1->__dd_loc = 0;
  _reclaim_telldir((uint64_t)a1);
  pthread_mutex_unlock(&a1->__dd_lock);
}

int scandir(const char *a1, dirent ***a2, int (__cdecl *a3)(const dirent *), int (__cdecl *a4)(const dirent **, const dirent **))
{
  size_t v4;
  uint64_t v6;
  DIR *v8;
  unint64_t v9;
  size_t __nel;
  _QWORD *__base;
  char *v12;
  dirent *v13;

  __nel = 0;
  v8 = opendir(a1);
  if (!v8)
    return -1;
  v9 = 32;
  __base = (_QWORD *)malloc_type_malloc(256, 0x2004093837F09);
  if (__base)
  {
    while (1)
    {
      v13 = readdir(v8);
      if (!v13)
        break;
      if (!a3 || ((unsigned int (*)(dirent *))a3)(v13))
      {
        v12 = (char *)malloc_type_malloc((int)((v13->d_namlen + 4) & 0xFFFFFFFC) + 24, 3587914482);
        if (!v12)
          goto LABEL_17;
        *(_QWORD *)v12 = v13->d_ino;
        v12[20] = v13->d_type;
        *((_WORD *)v12 + 8) = v13->d_reclen;
        *((_WORD *)v12 + 9) = v13->d_namlen;
        bcopy(v13->d_name, v12 + 21, *((unsigned __int16 *)v12 + 9) + 1);
        if (__nel >= v9)
        {
          v6 = malloc_type_realloc(__base, 16 * v9, 0x2004093837F09);
          if (!v6)
          {
            free(v12);
            goto LABEL_17;
          }
          __base = (_QWORD *)v6;
          v9 *= 2;
        }
        v4 = __nel++;
        __base[v4] = v12;
      }
    }
    closedir(v8);
    if (__nel && a4)
      qsort(__base, __nel, 8uLL, (int (__cdecl *)(const void *, const void *))a4);
    *a2 = (dirent **)__base;
    return __nel;
  }
  else
  {
LABEL_17:
    while (__nel)
      free((void *)__base[--__nel]);
    free(__base);
    closedir(v8);
    return -1;
  }
}

int alphasort(const dirent **a1, const dirent **a2)
{
  return strcoll((*a1)->d_name, (*a2)->d_name);
}

unsigned __int16 *__cdecl seed48(unsigned __int16 a1[3])
{
  unsigned __int16 *result;

  result = (unsigned __int16 *)&seed48_sseed;
  seed48_sseed = _rand48_seed;
  word_DEAF8 = WORD2(_rand48_seed);
  _rand48_seed = *a1 + ((unint64_t)a1[1] << 16) + ((unint64_t)a1[2] << 32);
  _rand48_mult = 0x5DEECE66DLL;
  _rand48_add = 11;
  return result;
}

void seekdir(DIR *a1, uint64_t a2)
{
  pthread_mutex_lock(&a1->__dd_lock);
  _seekdir((off_t)a1, a2);
  pthread_mutex_unlock(&a1->__dd_lock);
}

int sethostname(const char *a1, int a2)
{
  int v4[2];

  v4[0] = 1;
  v4[1] = 10;
  if (sysctl(v4, 2u, 0, 0, (void *)a1, a2) == -1)
    return -1;
  else
    return 0;
}

mode_t getmode(const void *a1, mode_t a2)
{
  __int16 v3;
  int v4;
  __int16 v5;
  mode_t v6;

  v6 = a2;
  while (1)
  {
    v4 = *(char *)a1;
    if (!*(_BYTE *)a1)
      break;
    switch(v4)
    {
      case '+':
        v6 |= *((_WORD *)a1 + 1);
        break;
      case '-':
        v6 &= ~*((_WORD *)a1 + 1);
        break;
      case 'X':
        if ((a2 & 0x4049) != 0)
          v6 |= *((_WORD *)a1 + 1);
        break;
      default:
        switch(v4)
        {
          case 'g':
            v5 = (v6 & 0x38) >> 3;
            break;
          case 'o':
            v5 = v6 & 7;
            break;
          case 'u':
            v5 = (v6 & 0x1C0) >> 6;
            break;
          default:
            return v6;
        }
        if ((*((_BYTE *)a1 + 1) & 1) != 0)
        {
          if ((*((_BYTE *)a1 + 1) & 2) != 0)
            v3 = 7;
          else
            v3 = v5;
          if ((*((_BYTE *)a1 + 1) & 0x10) != 0)
            v6 &= ~(*((_WORD *)a1 + 1) & (v3 << 6));
          if ((*((_BYTE *)a1 + 1) & 4) != 0)
            v6 &= ~(*((_WORD *)a1 + 1) & (8 * v3));
          if ((*((_BYTE *)a1 + 1) & 8) != 0)
            v6 &= ~(v3 & *((_WORD *)a1 + 1));
        }
        if ((*((_BYTE *)a1 + 1) & 2) != 0)
        {
          if ((*((_BYTE *)a1 + 1) & 0x10) != 0)
            v6 |= *((_WORD *)a1 + 1) & (unsigned __int16)(v5 << 6);
          if ((*((_BYTE *)a1 + 1) & 4) != 0)
            v6 |= *((_WORD *)a1 + 1) & (unsigned __int16)(8 * v5);
          if ((*((_BYTE *)a1 + 1) & 8) != 0)
            v6 |= v5 & *((_WORD *)a1 + 1);
        }
        break;
    }
    a1 = (char *)a1 + 4;
  }
  return v6;
}

void *__cdecl setmode(const char *a1)
{
  const char *v1;
  unint64_t v3;
  unint64_t v4;
  char *v5;
  char *v6;
  uint64_t v7;
  int v8;
  _BOOL4 v9;
  mode_t v10;
  __int16 v11;
  sigset_t v12;
  sigset_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *__endptr;
  char v18;
  int v19;
  int v20;
  const char *v21;

  v21 = a1;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  __endptr = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v9 = 0;
  if (!*a1)
    return 0;
  v13 = -1;
  sigprocmask(1, &v13, &v12);
  v10 = umask(0);
  umask(v10);
  v11 = ~v10;
  sigprocmask(3, &v12, 0);
  v8 = 8;
  v16 = (char *)malloc_type_malloc(32, 2572087479);
  if (!v16)
    return 0;
  v15 = v16;
  v14 = (unint64_t)(v16 + 24);
  if (!isdigit(*(unsigned __int8 *)v21))
  {
LABEL_17:
    v19 = 0;
    v4 = (*v21 - 97);
    if (v4 <= 0x14)
      __asm { BR              X8 }
    while (1)
    {
      v1 = v21++;
      LODWORD(v1) = *v1;
      v18 = (char)v1;
      if ((_DWORD)v1 != 43 && v18 != 45 && v18 != 61)
        goto LABEL_22;
      if (v18 == 61)
        v9 = 0;
      v20 = 0;
      v3 = (*v21 - 88);
      if (v3 <= 0x20)
        __asm { BR              X8 }
      if (v18 == 61 && !v9)
      {
        v9 = v18 == 61;
        if ((unint64_t)v16 >= v14)
        {
          v8 += 4;
          v5 = (char *)malloc_type_realloc(v15, 4 * v8, 0x100004052888210);
          if (!v5)
          {
            if (v15)
              free(v15);
            v15 = 0;
            return 0;
          }
          v16 = &v5[4 * ((v16 - v15) / 4)];
          v15 = v5;
          v14 = (unint64_t)&v5[4 * v8 - 8];
        }
        v16 = (char *)addcmd((uint64_t)v16, v18, v19, v20, v11);
        v20 = 0;
      }
      if (!*v21)
      {
        *v16 = 0;
        _sm_compress_mode(v15);
        return v15;
      }
      if (*v21 == 44)
      {
        ++v21;
        goto LABEL_17;
      }
    }
  }
  v7 = strtol(v21, &__endptr, 8);
  if (*__endptr || v7 < 0 || (v7 & 0xFFFFFFFFFFFFF000) != 0)
  {
LABEL_22:
    free(v15);
    return 0;
  }
  v20 = (unsigned __int16)v7;
  if ((unint64_t)v16 < v14)
  {
LABEL_16:
    v16 = (char *)addcmd((uint64_t)v16, 61, 4095, v20, v11);
    *v16 = 0;
    return v15;
  }
  v6 = (char *)malloc_type_realloc(v15, 48, 0x100004052888210);
  if (v6)
  {
    v16 = &v6[4 * ((v16 - v15) / 4)];
    v15 = v6;
    v14 = (unint64_t)(v6 + 40);
    goto LABEL_16;
  }
  if (v15)
    free(v15);
  v15 = 0;
  return 0;
}

uint64_t addcmd(uint64_t a1, int a2, int a3, int a4, __int16 a5)
{
  char v5;
  char v6;
  char v7;
  char v8;
  __int16 v10;
  __int16 v11;
  char v12;
  uint64_t v13;

  v13 = a1;
  v12 = a2;
  switch(a2)
  {
    case '+':
    case '-':
      goto LABEL_13;
    case '=':
      *(_BYTE *)a1 = 45;
      if (a3)
        v11 = a3;
      else
        v11 = 4095;
      *(_WORD *)(a1 + 2) = v11;
      v13 = a1 + 4;
      v12 = 43;
      goto LABEL_13;
    case 'X':
LABEL_13:
      *(_BYTE *)v13 = v12;
      if (a3)
        v10 = a3;
      else
        v10 = a5;
      *(_WORD *)(v13 + 2) = v10 & a4;
      return v13 + 4;
    case 'g':
    case 'o':
    case 'u':
      *(_BYTE *)a1 = a2;
      if (a3)
      {
        if ((a3 & 0x100) != 0)
          v5 = 16;
        else
          v5 = 0;
        if ((a3 & 0x20) != 0)
          v6 = 4;
        else
          v6 = 0;
        v7 = v5 | v6;
        if ((a3 & 4) != 0)
          v8 = 8;
        else
          v8 = 0;
        *(_BYTE *)(a1 + 1) = v7 | v8;
        *(_WORD *)(a1 + 2) = -1;
      }
      else
      {
        *(_BYTE *)(a1 + 1) = 28;
        *(_WORD *)(a1 + 2) = a5;
      }
      switch(a4)
      {
        case '+':
          *(_BYTE *)(a1 + 1) |= 2u;
          break;
        case '-':
          *(_BYTE *)(a1 + 1) |= 1u;
          break;
        case '=':
          *(_BYTE *)(a1 + 1) |= 3u;
          break;
      }
      break;
  }
  return v13 + 4;
}

char *_sm_compress_mode(char *result)
{
  _DWORD *v1;
  _DWORD *v2;
  BOOL v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  char *v9;
  char *v10;

  v10 = result;
  v9 = result;
  while (1)
  {
LABEL_2:
    v4 = *v9;
    v3 = 0;
    if (v4 != 43)
    {
      v3 = 0;
      if (v4 != 45)
        v3 = v4 != 88;
    }
    if (v3)
      break;
    v6 = 0;
    v7 = 0;
    v8 = 0;
    while (1)
    {
      v5 = *v9;
      if (v5 == 45)
      {
        v7 |= *((unsigned __int16 *)v9 + 1);
        v8 &= ~*((unsigned __int16 *)v9 + 1);
        v6 &= ~*((unsigned __int16 *)v9 + 1);
        goto LABEL_16;
      }
      if (v5 == 43)
      {
        v8 |= *((unsigned __int16 *)v9 + 1);
        v7 &= ~*((unsigned __int16 *)v9 + 1);
        v6 &= ~*((unsigned __int16 *)v9 + 1);
        goto LABEL_16;
      }
      if (v5 != 88)
        break;
      v6 |= *((unsigned __int16 *)v9 + 1) & ~v8;
LABEL_16:
      v9 += 4;
    }
    if (v7)
    {
      *v10 = 45;
      v10[1] = 0;
      *((_WORD *)v10 + 1) = v7;
      v10 += 4;
    }
    if (v8)
    {
      *v10 = 43;
      v10[1] = 0;
      *((_WORD *)v10 + 1) = v8;
      v10 += 4;
    }
    if (v6)
    {
      *v10 = 88;
      v10[1] = 0;
      *((_WORD *)v10 + 1) = v6;
      v10 += 4;
    }
  }
  v1 = v10;
  v10 += 4;
  v2 = v9;
  v9 += 4;
  *v1 = *v2;
  if (v4)
    goto LABEL_2;
  return result;
}

void setprogname(const char *a1)
{
  size_t v1;
  char *v2;
  char *v3;
  int v5[2];
  _BYTE v6[33];

  v2 = strrchr(a1, 47);
  if (v2)
  {
    v3 = v2 + 1;
    *_NSGetProgname() = v3;
  }
  else
  {
    v3 = (char *)a1;
    *_NSGetProgname() = (char *)a1;
  }
  _platform_strlcpy(v6, v3, 33);
  v5[0] = 1;
  v5[1] = 62;
  v1 = _platform_strlen(v6);
  sysctl(v5, 2u, 0, 0, v6, v1);
}

int siginterrupt(int a1, int a2)
{
  int v3;
  int v4;
  int v5;
  sigaction v6;
  int v7;
  int v8;
  int v10;
  int v11;

  v8 = a1;
  v7 = a2;
  v6.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v6.sa_mask = 0;
  v5 = sigaction(a1, 0, &v6);
  if (v5 < 0)
    return v5;
  if (v7)
  {
    v11 = v8;
    if (v8 <= 32)
      v4 = 1 << (v11 - 1);
    else
      v4 = 0;
    _sigintr |= v4;
    v6.sa_flags &= ~2u;
  }
  else
  {
    v10 = v8;
    if (v8 <= 32)
      v3 = 1 << (v10 - 1);
    else
      v3 = 0;
    _sigintr &= ~v3;
    v6.sa_flags |= 2u;
  }
  return sigaction(v8, &v6, 0);
}

void (__cdecl *__cdecl signal(int a1, __sigaction_u a2))(int)
{
  return signal__(a1, a2, 1).__sa_handler;
}

__sigaction_u signal__(int a1, __sigaction_u a2, int a3)
{
  int v4;
  sigaction v5;
  sigaction v6;
  int v7;
  __sigaction_u v8;
  int v9;
  int v11;

  v9 = a1;
  v8.__sa_handler = a2.__sa_handler;
  v7 = a3;
  *(_QWORD *)&v6.sa_mask = 0;
  v5.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v5.sa_mask = 0;
  v6.__sigaction_u = a2;
  v11 = a1;
  if (a1 <= 32)
    v4 = 1 << (v11 - 1);
  else
    v4 = 0;
  if ((_sigintr & v4) == 0)
    v6.sa_flags |= 2u;
  if (!v7)
  {
    if ((int)_sigaction_nobind(v9, &v6, &v5) < 0)
      return (__sigaction_u)-1;
    return (__sigaction_u)v5.__sigaction_u.__sa_handler;
  }
  if (sigaction(v9, &v6, &v5) >= 0)
    return (__sigaction_u)v5.__sigaction_u.__sa_handler;
  return (__sigaction_u)-1;
}

__sigaction_u _signal_nobind(int a1, __sigaction_u a2)
{
  return signal__(a1, a2, 0);
}

uint64_t sleep_NOCANCEL(unsigned int a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;

  v6 = a1;
  v4 = 0;
  v5 = 0;
  v2 = 0;
  v3 = 0;
  if (a1 <= 0x7FFFFFFF)
  {
    v4 = v6;
    v5 = 0;
    if (nanosleep_NOCANCEL(&v4, &v2) == -1)
    {
      if (*__error() == 4)
        return (v2 + (v3 != 0));
      else
        return v6;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return (v6 - 0x7FFFFFFF + sleep_NOCANCEL());
  }
}

void srand48(uint64_t a1)
{
  _rand48_seed = ((unint64_t)(unsigned __int16)a1 << 16) + 13070 + ((unint64_t)WORD1(a1) << 32);
  _rand48_mult = 0x5DEECE66DLL;
  _rand48_add = 11;
}

StringList *sl_init(void)
{
  StringList *v1;

  v1 = (StringList *)malloc_type_malloc(24, 0x1080040468F112ELL);
  if (!v1)
    err(1, "stringlist: %m");
  v1->sl_cur = 0;
  v1->sl_max = 20;
  v1->sl_str = (char **)malloc_type_malloc(8 * v1->sl_max, 0x10040436913F5);
  if (!v1->sl_str)
    err(1, "stringlist: %m");
  return v1;
}

int sl_add(StringList *a1, char *a2)
{
  char **sl_str;
  size_t sl_cur;

  if (a1->sl_cur == a1->sl_max - 1)
  {
    a1->sl_max += 20;
    a1->sl_str = (char **)reallocf(a1->sl_str, 8 * a1->sl_max);
    if (!a1->sl_str)
      return -1;
  }
  sl_str = a1->sl_str;
  sl_cur = a1->sl_cur;
  a1->sl_cur = sl_cur + 1;
  sl_str[sl_cur] = a2;
  return 0;
}

void sl_free(StringList *a1, int a2)
{
  size_t i;

  if (a1)
  {
    if (a1->sl_str)
    {
      if (a2)
      {
        for (i = 0; i < a1->sl_cur; ++i)
          free(a1->sl_str[i]);
      }
      free(a1->sl_str);
    }
    free(a1);
  }
}

char *__cdecl sl_find(StringList *a1, char *a2)
{
  size_t i;

  for (i = 0; i < a1->sl_cur; ++i)
  {
    if (!_platform_strcmp(a1->sl_str[i], a2))
      return a1->sl_str[i];
  }
  return 0;
}

uint64_t sysconf(int a1)
{
  unint64_t v2;

  v2 = (a1 - 1);
  if (v2 <= 0xC7)
    __asm { BR              X8 }
  *__error() = 22;
  return -1;
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  unint64_t v7;

  if (*a1 != 8)
  {
    if (a2 != 2 || *a1 != 1 || a1[1] != 45)
      return __sysctl(a1, a2, a3, a4, a5, a6);
    if (a5)
      goto LABEL_6;
    if (!a3)
    {
      if (a4)
        *a4 = 2;
      return 0;
    }
    if (!a4)
    {
      *__error() = 14;
      return -1;
    }
    if (*a4 >= 2)
    {
      strcpy((char *)a3, "/");
      *a4 = 2;
      return 0;
    }
LABEL_27:
    *__error() = 12;
    return -1;
  }
  if (a5)
  {
LABEL_6:
    *__error() = 1;
    return -1;
  }
  if (a2 != 2)
  {
LABEL_32:
    *__error() = 22;
    return -1;
  }
  if (a1[1] != 1)
  {
    if (a3 && *a4 < 4)
      goto LABEL_27;
    *a4 = 4;
    if (!a3)
      return 0;
    v7 = (a1[1] - 2);
    if (v7 <= 0x12)
      __asm { BR              X8 }
    goto LABEL_32;
  }
  if (a3 && *a4 < 0x1E)
    goto LABEL_27;
  *a4 = 30;
  if (a3)
    strcpy((char *)a3, "/usr/bin:/bin:/usr/sbin:/sbin");
  return 0;
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  uint64_t v5;
  unint64_t v8;
  int v9;
  size_t v10;
  void *v11;
  size_t *v12;
  void *v13;
  const char *v14;
  _BYTE v15[56];
  _DWORD v16[2];

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = 0;
  v16[0] = 0;
  v16[1] = 3;
  v8 = 56;
  v5 = _platform_strlen(a1);
  v9 = __sysctl(v16, 2, v15, &v8, a1, v5);
  if (v9 >= 0)
  {
    v8 /= 4uLL;
    return __sysctl(v15, v8, v13, v12, v11, v10);
  }
  return v9;
}

int sysctlnametomib(const char *a1, int *a2, size_t *a3)
{
  uint64_t v3;
  int result;
  _DWORD v9[2];

  v9[0] = 0;
  v9[1] = 3;
  *a3 *= 4;
  v3 = _platform_strlen(a1);
  result = __sysctl(v9, 2, a2, a3, a1, v3);
  *a3 /= 4uLL;
  return result;
}

uint64_t telldir(DIR *a1)
{
  _telldir *dd_td;
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  _QWORD *i;

  pthread_mutex_lock(&a1->__dd_lock);
  for (i = *(_QWORD **)a1->__dd_td; i && (i[3] != *((_QWORD *)a1->__dd_td + 2) || i[4] != a1->__dd_loc); i = (_QWORD *)*i)
    ;
  if (i)
  {
LABEL_12:
    v5 = i[2];
    pthread_mutex_unlock(&a1->__dd_lock);
    return v5;
  }
  i = (_QWORD *)malloc_type_malloc(40, 0x10A00404BF391D6);
  if (i)
  {
    dd_td = a1->__dd_td;
    v2 = *((_QWORD *)dd_td + 1);
    *((_QWORD *)dd_td + 1) = v2 + 1;
    i[2] = v2;
    i[3] = *((_QWORD *)a1->__dd_td + 2);
    i[4] = a1->__dd_loc;
    v3 = *(_QWORD *)a1->__dd_td;
    *i = v3;
    if (v3)
      *(_QWORD *)(*(_QWORD *)a1->__dd_td + 8) = i;
    *(_QWORD *)a1->__dd_td = i;
    i[1] = a1->__dd_td;
    goto LABEL_12;
  }
  pthread_mutex_unlock(&a1->__dd_lock);
  return -1;
}

off_t _seekdir(off_t result, uint64_t a2)
{
  _QWORD *i;
  off_t v3;

  v3 = result;
  for (i = **(_QWORD ***)(result + 128); i && i[2] != a2; i = (_QWORD *)*i)
    ;
  if (i && (i[4] != *(_QWORD *)(result + 8) || i[3] != *(_QWORD *)(*(_QWORD *)(result + 128) + 16)))
  {
    if (i[3] == *(_QWORD *)(*(_QWORD *)(result + 128) + 16))
    {
      if (!i[4])
        *(_DWORD *)(result + 56) |= 0x10u;
      *(_QWORD *)(result + 8) = i[4];
    }
    else
    {
      result = lseek(*(_DWORD *)result, i[3], 0);
      *(_QWORD *)(*(_QWORD *)(v3 + 128) + 16) = i[3];
      *(_QWORD *)(v3 + 8) = 0;
      *(_DWORD *)(v3 + 56) &= 0xFFFFFFCF;
      do
      {
        if (*(_QWORD *)(v3 + 8) >= i[4])
          break;
        result = _readdir_unlocked((unsigned int *)v3, 0);
      }
      while (result);
    }
  }
  return result;
}

uint64_t _fixtelldir(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  v3 = **(_QWORD **)(result + 128);
  if (v3 && *(_QWORD *)(v3 + 32) == a3 && *(_QWORD *)(v3 + 24) == a2)
  {
    *(_QWORD *)(v3 + 24) = *(_QWORD *)(*(_QWORD *)(result + 128) + 16);
    *(_QWORD *)(v3 + 32) = *(_QWORD *)(result + 8);
  }
  return result;
}

void _reclaim_telldir(uint64_t a1)
{
  void *v1;
  _QWORD *v2;

  v2 = **(_QWORD ***)(a1 + 128);
  while (v2)
  {
    v1 = v2;
    v2 = (_QWORD *)*v2;
    free(v1);
  }
  **(_QWORD **)(a1 + 128) = 0;
}

int tcgetattr(int a1, termios *a2)
{
  return ioctl(a1, 0x40487413uLL, a2);
}

int tcsetattr(int a1, int a2, const termios *a3)
{
  unsigned int v4;
  _BYTE v9[16];
  uint64_t v10;

  _platform_memset(v9, 0, 72);
  if ((a2 & 0x10) != 0)
  {
    j___platform_memmove(v9, a3, 72);
    v10 |= 1uLL;
    a3 = (const termios *)v9;
  }
  v4 = a2 & 0xFFFFFFEF;
  if ((a2 & 0xFFFFFFEF) == 0)
    return ioctl(a1, 0x80487414uLL, a3);
  if (v4 == 1)
    return ioctl(a1, 0x80487415uLL, a3);
  if (v4 == 2)
    return ioctl(a1, 0x80487416uLL, a3);
  *__error() = 22;
  return -1;
}

int tcsetpgrp(int a1, pid_t a2)
{
  pid_t v3;
  pid_t v4;
  int v5;

  v5 = a1;
  v4 = a2;
  v3 = 0;
  if (!isatty(a1))
    return -1;
  v3 = v4;
  return ioctl(v5, 0x80047476uLL, &v3);
}

pid_t tcgetpgrp(int a1)
{
  pid_t v2;
  int v3;

  v3 = a1;
  v2 = 0;
  if (!isatty(a1))
    return -1;
  if (ioctl(v3, 0x40047477uLL, &v2) >= 0)
    return v2;
  return -1;
}

speed_t cfgetospeed(const termios *a1)
{
  return a1->c_ospeed;
}

speed_t cfgetispeed(const termios *a1)
{
  return a1->c_ispeed;
}

int cfsetospeed(termios *a1, speed_t a2)
{
  a1->c_ospeed = a2;
  return 0;
}

int cfsetispeed(termios *a1, speed_t a2)
{
  a1->c_ispeed = a2;
  return 0;
}

int cfsetspeed(termios *a1, speed_t a2)
{
  a1->c_ospeed = a2;
  a1->c_ispeed = a2;
  return 0;
}

void cfmakeraw(termios *a1)
{
  a1->c_iflag &= 0xFFFFFFFFFFFFD801;
  a1->c_iflag |= 1uLL;
  a1->c_oflag &= ~1uLL;
  a1->c_lflag &= 0x5FBFFA61uLL;
  a1->c_cflag &= 0xFFFFFFFFFFFFECFFLL;
  a1->c_cflag |= 0xB00uLL;
  a1->c_cc[16] = 1;
  a1->c_cc[17] = 0;
}

int tcsendbreak(int a1, int a2)
{
  _QWORD v3[2];
  int v4;
  int v5;

  v5 = a1;
  v4 = a2;
  v3[0] = 0;
  v3[1] = 400000;
  if (ioctl(a1, 0x2000747BuLL, 0) == -1)
    return -1;
  select_NOCANCEL(0, 0, 0, 0, v3);
  if (ioctl(v5, 0x2000747AuLL, 0) == -1)
    return -1;
  else
    return 0;
}

uint64_t tcdrain_NOCANCEL(int a1)
{
  int v2;

  v2 = a1;
  return ioctl(a1, 0x2000745EuLL, 0);
}

int tcflush(int a1, int a2)
{
  _DWORD v3[2];
  int v4;

  v4 = a1;
  v3[1] = a2;
  v3[0] = 0;
  switch(a2)
  {
    case 1:
      v3[0] = 1;
      return ioctl(v4, 0x80047410uLL, v3);
    case 2:
      v3[0] = 2;
      return ioctl(v4, 0x80047410uLL, v3);
    case 3:
      v3[0] = 3;
      return ioctl(v4, 0x80047410uLL, v3);
  }
  *__error() = 22;
  return -1;
}

int tcflow(int a1, int a2)
{
  unint64_t v3;

  v3 = (a2 - 1);
  if (v3 <= 3)
    __asm { BR              X8 }
  *__error() = 22;
  return -1;
}

time_t time(time_t *a1)
{
  fenv_t v2;
  time_t tv_sec;
  timeval v4;
  time_t *v5;

  v5 = a1;
  v4.tv_sec = 0;
  *(_QWORD *)&v4.tv_usec = 0;
  tv_sec = 0;
  v2.__fpsr = 0;
  v2.__fpcr = 0;
  fegetenv(&v2);
  if (gettimeofday(&v4, 0) >= 0)
    tv_sec = v4.tv_sec;
  else
    tv_sec = -1;
  if (v5)
    *v5 = tv_sec;
  fesetenv(&v2);
  return tv_sec;
}

clock_t times(tms *a1)
{
  timeval v2;
  rusage v3;
  tms *v4;

  v4 = a1;
  _platform_memset(&v3, 0, 144);
  v2.tv_sec = 0;
  *(_QWORD *)&v2.tv_usec = 0;
  if (getrusage(0, &v3) < 0)
    return -1;
  v4->tms_utime = 100 * v3.ru_utime.tv_sec + v3.ru_utime.tv_usec / 10000;
  v4->tms_stime = 100 * v3.ru_stime.tv_sec + v3.ru_stime.tv_usec / 10000;
  if (getrusage(-1, &v3) < 0)
    return -1;
  v4->tms_cutime = 100 * v3.ru_utime.tv_sec + v3.ru_utime.tv_usec / 10000;
  v4->tms_cstime = 100 * v3.ru_stime.tv_sec + v3.ru_stime.tv_usec / 10000;
  if (gettimeofday(&v2, 0))
    return -1;
  else
    return 100 * v2.tv_sec + v2.tv_usec / 10000;
}

char *__cdecl ttyname(int a1)
{
  return ttyname_threaded(a1);
}

char *ttyname_threaded(int a1)
{
  int v3;
  int v4;
  char *v5;

  if (!ttyname_init)
  {
    pthread_mutex_lock(&ttyname_lock);
    if (!ttyname_init)
    {
      ttyname_key = 16;
      if (pthread_key_init_np(16, &_free))
      {
        v4 = *__error();
        pthread_mutex_unlock(&ttyname_lock);
        *__error() = v4;
        return 0;
      }
      ttyname_init = 1;
    }
    pthread_mutex_unlock(&ttyname_lock);
  }
  v5 = (char *)pthread_getspecific(ttyname_key);
  if (v5)
    goto LABEL_20;
  v5 = (char *)malloc_type_malloc(261, 1592123336);
  if (!v5)
    return 0;
  if (!pthread_setspecific(ttyname_key, v5))
  {
LABEL_20:
    if (ttyname_r(a1, v5, 0x105uLL))
      return 0;
    else
      return v5;
  }
  else
  {
    v3 = *__error();
    free(v5);
    *__error() = v3;
    return 0;
  }
}

int ttyname_r(int a1, char *a2, size_t a3)
{
  int v3;
  char *v5;
  int v6;
  char *buf;
  dev_t st_rdev;
  stat v9;
  size_t v10;
  char *v11;
  int v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  _platform_memset(&v9, 0, 144);
  if (fstat(v12, &v9) < 0)
    return 9;
  if (!isatty(v12))
    return 25;
  if ((v9.st_mode & 0xF000) != 0x2000)
    return 25;
  if (v10 <= 6)
    return 34;
  _platform_strlcpy(v11, "/dev/", v10);
  st_rdev = v9.st_rdev;
  v5 = v11;
  buf = &v5[_platform_strlen(v11)];
  v6 = v10;
  v3 = _platform_strlen(v11);
  if (devname_r(st_rdev, 0x2000u, buf, v6 - v3))
    return 0;
  else
    return 34;
}

int ttyslot(void)
{
  return 0;
}

useconds_t ualarm(useconds_t a1, useconds_t a2)
{
  itimerval v3;
  itimerval v4;
  useconds_t v5;
  useconds_t v6;

  v6 = a1;
  v5 = a2;
  memset(&v4, 0, sizeof(v4));
  memset(&v3, 0, sizeof(v3));
  v4.it_interval.tv_usec = a2 % 0xF4240;
  v4.it_interval.tv_sec = a2 / 0xF4240;
  v4.it_value.tv_usec = a1 % 0xF4240;
  v4.it_value.tv_sec = a1 / 0xF4240;
  if (setitimer(0, &v4, &v3))
    return -1;
  else
    return 1000000 * LODWORD(v3.it_value.tv_sec) + v3.it_value.tv_usec;
}

uint64_t ulimit(int a1, ...)
{
  rlimit v2;
  int v3;
  uint64_t v5;
  va_list va;

  va_start(va, a1);
  v5 = va_arg(va, _QWORD);
  v3 = a1;
  v2.rlim_cur = 0;
  v2.rlim_max = 0;
  if (a1 == 1)
  {
    if (getrlimit(1, &v2) == -1)
    {
      return -1;
    }
    else
    {
      v2.rlim_cur /= 0x200uLL;
      if (v2.rlim_cur <= 0x7FFFFFFFFFFFFFFFLL)
        return v2.rlim_cur;
      else
        return 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  else if (v3 == 2)
  {
    v2.rlim_cur = v5 << 9;
    v2.rlim_max = v5 << 9;
    if (setrlimit(1, &v2) == -1)
      return -1;
    else
      return v5;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int unvis(char *a1, int a2, int *a3, int a4)
{
  BOOL v4;
  unsigned __int8 v6;

  if (!a1)
    __assert_rtn("unvis", "unvis.c", 210, "cp != ((void *)0)");
  if (!a3)
    __assert_rtn("unvis", "unvis.c", 211, "astate != ((void *)0)");
  v6 = *(_BYTE *)a3;
  if ((a4 & 0x1000) != 0)
  {
    if (v6)
    {
      v4 = v6 == 6 || v6 == 5;
      if (v4 || v6 == 9)
      {
        *a3 = 0;
        return 1;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return 3;
    }
  }
  else
  {
    if (v6 <= 0xFuLL)
      __asm { BR              X8 }
    *a3 = 0;
    return -1;
  }
}

int strnunvisx(char *a1, size_t a2, const char *a3, int a4)
{
  const char *v4;
  char *v6;
  unint64_t v9;
  int v10;
  char *v11;
  char v12;
  _BYTE v13[5];
  const char *v14;
  size_t v15;
  char *v16;

  v16 = a1;
  v15 = a2;
  v14 = a3;
  *(_DWORD *)&v13[1] = a4;
  v13[0] = 0;
  v12 = 0;
  v11 = a1;
  v10 = 0;
  if (!a3)
    __assert_rtn("strnunvisx", "unvis.c", 504, "src != ((void *)0)");
  if (!v16)
    __assert_rtn("strnunvisx", "unvis.c", 505, "dst != ((void *)0)");
  v4 = v14++;
  LODWORD(v4) = *v4;
  v13[0] = (_BYTE)v4;
  if ((_DWORD)v4)
  {
    v9 = (unvis(&v12, v13[0], &v10, *(int *)&v13[1]) + 1);
    if (v9 <= 4)
      __asm { BR              X8 }
    __assert_rtn("strnunvisx", "unvis.c", 532, "0");
  }
  if (unvis(&v12, v13[0], &v10, 4096) == 1)
  {
    if (!v15--)
      goto LABEL_11;
    v6 = v16++;
    *v6 = v12;
  }
  if (v15--)
  {
    *v16 = 0;
    return (_DWORD)v16 - (_DWORD)v11;
  }
LABEL_11:
  *__error() = 28;
  return -1;
}

int strunvisx(char *a1, const char *a2, int a3)
{
  return strnunvisx(a1, 0xFFFFFFFFFFFFFFFFLL, a2, a3);
}

int strunvis(char *a1, const char *a2)
{
  return strnunvisx(a1, 0xFFFFFFFFFFFFFFFFLL, a2, 0);
}

int strnunvis(char *a1, size_t a2, const char *a3)
{
  return strnunvisx(a1, a2, a3, 0);
}

uint64_t usleep_NOCANCEL(unsigned int a1)
{
  _QWORD v2[2];
  unsigned int v3;

  v3 = a1;
  v2[1] = 1000 * (a1 % 0xF4240);
  v2[0] = a1 / 0xF4240;
  return nanosleep_NOCANCEL(v2, 0);
}

int utime(const char *a1, const utimbuf *a2)
{
  timeval v3;
  time_t modtime;
  int v5;

  if (!a2)
    return utimes(a1, 0);
  v3.tv_sec = a2->actime;
  modtime = a2->modtime;
  v5 = 0;
  v3.tv_usec = 0;
  return utimes(a1, &v3);
}

char *__cdecl svis(char *a1, int a2, int a3, int a4, const char *a5)
{
  int v6;
  _BYTE v7[2];
  const char *v8;
  int v9;
  int v10;
  int v11;
  char *v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7[0] = a2;
  v7[1] = a4;
  v6 = istrsenvisx((uint64_t)&v12, 0, (uint64_t)v7, 1, a3, (uint64_t)a5, 0);
  if (v6 >= 0)
    return &v12[v6];
  else
    return 0;
}

uint64_t istrsenvisx(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7)
{
  char v7;
  char v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  BOOL v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;
  __int32 *v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  void *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v30;
  _QWORD *v31;
  unint64_t v32;
  size_t v33;
  unsigned int v34;
  __int32 *(*v35)(__int32 *, __int32, __int16, unsigned int, const __int32 *);
  __int32 *v36;
  __int32 v37;
  unsigned int v38;
  size_t v39;
  __int32 *v40;
  const char *v41;
  int v42;
  _BOOL4 v43;
  char *v44;
  _QWORD *v45;
  uint64_t *v46;
  uint64_t v47;
  int v48;
  unint64_t v49;
  uint64_t v50;
  void *v51;
  char *v52;
  char *v53;
  int v54;
  int i;
  int v56;
  int v57;
  int v58;
  __int32 *(*v59)(__int32 *, __int32, __int16, unsigned int, const __int32 *);
  __int32 v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  size_t v64;
  __int32 *v65;
  const __int32 *v66;
  _QWORD v67[8];
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  uint64_t v74;
  mbstate_t v75;

  v46 = v67;
  v47 = 0x100004052888210;
  v72 = a1;
  v71 = a2;
  v70 = a3;
  v69 = a4;
  v68 = a5;
  v67[7] = a6;
  v67[6] = a7;
  v74 = 0;
  if (v7)
    v8 = 1;
  else
    v8 = 0;
  if ((v8 & 1) != 0)
  {
    v46[15] = (uint64_t)pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = v46;
    v46[16] = __locale_key;
    v9[19] = v9[16];
    v9[20] = 0;
    v9[20] = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v9[15] = *(_QWORD *)(v9[20] + 8 * v9[19]);
  }
  if (v46[15])
    v45 = (_QWORD *)v46[15];
  else
    v45 = __global_locale;
  v10 = v46;
  v11 = *(unsigned int *)(v45[166] + 64);
  v46[5] = (uint64_t)&v30;
  v44 = (char *)&v30 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
  v10[4] = v11;
  v10[3] = 0;
  v10[2] = 0;
  v10[1] = 0;
  *v10 = 0;
  v66 = 0;
  v65 = 0;
  v64 = 0;
  v63 = 0;
  v62 = 0;
  v61 = 0;
  v60 = 0;
  v59 = 0;
  v58 = 0;
  v57 = 0;
  v56 = -1;
  i = 0;
  v54 = 0;
  v53 = 0;
  v52 = 0;
  v51 = 0;
  v50 = 0;
  v49 = 0;
  _platform_memset(&v75, 0, 128);
  if (!v46[12])
    __assert_rtn("istrsenvisx", "vis.c", 394, "mbdstp != ((void *)0)");
  v12 = v46[10] != 0;
  v43 = 1;
  if (!v12)
    v43 = v46[9] == 0;
  if (!v43)
    __assert_rtn("istrsenvisx", "vis.c", 395, "mbsrc != ((void *)0) || mblength == 0");
  if (!v46[7])
    __assert_rtn("istrsenvisx", "vis.c", 396, "mbextra != ((void *)0)");
  v50 = v46[9];
  if (v50 == 1)
    v50 = 2;
  v13 = v46;
  v14 = v47;
  v65 = 0;
  v46[1] = 0;
  *v13 = 0;
  v51 = 0;
  v15 = malloc_type_calloc(v50 + 1, 4, v14);
  *v46 = v15;
  if (!v15)
  {
    v73 = -1;
    v48 = 1;
    return v73;
  }
  v16 = malloc_type_calloc(16 * v50 + 1, 4, v47);
  v46[1] = v16;
  if (!v16)
    goto LABEL_96;
  if (!*(_QWORD *)v46[12])
  {
    v51 = (void *)malloc_type_calloc(16 * v50 + 1, 1, 0x100004077774924);
    if (v51)
    {
      *(_QWORD *)v46[12] = v51;
      goto LABEL_26;
    }
LABEL_96:
    free(v65);
    free((void *)v46[1]);
    free((void *)*v46);
    free(v51);
    v73 = v56;
    v48 = 1;
    return v73;
  }
LABEL_26:
  v17 = v46;
  v53 = *(char **)v46[12];
  v46[3] = v46[1];
  v17[2] = *v17;
  if ((v68 & 0x4000) != 0)
  {
    v57 = 1;
  }
  else
  {
    if (v46[6])
      v42 = *(_DWORD *)v46[6];
    else
      v42 = 0;
    v57 = v42;
  }
  _platform_memset(&v75, 0, 128);
  while (v50 > 0)
  {
    if (!v57)
    {
      v40 = (__int32 *)v46[2];
      v41 = (const char *)v46[10];
      if (v50 >= 6)
        v39 = 6;
      else
        v39 = v50;
      v58 = mbrtowc(v40, v41, v39, &v75);
    }
    if (v57 || v58 < 0)
    {
      *(_DWORD *)v46[2] = *(unsigned __int8 *)v46[10];
      v58 = 1;
      v57 = 1;
    }
    if (!v58)
      v58 = 1;
    v18 = v46;
    v46[2] += 4;
    v18[10] += v58;
    v50 -= v58;
  }
  v19 = v46;
  v64 = (v19[2] - *v19) / 4;
  v46[2] = *v46;
  if (v19[9] < v64)
    v64 = v46[9];
  v65 = makeextralist(v68, (char *)v46[7]);
  if (!v65)
  {
    if (!v46[11] || *(_QWORD *)v46[11])
    {
      *v53 = 0;
      v56 = 0;
    }
    else
    {
LABEL_85:
      *__error() = 28;
    }
    goto LABEL_96;
  }
  v59 = getvisfun(v68);
  v66 = (const __int32 *)v46[3];
  while (v64)
  {
    v20 = v46;
    v21 = (__int32 *)v46[2];
    v46[2] = (uint64_t)(v21 + 1);
    v60 = *v21;
    v35 = v59;
    v36 = (__int32 *)v20[3];
    v37 = v60;
    v38 = v68;
    if (v64)
      v34 = *(_DWORD *)v46[2];
    else
      v34 = 0;
    v22 = (uint64_t)v35(v36, v37, v38, v34, v65);
    v23 = v46;
    v46[3] = v22;
    if (!v23[3])
      goto LABEL_85;
    --v64;
  }
  *(_DWORD *)v46[3] = 0;
  v64 = wcslen(v66);
  if (v46[11])
    v33 = *(_QWORD *)v46[11];
  else
    v33 = 6 * wcslen(v66) + 1;
  v49 = v33;
  v63 = 0;
  _platform_memset(&v75, 0, 128);
  v46[3] = (uint64_t)v66;
  while (v64)
  {
    if (!v57)
    {
      v24 = v49 - v63;
      v32 = v49 - v63;
      v46[14] = 0;
      if (v24)
      {
        v25 = v46;
        v46[17] = __locale_key;
        v25[18] = v25[17];
        v25[21] = 0;
        v25[21] = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        v25[14] = *(_QWORD *)(v25[21] + 8 * v25[18]);
      }
      else
      {
        v26 = pthread_getspecific(__locale_key);
        v46[14] = (uint64_t)v26;
      }
      v31 = v46[14] ? (_QWORD *)v46[14] : __global_locale;
      v52 = v32 <= *(int *)(v31[166] + 64) ? v44 : v53;
      v58 = wcrtomb(v52, *(_DWORD *)v46[3], &v75);
      if (v58 > 0 && v52 != v53)
      {
        if (v63 + v58 >= v49)
          goto LABEL_85;
        j___platform_memmove(v53, v52, v58);
      }
    }
    if (v57 || v58 < 0)
    {
      v58 = 0;
      v61 = 0;
      for (i = 7; i >= 0; --i)
      {
        v54 = 8 * i;
        v62 = 255 << (8 * i);
        v61 |= v62;
        if ((*(int *)v46[3] & v61) != 0 || !i)
        {
          if (v63 + v58 + 1 >= v49)
            goto LABEL_85;
          v27 = (*(int *)v46[3] & (unint64_t)v62) >> v54;
          v28 = v58++;
          v53[v28] = v27;
        }
      }
      v57 = 1;
    }
    if (v63 + v58 >= v49)
      __assert_rtn("istrsenvisx", "vis.c", 590, "olen + clen < maxolen");
    v53 += v58;
    v46[3] += 4;
    v63 += v58;
    --v64;
  }
  *v53 = 0;
  if ((v68 & 0x4000) != 0 && v46[6])
    *(_DWORD *)v46[6] = v57;
  free(v65);
  free((void *)v46[1]);
  free((void *)*v46);
  v73 = v63;
  v48 = 1;
  return v73;
}

char *__cdecl snvis(char *a1, size_t a2, int a3, int a4, int a5, const char *a6)
{
  int v7;
  _BYTE v8[2];
  const char *v9;
  int v10;
  int v11;
  int v12;
  size_t v13;
  char *v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = a4;
  v10 = a5;
  v9 = a6;
  v8[0] = a3;
  v8[1] = a5;
  v7 = istrsenvisx((uint64_t)&v14, (uint64_t)&v13, (uint64_t)v8, 1, a4, (uint64_t)a6, 0);
  if (v7 >= 0)
    return &v14[v7];
  else
    return 0;
}

int strsvis(char *a1, const char *a2, int a3, const char *a4)
{
  char *v5;

  v5 = a1;
  return istrsenvisxl((uint64_t)&v5, 0, (uint64_t)a2, a3, (uint64_t)a4, 0);
}

uint64_t istrsenvisxl(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;

  if (!a3)
    return istrsenvisx(a1, a2, 0, 0, a4, a5, a6);
  v7 = _platform_strlen(a3);
  return istrsenvisx(a1, a2, a3, v7, a4, a5, a6);
}

int strsnvis(char *a1, size_t a2, const char *a3, int a4, const char *a5)
{
  size_t v6;
  char *v7;

  v7 = a1;
  v6 = a2;
  return istrsenvisxl((uint64_t)&v7, (uint64_t)&v6, (uint64_t)a3, a4, (uint64_t)a5, 0);
}

int strsvisx(char *a1, const char *a2, size_t a3, int a4, const char *a5)
{
  char *v6;

  v6 = a1;
  return istrsenvisx((uint64_t)&v6, 0, (uint64_t)a2, a3, a4, (uint64_t)a5, 0);
}

int strsnvisx(char *a1, size_t a2, const char *a3, size_t a4, int a5, const char *a6)
{
  size_t v7;
  char *v8;

  v8 = a1;
  v7 = a2;
  return istrsenvisx((uint64_t)&v8, (uint64_t)&v7, (uint64_t)a3, a4, a5, (uint64_t)a6, 0);
}

int strsenvisx(char *a1, size_t a2, const char *a3, size_t a4, int a5, const char *a6, int *a7)
{
  size_t v8;
  char *v9;

  v9 = a1;
  v8 = a2;
  return istrsenvisx((uint64_t)&v9, (uint64_t)&v8, (uint64_t)a3, a4, a5, (uint64_t)a6, (uint64_t)a7);
}

char *__cdecl vis(char *a1, int a2, int a3, int a4)
{
  int v5;
  _BYTE v6[2];
  int v7;
  int v8;
  int v9;
  char *v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = a4;
  v6[0] = a2;
  v6[1] = a4;
  v5 = istrsenvisx((uint64_t)&v10, 0, (uint64_t)v6, 1, a3, (uint64_t)&unk_D495D, 0);
  if (v5 >= 0)
    return &v10[v5];
  else
    return 0;
}

char *__cdecl nvis(char *a1, size_t a2, int a3, int a4, int a5)
{
  int v6;
  _BYTE v7[2];
  int v8;
  int v9;
  int v10;
  size_t v11;
  char *v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7[0] = a3;
  v7[1] = a5;
  v6 = istrsenvisx((uint64_t)&v12, (uint64_t)&v11, (uint64_t)v7, 1, a4, (uint64_t)&unk_D495D, 0);
  if (v6 >= 0)
    return &v12[v6];
  else
    return 0;
}

int strvis(char *a1, const char *a2, int a3)
{
  char *v4;

  v4 = a1;
  return istrsenvisxl((uint64_t)&v4, 0, (uint64_t)a2, a3, (uint64_t)&unk_D495D, 0);
}

int strnvis(char *a1, size_t a2, const char *a3, int a4)
{
  size_t v5;
  char *v6;

  v6 = a1;
  v5 = a2;
  return istrsenvisxl((uint64_t)&v6, (uint64_t)&v5, (uint64_t)a3, a4, (uint64_t)&unk_D495D, 0);
}

uint64_t stravis(_QWORD *a1, uint64_t a2, int a3)
{
  *a1 = 0;
  return istrsenvisxl((uint64_t)a1, 0, a2, a3, (uint64_t)&unk_D495D, 0);
}

int strvisx(char *a1, const char *a2, size_t a3, int a4)
{
  char *v5;

  v5 = a1;
  return istrsenvisx((uint64_t)&v5, 0, (uint64_t)a2, a3, a4, (uint64_t)&unk_D495D, 0);
}

int strnvisx(char *a1, size_t a2, const char *a3, size_t a4, int a5)
{
  size_t v6;
  char *v7;

  v7 = a1;
  v6 = a2;
  return istrsenvisx((uint64_t)&v7, (uint64_t)&v6, (uint64_t)a3, a4, a5, (uint64_t)&unk_D495D, 0);
}

int strenvisx(char *a1, size_t a2, const char *a3, size_t a4, int a5, int *a6)
{
  size_t v7;
  char *v8;

  v8 = a1;
  v7 = a2;
  return istrsenvisx((uint64_t)&v8, (uint64_t)&v7, (uint64_t)a3, a4, a5, (uint64_t)&unk_D495D, (uint64_t)a6);
}

__int32 *makeextralist(int a1, char *a2)
{
  __int32 *v2;
  __int32 *v3;
  __int32 *v4;
  __int32 *v5;
  __int32 *v6;
  __int32 *v7;
  __int32 *v8;
  __int32 *v9;
  __int32 *v10;
  unint64_t i;
  __int32 *v13;
  __int32 *v14;
  unint64_t v15;
  __int32 *v16;
  __int32 *v17;
  char *v18;
  int v19;
  mbstate_t v21;

  v19 = a1;
  v18 = a2;
  _platform_memset(&v21, 0, 128);
  _platform_memset(&v21, 0, 128);
  v15 = _platform_strlen(v18);
  v17 = (__int32 *)malloc_type_calloc(v15 + 30, 4, 0x100004052888210);
  if (!v17)
    return 0;
  if ((v19 & 0x4000) != 0 || mbsrtowcs(v17, (const char **)&v18, v15, &v21) == -1)
  {
    for (i = 0; i < v15; ++i)
      v17[i] = v18[i];
    v16 = &v17[v15];
  }
  else
  {
    v16 = &v17[wcslen(v17)];
  }
  if ((v19 & 0x100) != 0)
  {
    v13 = (__int32 *)&char_glob;
    while (*v13)
    {
      v2 = v13++;
      v3 = v16++;
      *v3 = *v2;
    }
  }
  if ((v19 & 0x2000) != 0)
  {
    v14 = (__int32 *)&char_shell;
    while (*v14)
    {
      v4 = v14++;
      v5 = v16++;
      *v5 = *v4;
    }
  }
  if ((v19 & 4) != 0)
  {
    v6 = v16++;
    *v6 = 32;
  }
  if ((v19 & 8) != 0)
  {
    v7 = v16++;
    *v7 = 9;
  }
  if ((v19 & 0x10) != 0)
  {
    v8 = v16++;
    *v8 = 10;
  }
  if ((v19 & 0x8000u) != 0)
  {
    v9 = v16++;
    *v9 = 34;
  }
  if ((v19 & 0x40) == 0)
  {
    v10 = v16++;
    *v10 = 92;
  }
  *v16 = 0;
  return v17;
}

__int32 *(*getvisfun(__int16 a1))(__int32 *a1, __int32 a2, __int16 a3, unsigned int a4, const __int32 *a5)
{
  if ((a1 & 0x80u) != 0)
    return do_hvis;
  if ((a1 & 0x200) != 0)
    return do_mvis;
  return do_svis;
}

__int32 *do_hvis(__int32 *a1, __int32 a2, __int16 a3, unsigned int a4, const __int32 *a5)
{
  _DWORD *v5;
  __int32 *v12;

  if (iswalnum(a2)
    || a2 == 36
    || a2 == 45
    || a2 == 95
    || a2 == 46
    || a2 == 43
    || a2 == 33
    || a2 == 42
    || a2 == 39
    || a2 == 40
    || a2 == 41
    || a2 == 44)
  {
    return do_svis(a1, a2, a3, a4, a5);
  }
  *a1 = 37;
  a1[1] = dword_D2BC8[a2 >> 4];
  v5 = a1 + 2;
  v12 = a1 + 3;
  *v5 = dword_D2BC8[a2 & 0xF];
  return v12;
}

__int32 *do_mvis(__int32 *a1, __int32 a2, __int16 a3, unsigned int a4, const __int32 *a5)
{
  _DWORD *v5;
  __int32 *v12;

  if (a2 == 10
    || (!iswspace(a2) || a4 != 13 && a4 != 10)
    && (iswspace(a2) || a2 >= 33 && a2 != 61 && a2 <= 126)
    && !wcschr(dword_D2C0C, a2))
  {
    return do_svis(a1, a2, a3, a4, a5);
  }
  *a1 = 61;
  a1[1] = dword_D2C40[a2 >> 4];
  v5 = a1 + 2;
  v12 = a1 + 3;
  *v5 = dword_D2C40[a2 & 0xF];
  return v12;
}

__int32 *do_svis(__int32 *a1, __int32 a2, __int16 a3, unsigned int a4, const __int32 *a5)
{
  unint64_t v6;
  int i;
  _BOOL4 v8;

  v8 = wcschr(a5, a2) != 0;
  if (v8)
    goto LABEL_17;
  if ((a3 & 0x4000) == 0)
  {
    if (!iswgraph(a2))
      goto LABEL_6;
LABEL_16:
    *a1 = a2;
    return a1 + 1;
  }
  if (isgraph_l(a2, 0))
    goto LABEL_16;
LABEL_6:
  if (a2 == 32
    || a2 == 9
    || a2 == 10
    || (a3 & 0x4000) == 0 && a2 > 127 && iswspace(a2)
    || (a3 & 0x20) != 0 && (a2 == 8 || a2 == 7 || a2 == 13))
  {
    goto LABEL_16;
  }
LABEL_17:
  v6 = 0;
  for (i = 7; i >= 0; --i)
  {
    v6 |= 255 << (8 * i);
    if ((a2 & v6) != 0 || !i)
      a1 = do_mbyte(a1, (a2 & (unint64_t)(255 << (8 * i))) >> (8 * i), a3, a4, v8);
  }
  return a1;
}

_DWORD *do_mbyte(_DWORD *a1, unsigned int a2, __int16 a3, uint64_t a4, int a5)
{
  _DWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  wint_t *v9;
  char v12;
  wint_t v13;
  _DWORD *v15;

  v13 = a2;
  v12 = a3;
  if ((a3 & 2) == 0)
    goto LABEL_11;
  if (a2 <= 0x76uLL)
    __asm { BR              X8 }
  if ((a3 & 0x4000) != 0)
  {
    if (!isgraph_l(a2, 0))
      goto LABEL_11;
  }
  else if (!iswgraph(a2))
  {
    goto LABEL_11;
  }
  if (v13 < 0x30u || v13 > 0x37u)
  {
    *a1 = 92;
    a1[1] = v13;
    return a1 + 2;
  }
LABEL_11:
  if (a5 || (v13 & 0x7F) == 0x20 || (v12 & 1) != 0)
  {
    *a1 = 92;
    a1[1] = (v13 >> 6) + 48;
    a1[2] = ((v13 >> 3) & 7) + 48;
    v5 = a1 + 3;
    v15 = a1 + 4;
    *v5 = (v13 & 7) + 48;
  }
  else
  {
    if ((v12 & 0x40) == 0)
    {
      v6 = a1++;
      *v6 = 92;
    }
    if ((v13 & 0x80) != 0)
    {
      v13 &= 0x7Fu;
      v7 = a1++;
      *v7 = 77;
    }
    if (iswcntrl(v13))
    {
      *a1 = 94;
      v8 = a1 + 1;
      v15 = a1 + 2;
      if (v13 == 127)
        *v8 = 63;
      else
        *v8 = v13 + 64;
    }
    else
    {
      *a1 = 45;
      v9 = a1 + 1;
      v15 = a1 + 2;
      *v9 = v13;
    }
  }
  return v15;
}

uint64_t wait_NOCANCEL(uint64_t a1)
{
  return __wait4_nocancel(0xFFFFFFFFLL, a1, 0, 0);
}

pid_t wait3(int *a1, int a2, rusage *a3)
{
  return wait4(-1, a1, a2, a3);
}

uint64_t waitpid_NOCANCEL(unsigned int a1, uint64_t a2, unsigned int a3)
{
  if ((a3 & 0x13) == a3)
  {
    return __wait4_nocancel(a1, a2, a3, 0);
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t _ascii_init(uint64_t a1)
{
  *(_QWORD *)(a1 + 72) = _ascii_mbrtowc;
  *(_QWORD *)(a1 + 80) = _ascii_mbsinit;
  *(_QWORD *)(a1 + 88) = _ascii_mbsnrtowcs;
  *(_QWORD *)(a1 + 96) = _ascii_wcrtomb;
  *(_QWORD *)(a1 + 104) = _ascii_wcsnrtombs;
  *(_DWORD *)(a1 + 64) = 1;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _ascii_mbrtowc(_DWORD *a1, char *a2, uint64_t a3)
{
  if (!a2)
    return 0;
  if (!a3)
    return -2;
  if (*a2 >= 0)
  {
    if (a1)
      *a1 = *a2;
    return *a2 != 0;
  }
  else
  {
    *__error() = 92;
    return -1;
  }
}

uint64_t _ascii_mbsinit()
{
  return 1;
}

uint64_t _ascii_mbsnrtowcs(_DWORD *a1, char **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  char *v6;
  _DWORD *v7;
  BOOL v9;
  BOOL v10;
  uint64_t i;
  char *j;
  char *v13;
  _DWORD *v16;

  v16 = a1;
  if (a1)
  {
    v13 = *a2;
    for (i = 0; ; ++i)
    {
      v4 = a4--;
      v9 = 0;
      if (v4)
      {
        v5 = a3--;
        v9 = v5 != 0;
      }
      if (!v9)
        break;
      if (*v13 < 0)
      {
        *a2 = v13;
        *__error() = 92;
        return -1;
      }
      v6 = v13++;
      LODWORD(v6) = *v6;
      v7 = v16++;
      *v7 = (_DWORD)v6;
      if (!(_DWORD)v6)
      {
        *a2 = 0;
        return i;
      }
    }
    *a2 = v13;
    return i;
  }
  else
  {
    for (j = *a2; ; ++j)
    {
      v10 = 0;
      if (a3)
        v10 = *j != 0;
      if (!v10)
        break;
      if (*j < 0)
      {
        *__error() = 92;
        return -1;
      }
      --a3;
    }
    return j - *a2;
  }
}

uint64_t _ascii_wcrtomb(_BYTE *a1, unsigned int a2)
{
  if (!a1)
    return 1;
  if (a2 < 0x80)
  {
    *a1 = a2;
    return 1;
  }
  else
  {
    *__error() = 92;
    return -1;
  }
}

uint64_t _ascii_wcsnrtombs(_BYTE *a1, _DWORD **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _BYTE *v7;
  BOOL v9;
  BOOL v10;
  uint64_t i;
  _DWORD *j;
  _DWORD *v13;
  _BYTE *v16;

  v16 = a1;
  if (a1)
  {
    v13 = *a2;
    for (i = 0; ; ++i)
    {
      v4 = a4--;
      v9 = 0;
      if (v4)
      {
        v5 = a3--;
        v9 = v5 != 0;
      }
      if (!v9)
        break;
      if (*v13 >= 0x80u)
      {
        *a2 = v13;
        *__error() = 92;
        return -1;
      }
      v6 = v13++;
      LOBYTE(v6) = *v6;
      v7 = v16++;
      *v7 = (_BYTE)v6;
      if (!(_BYTE)v6)
      {
        *a2 = 0;
        return i;
      }
    }
    *a2 = v13;
    return i;
  }
  else
  {
    for (j = *a2; ; ++j)
    {
      v10 = 0;
      if (a3)
        v10 = *j != 0;
      if (!v10)
        break;
      if (*j >= 0x80u)
      {
        *__error() = 92;
        return -1;
      }
      --a3;
    }
    return j - *a2;
  }
}

uint64_t _BIG5_init(uint64_t a1)
{
  *(_QWORD *)(a1 + 72) = _BIG5_mbrtowc;
  *(_QWORD *)(a1 + 96) = _BIG5_wcrtomb;
  *(_QWORD *)(a1 + 80) = _BIG5_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _BIG5_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4)
{
  unsigned __int8 *v4;
  uint64_t v6;
  int v7;
  int v8;
  unsigned __int8 *v11;
  _BYTE *v12;

  v11 = a2;
  if ((*a4 & 0xFFFFFF00) != 0)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    v11 = (unsigned __int8 *)&unk_D495D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3)
    return -2;
  if (*a4)
  {
    if (!*v11)
    {
LABEL_9:
      *__error() = 92;
      return -1;
    }
    if (a1)
      *a1 = *v11 | (*a4 << 8);
    *a4 = 0;
    return 1;
  }
  else
  {
    v6 = (int)_big5_check(*v11);
    v4 = v11;
    v12 = v11 + 1;
    v7 = *v4;
    if (v6 == 2)
    {
      if (a3 < 2)
      {
        *a4 = v7;
        return -2;
      }
      if (!*v12)
        goto LABEL_9;
      v8 = *v12 | (v7 << 8);
      if (a1)
        *a1 = v8;
      return 2;
    }
    else
    {
      if (a1)
        *a1 = v7;
      return v7 != 0;
    }
  }
}

uint64_t _BIG5_wcrtomb(_BYTE *a1, __int16 a2, _DWORD *a3)
{
  if (*a3)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if (a2 < 0)
    {
      *a1 = HIBYTE(a2);
      a1[1] = a2;
      return 2;
    }
    else
    {
      *a1 = a2;
      return 1;
    }
  }
  else
  {
    return 1;
  }
}

BOOL _BIG5_mbsinit(_DWORD *a1)
{
  BOOL v2;

  v2 = 1;
  if (a1)
    return *a1 == 0;
  return v2;
}

uint64_t _big5_check(unsigned __int8 a1)
{
  BOOL v2;

  v2 = 0;
  if (a1 >= 0xA1u)
    v2 = a1 != 255;
  if (v2)
    return 2;
  else
    return 1;
}

wint_t btowc_l(int a1, locale_t a2)
{
  wint_t v3;
  char v4;
  locale_t v5;
  int v6;
  _BYTE v8[128];

  v6 = a1;
  v5 = a2;
  _platform_memset(v8, 0, 128);
  j___platform_memmove(v8, &btowc_l_initial, 128);
  v4 = 0;
  v3 = 0;
  if (v5)
  {
    if (v5 == (locale_t)-1)
      v5 = (locale_t)&__global_locale;
  }
  else
  {
    v5 = (locale_t)&__c_locale;
  }
  if (v6 == -1)
    return -1;
  v4 = v6;
  if ((unint64_t)(*(uint64_t (**)(wint_t *, char *, uint64_t, _BYTE *, locale_t))(*((_QWORD *)v5 + 166)
                                                                                                 + 72))(&v3, &v4, 1, v8, v5) <= 1)return v3;
  else
    return -1;
}

wint_t btowc(int a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return btowc_l(a1, v5);
  else
    return btowc_l(a1, (locale_t)__global_locale);
}

uint64_t __collate_load_tables(uint64_t a1, _QWORD *a2)
{
  stat v3;
  _DWORD *v4;
  void *v5;
  char *v6;
  uint64_t v7;
  int i;
  int v9;
  int v10;
  int v11;
  _QWORD *v12;
  uint64_t v13;
  char v15[1024];

  v13 = a1;
  v12 = a2;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  i = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  _platform_memset(&v3, 0, 144);
  if (_platform_strcmp(v13, "C")
    && _platform_strcmp(v13, "POSIX")
    && _platform_strncmp(v13, "C.", 2))
  {
    if (!__collate_load_tables_cache || _platform_strcmp(v13, __collate_load_tables_cache + 16))
    {
      _platform_strcpy(v15, v13);
      strcat(v15, "/LC_COLLATE");
      v11 = __open_path_locale(v15);
      if (v11 == -1)
      {
        return -1;
      }
      else if (fstat(v11, &v3) >= 0)
      {
        if (v3.st_size >= 0xA8uLL)
        {
          v5 = mmap(0, v3.st_size, 3, 2, v11, 0);
          close_NOCANCEL(v11);
          v6 = (char *)v5;
          if (v5 == (void *)-1)
          {
            return -1;
          }
          else
          {
            v9 = 1;
            if (_platform_strncmp(v6, "1.1A\n", 12))
            {
              if (_platform_strncmp(v6, "DARWIN 1.0\n", 12)
                || (v6 += 12, v6 += 12, v4 = v6, v6 += 144, v9 = v4[14], v9 < 0))
              {
                munmap(v5, v3.st_size);
                *__error() = 79;
                return -1;
              }
              else
              {
                if ((v4[13] & 1) != 0)
                  goto LABEL_26;
                v10 = 136 * v9 + 10240 + 44 * v4[15];
                for (i = 0; i < *(unsigned __int8 *)v4; v10 += 100 * v4[i++ + 16])
                  ;
                if (v10 != v3.st_size - (v6 - (_BYTE *)v5))
                {
LABEL_26:
                  munmap(v5, v3.st_size);
                  *__error() = 22;
                  return -1;
                }
                else
                {
                  v7 = malloc_type_malloc(200, 0x10B004021DA7767);
                  if (v7)
                  {
                    *(_QWORD *)(v7 + 72) = v5;
                    *(_QWORD *)(v7 + 80) = v3.st_size;
                    *(_DWORD *)v7 = 2;
                    *(_QWORD *)(v7 + 8) = destruct_collate;
                    *(_QWORD *)(v7 + 192) = v6;
                    v6 += 10240;
                    for (i = 0; i < *(unsigned __int8 *)v4; ++i)
                    {
                      if ((int)v4[i + 16] <= 0)
                      {
                        *(_QWORD *)(v7 + 96 + 8 * i) = 0;
                      }
                      else
                      {
                        *(_QWORD *)(v7 + 96 + 8 * i) = v6;
                        v6 += 100 * v4[i + 16];
                      }
                    }
                    if (v9 <= 0)
                    {
                      *(_QWORD *)(v7 + 176) = 0;
                    }
                    else
                    {
                      *(_QWORD *)(v7 + 176) = v6;
                      v6 += 136 * v9;
                    }
                    if ((int)v4[15] <= 0)
                      *(_QWORD *)(v7 + 184) = 0;
                    else
                      *(_QWORD *)(v7 + 184) = v6;
                    _platform_strcpy(v7 + 16, v13);
                    *(_QWORD *)(v7 + 88) = v4;
                    xlocale_release(__collate_load_tables_cache);
                    __collate_load_tables_cache = v7;
                    xlocale_release(v12[165]);
                    v12[165] = __collate_load_tables_cache;
                    *(_BYTE *)(v7 + 64) = 0;
                    if (v12 == __global_locale)
                      __collate_load_error = 0;
                    return 0;
                  }
                  else
                  {
                    munmap(v5, v3.st_size);
                    *__error() = 12;
                    return -1;
                  }
                }
              }
            }
            else
            {
              return __collate_load_tables_legacy(v13, v12, (uint64_t)v6, v5, (uint64_t)&v3, &__collate_load_tables_cache);
            }
          }
        }
        else
        {
          close_NOCANCEL(v11);
          *__error() = 22;
          return -1;
        }
      }
      else
      {
        close_NOCANCEL(v11);
        return -1;
      }
    }
    else
    {
      if (v12 == __global_locale)
        __collate_load_error = 0;
      xlocale_release(v12[165]);
      v12[165] = __collate_load_tables_cache;
      xlocale_retain((unsigned int *)__collate_load_tables_cache);
      return 1;
    }
  }
  else
  {
    if (v12 == __global_locale)
      __collate_load_error = 1;
    xlocale_release(v12[165]);
    v12[165] = __xlocale_C_collate;
    xlocale_retain(__xlocale_C_collate);
    return 1;
  }
}

uint64_t __collate_load_tables_legacy(uint64_t a1, _QWORD *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t *a6)
{
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int *v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  uint64_t v18;
  uint64_t v19;
  int i;
  int j;
  int k;
  int m;
  int n;
  int ii;
  int jj;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int *v36;
  unsigned int *v37;
  uint64_t v38;
  char *v39;
  uint64_t v40;
  uint64_t v44;
  unsigned int *v45;
  unsigned int *v49;
  unsigned int *v50;

  v49 = 0;
  v50 = 0;
  v40 = a3 + 10;
  v44 = a3 + 38;
  for (i = 0; i < (*(_BYTE *)(v40 + 3) & 0xF); ++i)
  {
    *(_DWORD *)(v40 + 4 + 4 * i) = _OSSwapInt32(*(_DWORD *)(v40 + 4 + 4 * i));
    *(_DWORD *)(v40 + 12 + 4 * i) = _OSSwapInt32(*(_DWORD *)(v40 + 12 + 4 * i));
  }
  *(_DWORD *)(v40 + 20) = _OSSwapInt32(*(_DWORD *)(v40 + 20));
  *(_DWORD *)(v40 + 24) = _OSSwapInt32(*(_DWORD *)(v40 + 24));
  v27 = *(_DWORD *)(v40 + 20);
  if (v27 >= 0)
  {
    v28 = 48 * v27 + 2048 + 12 * *(_DWORD *)(v40 + 24);
    for (j = 0; j < (*(_BYTE *)(v40 + 3) & 0xF); ++j)
      v28 += 44 * *(_DWORD *)(v40 + 12 + 4 * j);
    if (v28 == *(_QWORD *)(a5 + 96) - (v44 - (_QWORD)a4))
    {
      v39 = (char *)malloc_type_malloc(200, 0x10B004021DA7767);
      if (v39)
      {
        *((_QWORD *)v39 + 9) = a4;
        *((_QWORD *)v39 + 10) = *(_QWORD *)(a5 + 96);
        v29 = 136 * v27 + 10384 + 44 * *(_DWORD *)(v40 + 24);
        for (k = 0; k < (*(_BYTE *)(v40 + 3) & 0xF); ++k)
          v29 += 100 * *(_DWORD *)(v40 + 12 + 4 * k);
        v6 = malloc_type_calloc(1, v29, 2410357186);
        *((_QWORD *)v39 + 11) = v6;
        if (v6)
        {
          v34 = *((_QWORD *)v39 + 11) + 144;
          *(_DWORD *)v39 = 2;
          *((_QWORD *)v39 + 1) = destruct_collate;
          v38 = v44;
          *((_QWORD *)v39 + 24) = v34;
          v45 = (unsigned int *)(v44 + 2048);
          v35 = v34 + 10240;
          if (*(int *)(v40 + 12) <= 0)
          {
            *((_QWORD *)v39 + 12) = 0;
          }
          else
          {
            v49 = v45;
            *((_QWORD *)v39 + 12) = v35;
            v45 += 11 * *(int *)(v40 + 12);
            v35 += 100 * *(int *)(v40 + 12);
          }
          if ((*(_BYTE *)(v40 + 2) & 1) != 0)
          {
            *((_QWORD *)v39 + 13) = *((_QWORD *)v39 + 12);
          }
          else if (*(int *)(v40 + 16) <= 0)
          {
            *((_QWORD *)v39 + 13) = 0;
          }
          else
          {
            v50 = v45;
            *((_QWORD *)v39 + 13) = v35;
            v45 += 11 * *(int *)(v40 + 16);
            v35 += 100 * *(int *)(v40 + 16);
          }
          if (v27 <= 0)
          {
            v37 = 0;
            *((_QWORD *)v39 + 22) = 0;
          }
          else
          {
            v37 = v45;
            *((_QWORD *)v39 + 22) = v35;
            v45 += 12 * v27;
            v35 += 136 * v27;
          }
          if (*(int *)(v40 + 24) <= 0)
          {
            v36 = 0;
            *((_QWORD *)v39 + 23) = 0;
          }
          else
          {
            v36 = v45;
            *((_QWORD *)v39 + 23) = v35;
          }
          v19 = *((_QWORD *)v39 + 24);
          v18 = v38;
          v30 = 256;
          while (1)
          {
            v7 = v30--;
            if (v7 <= 0)
              break;
            for (m = 0; m < (*(_BYTE *)(v40 + 3) & 0xF); ++m)
              *(_DWORD *)(v19 + 4 * m) = _OSSwapInt32(*(_DWORD *)(v18 + 4 * m));
            v19 += 40;
            v18 += 8;
          }
          for (n = 0; n < (*(_BYTE *)(v40 + 3) & 0xF); ++n)
          {
            if (*(int *)(v40 + 12 + 4 * n) > 0)
            {
              v17 = (&v49)[n];
              v16 = *(unsigned int **)&v39[8 * n + 96];
              v31 = *(_DWORD *)(v40 + 12 + 4 * n);
              while (1)
              {
                v8 = v31--;
                if (v8 <= 0)
                  break;
                j___platform_memmove(v16 + 1, v17 + 1, 40);
                *v16 = *v17;
                *v16 = _OSSwapInt32(*v16);
                wntohl((uint64_t)(v16 + 1), 10);
                v17 += 11;
                v16 += 25;
              }
            }
          }
          v15 = *((_QWORD *)v39 + 22);
          v14 = v37;
          v32 = v27;
          while (1)
          {
            v9 = v32--;
            if (v9 <= 0)
              break;
            j___platform_memmove(v15, v14, 40);
            wntohl(v15, 10);
            for (ii = 0; ii < (*(_BYTE *)(v40 + 3) & 0xF); ++ii)
              *(_DWORD *)(v15 + 96 + 4 * ii) = _OSSwapInt32(v14[ii + 10]);
            v15 += 136;
            v14 += 12;
          }
          if (*(int *)(v40 + 24) > 0)
          {
            v13 = (unsigned int *)*((_QWORD *)v39 + 23);
            v12 = v36;
            v33 = *(_DWORD *)(v40 + 24);
            while (1)
            {
              v10 = v33--;
              if (v10 <= 0)
                break;
              *v13 = *v12;
              *v13 = _OSSwapInt32(*v13);
              for (jj = 0; jj < (*(_BYTE *)(v40 + 3) & 0xF); ++jj)
                v13[jj + 1] = _OSSwapInt32(v12[jj + 1]);
              v13 += 11;
              v12 += 3;
            }
          }
          _platform_strcpy(v39 + 16, a1);
          __collate_fill_info((uint64_t)v39, v40);
          xlocale_release(*a6);
          *a6 = (uint64_t)v39;
          xlocale_release(a2[165]);
          a2[165] = v39;
          v39[64] = 0;
          if (a2 == __global_locale)
            __collate_load_error = 0;
          return 0;
        }
        else
        {
          munmap(a4, *(_QWORD *)(a5 + 96));
          free(v39);
          *__error() = 12;
          return -1;
        }
      }
      else
      {
        munmap(a4, *(_QWORD *)(a5 + 96));
        *__error() = 12;
        return -1;
      }
    }
    else
    {
      munmap(a4, *(_QWORD *)(a5 + 96));
      *__error() = 22;
      return -1;
    }
  }
  else
  {
    munmap(a4, *(_QWORD *)(a5 + 96));
    *__error() = 79;
    return -1;
  }
}

void destruct_collate(uint64_t a1)
{
  if ((*(_DWORD *)(*(_QWORD *)(a1 + 88) + 52) & 2) != 0)
    free(*(void **)(a1 + 88));
  if (*(_QWORD *)(a1 + 72) && *(_QWORD *)(a1 + 80))
    munmap(*(void **)(a1 + 72), *(_QWORD *)(a1 + 80));
  free((void *)a1);
}

__int32 *__collate_substitute(const __int32 *a1, int a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  __int32 *v6;
  void *__ptr;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  const __int32 *v17;

  v17 = a1;
  if (!a1 || !*a1)
    return __collate_wcsdup((const __int32 *)&unk_D2D08);
  v13 = wcslen(a1);
  v8 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 1320) + 88) + 64 + 4 * a2);
  if (v8 <= 0)
    return __collate_wcsdup(v17);
  v5 = *(_QWORD *)(*(_QWORD *)(a3 + 1320) + 96 + 8 * a2);
  v9 = v13 / 4;
  if (v13 / 4 < 2)
    v9 = 2;
  v14 = v13 + v9;
  __ptr = (void *)malloc_type_malloc(4 * v14, 0x100004052888210);
  if (!__ptr)
    __collate_err(71, (uint64_t)"__collate_substitute");
  v12 = 0;
  while (*v17)
  {
    v4 = substsearch(*v17, v5, v8);
    if (v4)
    {
      v6 = (__int32 *)(v4 + 4);
      v10 = __collate_wcsnlen((_DWORD *)(v4 + 4), 24);
    }
    else
    {
      v6 = (__int32 *)v17;
      v10 = 1;
    }
    v11 = v12 + v10;
    if (v14 <= v12 + v10)
    {
      v14 = v11 + v9;
      __ptr = reallocf(__ptr, 4 * (v11 + v9));
      if (!__ptr)
        __collate_err(71, (uint64_t)"__collate_substitute");
    }
    wcsncpy((__int32 *)__ptr + v12, v6, v10);
    v12 += v10;
    ++v17;
  }
  *((_DWORD *)__ptr + v12) = 0;
  return (__int32 *)__ptr;
}

__int32 *__collate_wcsdup(const __int32 *a1)
{
  __int32 *v2;
  size_t v3;

  v3 = wcslen(a1) + 1;
  v2 = (__int32 *)malloc_type_malloc(4 * v3, 0x100004052888210);
  if (!v2)
    __collate_err(71, (uint64_t)"__collate_wcsdup");
  wcscpy(v2, a1);
  return v2;
}

void __collate_err(int a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const char *v5;
  char *v6;
  int v7;

  v7 = *__error();
  v5 = getprogname();
  v2 = _platform_strlen(v5);
  write_NOCANCEL(2, v5, v2);
  write_NOCANCEL(2, ": ", 2);
  v3 = _platform_strlen(a2);
  write_NOCANCEL(2, a2, v3);
  write_NOCANCEL(2, ": ", 2);
  v6 = strerror(v7);
  v4 = _platform_strlen(v6);
  write_NOCANCEL(2, v6, v4);
  write_NOCANCEL(2, "\n", 1);
  exit(a1);
}

uint64_t substsearch(int a1, uint64_t a2, int a3)
{
  int v3;
  int v5;
  int v6;
  int v7;

  v7 = 0;
  v6 = a3 - 1;
  while (v7 <= v6)
  {
    v5 = (v7 + v6) / 2;
    v3 = *(_DWORD *)(a2 + 100 * v5);
    if (a1 == v3)
      return a2 + 100 * v5;
    if (a1 - v3 <= 0)
      v6 = v5 - 1;
    else
      v7 = v5 + 1;
  }
  return 0;
}

uint64_t __collate_wcsnlen(_DWORD *a1, int a2)
{
  BOOL v3;
  unsigned int i;

  for (i = 0; ; ++i)
  {
    v3 = 0;
    if (*a1)
      v3 = (int)i < a2;
    if (!v3)
      break;
    ++a1;
  }
  return i;
}

const __int32 *__collate_lookup_l(const __int32 *result, int *a2, int *a3, int *a4, _QWORD *a5)
{
  __int32 v5;
  __int32 v6;
  int v7;
  int *v8;
  uint64_t v9;
  const __int32 *v10;
  const __int32 *v11;
  _QWORD *v12;
  int *v13;
  int *v14;
  int *v15;
  const __int32 *v16;

  v16 = result;
  v15 = a2;
  v14 = a3;
  v13 = a4;
  v12 = a5;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  if (!*result)
  {
    *v15 = 0;
    *v14 = 0;
    *v13 = 0;
    return result;
  }
  if (v12)
  {
    if (v12 == (_QWORD *)-1)
      v12 = __global_locale;
  }
  else
  {
    v12 = &__c_locale;
  }
  v9 = v12[165];
  if (*(_BYTE *)(v9 + 64))
  {
    *v15 = 1;
    *v14 = *v16;
    *v13 = 0;
    return result;
  }
  *v15 = 1;
  result = (const __int32 *)chainsearch(v16, &v7, (uint64_t)v12);
  v11 = result;
  if (result && v11[24] >= 0)
  {
    *v15 = v7;
    *v14 = v11[24];
    *v13 = v11[25];
  }
  else if (*v16 > 255)
  {
    if (*(int *)(*(_QWORD *)(v12[165] + 88) + 60) <= 0
      || (result = (const __int32 *)largesearch(*v16, (uint64_t)v12), (v10 = result) == 0))
    {
      v7 = *(_DWORD *)(*(_QWORD *)(v12[165] + 88) + 104);
      if (v7 < 0)
        v6 = *v16 - v7;
      else
        v6 = v7;
      *v14 = v6;
      v7 = *(_DWORD *)(*(_QWORD *)(v12[165] + 88) + 108);
      if (v7 < 0)
        v5 = *v16 - v7;
      else
        v5 = v7;
      *v13 = v5;
      return result;
    }
    *v14 = v10[1];
    *v13 = v10[2];
  }
  else
  {
    *v14 = *(_DWORD *)(*(_QWORD *)(v12[165] + 192) + 40 * *v16);
    *v13 = *(_DWORD *)(*(_QWORD *)(v12[165] + 192) + 40 * *v16 + 4);
  }
  if (*v14 >= 0)
  {
    result = lookup_substsearch(v9, *v14, 0);
    v8 = (int *)result;
    if (result)
      *v14 = *v8;
  }
  if (*v13 >= 0)
  {
    result = lookup_substsearch(v9, *v13, 1);
    v8 = (int *)result;
    if (result)
      *v13 = v8[1];
  }
  return result;
}

uint64_t chainsearch(const __int32 *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v4;
  __int32 *v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;

  v10 = 0;
  v9 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a3 + 1320) + 88) + 56) - 1;
  v4 = *(_QWORD *)(*(_QWORD *)(a3 + 1320) + 176);
  while (v10 <= v9)
  {
    v8 = (v10 + v9) / 2;
    v5 = (__int32 *)(v4 + 136 * v8);
    v7 = *a1 - *v5;
    if (*a1 == *v5)
    {
      v6 = __collate_wcsnlen(v5, 24);
      v7 = wcsncmp(a1, v5, v6);
      if (!v7)
      {
        *a2 = v6;
        return v4 + 136 * v8;
      }
    }
    if (v7 <= 0)
      v9 = v8 - 1;
    else
      v10 = v8 + 1;
  }
  return 0;
}

uint64_t largesearch(int a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  int v5;
  int v6;
  int v7;

  v7 = 0;
  v6 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 1320) + 88) + 60) - 1;
  v4 = *(_QWORD *)(*(_QWORD *)(a2 + 1320) + 184);
  while (v7 <= v6)
  {
    v5 = (v7 + v6) / 2;
    v2 = *(_DWORD *)(v4 + 44 * v5);
    if (a1 == v2)
      return v4 + 44 * v5;
    if (a1 - v2 <= 0)
      v6 = v5 - 1;
    else
      v7 = v5 + 1;
  }
  return 0;
}

_DWORD *lookup_substsearch(uint64_t a1, int a2, int a3)
{
  _DWORD *v4;

  if (!*(_DWORD *)(*(_QWORD *)(a1 + 88) + 64 + 4 * a3))
    return 0;
  if (a3 >= **(unsigned __int8 **)(a1 + 88))
    return 0;
  if ((a2 & 0x40000000) == 0)
    return 0;
  v4 = (_DWORD *)(*(_QWORD *)(a1 + 96 + 8 * a3) + 100 * (int)(a2 & 0xBFFFFFFF));
  if (*v4 != a2)
    __assert_rtn("lookup_substsearch", "collate.c", 596, "p->val == key");
  return v4 + 1;
}

char *__collate_lookup(char *result, int *a2, int *a3, int *a4)
{
  char v4;
  char v5;
  _xlocale *v6;
  int v7;
  int v8;
  __int32 *v9;
  char *v13;
  char *v14;
  uint64_t v15;

  v13 = result;
  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    result = (char *)pthread_getspecific(__locale_key);
    v14 = result;
  }
  else
  {
    v15 = __locale_key;
    v14 = *(char **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v15);
  }
  if (v14)
    v6 = (_xlocale *)v14;
  else
    v6 = (_xlocale *)__global_locale;
  v9 = 0;
  if (*v13)
  {
    if (!*(_BYTE *)(*((_QWORD *)v6 + 165) + 64) && (v9 = __collate_mbstowcs(v13, v6)) != 0)
    {
      __collate_lookup_l(v9, a2, a3, a4, v6);
      v8 = *__error();
      free(v9);
      result = (char *)__error();
      *(_DWORD *)result = v8;
    }
    else
    {
      *a2 = 1;
      *a3 = *v13;
      *a4 = 0;
      v7 = *__error();
      free(v9);
      result = (char *)__error();
      *(_DWORD *)result = v7;
    }
  }
  else
  {
    *a2 = 0;
    *a3 = 0;
    *a4 = 0;
  }
  return result;
}

__int32 *__collate_mbstowcs(char *a1, _xlocale *a2)
{
  __int32 *v3;
  char *v4;
  size_t v5;
  locale_t v6;
  char *v7;
  mbstate_t v9;

  v7 = a1;
  v6 = a2;
  _platform_memset(&v9, 0, 128);
  v5 = 0;
  v4 = v7;
  j___platform_memmove(&v9, &__collate_mbstowcs_initial, 128);
  v5 = mbsrtowcs_l(0, (const char **)&v4, 0, &v9, v6);
  if (v5 == -1)
    return 0;
  v3 = (__int32 *)malloc_type_malloc(4 * (v5 + 1), 0x100004052888210);
  if (!v3)
    __collate_err(71, (uint64_t)"__collate_mbstowcs");
  j___platform_memmove(&v9, &__collate_mbstowcs_initial, 128);
  mbsrtowcs_l(v3, (const char **)&v7, v5, &v9, v6);
  v3[v5] = 0;
  return v3;
}

uint64_t __collate_lookup_which(const __int32 *a1, _DWORD *a2, int *a3, int a4, uint64_t a5)
{
  uint64_t result;
  int v6;
  int v7;
  uint64_t v8;
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int *v14;
  _DWORD *v15;
  const __int32 *v16;

  v16 = a1;
  v15 = a2;
  v14 = a3;
  v13 = a4;
  v12 = a5;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v8 = *(_QWORD *)(a5 + 1320);
  *a2 = 1;
  result = chainsearch(v16, &v6, v12);
  v11 = result;
  if (result)
  {
    v7 = *(_DWORD *)(v11 + 96 + 4 * v13);
    if (v7 >= 0)
    {
      *v15 = v6;
      *v14 = v7;
      goto LABEL_12;
    }
  }
  if (*v16 <= 255)
  {
    *v14 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 1320) + 192) + 40 * *v16 + 4 * v13);
    goto LABEL_12;
  }
  if (*(int *)(*(_QWORD *)(*(_QWORD *)(v12 + 1320) + 88) + 60) > 0)
  {
    result = largesearch(*v16, v12);
    v10 = result;
    if (result)
    {
      *v14 = *(_DWORD *)(v10 + 4 + 4 * v13);
LABEL_12:
      result = (uint64_t)lookup_substsearch(v8, *v14, 0);
      v9 = (int *)result;
      if (result)
        *v14 = *v9;
      return result;
    }
  }
  if ((*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v12 + 1320) + 88) + 1 + v13) & 8) != 0)
    *v14 = *v16 & 0xFFFFFF;
  else
    *v14 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v12 + 1320) + 88) + 104 + 4 * v13);
  return result;
}

int *__collate_xfrm(const __int32 *a1, uint64_t a2, uint64_t a3)
{
  __int32 *v3;
  __int32 *v4;
  __int32 *v5;
  size_t v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  int *result;
  __int32 v11;
  __int32 *k;
  __int32 *v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unsigned __int8 *v18;
  _DWORD *v19;
  int i;
  int j;
  unsigned __int8 v22;
  __int32 *v23;
  __int32 *v24;
  const __int32 *v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  const __int32 *v30;

  v30 = a1;
  v29 = a2;
  v28 = a3;
  v27 = 0;
  v26 = 0;
  v24 = 0;
  v23 = 0;
  v18 = *(unsigned __int8 **)(*(_QWORD *)(a3 + 1320) + 88);
  for (i = 0; i < 10; ++i)
    *(_QWORD *)(v29 + 8 * i) = 0;
  for (j = 0; j < *v18; ++j)
  {
    v22 = v18[j + 1];
    if (!j || (*((_DWORD *)v18 + 13) & 1) == 0)
    {
      v14 = *__error();
      free(v24);
      *__error() = v14;
      v24 = __collate_substitute(v30, j, v28);
    }
    if ((v22 & 2) != 0)
    {
      v15 = *__error();
      free(v23);
      *__error() = v15;
      if (v24)
        v3 = __collate_wcsdup(v24);
      else
        v3 = __collate_wcsdup(v30);
      v23 = v3;
      v13 = v3;
      for (k = &v3[wcslen(v3) - 1]; v13 < k; --k)
      {
        v11 = *v13;
        v4 = v13++;
        *v4 = *k;
        v5 = k;
        *v5 = v11;
      }
      v25 = v23;
    }
    else if (v24)
    {
      v25 = v24;
    }
    else
    {
      v25 = v30;
    }
    v16 = *__error();
    v6 = wcslen(v25);
    v7 = malloc_type_malloc(4 * (v6 + 1), 0x100004052888210);
    *(_QWORD *)(v29 + 8 * j) = v7;
    if (!v7)
    {
      *__error() = v16;
      break;
    }
    *__error() = v16;
    v19 = *(_DWORD **)(v29 + 8 * j);
    if ((v22 & 4) != 0)
    {
      while (*v25)
      {
        __collate_lookup_which(v25, &v26, &v27, j, v28);
        v25 += v26;
        if (v27 <= 0)
        {
          if (v27 < 0)
            goto LABEL_26;
          v27 = 0xFFFFFF;
        }
        v8 = v19++;
        *v8 = v27;
      }
    }
    else
    {
      while (*v25)
      {
        __collate_lookup_which(v25, &v26, &v27, j, v28);
        v25 += v26;
        if (v27 > 0)
        {
          v9 = v19++;
          *v9 = v27;
        }
        else if (v27 < 0)
        {
LABEL_26:
          *__error() = 22;
          goto LABEL_36;
        }
      }
    }
    *v19 = 0;
  }
LABEL_36:
  v17 = *__error();
  free(v24);
  free(v23);
  result = __error();
  *result = v17;
  return result;
}

uint64_t __collate_collating_symbol(__int32 *a1, size_t a2, char *a3, size_t a4, mbstate_t *a5, _xlocale *a6)
{
  __int32 *v6;
  int v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  size_t i;
  __int32 *v13;
  __int32 v14;
  locale_t v15;
  mbstate_t *v16;
  size_t v17;
  char *v18;
  size_t v19;
  __int32 *v20;
  __int32 v22[24];

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = a4;
  v16 = a5;
  v15 = a6;
  v14 = 0;
  v13 = 0;
  i = 0;
  v11 = 0;
  if (*(_BYTE *)(*((_QWORD *)a6 + 165) + 64))
  {
    if (v19)
    {
      if (v17 == 1 && isascii(*v18))
      {
        *v20 = *v18;
        return 1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    v13 = v22;
    for (i = 0; v17; ++i)
    {
      v11 = mbrtowc_l(&v14, v18, v17, v16, v15);
      if (v11 >= 0xFFFFFFFFFFFFFFFELL)
        return -1;
      if (!v11)
        break;
      if (i >= 0x18)
        return -1;
      v6 = v13++;
      *v6 = v14;
      v18 += v11;
      v17 -= v11;
    }
    if (i && i <= v19)
    {
      if (i == 1)
      {
        if (v22[0] > 255)
        {
          if (*(int *)(*(_QWORD *)(*((_QWORD *)v15 + 165) + 88) + 60) > 0
            && (v10 = largesearch(v22[0], (uint64_t)v15)) != 0
            && *(int *)(v10 + 4) >= 0)
          {
            if (v19)
              *v20 = v22[0];
            return 1;
          }
          else
          {
            return 0;
          }
        }
        else if (*(int *)(*(_QWORD *)(*((_QWORD *)v15 + 165) + 192) + 40 * v22[0]) < 0)
        {
          return 0;
        }
        else
        {
          if (v19)
            *v20 = v22[0];
          return 1;
        }
      }
      else
      {
        *v13 = 0;
        if (*(int *)(*(_QWORD *)(*((_QWORD *)v15 + 165) + 88) + 56) > 0
          && (v9 = 0, v8 = 0, (v9 = chainsearch(v22, &v8, (uint64_t)v15)) != 0))
        {
          if (v8 < v19)
            v19 = v8;
          wcsncpy(v20, v22, v19);
          return v8;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return -1;
    }
  }
}

uint64_t __collate_equiv_class(char *a1, size_t a2, mbstate_t *a3, _xlocale *a4)
{
  __int32 *v4;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  size_t v12;
  unint64_t i;
  __int32 *v14;
  __int32 v15;
  locale_t v16;
  mbstate_t *v17;
  size_t v18;
  char *v19;
  __int32 v21[24];

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = 0;
  v14 = 0;
  i = 0;
  v12 = 0;
  v11 = 0;
  if (*(_BYTE *)(*((_QWORD *)a4 + 165) + 64))
  {
    return 0;
  }
  else
  {
    v14 = v21;
    for (i = 0; v18; ++i)
    {
      v12 = mbrtowc_l(&v15, v19, v18, v17, v16);
      if (v12 >= 0xFFFFFFFFFFFFFFFELL)
        return -1;
      if (!v12)
        break;
      if (i >= 0x18)
        return -1;
      v4 = v14++;
      *v4 = v15;
      v19 += v12;
      v18 -= v12;
    }
    if (i)
    {
      if (i == 1)
      {
        v11 = -1;
        if (v21[0] > 255)
        {
          if (*(int *)(*(_QWORD *)(*((_QWORD *)v16 + 165) + 88) + 60) > 0)
          {
            v10 = largesearch(v21[0], (uint64_t)v16);
            if (v10)
              v11 = *(_DWORD *)(v10 + 4);
          }
        }
        else
        {
          v11 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v16 + 165) + 192) + 40 * v21[0]);
        }
        if (v11)
        {
          if (v11 <= 0)
            return 0;
          else
            return v11;
        }
        else
        {
          return 1;
        }
      }
      else
      {
        *v14 = 0;
        if (*(int *)(*(_QWORD *)(*((_QWORD *)v16 + 165) + 88) + 56) > 0
          && (v9 = 0, v8 = 0, (v9 = chainsearch(v21, &v8, (uint64_t)v16)) != 0))
        {
          v11 = *(_DWORD *)(v9 + 96);
          if (v11)
          {
            if (v11 >= 0)
              return v11;
            else
              return -v11;
          }
          else
          {
            return 1;
          }
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      return -1;
    }
  }
}

uint64_t __collate_equiv_match(int a1, _DWORD *a2, unint64_t a3, __int32 a4, char *a5, size_t a6, mbstate_t *a7, _QWORD *a8, _xlocale *a9)
{
  __int32 *v9;
  int v10;
  __int32 *v11;
  _DWORD *v12;
  BOOL v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  size_t v18;
  const char *v19;
  __int32 *v20;
  __int32 *v21;
  int v22;
  uint64_t v23;
  size_t v24;
  unint64_t v25;
  __int32 v26;
  locale_t v27;
  _QWORD *v28;
  mbstate_t *v29;
  size_t v30;
  char *v31;
  __int32 v32;
  unint64_t v33;
  _DWORD *v34;
  int v35;
  _BYTE v37[128];
  __int32 v38;
  int v39;

  v35 = a1;
  v34 = a2;
  v33 = a3;
  v32 = a4;
  v31 = a5;
  v30 = a6;
  v29 = a7;
  v28 = a8;
  v27 = a9;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  _platform_memset(v37, 0, 128);
  v19 = v31;
  v18 = v30;
  if (*(_BYTE *)(*((_QWORD *)a9 + 165) + 64))
    return -1;
  if (v35 == 1)
    v35 = 0;
  if (v29)
    j___platform_memmove(v37, v29, 128);
  v20 = &v38;
  v23 = 0;
  v25 = 0;
  if (v32)
  {
    v20 = &v39;
    v38 = v32;
    v25 = 1;
  }
  while (1)
  {
    v14 = 0;
    if (v18)
      v14 = v25 < *(unsigned __int8 *)(*(_QWORD *)(*((_QWORD *)v27 + 165) + 88) + 11);
    if (!v14)
      break;
    v24 = mbrtowc_l(&v26, v19, v18, v29, v27);
    if (v24 == -1 || v24 == -2 || !v24)
      break;
    v9 = v20++;
    *v9 = v26;
    v19 += v24;
    v23 += v24;
    v18 -= v24;
    ++v25;
  }
  *v20 = 0;
  if (v25 <= 1)
    goto LABEL_22;
  v17 = chainsearch(&v38, &v22, (uint64_t)v27);
  if (!v17)
    goto LABEL_22;
  v16 = *(_DWORD *)(v17 + 96);
  if (v16 < 0)
    v16 = -v16;
  if (v16 != v35)
  {
LABEL_22:
    v22 = 1;
    if (v38 > 255)
    {
      if (*(int *)(*(_QWORD *)(*((_QWORD *)v27 + 165) + 88) + 60) <= 0)
        goto LABEL_28;
      v15 = largesearch(v38, (uint64_t)v27);
      if (!v15 || v35 != *(_DWORD *)(v15 + 4))
        goto LABEL_28;
    }
    else if (v35 != *(_DWORD *)(*(_QWORD *)(*((_QWORD *)v27 + 165) + 192) + 40 * v38))
    {
LABEL_28:
      if (v29)
        j___platform_memmove(v29, v37, 128);
      return 0;
    }
  }
  if (v22 < v25)
  {
    v25 = v22;
    if (v29)
      j___platform_memmove(v29, v37, 128);
    if (v32)
      --v22;
    v23 = 0;
    while (1)
    {
      v10 = v22--;
      if (v10 <= 0)
        break;
      v24 = mbrtowc_l(&v26, v31, v30, v29, v27);
      v31 += v24;
      v23 += v24;
      v30 -= v24;
    }
  }
  if (v34)
  {
    if (v33 < v25)
    {
      if (v29)
        j___platform_memmove(v29, v37, 128);
      return -1;
    }
    v21 = &v38;
    while (v25)
    {
      v11 = v21++;
      LODWORD(v11) = *v11;
      v12 = v34++;
      *v12 = (_DWORD)v11;
      --v25;
    }
  }
  if (v28)
    *v28 = v23;
  return v25;
}

uint64_t __collate_equiv_value(uint64_t a1, __int32 *a2, size_t a3)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  size_t v11;
  __int32 *v12;
  uint64_t v13;
  __int32 v15[24];

  v13 = a1;
  v12 = a2;
  v11 = a3;
  v10 = 0;
  if (a3 && v11 < 0x18)
  {
    if (*(_BYTE *)(*(_QWORD *)(v13 + 1320) + 64))
    {
      if (v11 == 1 && *v12 <= 255)
        return *v12;
      else
        return -1;
    }
    else if (v11 == 1)
    {
      v10 = -1;
      if (*v12 > 255)
      {
        if (*(int *)(*(_QWORD *)(*(_QWORD *)(v13 + 1320) + 88) + 60) > 0)
        {
          v9 = 0;
          v9 = largesearch(*v12, v13);
          if (v9)
            v10 = *(_DWORD *)(v9 + 4);
        }
      }
      else
      {
        v10 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v13 + 1320) + 192) + 40 * *v12);
      }
      if (v10)
      {
        if (v10 <= 0)
          return 0;
        else
          return v10;
      }
      else
      {
        return 1;
      }
    }
    else if (*(int *)(*(_QWORD *)(*(_QWORD *)(v13 + 1320) + 88) + 56) > 0
           && (v8 = 0, v7 = 0, wcsncpy(v15, v12, v11), v15[v11] = 0, (v8 = chainsearch(v15, &v7, v13)) != 0))
    {
      v10 = *(_DWORD *)(v8 + 96);
      if (v10)
      {
        if (v10 >= 0)
          return v10;
        else
          return -v10;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return -1;
  }
}

uint64_t _OSSwapInt32(unsigned int a1)
{
  return bswap32(a1);
}

uint64_t wntohl(uint64_t result, int a2)
{
  BOOL v2;
  unsigned int *i;

  for (i = (unsigned int *)result; ; ++i)
  {
    v2 = 0;
    if (*i)
      v2 = a2 > 0;
    if (!v2)
      break;
    result = _OSSwapInt32(*i);
    *i = result;
    --a2;
  }
  return result;
}

uint64_t __collate_fill_info(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 88);
  result = _platform_memset(v3, 0, 144);
  *(_BYTE *)v3 = *(_BYTE *)(a2 + 3) & 0xF;
  *(_BYTE *)(v3 + 11) = *(_BYTE *)(a2 + 3) >> 4;
  *(_DWORD *)(v3 + 52) = *(unsigned __int8 *)(a2 + 2) | 2;
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 20);
  *(_DWORD *)(v3 + 60) = *(_DWORD *)(a2 + 24);
  *(_WORD *)(v3 + 1) = *(_WORD *)a2;
  *(_QWORD *)(v3 + 64) = *(_QWORD *)(a2 + 12);
  *(_QWORD *)(v3 + 104) = *(_QWORD *)(a2 + 4);
  return result;
}

uint64_t __collate_range_cmp(int a1, int a2, _xlocale *a3)
{
  __collate_range_cmp_s1 = a1;
  __collate_range_cmp_s2 = a2;
  return wcscoll_l(&__collate_range_cmp_s1, &__collate_range_cmp_s2, a3);
}

uint64_t _EUC_CN_init(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(v2 + 3184) = 0;
  result = 0;
  *(_DWORD *)(v2 + 3192) = 0;
  *(_QWORD *)(a1 + 72) = _EUC_CN_mbrtowc;
  *(_QWORD *)(a1 + 96) = _EUC_CN_wcrtomb;
  *(_QWORD *)(a1 + 88) = _EUC_CN_mbsnrtowcs;
  *(_QWORD *)(a1 + 104) = _EUC_CN_wcsnrtombs;
  *(_QWORD *)(a1 + 80) = _EUC_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return result;
}

uint64_t _EUC_CN_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, uint64_t a5)
{
  return _EUC_mbrtowc_impl(a1, a2, a3, a4, 0, 0, 0, 0, a5);
}

uint64_t _EUC_CN_wcrtomb(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  return _EUC_wcrtomb_impl(a1, a2, a3, 0, 0, 0, 0);
}

uint64_t _EUC_CN_mbsnrtowcs(int *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return __mbsnrtowcs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_CN_wcsnrtombs(_BYTE *a1, _DWORD **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  return __wcsnrtombs_std(a1, a2, a3, a4, a5, a6);
}

BOOL _EUC_mbsinit(uint64_t a1)
{
  BOOL v2;

  v2 = 1;
  if (a1)
    return *(_DWORD *)(a1 + 4) == 0;
  return v2;
}

uint64_t _EUC_KR_init(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(v2 + 3184) = 0;
  result = 0;
  *(_DWORD *)(v2 + 3192) = 0;
  *(_QWORD *)(a1 + 72) = _EUC_KR_mbrtowc;
  *(_QWORD *)(a1 + 96) = _EUC_KR_wcrtomb;
  *(_QWORD *)(a1 + 88) = _EUC_KR_mbsnrtowcs;
  *(_QWORD *)(a1 + 104) = _EUC_KR_wcsnrtombs;
  *(_QWORD *)(a1 + 80) = _EUC_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return result;
}

uint64_t _EUC_KR_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, uint64_t a5)
{
  return _EUC_mbrtowc_impl(a1, a2, a3, a4, 0, 0, 0, 0, a5);
}

uint64_t _EUC_KR_wcrtomb(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  return _EUC_wcrtomb_impl(a1, a2, a3, 0, 0, 0, 0);
}

uint64_t _EUC_KR_mbsnrtowcs(int *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return __mbsnrtowcs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_KR_wcsnrtombs(_BYTE *a1, _DWORD **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  return __wcsnrtombs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_JP_init(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(v2 + 3184) = 0;
  result = 0;
  *(_DWORD *)(v2 + 3192) = 0;
  *(_QWORD *)(a1 + 72) = _EUC_JP_mbrtowc;
  *(_QWORD *)(a1 + 96) = _EUC_JP_wcrtomb;
  *(_QWORD *)(a1 + 88) = _EUC_JP_mbsnrtowcs;
  *(_QWORD *)(a1 + 104) = _EUC_JP_wcsnrtombs;
  *(_QWORD *)(a1 + 80) = _EUC_mbsinit;
  *(_DWORD *)(a1 + 64) = 3;
  *(_DWORD *)(a1 + 68) = 128;
  return result;
}

uint64_t _EUC_JP_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, uint64_t a5)
{
  return _EUC_mbrtowc_impl(a1, a2, a3, a4, 0x8Eu, 2u, 0x8Fu, 3u, a5);
}

uint64_t _EUC_JP_wcrtomb(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  return _EUC_wcrtomb_impl(a1, a2, a3, 0x8Eu, 2u, 0x8Fu, 3u);
}

uint64_t _EUC_JP_mbsnrtowcs(int *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return __mbsnrtowcs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_JP_wcsnrtombs(_BYTE *a1, _DWORD **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  return __wcsnrtombs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_init(uint64_t a1)
{
  unsigned int v2;

  v2 = _EUC_JP_init(a1);
  if (!v2)
    *(_DWORD *)(a1 + 68) = 256;
  return v2;
}

uint64_t _EUC_TW_init(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 120);
  *(_QWORD *)(v2 + 3184) = 0;
  result = 0;
  *(_DWORD *)(v2 + 3192) = 0;
  *(_QWORD *)(a1 + 72) = _EUC_TW_mbrtowc;
  *(_QWORD *)(a1 + 96) = _EUC_TW_wcrtomb;
  *(_QWORD *)(a1 + 88) = _EUC_TW_mbsnrtowcs;
  *(_QWORD *)(a1 + 104) = _EUC_TW_wcsnrtombs;
  *(_QWORD *)(a1 + 80) = _EUC_mbsinit;
  *(_DWORD *)(a1 + 64) = 4;
  *(_DWORD *)(a1 + 68) = 128;
  return result;
}

uint64_t _EUC_TW_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, uint64_t a5)
{
  return _EUC_mbrtowc_impl(a1, a2, a3, a4, 0x8Eu, 4u, 0, 0, a5);
}

uint64_t _EUC_TW_wcrtomb(_BYTE *a1, unsigned int a2, uint64_t a3)
{
  return _EUC_wcrtomb_impl(a1, a2, a3, 0x8Eu, 4u, 0, 0);
}

uint64_t _EUC_TW_mbsnrtowcs(int *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  return __mbsnrtowcs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_TW_wcsnrtombs(_BYTE *a1, _DWORD **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  return __wcsnrtombs_std(a1, a2, a3, a4, a5, a6);
}

uint64_t _EUC_mbrtowc_impl(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7, unsigned __int8 a8, uint64_t a9)
{
  unint64_t v11;
  unsigned __int8 v12;
  int v13;
  int v14;
  int i;
  unsigned __int8 *v17;

  v17 = a2;
  v13 = 0;
  if (a4[1] < 0 || a4[1] > *(_DWORD *)(*(_QWORD *)(a9 + 1328) + 64))
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    v17 = (unsigned __int8 *)&unk_D495D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3)
    return -2;
  if (a4[1])
  {
    v14 = a4[1];
    v13 = *a4;
  }
  else
  {
    v12 = *v17;
    if ((*v17 & 0x80u) == 0)
    {
      if (a1)
        *a1 = v12;
      return v12 != 0;
    }
    if (v12 < 0xA1u)
    {
      if (v12 == a5)
      {
        v14 = a6;
      }
      else
      {
        if (v12 != a7)
        {
          *__error() = 92;
          return -1;
        }
        v14 = a8;
      }
    }
    else
    {
      v14 = 2;
    }
    a4[1] = v14;
    *a4 = 0;
  }
  for (i = 0; ; ++i)
  {
    v11 = v14 >= a3 ? a3 : v14;
    if (i >= v11)
      break;
    v13 = (v13 << 8) | *v17++;
  }
  if (i >= v14)
  {
    if (a1)
      *a1 = v13;
    a4[1] = 0;
    if (v13)
      return v14;
    else
      return 0;
  }
  else
  {
    a4[1] = v14 - i;
    *a4 = v13;
    *__error() = 92;
    return -2;
  }
}

uint64_t _EUC_wcrtomb_impl(_BYTE *a1, unsigned int a2, uint64_t a3, unsigned __int8 a4, unsigned __int8 a5, unsigned __int8 a6, unsigned __int8 a7)
{
  BOOL v7;
  char v8;
  _QWORD *v10;
  int v11;
  int v12;
  int i;
  int v18;
  _QWORD *v21;
  uint64_t v22;

  v18 = a2;
  if (*(_DWORD *)(a3 + 4))
  {
    *__error() = 22;
    return -1;
  }
  if (!a1)
    return 1;
  if ((a2 & 0xFFFFFF80) == 0)
  {
    *a1 = a2;
    return 1;
  }
  v7 = a2 == 0xFFFFFF;
  if (a2 <= 0xFFFFFF)
  {
    v7 = a2 == 0x10000;
    if (a2 < 0x10000)
    {
      v7 = a2 == 255;
      if (a2 <= 0xFF)
        v12 = 1;
      else
        v12 = 2;
    }
    else
    {
      v12 = 3;
    }
  }
  else
  {
    v12 = 4;
  }
  v8 = v7;
  if ((v8 & 1) != 0)
  {
    v21 = pthread_getspecific(__locale_key);
  }
  else
  {
    v22 = __locale_key;
    v21 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v22);
  }
  if (v21)
    v10 = v21;
  else
    v10 = &__global_locale;
  if (v12 > *(_DWORD *)(v10[166] + 64))
  {
LABEL_32:
    *__error() = 92;
    return -1;
  }
  if (v18 < 41216 || v18 >= 0x10000)
  {
    v11 = (v18 >> (8 * (v12 - 1)));
    if (v11 == a4)
    {
      if (v12 != a5)
        goto LABEL_32;
    }
    else if (v11 != a6 || v12 != a7)
    {
      goto LABEL_32;
    }
  }
  for (i = v12 - 1; i >= 0; --i)
  {
    a1[i] = v18;
    v18 >>= 8;
  }
  return v12;
}

unsigned __int8 *__fix_locale_grouping_str(unsigned __int8 *a1)
{
  unsigned __int8 *v1;
  unsigned __int8 v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;

  if (!a1 || !*a1)
    return (unsigned __int8 *)&nogrouping;
  v6 = a1;
  v5 = a1;
  while (1)
  {
    if (!*v6)
    {
      *v5 = 0;
      return a1;
    }
    if (*v6 != 59)
      break;
LABEL_20:
    ++v6;
  }
  if (*v6 == 45 && v6[1] == 49)
  {
    v1 = v5++;
    *v1 = 127;
    ++v6;
    goto LABEL_20;
  }
  if (!isdigit(*v6))
    return (unsigned __int8 *)&nogrouping;
  v4 = *v6 - 48;
  if (isdigit(v6[1]))
    v4 = 10 * v4 + *++v6 - 48;
  *v5 = v4;
  if (*v5)
  {
    ++v5;
    goto LABEL_20;
  }
  if (v5 == a1)
    return (unsigned __int8 *)&nogrouping;
  else
    return a1;
}

_BYTE *__fix_nogrouping(_BYTE *a1)
{
  if (a1 && *a1)
    return a1;
  else
    return &__nogrouping;
}

uint64_t _GB18030_init(uint64_t a1)
{
  *(_QWORD *)(a1 + 72) = _GB18030_mbrtowc;
  *(_QWORD *)(a1 + 96) = _GB18030_wcrtomb;
  *(_QWORD *)(a1 + 80) = _GB18030_mbsinit;
  *(_DWORD *)(a1 + 64) = 4;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _GB18030_mbrtowc(int *a1, void *a2, unint64_t a3, int *a4)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unsigned __int8 *v6;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unint64_t v22;
  void *v23;
  unsigned __int8 *v24;

  v23 = a2;
  if (*a4 < 0 || (unint64_t)*a4 > 4)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    v23 = &unk_D495D;
    a3 = 1;
    a1 = 0;
  }
  if (a3 >= 4)
    v11 = 4;
  else
    v11 = a3;
  if (v11 >= 4 - *a4)
  {
    v9 = 4 - *a4;
  }
  else
  {
    if (a3 >= 4)
      v10 = 4;
    else
      v10 = a3;
    v9 = v10;
  }
  _platform_strncpy((char *)a4 + *a4 + 4, v23, v9);
  v12 = *a4;
  *a4 += v9;
  v22 = *a4;
  if (!*a4)
    return -2;
  v4 = (unsigned __int8 *)(a4 + 1);
  if (*((unsigned __int8 *)a4 + 4) > 0x7Fu)
  {
    if (*v4 >= 0x81u && *v4 != 255)
    {
      v17 = *v4;
      if (v22 < 2)
        return -2;
      v5 = (unsigned __int8 *)a4 + 5;
      v14 = *((unsigned __int8 *)a4 + 5);
      if (v14 >= 0x40 && *v5 <= 0x7Eu || *v5 >= 0x80u && *v5 != 255)
      {
        v16 = v14 | (v17 << 8);
        v13 = 2;
        goto LABEL_43;
      }
      if (*v5 >= 0x30u && *v5 <= 0x39u)
      {
        v18 = v14 | ((v17 & 0x7F) << 8);
        if (v22 < 3)
          return -2;
        v6 = (unsigned __int8 *)a4 + 6;
        v24 = (unsigned __int8 *)a4 + 7;
        if (*((unsigned __int8 *)a4 + 6) >= 0x81u && *v6 != 255)
        {
          v19 = *v6 | (v18 << 8);
          if (v22 < 4)
            return -2;
          v15 = *v24;
          if (v15 >= 0x30 && *v24 <= 0x39u)
          {
            v16 = v15 | (v19 << 8);
            v13 = 4;
            goto LABEL_43;
          }
        }
      }
    }
    *__error() = 92;
    return -1;
  }
  v13 = 1;
  v16 = *v4;
LABEL_43:
  if (a1)
    *a1 = v16;
  *a4 = 0;
  if (v16)
    return v13 - v12;
  else
    return 0;
}

uint64_t _GB18030_wcrtomb(_BYTE *a1, int a2, _DWORD *a3)
{
  unsigned int v5;

  if (!*a3)
  {
    if (!a1)
      return 1;
    if (a2 >= 0)
    {
      if ((a2 & 0x7F000000) != 0)
      {
        v5 = a2 | 0x80000000;
        if ((a2 | 0x80000000) >> 24 < 0x81)
          goto LABEL_34;
        if (HIBYTE(v5) == 255)
          goto LABEL_34;
        *a1 = (a2 | 0x80000000) >> 24;
        if (BYTE2(v5) < 0x30u)
          goto LABEL_34;
        if (BYTE2(v5) > 0x39u)
          goto LABEL_34;
        a1[1] = BYTE2(v5);
        if (BYTE1(v5) < 0x81u)
          goto LABEL_34;
        if (BYTE1(v5) == 255)
          goto LABEL_34;
        a1[2] = BYTE1(v5);
        if (a2 < 0x30u || a2 > 0x39u)
          goto LABEL_34;
        a1[3] = a2;
        return 4;
      }
      if ((a2 & 0xFF0000) == 0)
      {
        if ((a2 & 0xFF00) != 0)
        {
          if (BYTE1(a2) < 0x81u)
            goto LABEL_34;
          if (BYTE1(a2) == 255)
            goto LABEL_34;
          *a1 = BYTE1(a2);
          if (a2 < 0x40u || a2 == 127 || a2 == 255)
            goto LABEL_34;
          a1[1] = a2;
          return 2;
        }
        if (a2 <= 127)
        {
          *a1 = a2;
          return 1;
        }
      }
    }
LABEL_34:
    *__error() = 92;
    return -1;
  }
  *__error() = 22;
  return -1;
}

BOOL _GB18030_mbsinit(_DWORD *a1)
{
  BOOL v2;

  v2 = 1;
  if (a1)
    return *a1 == 0;
  return v2;
}

uint64_t _GB2312_init(uint64_t a1)
{
  *(_QWORD *)(a1 + 72) = _GB2312_mbrtowc;
  *(_QWORD *)(a1 + 96) = _GB2312_wcrtomb;
  *(_QWORD *)(a1 + 80) = _GB2312_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _GB2312_mbrtowc(int *a1, void *a2, unint64_t a3, int *a4)
{
  int v4;
  int *v5;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  void *v17;
  int *v18;

  v17 = a2;
  if (*a4 >= 0 && (unint64_t)*a4 <= 2)
  {
    if (!a2)
    {
      v17 = &unk_D495D;
      a3 = 1;
      a1 = 0;
    }
    if (a3 >= 2)
      v10 = 2;
    else
      v10 = a3;
    if (v10 >= 2 - *a4)
    {
      v8 = 2 - *a4;
    }
    else
    {
      if (a3 >= 2)
        v9 = 2;
      else
        v9 = a3;
      v8 = v9;
    }
    _platform_strncpy((char *)a4 + *a4 + 4, v17, v8);
    v11 = *a4;
    *a4 += v8;
    v18 = a4 + 1;
    v12 = _GB2312_check((char *)a4 + 4, *a4);
    if (v12 >= 0)
    {
      v14 = 0;
      v13 = v12;
      while (1)
      {
        v4 = v13--;
        if (v4 <= 0)
          break;
        v5 = v18;
        v18 = (int *)((char *)v18 + 1);
        v14 = *(unsigned __int8 *)v5 | (v14 << 8);
      }
      if (a1)
        *a1 = v14;
      *a4 = 0;
      if (v14)
        return v12 - v11;
      else
        return 0;
    }
    else
    {
      return v12;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t _GB2312_wcrtomb(_BYTE *a1, __int16 a2, _DWORD *a3)
{
  if (*a3)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if (a2 < 0)
    {
      *a1 = HIBYTE(a2);
      a1[1] = a2;
      return 2;
    }
    else
    {
      *a1 = a2;
      return 1;
    }
  }
  else
  {
    return 1;
  }
}

BOOL _GB2312_mbsinit(_DWORD *a1)
{
  BOOL v2;

  v2 = 1;
  if (a1)
    return *a1 == 0;
  return v2;
}

uint64_t _GB2312_check(char *a1, unint64_t a2)
{
  if (a2)
  {
    if (*a1 < 0xA1u || *a1 == 255)
    {
      if (*a1 >= 0)
        return 1;
      else
        return -1;
    }
    else if (a2 >= 2)
    {
      if (a1[1] < 0xA1u || a1[1] == 255)
        return -1;
      else
        return 2;
    }
    else
    {
      return -2;
    }
  }
  else
  {
    return -2;
  }
}

uint64_t _GBK_init(uint64_t a1)
{
  *(_QWORD *)(a1 + 72) = _GBK_mbrtowc;
  *(_QWORD *)(a1 + 96) = _GBK_wcrtomb;
  *(_QWORD *)(a1 + 80) = _GBK_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _GBK_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4)
{
  unsigned __int8 *v4;
  uint64_t v6;
  int v7;
  int v8;
  unsigned __int8 *v11;
  _BYTE *v12;

  v11 = a2;
  if ((*a4 & 0xFFFFFF00) != 0)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    v11 = (unsigned __int8 *)&unk_D495D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3)
    return -2;
  if (*a4)
  {
    if (!*v11)
    {
LABEL_9:
      *__error() = 92;
      return -1;
    }
    if (a1)
      *a1 = *v11 | (*a4 << 8);
    *a4 = 0;
    return 1;
  }
  else
  {
    v6 = (int)_gbk_check(*v11);
    v4 = v11;
    v12 = v11 + 1;
    v7 = *v4;
    if (v6 == 2)
    {
      if (a3 < 2)
      {
        *a4 = v7;
        return -2;
      }
      if (!*v12)
        goto LABEL_9;
      v8 = *v12 | (v7 << 8);
      if (a1)
        *a1 = v8;
      return 2;
    }
    else
    {
      if (a1)
        *a1 = v7;
      return v7 != 0;
    }
  }
}

uint64_t _GBK_wcrtomb(_BYTE *a1, __int16 a2, _DWORD *a3)
{
  if (*a3)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if (a2 < 0)
    {
      *a1 = HIBYTE(a2);
      a1[1] = a2;
      return 2;
    }
    else
    {
      *a1 = a2;
      return 1;
    }
  }
  else
  {
    return 1;
  }
}

BOOL _GBK_mbsinit(_DWORD *a1)
{
  BOOL v2;

  v2 = 1;
  if (a1)
    return *a1 == 0;
  return v2;
}

uint64_t _gbk_check(unsigned __int8 a1)
{
  BOOL v2;

  v2 = 0;
  if (a1 >= 0x81u)
    v2 = a1 != 255;
  if (v2)
    return 2;
  else
    return 1;
}

uint64_t __part_load_locale(uint64_t a1, _BYTE *a2, void **a3, char *a4, int a5, int a6, uint64_t a7)
{
  uint64_t NOCANCEL;
  uint64_t v8;
  int v10;
  int v11;
  uint64_t v12;
  stat v13;
  unint64_t v14;
  _BYTE *v15;
  void *v16;
  int v17;
  int i;
  int v19;
  int v20;
  uint64_t v21;
  int v22;
  int v23;
  char *__s2;
  void **v25;
  _BYTE *v26;
  uint64_t v27;
  char v29[1024];

  v27 = a1;
  v26 = a2;
  v25 = a3;
  __s2 = a4;
  v23 = a5;
  v22 = a6;
  v21 = a7;
  v20 = 0;
  v19 = 0;
  i = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  _platform_memset(&v13, 0, 144);
  v12 = _platform_strlen(v27) + 1;
  _platform_strcpy(v29, v27);
  strcat(v29, "/");
  strcat(v29, __s2);
  v19 = __open_path_locale(v29);
  if (v19 < 0)
    return -1;
  if (fstat(v19, &v13))
  {
LABEL_24:
    v20 = *__error();
    close_NOCANCEL(v19);
    v10 = v20;
    *__error() = v10;
    return -1;
  }
  if (v13.st_size <= 0)
  {
    *__error() = 79;
    goto LABEL_24;
  }
  v16 = (void *)malloc_type_malloc(v12 + v13.st_size, 1588312491);
  if (!v16)
  {
    *__error() = 12;
    goto LABEL_24;
  }
  _platform_strcpy(v16, v27);
  v15 = (char *)v16 + v12;
  v14 = (unint64_t)v16 + v12 + v13.st_size;
  NOCANCEL = read_NOCANCEL(v19, (char *)v16 + v12, v13.st_size);
  if (NOCANCEL != v13.st_size)
  {
LABEL_23:
    v20 = *__error();
    free(v16);
    v11 = v20;
    *__error() = v11;
    goto LABEL_24;
  }
  if (*(_BYTE *)(v14 - 1) != 10)
  {
LABEL_10:
    *__error() = 79;
    goto LABEL_23;
  }
  v17 = split_lines(v15, v14);
  if (v17 < v23)
  {
    if (v17 < v22)
      goto LABEL_10;
  }
  else
  {
    v17 = v23;
  }
  close_NOCANCEL(v19);
  if (*v25)
    free(*v25);
  *v25 = v16;
  v15 = *v25;
  for (i = 0; i < v17; ++i)
  {
    v8 = _platform_strlen(v15);
    v15 += v8 + 1;
    *(_QWORD *)(v21 + 8 * i) = v15;
  }
  for (i = v17; i < v23; ++i)
    *(_QWORD *)(v21 + 8 * i) = 0;
  *v26 = 1;
  return 0;
}

uint64_t split_lines(_BYTE *a1, unint64_t a2)
{
  unsigned int v3;

  v3 = 0;
  while ((unint64_t)a1 < a2)
  {
    if (*a1 == 10)
    {
      *a1 = 0;
      ++v3;
    }
    ++a1;
  }
  return v3;
}

void destruct_ldpart(void **a1)
{
  if (a1)
    free(a1[8]);
  free(a1);
}

uint64_t __messages_load_locale(uint64_t a1, uint64_t a2)
{
  void **v3;
  unsigned int locale;

  if (_platform_strcmp(a1, "C")
    && _platform_strcmp(a1, "POSIX")
    && _platform_strncmp(a1, "C.", 2))
  {
    if (__messages_load_locale_cache
      && *(_QWORD *)(__messages_load_locale_cache + 64)
      && !_platform_strcmp(a1, *(_QWORD *)(__messages_load_locale_cache + 64)))
    {
      *(_BYTE *)(a2 + 1312) = 1;
      xlocale_release(*(_QWORD *)(a2 + 1360));
      *(_QWORD *)(a2 + 1360) = __messages_load_locale_cache;
      xlocale_retain((unsigned int *)__messages_load_locale_cache);
      return 1;
    }
    else
    {
      v3 = (void **)malloc_type_malloc(104, 0x10D0040B9A2EC5ALL);
      if (v3)
      {
        *(_DWORD *)v3 = 1;
        v3[1] = destruct_ldpart;
        v3[8] = 0;
        locale = __part_load_locale(a1, (_BYTE *)(a2 + 1312), v3 + 8, "LC_MESSAGES/LC_MESSAGES", 4, 2, (uint64_t)(v3 + 9));
        if (locale)
        {
          if (locale == -1)
            free(v3);
        }
        else
        {
          if (!v3[11])
            v3[11] = &empty;
          if (!v3[12])
            v3[12] = &empty;
          xlocale_release(*(_QWORD *)(a2 + 1360));
          *(_QWORD *)(a2 + 1360) = v3;
          xlocale_release(__messages_load_locale_cache);
          __messages_load_locale_cache = (uint64_t)v3;
          xlocale_retain((unsigned int *)v3);
        }
        return locale;
      }
      else
      {
        return -1;
      }
    }
  }
  else
  {
    *(_BYTE *)(a2 + 1312) = 0;
    xlocale_release(*(_QWORD *)(a2 + 1360));
    *(_QWORD *)(a2 + 1360) = 0;
    return 1;
  }
}

char **__get_current_messages_locale(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 1312))
    return (char **)(*(_QWORD *)(a1 + 1360) + 72);
  else
    return _C_messages_locale;
}

uint64_t __monetary_load_locale(uint64_t a1, uint64_t a2)
{
  void *v3;
  unsigned int locale;

  if (_platform_strcmp(a1, "C")
    && _platform_strcmp(a1, "POSIX")
    && _platform_strncmp(a1, "C.", 2))
  {
    if (!*(_BYTE *)(a2 + 1313) || _platform_strcmp(a1, *(_QWORD *)(*(_QWORD *)(a2 + 1336) + 64)))
    {
      if (__monetary_load_locale_cache
        && *(_QWORD *)(__monetary_load_locale_cache + 64)
        && !_platform_strcmp(a1, *(_QWORD *)(__monetary_load_locale_cache + 64)))
      {
        *(_BYTE *)(a2 + 1313) = 1;
        xlocale_release(*(_QWORD *)(a2 + 1336));
        *(_QWORD *)(a2 + 1336) = __monetary_load_locale_cache;
        xlocale_retain((unsigned int *)__monetary_load_locale_cache);
        *(_BYTE *)(a2 + 1316) = 1;
        return 1;
      }
      else
      {
        v3 = (void *)malloc_type_malloc(240, 0x10D0040AB25FCE3);
        if (v3)
        {
          *(_DWORD *)v3 = 1;
          *((_QWORD *)v3 + 1) = destruct_ldpart;
          *((_QWORD *)v3 + 8) = 0;
          locale = __part_load_locale(a1, (_BYTE *)(a2 + 1313), (void **)v3 + 8, "LC_MONETARY", 21, 15, (uint64_t)v3 + 72);
          if (locale == -1)
            free(v3);
          else
            *(_BYTE *)(a2 + 1316) = 1;
          if (!locale)
          {
            *((_QWORD *)v3 + 13) = __fix_locale_grouping_str(*((unsigned __int8 **)v3 + 13));
            **((_BYTE **)v3 + 16) = cnv(*((const char **)v3 + 16));
            **((_BYTE **)v3 + 17) = cnv(*((const char **)v3 + 17));
            **((_BYTE **)v3 + 18) = cnv(*((const char **)v3 + 18));
            **((_BYTE **)v3 + 19) = cnv(*((const char **)v3 + 19));
            **((_BYTE **)v3 + 20) = cnv(*((const char **)v3 + 20));
            **((_BYTE **)v3 + 21) = cnv(*((const char **)v3 + 21));
            **((_BYTE **)v3 + 22) = cnv(*((const char **)v3 + 22));
            **((_BYTE **)v3 + 23) = cnv(*((const char **)v3 + 23));
            if (*((_QWORD *)v3 + 24))
              **((_BYTE **)v3 + 24) = cnv(*((const char **)v3 + 24));
            else
              *((_QWORD *)v3 + 24) = *((_QWORD *)v3 + 18);
            if (*((_QWORD *)v3 + 25))
              **((_BYTE **)v3 + 25) = cnv(*((const char **)v3 + 25));
            else
              *((_QWORD *)v3 + 25) = *((_QWORD *)v3 + 20);
            if (*((_QWORD *)v3 + 26))
              **((_BYTE **)v3 + 26) = cnv(*((const char **)v3 + 26));
            else
              *((_QWORD *)v3 + 26) = *((_QWORD *)v3 + 19);
            if (*((_QWORD *)v3 + 27))
              **((_BYTE **)v3 + 27) = cnv(*((const char **)v3 + 27));
            else
              *((_QWORD *)v3 + 27) = *((_QWORD *)v3 + 21);
            if (*((_QWORD *)v3 + 28))
              **((_BYTE **)v3 + 28) = cnv(*((const char **)v3 + 28));
            else
              *((_QWORD *)v3 + 28) = *((_QWORD *)v3 + 22);
            if (*((_QWORD *)v3 + 29))
              **((_BYTE **)v3 + 29) = cnv(*((const char **)v3 + 29));
            else
              *((_QWORD *)v3 + 29) = *((_QWORD *)v3 + 23);
            xlocale_release(*(_QWORD *)(a2 + 1336));
            *(_QWORD *)(a2 + 1336) = v3;
            xlocale_release(__monetary_load_locale_cache);
            __monetary_load_locale_cache = (uint64_t)v3;
            xlocale_retain((unsigned int *)v3);
          }
          return locale;
        }
        else
        {
          return -1;
        }
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (*(_BYTE *)(a2 + 1313))
    {
      *(_BYTE *)(a2 + 1313) = 0;
      xlocale_release(*(_QWORD *)(a2 + 1336));
      *(_QWORD *)(a2 + 1336) = 0;
      *(_BYTE *)(a2 + 1316) = 1;
    }
    return 1;
  }
}

uint64_t cnv(const char *a1)
{
  int v2;

  v2 = strtol(a1, 0, 10);
  if (v2 == -1)
    LOBYTE(v2) = 127;
  return (char)v2;
}

_UNKNOWN **__get_current_monetary_locale(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 1313))
    return (_UNKNOWN **)(*(_QWORD *)(a1 + 1336) + 72);
  else
    return &_C_monetary_locale;
}

uint64_t __numeric_load_locale(uint64_t a1, uint64_t a2)
{
  void *v3;
  unsigned int locale;

  if (_platform_strcmp(a1, "C")
    && _platform_strcmp(a1, "POSIX")
    && _platform_strncmp(a1, "C.", 2))
  {
    if (!*(_BYTE *)(a2 + 1314) || _platform_strcmp(a1, *(_QWORD *)(*(_QWORD *)(a2 + 1344) + 64)))
    {
      if (__numeric_load_locale_cache
        && *(_QWORD *)(__numeric_load_locale_cache + 64)
        && !_platform_strcmp(a1, *(_QWORD *)(__numeric_load_locale_cache + 64)))
      {
        *(_BYTE *)(a2 + 1314) = 1;
        xlocale_release(*(_QWORD *)(a2 + 1344));
        *(_QWORD *)(a2 + 1344) = __numeric_load_locale_cache;
        xlocale_retain((unsigned int *)__numeric_load_locale_cache);
        *(_BYTE *)(a2 + 1317) = 1;
        return 1;
      }
      else
      {
        v3 = (void *)malloc_type_malloc(96, 0x10D0040E5D34ACFLL);
        if (v3)
        {
          *(_DWORD *)v3 = 1;
          *((_QWORD *)v3 + 1) = destruct_ldpart;
          *((_QWORD *)v3 + 8) = 0;
          locale = __part_load_locale(a1, (_BYTE *)(a2 + 1314), (void **)v3 + 8, "LC_NUMERIC", 3, 3, (uint64_t)v3 + 72);
          if (locale == -1)
            free(v3);
          else
            *(_BYTE *)(a2 + 1317) = 1;
          if (!locale)
          {
            if (!**((_BYTE **)v3 + 9))
              *((_QWORD *)v3 + 9) = ".";
            *((_QWORD *)v3 + 11) = __fix_locale_grouping_str(*((unsigned __int8 **)v3 + 11));
            xlocale_release(*(_QWORD *)(a2 + 1344));
            *(_QWORD *)(a2 + 1344) = v3;
            xlocale_release(__numeric_load_locale_cache);
            __numeric_load_locale_cache = (uint64_t)v3;
            xlocale_retain((unsigned int *)v3);
          }
          return locale;
        }
        else
        {
          return -1;
        }
      }
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (*(_BYTE *)(a2 + 1314))
    {
      *(_BYTE *)(a2 + 1314) = 0;
      xlocale_release(*(_QWORD *)(a2 + 1344));
      *(_QWORD *)(a2 + 1344) = 0;
      *(_BYTE *)(a2 + 1317) = 1;
    }
    return 1;
  }
}

char **__get_current_numeric_locale(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 1314))
    return (char **)(*(_QWORD *)(a1 + 1344) + 72);
  else
    return &_C_numeric_locale;
}

void _locale_lock_fork_prepare()
{
  char v0;
  char v1;
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  uint64_t v4;

  if (v0)
    v1 = 1;
  else
    v1 = 0;
  if ((v1 & 1) != 0)
  {
    v3 = (os_unfair_lock_s *)pthread_getspecific(__locale_key);
  }
  else
  {
    v4 = __locale_key;
    v3 = *(os_unfair_lock_s **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  }
  if (v3)
    v2 = v3;
  else
    v2 = (os_unfair_lock_s *)&__global_locale;
  os_unfair_lock_lock(v2 + 324);
}

void _locale_lock_fork_parent()
{
  char v0;
  char v1;
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  uint64_t v4;

  if (v0)
    v1 = 1;
  else
    v1 = 0;
  if ((v1 & 1) != 0)
  {
    v3 = (os_unfair_lock_s *)pthread_getspecific(__locale_key);
  }
  else
  {
    v4 = __locale_key;
    v3 = *(os_unfair_lock_s **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  }
  if (v3)
    v2 = v3;
  else
    v2 = (os_unfair_lock_s *)&__global_locale;
  os_unfair_lock_unlock(v2 + 324);
}

void _locale_lock_fork_child()
{
  char v0;
  char v1;
  _DWORD *v2;
  _DWORD *v3;
  uint64_t v4;

  if (v0)
    v1 = 1;
  else
    v1 = 0;
  if ((v1 & 1) != 0)
  {
    v3 = pthread_getspecific(__locale_key);
  }
  else
  {
    v4 = __locale_key;
    v3 = *(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  }
  if (v3)
    v2 = v3;
  else
    v2 = &__global_locale;
  v2[324] = 0;
}

lconv *__cdecl localeconv_l(locale_t a1)
{
  char **current_numeric_locale;
  _UNKNOWN **current_monetary_locale;
  locale_t v4;

  v4 = a1;
  if (a1)
  {
    if (a1 == (locale_t)-1)
      v4 = (locale_t)&__global_locale;
  }
  else
  {
    v4 = (locale_t)&__c_locale;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v4 + 324);
  if (*((_BYTE *)v4 + 1316))
  {
    current_monetary_locale = __get_current_monetary_locale((uint64_t)v4);
    *((_QWORD *)v4 + 175) = *current_monetary_locale;
    *((_QWORD *)v4 + 176) = current_monetary_locale[1];
    *((_QWORD *)v4 + 177) = current_monetary_locale[2];
    *((_QWORD *)v4 + 178) = current_monetary_locale[3];
    *((_QWORD *)v4 + 179) = current_monetary_locale[4];
    *((_QWORD *)v4 + 180) = current_monetary_locale[5];
    *((_QWORD *)v4 + 181) = current_monetary_locale[6];
    *((_BYTE *)v4 + 1456) = *(_BYTE *)current_monetary_locale[7];
    *((_BYTE *)v4 + 1457) = *(_BYTE *)current_monetary_locale[8];
    *((_BYTE *)v4 + 1458) = *(_BYTE *)current_monetary_locale[9];
    *((_BYTE *)v4 + 1459) = *(_BYTE *)current_monetary_locale[10];
    *((_BYTE *)v4 + 1460) = *(_BYTE *)current_monetary_locale[11];
    *((_BYTE *)v4 + 1461) = *(_BYTE *)current_monetary_locale[12];
    *((_BYTE *)v4 + 1462) = *(_BYTE *)current_monetary_locale[13];
    *((_BYTE *)v4 + 1463) = *(_BYTE *)current_monetary_locale[14];
    *((_BYTE *)v4 + 1464) = *(_BYTE *)current_monetary_locale[15];
    *((_BYTE *)v4 + 1465) = *(_BYTE *)current_monetary_locale[16];
    *((_BYTE *)v4 + 1466) = *(_BYTE *)current_monetary_locale[17];
    *((_BYTE *)v4 + 1467) = *(_BYTE *)current_monetary_locale[18];
    *((_BYTE *)v4 + 1468) = *(_BYTE *)current_monetary_locale[19];
    *((_BYTE *)v4 + 1469) = *(_BYTE *)current_monetary_locale[20];
    *((_BYTE *)v4 + 1316) = 0;
  }
  if (*((_BYTE *)v4 + 1317))
  {
    current_numeric_locale = __get_current_numeric_locale((uint64_t)v4);
    *((_QWORD *)v4 + 172) = *current_numeric_locale;
    *((_QWORD *)v4 + 173) = current_numeric_locale[1];
    *((_QWORD *)v4 + 174) = current_numeric_locale[2];
    *((_BYTE *)v4 + 1317) = 0;
    if (!*((_QWORD *)v4 + 172))
    {
      _os_crash((uint64_t)"loc->decimal_point is NULL (nlocale changed)");
      __break(1u);
      JUMPOUT(0x53A64);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v4 + 324);
  if (!*((_QWORD *)v4 + 172))
  {
    _os_crash((uint64_t)"loc->decimal_point is NULL");
    __break(1u);
    JUMPOUT(0x53AA0);
  }
  return (lconv *)((char *)v4 + 1376);
}

lconv *localeconv(void)
{
  char v0;
  char v1;
  _xlocale *v3;
  uint64_t v4;

  if (v0)
    v1 = 1;
  else
    v1 = 0;
  if ((v1 & 1) != 0)
  {
    v3 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v4 = __locale_key;
    v3 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v4);
  }
  if (v3)
    return localeconv_l(v3);
  else
    return localeconv_l((locale_t)__global_locale);
}

int mblen_l(const char *a1, size_t a2, locale_t a3)
{
  unint64_t v4;
  locale_t v5;

  v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v5 = (locale_t)&__global_locale;
  }
  else
  {
    v5 = (locale_t)&__c_locale;
  }
  if (a1)
  {
    v4 = (*(uint64_t (**)(_QWORD, const char *, size_t, uint64_t, locale_t))(*((_QWORD *)v5 + 166) + 72))(0, a1, a2, (uint64_t)v5 + 16, v5);
    if (v4 < 0xFFFFFFFFFFFFFFFELL)
      return v4;
    else
      return -1;
  }
  else
  {
    j___platform_memmove((char *)v5 + 16, &mblen_l_initial, 128);
    return 0;
  }
}

int mblen(const char *__s, size_t __n)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return mblen_l(__s, __n, v7);
  else
    return mblen_l(__s, __n, (locale_t)__global_locale);
}

size_t mbrlen_l(const char *a1, size_t a2, mbstate_t *a3, locale_t a4)
{
  locale_t v5;
  mbstate_t *v6;

  v6 = a3;
  v5 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v5 = (locale_t)&__global_locale;
  }
  else
  {
    v5 = (locale_t)&__c_locale;
  }
  if (!a3)
    v6 = (mbstate_t *)((char *)v5 + 144);
  return (*(uint64_t (**)(_QWORD, const char *, size_t, mbstate_t *, locale_t))(*((_QWORD *)v5 + 166) + 72))(0, a1, a2, v6, v5);
}

size_t mbrlen(const char *a1, size_t a2, mbstate_t *a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return mbrlen_l(a1, a2, a3, v9);
  else
    return mbrlen_l(a1, a2, a3, (locale_t)__global_locale);
}

size_t mbrtowc_l(__int32 *a1, const char *a2, size_t a3, mbstate_t *a4, locale_t a5)
{
  locale_t v6;
  mbstate_t *v7;

  v7 = a4;
  v6 = a5;
  if (a5)
  {
    if (a5 == (locale_t)-1)
      v6 = (locale_t)&__global_locale;
  }
  else
  {
    v6 = (locale_t)&__c_locale;
  }
  if (!a4)
    v7 = (mbstate_t *)((char *)v6 + 272);
  return (*(uint64_t (**)(__int32 *, const char *, size_t, mbstate_t *, locale_t))(*((_QWORD *)v6 + 166) + 72))(a1, a2, a3, v7, v6);
}

size_t mbrtowc(__int32 *a1, const char *a2, size_t a3, mbstate_t *a4)
{
  char v4;
  char v5;
  _xlocale *v11;
  uint64_t v12;

  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v12 = __locale_key;
    v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11)
    return mbrtowc_l(a1, a2, a3, a4, v11);
  else
    return mbrtowc_l(a1, a2, a3, a4, (locale_t)__global_locale);
}

int mbsinit_l(const mbstate_t *a1, locale_t a2)
{
  locale_t v3;

  v3 = a2;
  if (!a2)
    return (*((uint64_t (**)(const mbstate_t *, void *))off_DCE48 + 10))(a1, &__c_locale);
  if (a2 == (locale_t)-1)
    v3 = (locale_t)&__global_locale;
  return (*(uint64_t (**)(const mbstate_t *, locale_t))(*((_QWORD *)v3 + 166) + 80))(a1, v3);
}

int mbsinit(const mbstate_t *a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return mbsinit_l(a1, v5);
  else
    return mbsinit_l(a1, (locale_t)__global_locale);
}

size_t mbsnrtowcs_l(__int32 *a1, const char **a2, size_t a3, size_t a4, mbstate_t *a5, locale_t a6)
{
  locale_t v7;
  mbstate_t *v8;

  v8 = a5;
  v7 = a6;
  if (a6)
  {
    if (a6 == (locale_t)-1)
      v7 = (locale_t)&__global_locale;
  }
  else
  {
    v7 = (locale_t)&__c_locale;
  }
  if (!a5)
    v8 = (mbstate_t *)((char *)v7 + 400);
  return (*(uint64_t (**)(__int32 *, const char **, size_t, size_t, mbstate_t *, locale_t))(*((_QWORD *)v7 + 166) + 88))(a1, a2, a3, a4, v8, v7);
}

size_t mbsnrtowcs(__int32 *a1, const char **a2, size_t a3, size_t a4, mbstate_t *a5)
{
  char v5;
  char v6;
  _xlocale *v13;
  uint64_t v14;

  if (v5)
    v6 = 1;
  else
    v6 = 0;
  if ((v6 & 1) != 0)
  {
    v13 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v14 = __locale_key;
    v13 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v14);
  }
  if (v13)
    return mbsnrtowcs_l(a1, a2, a3, a4, a5, v13);
  else
    return mbsnrtowcs_l(a1, a2, a3, a4, a5, (locale_t)__global_locale);
}

uint64_t __mbsnrtowcs_std(int *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t (*v8)(int *, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  int *v19;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v8 = *(uint64_t (**)(int *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a6 + 1328) + 72);
  v13 = *a2;
  v12 = 0;
  if (a1)
  {
    while (v16--)
    {
      v10 = v8(v19, v13, v17, v15, v14);
      switch(v10)
      {
        case -1:
          *v18 = v13;
          return -1;
        case -2:
          *v18 = v13 + v17;
          return v12;
        case 0:
          *v18 = 0;
          return v12;
      }
      v13 += v10;
      v17 -= v10;
      ++v12;
      ++v19;
    }
    *v18 = v13;
    return v12;
  }
  else
  {
    while (1)
    {
      v9 = v8(&v11, v13, v17, v15, v14);
      if (v9 == -1)
        return -1;
      if (!v9 || v9 == -2)
        break;
      v13 += v9;
      v17 -= v9;
      ++v12;
    }
    return v12;
  }
}

size_t mbsrtowcs_l(__int32 *a1, const char **a2, size_t a3, mbstate_t *a4, locale_t a5)
{
  locale_t v6;
  mbstate_t *v7;

  v7 = a4;
  v6 = a5;
  if (a5)
  {
    if (a5 == (locale_t)-1)
      v6 = (locale_t)&__global_locale;
  }
  else
  {
    v6 = (locale_t)&__c_locale;
  }
  if (!a4)
    v7 = (mbstate_t *)((char *)v6 + 528);
  return (*(uint64_t (**)(__int32 *, const char **, uint64_t, size_t, mbstate_t *, locale_t))(*((_QWORD *)v6 + 166) + 88))(a1, a2, -1, a3, v7, v6);
}

size_t mbsrtowcs(__int32 *a1, const char **a2, size_t a3, mbstate_t *a4)
{
  char v4;
  char v5;
  _xlocale *v11;
  uint64_t v12;

  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v12 = __locale_key;
    v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11)
    return mbsrtowcs_l(a1, a2, a3, a4, v11);
  else
    return mbsrtowcs_l(a1, a2, a3, a4, (locale_t)__global_locale);
}

size_t mbstowcs_l(__int32 *a1, const char *a2, size_t a3, locale_t a4)
{
  const char *v5;
  locale_t v6;
  size_t v7;
  const char *v8;
  __int32 *v9;
  _BYTE v10[128];

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  _platform_memset(v10, 0, 128);
  v5 = 0;
  if (v6)
  {
    if (v6 == (locale_t)-1)
      v6 = (locale_t)&__global_locale;
  }
  else
  {
    v6 = (locale_t)&__c_locale;
  }
  j___platform_memmove(v10, &mbstowcs_l_initial, 128);
  v5 = v8;
  return (*(uint64_t (**)(__int32 *, const char **, uint64_t, size_t, _BYTE *, locale_t))(*((_QWORD *)v6 + 166)
                                                                                                 + 88))(v9, &v5, -1, v7, v10, v6);
}

size_t mbstowcs(__int32 *a1, const char *a2, size_t a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return mbstowcs_l(a1, a2, a3, v9);
  else
    return mbstowcs_l(a1, a2, a3, (locale_t)__global_locale);
}

int mbtowc_l(__int32 *a1, const char *a2, size_t a3, locale_t a4)
{
  unint64_t v5;
  locale_t v6;

  v6 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v6 = (locale_t)&__global_locale;
  }
  else
  {
    v6 = (locale_t)&__c_locale;
  }
  if (a2)
  {
    v5 = (*(uint64_t (**)(__int32 *, const char *, size_t, uint64_t, locale_t))(*((_QWORD *)v6 + 166) + 72))(a1, a2, a3, (uint64_t)v6 + 656, v6);
    if (v5 < 0xFFFFFFFFFFFFFFFELL)
      return v5;
    else
      return -1;
  }
  else
  {
    j___platform_memmove((char *)v6 + 656, &mbtowc_l_initial, 128);
    return 0;
  }
}

int mbtowc(__int32 *a1, const char *a2, size_t a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return mbtowc_l(a1, a2, a3, v9);
  else
    return mbtowc_l(a1, a2, a3, (locale_t)__global_locale);
}

uint64_t _MSKanji_init(uint64_t a1)
{
  *(_QWORD *)(a1 + 72) = _MSKanji_mbrtowc;
  *(_QWORD *)(a1 + 96) = _MSKanji_wcrtomb;
  *(_QWORD *)(a1 + 80) = _MSKanji_mbsinit;
  *(_DWORD *)(a1 + 64) = 2;
  *(_DWORD *)(a1 + 68) = 256;
  return 0;
}

uint64_t _MSKanji_mbrtowc(_DWORD *a1, unsigned __int8 *a2, unint64_t a3, unsigned int *a4)
{
  unsigned __int8 *v4;
  unsigned int v6;
  int v7;
  unsigned __int8 *v9;
  _BYTE *v10;

  v9 = a2;
  if ((*a4 & 0xFFFFFF00) != 0)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    v9 = (unsigned __int8 *)&unk_D495D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3)
    return -2;
  if (*a4)
  {
    if (!*v9)
    {
LABEL_9:
      *__error() = 92;
      return -1;
    }
    if (a1)
      *a1 = *v9 | (*a4 << 8);
    *a4 = 0;
    return 1;
  }
  else
  {
    v4 = v9;
    v10 = v9 + 1;
    v6 = *v4;
    if ((v6 <= 0x80 || *v4 >= 0xA0u) && (*v4 < 0xE0u || *v4 >= 0xFDu))
    {
      if (a1)
        *a1 = v6;
      return v6 != 0;
    }
    else
    {
      if (a3 < 2)
      {
        *a4 = v6;
        return -2;
      }
      if (!*v10)
        goto LABEL_9;
      v7 = *v10 | (v6 << 8);
      if (a1)
        *a1 = v7;
      return 2;
    }
  }
}

uint64_t _MSKanji_wcrtomb(_BYTE *a1, int a2, _DWORD *a3)
{
  int v3;
  int v4;
  _BYTE *v5;
  int i;
  int v8;
  _BYTE *v9;

  v9 = a1;
  if (*a3)
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if (a2 <= 256)
      v3 = 1;
    else
      v3 = 2;
    v8 = v3;
    for (i = v3; ; *v5 = a2 >> (8 * i))
    {
      v4 = i--;
      if (v4 <= 0)
        break;
      v5 = v9++;
    }
    return v8;
  }
  else
  {
    return 1;
  }
}

BOOL _MSKanji_mbsinit(_DWORD *a1)
{
  BOOL v2;

  v2 = 1;
  if (a1)
    return *a1 == 0;
  return v2;
}

wint_t nextwctype_l(wint_t a1, wctype_t a2, locale_t a3)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t j;
  wint_t v9;
  wint_t i;
  wint_t v11;

  v9 = a1;
  v4 = *(_QWORD *)(*((_QWORD *)a3 + 166) + 120);
  v5 = 0;
  if (a1 < 256)
  {
    for (i = a1 + 1; i < 256; ++i)
    {
      if ((*(_DWORD *)(v4 + 60 + 4 * i) & a2) != 0)
        return i;
    }
    v9 = i - 1;
  }
  if (*(_QWORD *)(v4 + 3144) && v9 < **(_DWORD **)(v4 + 3144))
  {
    v9 = **(_DWORD **)(v4 + 3144);
    v5 = 1;
  }
  v7 = *(_QWORD *)(v4 + 3144);
  for (j = *(int *)(v4 + 3136); ; j >>= 1)
  {
    if (!j)
      return -1;
    v6 = v7 + 24 * (j >> 1);
    if (*(_DWORD *)v6 <= v9 && v9 <= *(_DWORD *)(v6 + 4))
      break;
    if (v9 > *(_DWORD *)(v6 + 4))
    {
      v7 = v6 + 24;
      --j;
    }
  }
  if (!v5)
    ++v9;
  if (*(_DWORD *)v6 > v9 || v9 > *(_DWORD *)(v6 + 4))
  {
LABEL_31:
    while (1)
    {
      v6 += 24;
      if (v6 >= *(_QWORD *)(v4 + 3144) + 24 * *(int *)(v4 + 3136))
        break;
      v11 = *(_DWORD *)v6;
      if (*(_QWORD *)(v6 + 16))
      {
        while (v11 <= *(_DWORD *)(v6 + 4))
        {
          if ((*(_DWORD *)(*(_QWORD *)(v6 + 16) + 4 * (v11 - *(_DWORD *)v6)) & a2) != 0)
            return v11;
          ++v11;
        }
      }
      else if ((*(_DWORD *)(v6 + 8) & a2) != 0)
      {
        return *(_DWORD *)v6;
      }
    }
    return -1;
  }
  else if (*(_QWORD *)(v6 + 16))
  {
    while (1)
    {
      if (v9 > *(_DWORD *)(v6 + 4))
        goto LABEL_31;
      if ((*(_DWORD *)(*(_QWORD *)(v6 + 16) + 4 * (v9 - *(_DWORD *)v6)) & a2) != 0)
        return v9;
      ++v9;
    }
  }
  else
  {
    if ((*(_DWORD *)(v6 + 8) & a2) == 0)
      goto LABEL_31;
    return v9;
  }
}

wint_t nextwctype(wint_t a1, wctype_t a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return nextwctype_l(a1, a2, v7);
  else
    return nextwctype_l(a1, a2, (locale_t)__global_locale);
}

char *__cdecl nl_langinfo_l(nl_item a1, locale_t a2)
{
  if (a1 <= 0x39uLL)
    __asm { BR              X8 }
  return (char *)&unk_D495D;
}

char *__cdecl nl_langinfo(nl_item a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return nl_langinfo_l(a1, v5);
  else
    return nl_langinfo_l(a1, (locale_t)__global_locale);
}

uint64_t __maskrune(int a1, unsigned int a2)
{
  _QWORD *v3;
  int v4;
  _QWORD *v6;
  uint64_t v7;

  if (a1 < 0x100)
  {
    v7 = __locale_key;
    v6 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
    if (v6)
      v3 = v6;
    else
      v3 = __global_locale;
    v4 = *(_DWORD *)(*(_QWORD *)(v3[166] + 120) + 60 + 4 * a1);
  }
  else
  {
    v4 = ___runetype(a1);
  }
  return v4 & a2;
}

BOOL __istype(int a1, unsigned int a2)
{
  if (isascii(a1))
    return (_DefaultRuneLocale.__runetype[a1] & a2) != 0;
  else
    return __maskrune(a1, a2) != 0;
}

BOOL __isctype(unsigned int a1, int a2)
{
  return a1 < 0x100 && (_DefaultRuneLocale.__runetype[a1] & a2) != 0;
}

uint64_t __toupper(int a1)
{
  _QWORD *v2;
  _QWORD *v4;
  uint64_t v5;

  if (a1 < 0x100)
  {
    v5 = __locale_key;
    v4 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
    if (v4)
      v2 = v4;
    else
      v2 = __global_locale;
    return *(unsigned int *)(*(_QWORD *)(v2[166] + 120) + 2108 + 4 * a1);
  }
  else
  {
    return ___toupper(a1);
  }
}

uint64_t __tolower(int a1)
{
  _QWORD *v2;
  _QWORD *v4;
  uint64_t v5;

  if (a1 < 0x100)
  {
    v5 = __locale_key;
    v4 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
    if (v4)
      v2 = v4;
    else
      v2 = __global_locale;
    return *(unsigned int *)(*(_QWORD *)(v2[166] + 120) + 1084 + 4 * a1);
  }
  else
  {
    return ___tolower(a1);
  }
}

uint64_t __wcwidth(int a1)
{
  int v3;

  if (a1)
  {
    v3 = __maskrune(a1, 0xE0040000);
    if ((v3 & 0xE0000000) != 0)
    {
      return (uint64_t)(v3 & 0xE0000000) >> 30;
    }
    else if ((v3 & 0x40000) != 0)
    {
      return 1;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t __maskrune_l(int a1, unsigned int a2, _QWORD *a3)
{
  int v4;
  _QWORD *v6;

  if (a1 < 0x100)
  {
    v6 = a3;
    if (a3)
    {
      if (a3 == (_QWORD *)-1)
        v6 = __global_locale;
    }
    else
    {
      v6 = &__c_locale;
    }
    v4 = *(_DWORD *)(*(_QWORD *)(v6[166] + 120) + 60 + 4 * a1);
  }
  else
  {
    v4 = ___runetype_l(a1, a3);
  }
  return v4 & a2;
}

BOOL __istype_l(int a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v4;

  if (isascii(a1))
    v4 = _DefaultRuneLocale.__runetype[a1] & a2;
  else
    v4 = (int)__maskrune_l(a1, a2, a3);
  return v4 != 0;
}

uint64_t __toupper_l(int a1, _QWORD *a2)
{
  if (isascii(a1))
    return _DefaultRuneLocale.__mapupper[a1];
  else
    return ___toupper_l(a1, a2);
}

uint64_t __tolower_l(int a1, _QWORD *a2)
{
  if (isascii(a1))
    return _DefaultRuneLocale.__maplower[a1];
  else
    return ___tolower_l(a1, a2);
}

uint64_t __wcwidth_l(int a1, _QWORD *a2)
{
  int v4;

  if (a1)
  {
    v4 = __maskrune_l(a1, 0xE0040000, a2);
    if ((v4 & 0xE0000000) != 0)
    {
      return (uint64_t)(v4 & 0xE0000000) >> 30;
    }
    else if ((v4 & 0x40000) != 0)
    {
      return 1;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

uint64_t _none_init(uint64_t a1)
{
  *(_QWORD *)(a1 + 72) = _none_mbrtowc;
  *(_QWORD *)(a1 + 80) = _none_mbsinit;
  *(_QWORD *)(a1 + 88) = _none_mbsnrtowcs;
  *(_QWORD *)(a1 + 96) = _none_wcrtomb;
  *(_QWORD *)(a1 + 104) = _none_wcsnrtombs;
  *(_DWORD *)(a1 + 64) = 1;
  *(_DWORD *)(a1 + 68) = 256;
  return 0;
}

uint64_t _none_mbrtowc(_DWORD *a1, _BYTE *a2, uint64_t a3)
{
  if (!a2)
    return 0;
  if (!a3)
    return -2;
  if (a1)
    *a1 = *a2;
  return *a2 != 0;
}

uint64_t _none_mbsinit()
{
  return 1;
}

uint64_t _none_mbsnrtowcs(_DWORD *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  _DWORD *v7;
  BOOL v9;
  uint64_t i;
  uint64_t v12;
  unsigned __int8 *v13;
  uint64_t v15;
  _DWORD *v17;

  v17 = a1;
  v15 = a3;
  if (a1)
  {
    v13 = (unsigned __int8 *)*a2;
    for (i = 0; ; ++i)
    {
      v4 = a4--;
      v9 = 0;
      if (v4)
      {
        v5 = v15--;
        v9 = v5 != 0;
      }
      if (!v9)
        break;
      v6 = v13++;
      LODWORD(v6) = *v6;
      v7 = v17++;
      *v7 = (_DWORD)v6;
      if (!(_DWORD)v6)
      {
        *a2 = 0;
        return i;
      }
    }
    *a2 = v13;
    return i;
  }
  else
  {
    v12 = _platform_memchr(*a2, 0, a3);
    if (v12)
      return v12 - *a2;
    else
      return v15;
  }
}

uint64_t _none_wcrtomb(_BYTE *a1, unsigned int a2)
{
  if (!a1)
    return 1;
  if (a2 < 0x100)
  {
    *a1 = a2;
    return 1;
  }
  else
  {
    *__error() = 92;
    return -1;
  }
}

uint64_t _none_wcsnrtombs(_BYTE *a1, _DWORD **a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _BYTE *v7;
  BOOL v9;
  BOOL v10;
  uint64_t i;
  _DWORD *j;
  _DWORD *v13;
  _BYTE *v16;

  v16 = a1;
  if (a1)
  {
    v13 = *a2;
    for (i = 0; ; ++i)
    {
      v4 = a4--;
      v9 = 0;
      if (v4)
      {
        v5 = a3--;
        v9 = v5 != 0;
      }
      if (!v9)
        break;
      if (*v13 >= 0x100u)
      {
        *a2 = v13;
        *__error() = 92;
        return -1;
      }
      v6 = v13++;
      LOBYTE(v6) = *v6;
      v7 = v16++;
      *v7 = (_BYTE)v6;
      if (!(_BYTE)v6)
      {
        *a2 = 0;
        return i;
      }
    }
    *a2 = v13;
    return i;
  }
  else
  {
    for (j = *a2; ; ++j)
    {
      v10 = 0;
      if (a3)
        v10 = *j != 0;
      if (!v10)
        break;
      if (*j >= 0x100u)
      {
        *__error() = 92;
        return -1;
      }
      --a3;
    }
    return j - *a2;
  }
}

uint64_t ___runetype_l(int a1, _QWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t i;
  _QWORD *v6;

  v6 = a2;
  if (a1 < 0)
    return 0;
  if (a2)
  {
    if (a2 == (_QWORD *)-1)
      v6 = &__global_locale;
  }
  else
  {
    v6 = &__c_locale;
  }
  v4 = *(_QWORD *)(*(_QWORD *)(v6[166] + 120) + 3144);
  for (i = *(int *)(*(_QWORD *)(v6[166] + 120) + 3136); ; i >>= 1)
  {
    if (!i)
      return 0;
    v3 = v4 + 24 * (i >> 1);
    if (*(_DWORD *)v3 <= a1 && a1 <= *(_DWORD *)(v3 + 4))
      break;
    if (a1 > *(_DWORD *)(v3 + 4))
    {
      v4 = v3 + 24;
      --i;
    }
  }
  if (*(_QWORD *)(v3 + 16))
    return *(unsigned int *)(*(_QWORD *)(v3 + 16) + 4 * (a1 - *(_DWORD *)v3));
  else
    return *(int *)(v3 + 8);
}

uint64_t ___runetype(int a1)
{
  char v1;
  char v2;
  _QWORD *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return ___runetype_l(a1, v5);
  else
    return ___runetype_l(a1, __global_locale);
}

char *__cdecl setlocale(int a1, const char *a2)
{
  BOOL v3;
  uint64_t v5;
  const char *v6;
  const char *locale_env;
  const char *v8;
  char v9;
  int v10;
  int n;
  int i;
  int j;
  int k;
  int v15;
  int m;
  const char *v17;

  v17 = a2;
  if (a1 > 6)
  {
    *__error() = 22;
    return 0;
  }
  if (!a2)
  {
    if (a1)
      return &current_categories[32 * a1];
    else
      return (char *)currentlocale();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&__global_locale[162]);
  for (i = 1; i < 7; ++i)
    _platform_strcpy((char *)&new_categories + 32 * i, &current_categories[32 * i]);
  if (!*v17)
  {
    if (!a1)
    {
      for (j = 1; j < 7; ++j)
      {
        locale_env = __get_locale_env(j);
        if ((unint64_t)_platform_strlen(locale_env) > 0x1F)
          goto LABEL_37;
        _platform_strcpy((char *)&new_categories + 32 * j, locale_env);
      }
      goto LABEL_49;
    }
    v8 = __get_locale_env(a1);
    if ((unint64_t)_platform_strlen(v8) <= 0x1F)
    {
      _platform_strcpy((char *)&new_categories + 32 * a1, v8);
      goto LABEL_49;
    }
LABEL_37:
    *__error() = 22;
    os_unfair_lock_unlock((os_unfair_lock_t)&__global_locale[162]);
    return 0;
  }
  if (a1)
  {
    if ((unint64_t)_platform_strlen(v17) > 0x1F)
      goto LABEL_37;
    _platform_strcpy((char *)&new_categories + 32 * a1, v17);
  }
  else
  {
    v6 = (const char *)_platform_strchr(v17, 47);
    if (v6)
    {
      v15 = 1;
      while (v6[1] == 47)
        ++v6;
      if (v6[1])
      {
        do
        {
          if (v15 == 7)
            break;
          if ((int)v6 - (int)v17 > 31)
            goto LABEL_37;
          _platform_strlcpy((char *)&new_categories + 32 * v15++, v17, (int)v6 - (int)v17 + 1);
          while (*v6 == 47)
            ++v6;
          v17 = v6;
          while (1)
          {
            v3 = 0;
            if (*v6)
              v3 = *v6 != 47;
            if (!v3)
              break;
            ++v6;
          }
        }
        while (*v17);
        while (v15 < 7)
        {
          _platform_strcpy((char *)&new_categories + 32 * v15, (char *)&new_categories + 32 * v15 - 32);
          ++v15;
        }
        goto LABEL_49;
      }
      goto LABEL_37;
    }
    if ((unint64_t)_platform_strlen(v17) > 0x1F)
      goto LABEL_37;
    for (k = 1; k < 7; ++k)
      _platform_strcpy((char *)&new_categories + 32 * k, v17);
  }
LABEL_49:
  if (a1)
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&__global_locale[162]);
    return (char *)loadlocale(a1);
  }
  else
  {
    v9 = byte_DC856;
    v5 = qword_DC888;
    xlocale_retain((unsigned int *)qword_DC888);
    for (m = 1; ; ++m)
    {
      if (m >= 7)
      {
        xlocale_release(v5);
        os_unfair_lock_unlock((os_unfair_lock_t)&__global_locale[162]);
        return (char *)currentlocale();
      }
      _platform_strcpy((char *)&saved_categories + 32 * m, &current_categories[32 * m]);
      if (!loadlocale(m))
        break;
    }
    v10 = *__error();
    for (n = 1; n < m; ++n)
    {
      _platform_strcpy((char *)&new_categories + 32 * n, (char *)&saved_categories + 32 * n);
      if (!loadlocale(n))
      {
        _platform_strcpy((char *)&new_categories + 32 * n, "C");
        loadlocale(n);
      }
    }
    byte_DC856 = v9;
    qword_DC888 = v5;
    xlocale_release(v5);
    *__error() = v10;
    os_unfair_lock_unlock((os_unfair_lock_t)&__global_locale[162]);
    return 0;
  }
}

uint64_t currentlocale()
{
  int i;
  int j;

  if (!currentlocale_current_locale_string)
  {
    currentlocale_current_locale_string = malloc_type_malloc(231, 4169795762);
    if (!currentlocale_current_locale_string)
      return 0;
  }
  _platform_strlcpy(currentlocale_current_locale_string, &current_categories[32], 231);
  for (i = 2; i < 7; ++i)
  {
    if (_platform_strcmp(&current_categories[32], &current_categories[32 * i]))
    {
      for (j = 2; j < 7; ++j)
      {
        strcat((char *)currentlocale_current_locale_string, "/");
        strcat((char *)currentlocale_current_locale_string, &current_categories[32 * j]);
      }
      return currentlocale_current_locale_string;
    }
  }
  return currentlocale_current_locale_string;
}

const char *__get_locale_env(int a1)
{
  char *v2;

  v2 = getenv("LC_ALL");
  if (!v2 || !*v2)
    v2 = getenv(categories[a1]);
  if (!v2 || !*v2)
    v2 = getenv("LANG");
  if (!v2 || !*v2)
    return "C";
  return v2;
}

uint64_t loadlocale(int a1)
{
  unint64_t v2;
  int v3;
  int v4;
  char *v5;

  v5 = (char *)&new_categories + 32 * a1;
  if (*v5 == 46 && (!v5[1] || v5[1] == 46 && !v5[2]) || _platform_strchr(v5, 47))
    goto LABEL_10;
  v4 = *__error();
  v3 = __detect_path_locale();
  *__error() = v3;
  if (!*__error())
  {
    *__error() = v4;
    v2 = (a1 - 1);
    if (v2 <= 5)
      __asm { BR              X8 }
LABEL_10:
    *__error() = 22;
  }
  return 0;
}

uint64_t __detect_path_locale()
{
  const char *__s1;

  if (_PathLocale)
    return 0;
  __s1 = getenv("PATH_LOCALE");
  if (!__s1 || issetugid())
  {
    _PathLocale = (uint64_t)"/usr/share/locale";
    return 0;
  }
  if ((unint64_t)(_platform_strlen(__s1) + 44) >= 0x400)
    return 63;
  _PathLocale = (uint64_t)strdup(__s1);
  if (_PathLocale)
    return 0;
  if (*__error())
    return *__error();
  else
    return 12;
}

uint64_t __open_path_locale(const char *a1)
{
  int v2;
  int v3;
  char v6[1024];

  _platform_strcpy(v6, _PathLocale);
  strcat(v6, "/");
  strcat(v6, a1);
  v2 = open_NOCANCEL(v6, 0);
  if (v2 < 0)
  {
    _platform_strcpy(v6, "/usr/share/locale");
    strcat(v6, "/");
    strcat(v6, a1);
    v3 = open_NOCANCEL(v6, 0);
    if (v3 < 0)
    {
      _platform_strcpy(v6, "/usr/local/share/locale");
      strcat(v6, "/");
      strcat(v6, a1);
      return open_NOCANCEL(v6, 0);
    }
    else
    {
      return v3;
    }
  }
  else
  {
    return v2;
  }
}

uint64_t __setrunelocale(uint64_t a1, _QWORD *a2)
{
  int v2;
  unsigned int v4;
  unsigned int v6;
  uint64_t v7;
  _DWORD *RuneMagi;
  FILE *v9;
  char v13[1024];

  if (_platform_strcmp(a1, "C") && _platform_strcmp(a1, "POSIX"))
  {
    os_unfair_lock_lock(&__setrunelocale_cache_lock);
    if (!__setrunelocale_CachedRuneLocale || _platform_strcmp(a1, __setrunelocale_CachedRuneLocale + 16))
    {
      os_unfair_lock_unlock(&__setrunelocale_cache_lock);
      _platform_strcpy(v13, a1);
      strcat(v13, "/LC_CTYPE");
      v2 = __open_path_locale(v13);
      v9 = (FILE *)fdopen_DARWIN_EXTSN(v2, "r");
      if (v9)
      {
        RuneMagi = _Read_RuneMagi(v9);
        if (RuneMagi)
        {
          fclose(v9);
          *((_QWORD *)RuneMagi + 9) = 0;
          *((_QWORD *)RuneMagi + 10) = 0;
          *((_QWORD *)RuneMagi + 11) = __mbsnrtowcs_std;
          *((_QWORD *)RuneMagi + 12) = 0;
          *((_QWORD *)RuneMagi + 13) = __wcsnrtombs_std;
          v7 = *((_QWORD *)RuneMagi + 15);
          *(_QWORD *)(v7 + 48) = 0;
          *(_QWORD *)(v7 + 40) = 0;
          if (_platform_strcmp(v7 + 8, "NONE:US-ASCII")
            && _platform_strcmp(v7 + 8, "ASCII"))
          {
            if (_platform_strncmp(v7 + 8, "NONE", 4))
            {
              if (_platform_strcmp(v7 + 8, "UTF-8"))
              {
                if (_platform_strcmp(v7 + 8, "EUC-CN"))
                {
                  if (_platform_strcmp(v7 + 8, "EUC-JP"))
                  {
                    if (_platform_strcmp(v7 + 8, "EUC-KR"))
                    {
                      if (_platform_strcmp(v7 + 8, "EUC-TW"))
                      {
                        if (_platform_strcmp(v7 + 8, "EUC"))
                        {
                          if (_platform_strcmp(v7 + 8, "GB18030"))
                          {
                            if (_platform_strcmp(v7 + 8, "GB2312"))
                            {
                              if (_platform_strcmp(v7 + 8, "GBK"))
                              {
                                if (_platform_strcmp(v7 + 8, "BIG5"))
                                {
                                  if (_platform_strcmp(v7 + 8, "MSKanji"))
                                  {
                                    if (_platform_strcmp(v7 + 8, "UTF2"))
                                      v6 = 79;
                                    else
                                      v6 = _UTF2_init((uint64_t)RuneMagi);
                                  }
                                  else
                                  {
                                    v6 = _MSKanji_init((uint64_t)RuneMagi);
                                  }
                                }
                                else
                                {
                                  v6 = _BIG5_init((uint64_t)RuneMagi);
                                }
                              }
                              else
                              {
                                v6 = _GBK_init((uint64_t)RuneMagi);
                              }
                            }
                            else
                            {
                              v6 = _GB2312_init((uint64_t)RuneMagi);
                            }
                          }
                          else
                          {
                            v6 = _GB18030_init((uint64_t)RuneMagi);
                          }
                        }
                        else
                        {
                          v6 = _EUC_init((uint64_t)RuneMagi);
                        }
                      }
                      else
                      {
                        v6 = _EUC_TW_init((uint64_t)RuneMagi);
                      }
                    }
                    else
                    {
                      v6 = _EUC_KR_init((uint64_t)RuneMagi);
                    }
                  }
                  else
                  {
                    v6 = _EUC_JP_init((uint64_t)RuneMagi);
                  }
                }
                else
                {
                  v6 = _EUC_CN_init((uint64_t)RuneMagi);
                }
              }
              else
              {
                v6 = _UTF8_init((uint64_t)RuneMagi);
              }
            }
            else
            {
              v6 = _none_init((uint64_t)RuneMagi);
            }
          }
          else
          {
            v6 = _ascii_init((uint64_t)RuneMagi);
          }
          if (v6)
          {
            xlocale_release((uint64_t)RuneMagi);
          }
          else
          {
            _platform_strcpy(RuneMagi + 4, a1);
            xlocale_release(a2[166]);
            a2[166] = RuneMagi;
            if (a2 == __global_locale)
            {
              _CurrentRuneLocale = *(_RuneLocale **)(a2[166] + 120);
              __mb_cur_max = *(_DWORD *)(a2[166] + 64);
              __mb_sb_limit = *(_DWORD *)(a2[166] + 68);
            }
            os_unfair_lock_lock(&__setrunelocale_cache_lock);
            xlocale_release(__setrunelocale_CachedRuneLocale);
            __setrunelocale_CachedRuneLocale = (uint64_t)RuneMagi;
            xlocale_retain(RuneMagi);
            os_unfair_lock_unlock(&__setrunelocale_cache_lock);
          }
          return v6;
        }
        else
        {
          if (*__error())
            v4 = *__error();
          else
            v4 = 79;
          fclose(v9);
          return v4;
        }
      }
      else if (*__error())
      {
        return *__error();
      }
      else
      {
        return 2;
      }
    }
    else
    {
      xlocale_release(a2[166]);
      a2[166] = __setrunelocale_CachedRuneLocale;
      xlocale_retain((unsigned int *)__setrunelocale_CachedRuneLocale);
      if (a2 == __global_locale)
      {
        _CurrentRuneLocale = *(_RuneLocale **)(a2[166] + 120);
        __mb_cur_max = *(_DWORD *)(a2[166] + 64);
        __mb_sb_limit = *(_DWORD *)(a2[166] + 68);
      }
      os_unfair_lock_unlock(&__setrunelocale_cache_lock);
      return 0;
    }
  }
  else
  {
    xlocale_release(a2[166]);
    a2[166] = &_DefaultRuneXLocale;
    if (a2 == __global_locale)
    {
      _CurrentRuneLocale = *(_RuneLocale **)(a2[166] + 120);
      __mb_cur_max = *(_DWORD *)(a2[166] + 64);
      __mb_sb_limit = *(_DWORD *)(a2[166] + 68);
    }
    return 0;
  }
}

uint64_t __wrap_setrunelocale(uint64_t a1, _QWORD *a2)
{
  int v3;

  v3 = __setrunelocale(a1, a2);
  if (v3)
  {
    *__error() = v3;
    return -1;
  }
  else
  {
    return 0;
  }
}

uint64_t ___tolower_l(int a1, _QWORD *a2)
{
  int *v3;
  _DWORD *v4;
  unint64_t i;
  _QWORD *v6;

  v6 = a2;
  if (a1 >= 0)
  {
    if (a2)
    {
      if (a2 == (_QWORD *)-1)
        v6 = &__global_locale;
    }
    else
    {
      v6 = &__c_locale;
    }
    if (a1 >= 256)
    {
      v4 = *(_DWORD **)(*(_QWORD *)(v6[166] + 120) + 3160);
      for (i = *(int *)(*(_QWORD *)(v6[166] + 120) + 3152); i; i >>= 1)
      {
        v3 = &v4[6 * (i >> 1)];
        if (*v3 <= a1 && a1 <= v3[1])
          return (v3[2] + a1 - *v3);
        if (a1 > v3[1])
        {
          v4 = v3 + 6;
          --i;
        }
      }
      return a1;
    }
    else
    {
      return *(unsigned int *)(*(_QWORD *)(v6[166] + 120) + 1084 + 4 * a1);
    }
  }
  else
  {
    return a1;
  }
}

uint64_t ___tolower(int a1)
{
  char v1;
  char v2;
  _QWORD *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return ___tolower_l(a1, v5);
  else
    return ___tolower_l(a1, __global_locale);
}

uint64_t ___toupper_l(int a1, _QWORD *a2)
{
  int *v3;
  _DWORD *v4;
  unint64_t i;
  _QWORD *v6;

  v6 = a2;
  if (a1 >= 0)
  {
    if (a2)
    {
      if (a2 == (_QWORD *)-1)
        v6 = &__global_locale;
    }
    else
    {
      v6 = &__c_locale;
    }
    if (a1 >= 256)
    {
      v4 = *(_DWORD **)(*(_QWORD *)(v6[166] + 120) + 3176);
      for (i = *(int *)(*(_QWORD *)(v6[166] + 120) + 3168); i; i >>= 1)
      {
        v3 = &v4[6 * (i >> 1)];
        if (*v3 <= a1 && a1 <= v3[1])
          return (v3[2] + a1 - *v3);
        if (a1 > v3[1])
        {
          v4 = v3 + 6;
          --i;
        }
      }
      return a1;
    }
    else
    {
      return *(unsigned int *)(*(_QWORD *)(v6[166] + 120) + 2108 + 4 * a1);
    }
  }
  else
  {
    return a1;
  }
}

uint64_t ___toupper(int a1)
{
  char v1;
  char v2;
  _QWORD *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return ___toupper_l(a1, v5);
  else
    return ___toupper_l(a1, __global_locale);
}

uint64_t _UTF8_init(uint64_t a1)
{
  *(_QWORD *)(a1 + 72) = _UTF8_mbrtowc;
  *(_QWORD *)(a1 + 96) = _UTF8_wcrtomb;
  *(_QWORD *)(a1 + 80) = _UTF8_mbsinit;
  *(_QWORD *)(a1 + 88) = _UTF8_mbsnrtowcs;
  *(_QWORD *)(a1 + 104) = _UTF8_wcsnrtombs;
  *(_DWORD *)(a1 + 64) = 4;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _UTF8_mbrtowc(int *a1, _BYTE *a2, unint64_t a3, uint64_t a4)
{
  _BYTE *v4;
  _BYTE *v5;
  unint64_t v8;
  __int16 v9;
  int v10;
  int v11;
  char v12;
  int i;
  int v14;
  int v15;
  _BYTE *v17;

  v17 = a2;
  v12 = 0;
  if (*(_DWORD *)(a4 + 4) > 4u)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    v17 = &unk_D495D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3)
    return -2;
  if (!*(_DWORD *)(a4 + 4))
  {
    v14 = *v17;
    if ((v14 & 0xFFFFFF80) == 0)
    {
      if (a1)
        *a1 = v14;
      return v14 != 0;
    }
  }
  if (!*(_DWORD *)(a4 + 4))
  {
    v15 = *v17;
    if ((v15 & 0x80u) == 0)
    {
      v12 = 127;
      v11 = 1;
      v9 = sb_00_00;
      goto LABEL_33;
    }
    if ((v15 & 0xE0) == 0xC0)
    {
      if (*v17 >= 0xC2u)
      {
        v12 = 31;
        v11 = 2;
        v9 = sb_80_BF;
        goto LABEL_33;
      }
    }
    else
    {
      if ((v15 & 0xF0) == 0xE0)
      {
        v12 = 15;
        v11 = 3;
        if (v15 == 224)
        {
          v9 = sb_A0_BF;
        }
        else if (v15 == 237)
        {
          v9 = sb_80_9F;
        }
        else
        {
          v9 = sb_80_BF;
        }
        goto LABEL_33;
      }
      if ((v15 & 0xF8) == 0xF0 && *v17 <= 0xF4u)
      {
        v12 = 7;
        v11 = 4;
        if (v15 == 240)
        {
          v9 = sb_90_BF;
        }
        else if (v15 == 244)
        {
          v9 = sb_80_8F;
        }
        else
        {
          v9 = sb_80_BF;
        }
        goto LABEL_33;
      }
    }
LABEL_31:
    *__error() = 92;
    return -1;
  }
  v11 = *(_DWORD *)(a4 + 4);
  v9 = *(_WORD *)(a4 + 8);
LABEL_33:
  if (*(_DWORD *)(a4 + 4))
  {
    v10 = *(_DWORD *)a4;
  }
  else
  {
    v4 = v17++;
    v10 = (*v4 & v12);
  }
  for (i = *(_DWORD *)(a4 + 4) == 0; ; ++i)
  {
    v8 = v11 >= a3 ? a3 : v11;
    if (i >= v8)
      break;
    if ((_BYTE)v9)
    {
      if (*v17 < (int)v9 || *v17 > (int)HIBYTE(v9))
        goto LABEL_31;
      v9 = sb_00_00;
    }
    else if ((*v17 & 0xC0) != 0x80)
    {
      goto LABEL_31;
    }
    v5 = v17++;
    v10 = (v10 << 6) | *v5 & 0x3F;
  }
  if (i >= v11)
  {
    if (a1)
      *a1 = v10;
    *(_DWORD *)(a4 + 4) = 0;
    if (v10)
      return v11;
    else
      return 0;
  }
  else
  {
    *(_DWORD *)(a4 + 4) = v11 - i;
    *(_WORD *)(a4 + 8) = v9;
    *(_DWORD *)a4 = v10;
    return -2;
  }
}

uint64_t _UTF8_wcrtomb(_BYTE *a1, int a2, uint64_t a3)
{
  int v4;
  int i;
  char v6;
  int v7;

  v7 = a2;
  if (*(_DWORD *)(a3 + 4))
  {
    *__error() = 22;
    return -1;
  }
  if (!a1)
    return 1;
  if ((a2 & 0xFFFFFF80) == 0)
  {
    *a1 = a2;
    return 1;
  }
  if ((a2 & 0xFFFFF800) == 0)
  {
    v6 = -64;
    v4 = 2;
    goto LABEL_17;
  }
  if ((a2 & 0xFFFF0000) == 0)
  {
    if (a2 < 55296 || a2 >= 57344)
    {
      v6 = -32;
      v4 = 3;
      goto LABEL_17;
    }
LABEL_16:
    *__error() = 92;
    return -1;
  }
  if ((a2 & 0xFFE00000) != 0 || a2 >= 1114112)
    goto LABEL_16;
  v6 = -16;
  v4 = 4;
LABEL_17:
  for (i = v4 - 1; i > 0; --i)
  {
    a1[i] = v7 & 0x3F | 0x80;
    v7 >>= 6;
  }
  *a1 = v7 | v6;
  return v4;
}

BOOL _UTF8_mbsinit(uint64_t a1)
{
  BOOL v2;

  v2 = 1;
  if (a1)
    return *(_DWORD *)(a1 + 4) == 0;
  return v2;
}

uint64_t _UTF8_mbsnrtowcs(int *a1, char **a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char **v18;
  int *v19;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v13 = a5;
  v12 = *a2;
  v11 = 0;
  if (a1)
  {
    if (!v17 || !v16 || *(int *)(v13 + 4) <= 0 || *v12 <= 0)
    {
      while (1)
      {
        if (!v16--)
        {
          *v18 = v12;
          return v11;
        }
        if (v17 && *v12 > 0)
        {
          *v19 = *v12;
          v9 = 1;
        }
        else
        {
          v9 = _UTF8_mbrtowc(v19, v12, v17, v15);
          switch(v9)
          {
            case -1:
              *v18 = v12;
              return -1;
            case -2:
              *v18 = &v12[v17];
              return v11;
            case 0:
              *v18 = 0;
              return v11;
          }
        }
        v12 += v9;
        v17 -= v9;
        ++v11;
        ++v19;
      }
    }
  }
  else if (!v17 || *(int *)(v13 + 4) <= 0 || *v12 <= 0)
  {
    while (1)
    {
      if (v17 && *v12 > 0)
      {
        v8 = 1;
      }
      else
      {
        v8 = _UTF8_mbrtowc(&v10, v12, v17, v15);
        if (v8 == -1)
          return -1;
        if (!v8 || v8 == -2)
          return v11;
      }
      v12 += v8;
      v17 -= v8;
      ++v11;
    }
  }
  *__error() = 92;
  return -1;
}

uint64_t _UTF8_wcsnrtombs(_BYTE *a1, int **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  BOOL v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int *v13;
  _BYTE v14[6];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int **v20;
  _BYTE *v21;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = a5;
  v16 = a6;
  v15 = a5;
  if (*(_DWORD *)(a5 + 4))
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    v13 = *v20;
    v12 = 0;
    if (v21)
    {
      while (1)
      {
        v9 = 0;
        if (v18)
        {
          v7 = v19--;
          v9 = v7 != 0;
        }
        if (!v9)
          break;
        if (*v13 >= 0x80)
        {
          if (v18 <= 4)
          {
            v11 = _UTF8_wcrtomb(v14, *v13, v17);
            if (v11 == -1)
            {
              *v20 = v13;
              return -1;
            }
            if (v11 > (int)v18)
              break;
            j___platform_memmove(v21, v14, v11);
          }
          else
          {
            v11 = _UTF8_wcrtomb(v21, *v13, v17);
            if (v11 == -1)
            {
              *v20 = v13;
              return -1;
            }
          }
        }
        else
        {
          v11 = 1;
          *v21 = *v13;
        }
        if (!*v13)
        {
          *v20 = 0;
          return v12 + v11 - 1;
        }
        ++v13;
        v21 += v11;
        v18 -= v11;
        v12 += v11;
      }
      *v20 = v13;
      return v12;
    }
    else
    {
      while (v19--)
      {
        if (*v13 >= 0x80)
        {
          v10 = _UTF8_wcrtomb(v14, *v13, v17);
          if (v10 == -1)
            return -1;
        }
        else
        {
          v10 = 1;
        }
        if (!*v13)
          return v12 + v10 - 1;
        ++v13;
        v12 += v10;
      }
      return v12;
    }
  }
}

size_t wcrtomb_l(char *a1, __int32 a2, mbstate_t *a3, locale_t a4)
{
  locale_t v5;
  mbstate_t *v6;

  v6 = a3;
  v5 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v5 = (locale_t)&__global_locale;
  }
  else
  {
    v5 = (locale_t)&__c_locale;
  }
  if (!a3)
    v6 = (mbstate_t *)((char *)v5 + 784);
  return (*(uint64_t (**)(char *, _QWORD, mbstate_t *, locale_t))(*((_QWORD *)v5 + 166) + 96))(a1, a2, v6, v5);
}

size_t wcrtomb(char *a1, __int32 a2, mbstate_t *a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcrtomb_l(a1, a2, a3, v9);
  else
    return wcrtomb_l(a1, a2, a3, (locale_t)__global_locale);
}

size_t wcsftime_l(__int32 *a1, size_t a2, const __int32 *a3, const tm *a4, locale_t a5)
{
  int v6;
  size_t v7;
  size_t v8;
  __int32 *v9;
  char *v10;
  char *v11;
  char *v12;
  locale_t v13;
  tm *v14;
  __int32 *v15;
  size_t v16;
  __int32 *v17;
  mbstate_t v19;

  v17 = a1;
  v16 = a2;
  v15 = (__int32 *)a3;
  v14 = (tm *)a4;
  v13 = a5;
  _platform_memset(&v19, 0, 128);
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  if (v13)
  {
    if (v13 == (locale_t)-1)
      v13 = (locale_t)__global_locale;
  }
  else
  {
    v13 = (locale_t)&__c_locale;
  }
  v12 = 0;
  v11 = 0;
  j___platform_memmove(&v19, &wcsftime_l_initial, 128);
  v9 = v15;
  v7 = wcsrtombs_l(0, (const __int32 **)&v9, 0, &v19, v13);
  if (v7 == -1)
    goto LABEL_16;
  v11 = (char *)malloc_type_malloc(v7 + 1, 1589551727);
  if (!v11)
    goto LABEL_16;
  j___platform_memmove(&v19, &wcsftime_l_initial, 128);
  wcsrtombs_l(v11, (const __int32 **)&v9, v7 + 1, &v19, v13);
  if (0xFFFFFFFFFFFFFFFFLL / *(int *)(*((_QWORD *)v13 + 166) + 64) <= v16)
  {
    *__error() = 22;
LABEL_16:
    v6 = *__error();
    free(v11);
    free(v12);
    *__error() = v6;
    return 0;
  }
  v12 = (char *)malloc_type_malloc(v16 * *(int *)(*((_QWORD *)v13 + 166) + 64), 768804693);
  if (!v12)
    goto LABEL_16;
  if (!strftime_l(v12, v16, v11, v14, v13))
    goto LABEL_16;
  v10 = v12;
  j___platform_memmove(&v19, &wcsftime_l_initial, 128);
  v8 = mbsrtowcs_l(v17, (const char **)&v10, v16, &v19, v13);
  if (v8 == -2 || v8 == -1 || v10)
    goto LABEL_16;
  free(v11);
  free(v12);
  return v8;
}

size_t wcsftime(__int32 *a1, size_t a2, const __int32 *a3, const tm *a4)
{
  char v4;
  char v5;
  _xlocale *v11;
  uint64_t v12;

  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v12 = __locale_key;
    v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11)
    return wcsftime_l(a1, a2, a3, a4, v11);
  else
    return wcsftime_l(a1, a2, a3, a4, (locale_t)__global_locale);
}

size_t wcsnrtombs_l(char *a1, const __int32 **a2, size_t a3, size_t a4, mbstate_t *a5, locale_t a6)
{
  locale_t v7;
  mbstate_t *v8;

  v8 = a5;
  v7 = a6;
  if (a6)
  {
    if (a6 == (locale_t)-1)
      v7 = (locale_t)&__global_locale;
  }
  else
  {
    v7 = (locale_t)&__c_locale;
  }
  if (!a5)
    v8 = (mbstate_t *)((char *)v7 + 912);
  return (*(uint64_t (**)(char *, const __int32 **, size_t, size_t, mbstate_t *, locale_t))(*((_QWORD *)v7 + 166) + 104))(a1, a2, a3, a4, v8, v7);
}

size_t wcsnrtombs(char *a1, const __int32 **a2, size_t a3, size_t a4, mbstate_t *a5)
{
  char v5;
  char v6;
  _xlocale *v13;
  uint64_t v14;

  if (v5)
    v6 = 1;
  else
    v6 = 0;
  if ((v6 & 1) != 0)
  {
    v13 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v14 = __locale_key;
    v13 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v14);
  }
  if (v13)
    return wcsnrtombs_l(a1, a2, a3, a4, a5, v13);
  else
    return wcsnrtombs_l(a1, a2, a3, a4, a5, (locale_t)__global_locale);
}

uint64_t __wcsnrtombs_std(_BYTE *a1, _DWORD **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  BOOL v9;
  int v10;
  uint64_t (*v11)(_BYTE *, _QWORD, uint64_t, uint64_t);
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _DWORD *v16;
  _BYTE v17[6];
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  _DWORD **v22;
  _BYTE *v23;
  _BYTE v25[128];

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v19 = a5;
  v18 = a6;
  _platform_memset(v25, 0, 128);
  v12 = *(_QWORD *)(v18 + 1328);
  v11 = *(uint64_t (**)(_BYTE *, _QWORD, uint64_t, uint64_t))(v12 + 96);
  v10 = *(_DWORD *)(v12 + 64);
  v16 = *v22;
  v15 = 0;
  if (v23)
  {
    while (1)
    {
      v9 = 0;
      if (v20)
      {
        v7 = v21--;
        v9 = v7 != 0;
      }
      if (!v9)
        break;
      if (v20 <= v10)
      {
        j___platform_memmove(v25, v19, 128);
        v14 = v11(v17, *v16, v19, v18);
        if (v14 == -1)
        {
          *v22 = v16;
          return -1;
        }
        if (v14 > (int)v20)
        {
          j___platform_memmove(v19, v25, 128);
          break;
        }
        j___platform_memmove(v23, v17, v14);
      }
      else
      {
        v14 = v11(v23, *v16, v19, v18);
        if (v14 == -1)
        {
          *v22 = v16;
          return -1;
        }
      }
      if (!*v16)
      {
        *v22 = 0;
        return v15 + v14 - 1;
      }
      ++v16;
      v23 += v14;
      v20 -= v14;
      v15 += v14;
    }
    *v22 = v16;
    return v15;
  }
  else
  {
    while (v21--)
    {
      v13 = v11(v17, *v16, v19, v18);
      if (v13 == -1)
        return -1;
      if (!*v16)
        return v15 + v13 - 1;
      ++v16;
      v15 += v13;
    }
    return v15;
  }
}

size_t wcsrtombs_l(char *a1, const __int32 **a2, size_t a3, mbstate_t *a4, locale_t a5)
{
  locale_t v6;
  mbstate_t *v7;

  v7 = a4;
  v6 = a5;
  if (a5)
  {
    if (a5 == (locale_t)-1)
      v6 = (locale_t)&__global_locale;
  }
  else
  {
    v6 = (locale_t)&__c_locale;
  }
  if (!a4)
    v7 = (mbstate_t *)((char *)v6 + 1040);
  return (*(uint64_t (**)(char *, const __int32 **, uint64_t, size_t, mbstate_t *, locale_t))(*((_QWORD *)v6 + 166) + 104))(a1, a2, -1, a3, v7, v6);
}

size_t wcsrtombs(char *a1, const __int32 **a2, size_t a3, mbstate_t *a4)
{
  char v4;
  char v5;
  _xlocale *v11;
  uint64_t v12;

  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v12 = __locale_key;
    v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11)
    return wcsrtombs_l(a1, a2, a3, a4, v11);
  else
    return wcsrtombs_l(a1, a2, a3, a4, (locale_t)__global_locale);
}

size_t __wcs_end_offset(const char *a1, uint64_t a2, _xlocale *a3)
{
  size_t __len;
  const char *__little;

  __little = localeconv_l(a3)->decimal_point;
  __len = a2 - (_QWORD)a1;
  if (strnstr(a1, __little, a2 - (_QWORD)a1))
    __len -= _platform_strlen(__little) - 1;
  return __len;
}

double wcstod_l(const __int32 *a1, __int32 **a2, locale_t a3)
{
  char v3;
  char v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  size_t v9;
  _BYTE v11[16];
  wint_t *v12;
  __int32 *v13;
  _BOOL4 v14;
  char *v15;
  _QWORD *v16;
  char *v17;
  int v18;
  wint_t *v19;
  wint_t *v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  locale_t v24;
  size_t v25;
  char *v26;
  const char *v27;
  double v28;
  _xlocale *v29;
  __int32 **v30;
  wint_t *v31;
  double v32;
  _QWORD *v33;
  uint64_t v34;
  char v35;
  mbstate_t v36;

  v17 = &v35;
  v31 = (wint_t *)a1;
  v30 = a2;
  v29 = a3;
  _platform_memset(&v36, 0, 128);
  v28 = 0.0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v33 = 0;
  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v33 = pthread_getspecific(__locale_key);
  }
  else
  {
    v5 = v17;
    v34 = __locale_key;
    *(_QWORD *)v17 = __locale_key;
    *((_QWORD *)v5 + 1) = 0;
    *((_QWORD *)v5 + 1) = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v33 = *(_QWORD **)(*((_QWORD *)v5 + 1) + 8 * *(_QWORD *)v5);
  }
  if (v33)
    v16 = v33;
  else
    v16 = __global_locale;
  v6 = (*(_DWORD *)(v16[166] + 64) + 1);
  v22 = v11;
  v15 = &v11[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v21 = v6;
  v20 = v31;
  v19 = 0;
  if (v29)
  {
    if (v29 == (_xlocale *)-1)
      v29 = (_xlocale *)__global_locale;
  }
  else
  {
    v29 = (_xlocale *)&__c_locale;
  }
  v24 = (locale_t)__numeric_ctype((uint64_t)v29);
  while (1)
  {
    v7 = iswspace_l(*v31, v24);
    if (!(_DWORD)v7)
      break;
    ++v31;
  }
  v23 = _simple_salloc(v7);
  if (v23)
  {
    v19 = v31;
    j___platform_memmove(&v36, &wcstod_l_initial, 128);
    while (1)
    {
      v8 = *v31 == 0;
      v14 = 0;
      if (!v8)
      {
        v25 = wcrtomb_l(v15, *v31, &v36, v24);
        v14 = v25 != -1;
      }
      if (!v14)
        break;
      v15[v25] = 0;
      if ((int)_simple_sappend(v23) < 0)
      {
        _simple_sfree(v23);
        v32 = 0.0;
        v18 = 1;
        return v32;
      }
      ++v31;
    }
    v27 = (const char *)_simple_string(v23);
    v28 = strtod_l(v27, &v26, v29);
    if (v30)
    {
      if (v26 == v27)
      {
        v13 = v20;
      }
      else
      {
        v12 = v19;
        v9 = __wcs_end_offset(v27, (uint64_t)v26, v29);
        v13 = &v12[v9];
      }
      *v30 = v13;
    }
    _simple_sfree(v23);
    v32 = v28;
    v18 = 1;
  }
  else
  {
    v32 = 0.0;
    v18 = 1;
  }
  return v32;
}

double wcstod(const __int32 *a1, __int32 **a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return wcstod_l(a1, a2, v7);
  else
    return wcstod_l(a1, a2, (locale_t)__global_locale);
}

float wcstof_l(const __int32 *a1, __int32 **a2, locale_t a3)
{
  char v3;
  char v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  size_t v9;
  _BYTE v11[16];
  wint_t *v12;
  __int32 *v13;
  _BOOL4 v14;
  char *v15;
  _QWORD *v16;
  char *v17;
  int v18;
  wint_t *v19;
  wint_t *v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  locale_t v24;
  size_t v25;
  char *v26;
  const char *v27;
  float v28;
  _xlocale *v29;
  __int32 **v30;
  wint_t *v31;
  float v32;
  _QWORD *v33;
  uint64_t v34;
  char v35;
  mbstate_t v36;

  v17 = &v35;
  v31 = (wint_t *)a1;
  v30 = a2;
  v29 = a3;
  _platform_memset(&v36, 0, 128);
  v28 = 0.0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v33 = 0;
  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v33 = pthread_getspecific(__locale_key);
  }
  else
  {
    v5 = v17;
    v34 = __locale_key;
    *(_QWORD *)v17 = __locale_key;
    *((_QWORD *)v5 + 1) = 0;
    *((_QWORD *)v5 + 1) = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v33 = *(_QWORD **)(*((_QWORD *)v5 + 1) + 8 * *(_QWORD *)v5);
  }
  if (v33)
    v16 = v33;
  else
    v16 = __global_locale;
  v6 = (*(_DWORD *)(v16[166] + 64) + 1);
  v22 = v11;
  v15 = &v11[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v21 = v6;
  v20 = v31;
  v19 = 0;
  if (v29)
  {
    if (v29 == (_xlocale *)-1)
      v29 = (_xlocale *)__global_locale;
  }
  else
  {
    v29 = (_xlocale *)&__c_locale;
  }
  v24 = (locale_t)__numeric_ctype((uint64_t)v29);
  while (1)
  {
    v7 = iswspace_l(*v31, v24);
    if (!(_DWORD)v7)
      break;
    ++v31;
  }
  v23 = _simple_salloc(v7);
  if (v23)
  {
    v19 = v31;
    j___platform_memmove(&v36, &wcstof_l_initial, 128);
    while (1)
    {
      v8 = *v31 == 0;
      v14 = 0;
      if (!v8)
      {
        v25 = wcrtomb_l(v15, *v31, &v36, v24);
        v14 = v25 != -1;
      }
      if (!v14)
        break;
      v15[v25] = 0;
      if ((int)_simple_sappend(v23) < 0)
      {
        _simple_sfree(v23);
        v32 = 0.0;
        v18 = 1;
        return v32;
      }
      ++v31;
    }
    v27 = (const char *)_simple_string(v23);
    v28 = strtof_l(v27, &v26, v29);
    if (v30)
    {
      if (v26 == v27)
      {
        v13 = v20;
      }
      else
      {
        v12 = v19;
        v9 = __wcs_end_offset(v27, (uint64_t)v26, v29);
        v13 = &v12[v9];
      }
      *v30 = v13;
    }
    _simple_sfree(v23);
    v32 = v28;
    v18 = 1;
  }
  else
  {
    v32 = 0.0;
    v18 = 1;
  }
  return v32;
}

float wcstof(const __int32 *a1, __int32 **a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return wcstof_l(a1, a2, v7);
  else
    return wcstof_l(a1, a2, (locale_t)__global_locale);
}

intmax_t wcstoimax_l(const __int32 *nptr, __int32 **endptr, int base, locale_t a4)
{
  wint_t *v4;
  int *v5;
  int *v6;
  int v7;
  unint64_t v8;
  int *v9;
  unint64_t v10;
  __int32 *v12;
  wint_t v13;
  int v14;
  int v15;
  unint64_t v16;
  int v17;
  wint_t v18;
  unint64_t v19;
  const __int32 *v20;
  _xlocale *v21;

  v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v21 = (_xlocale *)__global_locale;
  }
  else
  {
    v21 = (_xlocale *)&__c_locale;
  }
  v20 = nptr;
  do
  {
    v4 = (wint_t *)v20++;
    v17 = *v4;
  }
  while (iswspace_l(*v4, v21));
  if (v17 == 45)
  {
    v15 = 1;
    v5 = (int *)v20++;
    v17 = *v5;
  }
  else
  {
    v15 = 0;
    if (v17 == 43)
    {
      v6 = (int *)v20++;
      v17 = *v6;
    }
  }
  if ((!base || base == 16) && v17 == 48 && (*v20 == 120 || *v20 == 88))
  {
    v17 = v20[1];
    v20 += 2;
    base = 16;
  }
  if (!base)
  {
    if (v17 == 48)
      v7 = 8;
    else
      v7 = 10;
    base = v7;
  }
  v14 = 0;
  v19 = 0;
  if (base < 2 || base > 36)
    goto LABEL_51;
  v8 = 0x8000000000000000;
  if (!v15)
    v8 = 0x7FFFFFFFFFFFFFFFLL;
  v13 = v8 % base;
  v16 = v8 / base;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      v18 = v17 - 48;
      goto LABEL_38;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      v18 = v17 - 55;
      goto LABEL_38;
    }
    if (v17 < 97 || v17 > 122)
      break;
    v18 = v17 - 87;
LABEL_38:
    if (v18 >= base)
      break;
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      v14 = -1;
    }
    else
    {
      v14 = 1;
      v19 = v19 * base + v18;
    }
    v9 = (int *)v20++;
    v17 = *v9;
  }
  if (v14 < 0)
  {
    v10 = 0x8000000000000000;
    if (!v15)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    v19 = v10;
    *__error() = 34;
    goto LABEL_54;
  }
  if (!v14)
  {
LABEL_51:
    *__error() = 22;
    goto LABEL_54;
  }
  if (v15)
    v19 = -(uint64_t)v19;
LABEL_54:
  if (endptr)
  {
    if (v14)
      v12 = (__int32 *)(v20 - 1);
    else
      v12 = (__int32 *)nptr;
    *endptr = v12;
  }
  return v19;
}

intmax_t wcstoimax(const __int32 *__nptr, __int32 **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcstoimax_l(__nptr, __endptr, __base, v9);
  else
    return wcstoimax_l(__nptr, __endptr, __base, (locale_t)__global_locale);
}

uint64_t wcstol_l(const __int32 *a1, __int32 **a2, int a3, locale_t a4)
{
  wint_t *v4;
  int *v5;
  int *v6;
  int v7;
  unint64_t v8;
  int *v9;
  unint64_t v10;
  __int32 *v12;
  wint_t v13;
  int v14;
  int v15;
  unint64_t v16;
  int v17;
  wint_t v18;
  unint64_t v19;
  const __int32 *v20;
  _xlocale *v21;

  v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v21 = (_xlocale *)__global_locale;
  }
  else
  {
    v21 = (_xlocale *)&__c_locale;
  }
  v20 = a1;
  do
  {
    v4 = (wint_t *)v20++;
    v17 = *v4;
  }
  while (iswspace_l(*v4, v21));
  if (v17 == 45)
  {
    v15 = 1;
    v5 = (int *)v20++;
    v17 = *v5;
  }
  else
  {
    v15 = 0;
    if (v17 == 43)
    {
      v6 = (int *)v20++;
      v17 = *v6;
    }
  }
  if ((!a3 || a3 == 16) && v17 == 48 && (*v20 == 120 || *v20 == 88))
  {
    v17 = v20[1];
    v20 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v17 == 48)
      v7 = 8;
    else
      v7 = 10;
    a3 = v7;
  }
  v14 = 0;
  v19 = 0;
  if (a3 < 2 || a3 > 36)
    goto LABEL_51;
  v8 = 0x8000000000000000;
  if (!v15)
    v8 = 0x7FFFFFFFFFFFFFFFLL;
  v13 = v8 % a3;
  v16 = v8 / a3;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      v18 = v17 - 48;
      goto LABEL_38;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      v18 = v17 - 55;
      goto LABEL_38;
    }
    if (v17 < 97 || v17 > 122)
      break;
    v18 = v17 - 87;
LABEL_38:
    if (v18 >= a3)
      break;
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      v14 = -1;
    }
    else
    {
      v14 = 1;
      v19 = v19 * a3 + v18;
    }
    v9 = (int *)v20++;
    v17 = *v9;
  }
  if (v14 < 0)
  {
    v10 = 0x8000000000000000;
    if (!v15)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    v19 = v10;
    *__error() = 34;
    goto LABEL_54;
  }
  if (!v14)
  {
LABEL_51:
    *__error() = 22;
    goto LABEL_54;
  }
  if (v15)
    v19 = -(uint64_t)v19;
LABEL_54:
  if (a2)
  {
    if (v14)
      v12 = (__int32 *)(v20 - 1);
    else
      v12 = (__int32 *)a1;
    *a2 = v12;
  }
  return v19;
}

uint64_t wcstol(const __int32 *a1, __int32 **a2, int a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcstol_l(a1, a2, a3, v9);
  else
    return wcstol_l(a1, a2, a3, (locale_t)__global_locale);
}

long double wcstold_l(const __int32 *a1, __int32 **a2, locale_t a3)
{
  char v3;
  char v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  size_t v9;
  _BYTE v11[16];
  wint_t *v12;
  __int32 *v13;
  _BOOL4 v14;
  char *v15;
  _QWORD *v16;
  char *v17;
  int v18;
  wint_t *v19;
  wint_t *v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  locale_t v24;
  size_t v25;
  char *v26;
  const char *v27;
  long double v28;
  _xlocale *v29;
  __int32 **v30;
  wint_t *v31;
  double v32;
  _QWORD *v33;
  uint64_t v34;
  char v35;
  mbstate_t v36;

  v17 = &v35;
  v31 = (wint_t *)a1;
  v30 = a2;
  v29 = a3;
  _platform_memset(&v36, 0, 128);
  v28 = 0.0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  v33 = 0;
  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v33 = pthread_getspecific(__locale_key);
  }
  else
  {
    v5 = v17;
    v34 = __locale_key;
    *(_QWORD *)v17 = __locale_key;
    *((_QWORD *)v5 + 1) = 0;
    *((_QWORD *)v5 + 1) = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v33 = *(_QWORD **)(*((_QWORD *)v5 + 1) + 8 * *(_QWORD *)v5);
  }
  if (v33)
    v16 = v33;
  else
    v16 = __global_locale;
  v6 = (*(_DWORD *)(v16[166] + 64) + 1);
  v22 = v11;
  v15 = &v11[-((v6 + 15) & 0xFFFFFFFFFFFFFFF0)];
  v21 = v6;
  v20 = v31;
  v19 = 0;
  if (v29)
  {
    if (v29 == (_xlocale *)-1)
      v29 = (_xlocale *)__global_locale;
  }
  else
  {
    v29 = (_xlocale *)&__c_locale;
  }
  v24 = (locale_t)__numeric_ctype((uint64_t)v29);
  while (1)
  {
    v7 = iswspace_l(*v31, v24);
    if (!(_DWORD)v7)
      break;
    ++v31;
  }
  v23 = _simple_salloc(v7);
  if (v23)
  {
    v19 = v31;
    j___platform_memmove(&v36, &wcstold_l_initial, 128);
    while (1)
    {
      v8 = *v31 == 0;
      v14 = 0;
      if (!v8)
      {
        v25 = wcrtomb_l(v15, *v31, &v36, v24);
        v14 = v25 != -1;
      }
      if (!v14)
        break;
      v15[v25] = 0;
      if ((int)_simple_sappend(v23) < 0)
      {
        _simple_sfree(v23);
        v32 = 0.0;
        v18 = 1;
        return v32;
      }
      ++v31;
    }
    v27 = (const char *)_simple_string(v23);
    v28 = strtold_l(v27, &v26, v29);
    if (v30)
    {
      if (v26 == v27)
      {
        v13 = v20;
      }
      else
      {
        v12 = v19;
        v9 = __wcs_end_offset(v27, (uint64_t)v26, v29);
        v13 = &v12[v9];
      }
      *v30 = v13;
    }
    _simple_sfree(v23);
    v32 = v28;
    v18 = 1;
  }
  else
  {
    v32 = 0.0;
    v18 = 1;
  }
  return v32;
}

long double wcstold(const __int32 *a1, __int32 **a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return wcstold_l(a1, a2, v7);
  else
    return wcstold_l(a1, a2, (locale_t)__global_locale);
}

uint64_t wcstoll_l(const __int32 *a1, __int32 **a2, int a3, locale_t a4)
{
  wint_t *v4;
  int *v5;
  int *v6;
  int v7;
  unint64_t v8;
  int *v9;
  unint64_t v10;
  __int32 *v12;
  wint_t v13;
  int v14;
  int v15;
  unint64_t v16;
  int v17;
  wint_t v18;
  unint64_t v19;
  const __int32 *v20;
  _xlocale *v21;

  v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v21 = (_xlocale *)__global_locale;
  }
  else
  {
    v21 = (_xlocale *)&__c_locale;
  }
  v20 = a1;
  do
  {
    v4 = (wint_t *)v20++;
    v17 = *v4;
  }
  while (iswspace_l(*v4, v21));
  if (v17 == 45)
  {
    v15 = 1;
    v5 = (int *)v20++;
    v17 = *v5;
  }
  else
  {
    v15 = 0;
    if (v17 == 43)
    {
      v6 = (int *)v20++;
      v17 = *v6;
    }
  }
  if ((!a3 || a3 == 16) && v17 == 48 && (*v20 == 120 || *v20 == 88))
  {
    v17 = v20[1];
    v20 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v17 == 48)
      v7 = 8;
    else
      v7 = 10;
    a3 = v7;
  }
  v14 = 0;
  v19 = 0;
  if (a3 < 2 || a3 > 36)
    goto LABEL_51;
  v8 = 0x8000000000000000;
  if (!v15)
    v8 = 0x7FFFFFFFFFFFFFFFLL;
  v13 = v8 % a3;
  v16 = v8 / a3;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      v18 = v17 - 48;
      goto LABEL_38;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      v18 = v17 - 55;
      goto LABEL_38;
    }
    if (v17 < 97 || v17 > 122)
      break;
    v18 = v17 - 87;
LABEL_38:
    if (v18 >= a3)
      break;
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      v14 = -1;
    }
    else
    {
      v14 = 1;
      v19 = v19 * a3 + v18;
    }
    v9 = (int *)v20++;
    v17 = *v9;
  }
  if (v14 < 0)
  {
    v10 = 0x8000000000000000;
    if (!v15)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    v19 = v10;
    *__error() = 34;
    goto LABEL_54;
  }
  if (!v14)
  {
LABEL_51:
    *__error() = 22;
    goto LABEL_54;
  }
  if (v15)
    v19 = -(uint64_t)v19;
LABEL_54:
  if (a2)
  {
    if (v14)
      v12 = (__int32 *)(v20 - 1);
    else
      v12 = (__int32 *)a1;
    *a2 = v12;
  }
  return v19;
}

uint64_t wcstoll(const __int32 *a1, __int32 **a2, int a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcstoll_l(a1, a2, a3, v9);
  else
    return wcstoll_l(a1, a2, a3, (locale_t)__global_locale);
}

size_t wcstombs_l(char *a1, const __int32 *a2, size_t a3, locale_t a4)
{
  const __int32 *v5;
  locale_t v6;
  size_t v7;
  const __int32 *v8;
  char *v9;
  _BYTE v10[128];

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = a4;
  _platform_memset(v10, 0, 128);
  v5 = 0;
  if (v6)
  {
    if (v6 == (locale_t)-1)
      v6 = (locale_t)&__global_locale;
  }
  else
  {
    v6 = (locale_t)&__c_locale;
  }
  j___platform_memmove(v10, &wcstombs_l_initial, 128);
  v5 = v8;
  return (*(uint64_t (**)(char *, const __int32 **, uint64_t, size_t, _BYTE *, locale_t))(*((_QWORD *)v6 + 166)
                                                                                                 + 104))(v9, &v5, -1, v7, v10, v6);
}

size_t wcstombs(char *a1, const __int32 *a2, size_t a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcstombs_l(a1, a2, a3, v9);
  else
    return wcstombs_l(a1, a2, a3, (locale_t)__global_locale);
}

unint64_t wcstoul_l(const __int32 *a1, __int32 **a2, int a3, locale_t a4)
{
  wint_t *v4;
  int *v5;
  int *v6;
  int v7;
  int *v8;
  __int32 *v10;
  int v11;
  int v12;
  unint64_t v13;
  int v14;
  wint_t v15;
  unint64_t v16;
  const __int32 *v17;
  _xlocale *v18;

  v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v18 = (_xlocale *)__global_locale;
  }
  else
  {
    v18 = (_xlocale *)&__c_locale;
  }
  v17 = a1;
  do
  {
    v4 = (wint_t *)v17++;
    v14 = *v4;
  }
  while (iswspace_l(*v4, v18));
  if (v14 == 45)
  {
    v12 = 1;
    v5 = (int *)v17++;
    v14 = *v5;
  }
  else
  {
    v12 = 0;
    if (v14 == 43)
    {
      v6 = (int *)v17++;
      v14 = *v6;
    }
  }
  if ((!a3 || a3 == 16) && v14 == 48 && (*v17 == 120 || *v17 == 88))
  {
    v14 = v17[1];
    v17 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v14 == 48)
      v7 = 8;
    else
      v7 = 10;
    a3 = v7;
  }
  v11 = 0;
  v16 = 0;
  if (a3 < 2 || a3 > 36)
    goto LABEL_47;
  v13 = 0xFFFFFFFFFFFFFFFFLL / a3;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      v15 = v14 - 48;
      goto LABEL_36;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      v15 = v14 - 55;
      goto LABEL_36;
    }
    if (v14 < 97 || v14 > 122)
      break;
    v15 = v14 - 87;
LABEL_36:
    if (v15 >= a3)
      break;
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % a3))
    {
      v11 = -1;
    }
    else
    {
      v11 = 1;
      v16 = v16 * a3 + v15;
    }
    v8 = (int *)v17++;
    v14 = *v8;
  }
  if (v11 < 0)
  {
    v16 = -1;
    *__error() = 34;
    goto LABEL_50;
  }
  if (v11)
  {
    if (v12)
      v16 = -(uint64_t)v16;
  }
  else
  {
LABEL_47:
    *__error() = 22;
  }
LABEL_50:
  if (a2)
  {
    if (v11)
      v10 = (__int32 *)(v17 - 1);
    else
      v10 = (__int32 *)a1;
    *a2 = v10;
  }
  return v16;
}

unint64_t wcstoul(const __int32 *a1, __int32 **a2, int a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcstoul_l(a1, a2, a3, v9);
  else
    return wcstoul_l(a1, a2, a3, (locale_t)__global_locale);
}

unint64_t wcstoull_l(const __int32 *a1, __int32 **a2, int a3, locale_t a4)
{
  wint_t *v4;
  int *v5;
  int *v6;
  int v7;
  int *v8;
  __int32 *v10;
  int v11;
  int v12;
  unint64_t v13;
  int v14;
  wint_t v15;
  unint64_t v16;
  const __int32 *v17;
  _xlocale *v18;

  v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v18 = (_xlocale *)__global_locale;
  }
  else
  {
    v18 = (_xlocale *)&__c_locale;
  }
  v17 = a1;
  do
  {
    v4 = (wint_t *)v17++;
    v14 = *v4;
  }
  while (iswspace_l(*v4, v18));
  if (v14 == 45)
  {
    v12 = 1;
    v5 = (int *)v17++;
    v14 = *v5;
  }
  else
  {
    v12 = 0;
    if (v14 == 43)
    {
      v6 = (int *)v17++;
      v14 = *v6;
    }
  }
  if ((!a3 || a3 == 16) && v14 == 48 && (*v17 == 120 || *v17 == 88))
  {
    v14 = v17[1];
    v17 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v14 == 48)
      v7 = 8;
    else
      v7 = 10;
    a3 = v7;
  }
  v11 = 0;
  v16 = 0;
  if (a3 < 2 || a3 > 36)
    goto LABEL_47;
  v13 = 0xFFFFFFFFFFFFFFFFLL / a3;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      v15 = v14 - 48;
      goto LABEL_36;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      v15 = v14 - 55;
      goto LABEL_36;
    }
    if (v14 < 97 || v14 > 122)
      break;
    v15 = v14 - 87;
LABEL_36:
    if (v15 >= a3)
      break;
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % a3))
    {
      v11 = -1;
    }
    else
    {
      v11 = 1;
      v16 = v16 * a3 + v15;
    }
    v8 = (int *)v17++;
    v14 = *v8;
  }
  if (v11 < 0)
  {
    v16 = -1;
    *__error() = 34;
    goto LABEL_50;
  }
  if (v11)
  {
    if (v12)
      v16 = -(uint64_t)v16;
  }
  else
  {
LABEL_47:
    *__error() = 22;
  }
LABEL_50:
  if (a2)
  {
    if (v11)
      v10 = (__int32 *)(v17 - 1);
    else
      v10 = (__int32 *)a1;
    *a2 = v10;
  }
  return v16;
}

unint64_t wcstoull(const __int32 *a1, __int32 **a2, int a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcstoull_l(a1, a2, a3, v9);
  else
    return wcstoull_l(a1, a2, a3, (locale_t)__global_locale);
}

uintmax_t wcstoumax_l(const __int32 *nptr, __int32 **endptr, int base, locale_t a4)
{
  wint_t *v4;
  int *v5;
  int *v6;
  int v7;
  int *v8;
  __int32 *v10;
  int v11;
  int v12;
  unint64_t v13;
  int v14;
  wint_t v15;
  uintmax_t v16;
  const __int32 *v17;
  _xlocale *v18;

  v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v18 = (_xlocale *)__global_locale;
  }
  else
  {
    v18 = (_xlocale *)&__c_locale;
  }
  v17 = nptr;
  do
  {
    v4 = (wint_t *)v17++;
    v14 = *v4;
  }
  while (iswspace_l(*v4, v18));
  if (v14 == 45)
  {
    v12 = 1;
    v5 = (int *)v17++;
    v14 = *v5;
  }
  else
  {
    v12 = 0;
    if (v14 == 43)
    {
      v6 = (int *)v17++;
      v14 = *v6;
    }
  }
  if ((!base || base == 16) && v14 == 48 && (*v17 == 120 || *v17 == 88))
  {
    v14 = v17[1];
    v17 += 2;
    base = 16;
  }
  if (!base)
  {
    if (v14 == 48)
      v7 = 8;
    else
      v7 = 10;
    base = v7;
  }
  v11 = 0;
  v16 = 0;
  if (base < 2 || base > 36)
    goto LABEL_47;
  v13 = 0xFFFFFFFFFFFFFFFFLL / base;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      v15 = v14 - 48;
      goto LABEL_36;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      v15 = v14 - 55;
      goto LABEL_36;
    }
    if (v14 < 97 || v14 > 122)
      break;
    v15 = v14 - 87;
LABEL_36:
    if (v15 >= base)
      break;
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % base))
    {
      v11 = -1;
    }
    else
    {
      v11 = 1;
      v16 = v16 * base + v15;
    }
    v8 = (int *)v17++;
    v14 = *v8;
  }
  if (v11 < 0)
  {
    v16 = -1;
    *__error() = 34;
    goto LABEL_50;
  }
  if (v11)
  {
    if (v12)
      v16 = -(uint64_t)v16;
  }
  else
  {
LABEL_47:
    *__error() = 22;
  }
LABEL_50:
  if (endptr)
  {
    if (v11)
      v10 = (__int32 *)(v17 - 1);
    else
      v10 = (__int32 *)nptr;
    *endptr = v10;
  }
  return v16;
}

uintmax_t wcstoumax(const __int32 *__nptr, __int32 **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcstoumax_l(__nptr, __endptr, __base, v9);
  else
    return wcstoumax_l(__nptr, __endptr, __base, (locale_t)__global_locale);
}

int wctob_l(wint_t a1, locale_t a2)
{
  _BYTE v3[6];
  locale_t v4;
  unsigned int v5;
  _BYTE v7[128];

  v5 = a1;
  v4 = a2;
  _platform_memset(v7, 0, 128);
  j___platform_memmove(v7, &wctob_l_initial, 128);
  if (v4)
  {
    if (v4 == (locale_t)-1)
      v4 = (locale_t)&__global_locale;
  }
  else
  {
    v4 = (locale_t)&__c_locale;
  }
  if (v5 != -1
    && (*(uint64_t (**)(_BYTE *, _QWORD, _BYTE *, locale_t))(*((_QWORD *)v4 + 166) + 96))(v3, v5, v7, v4) == 1)
  {
    return v3[0];
  }
  else
  {
    return -1;
  }
}

int wctob(wint_t a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return wctob_l(a1, v5);
  else
    return wctob_l(a1, (locale_t)__global_locale);
}

int wctomb_l(char *a1, __int32 a2, locale_t a3)
{
  uint64_t v4;
  locale_t v5;

  v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v5 = (locale_t)&__global_locale;
  }
  else
  {
    v5 = (locale_t)&__c_locale;
  }
  if (a1)
  {
    v4 = (*(uint64_t (**)(char *, _QWORD, uint64_t, locale_t))(*((_QWORD *)v5 + 166) + 96))(a1, a2, (uint64_t)v5 + 1168, v5);
    if (v4 == -1)
      return -1;
    else
      return v4;
  }
  else
  {
    j___platform_memmove((char *)v5 + 1168, &wctomb_l_initial, 128);
    return 0;
  }
}

int wctomb(char *a1, __int32 a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return wctomb_l(a1, a2, v7);
  else
    return wctomb_l(a1, a2, (locale_t)__global_locale);
}

wint_t towctrans_l(wint_t a1, wctrans_t a2, locale_t a3)
{
  _xlocale *v4;
  wint_t v5;

  v5 = a1;
  v4 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v4 = (_xlocale *)__global_locale;
  }
  else
  {
    v4 = (_xlocale *)&__c_locale;
  }
  if (!a2)
    goto LABEL_11;
  if (a2 == 1)
    return towlower_l(a1, v4);
  if (a2 != 2)
  {
LABEL_11:
    *__error() = 22;
    return v5;
  }
  return towupper_l(a1, v4);
}

wint_t towctrans(wint_t a1, wctrans_t a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return towctrans_l(a1, a2, v7);
  else
    return towctrans_l(a1, a2, (locale_t)__global_locale);
}

wctrans_t wctrans(const char *a1)
{
  BOOL v2;
  int i;
  _QWORD v5[6];

  j___platform_memmove(v5, &off_D8D28, 48);
  for (i = 0; ; ++i)
  {
    v2 = 0;
    if (v5[2 * i])
      v2 = _platform_strcmp(v5[2 * i], a1) != 0;
    if (!v2)
      break;
  }
  if (!LODWORD(v5[2 * i + 1]))
    *__error() = 22;
  return v5[2 * i + 1];
}

wctrans_t wctrans_l(const char *a1, locale_t a2)
{
  return wctrans(a1);
}

wctype_t wctype_l(const char *a1, locale_t a2)
{
  int v2;
  BOOL v4;
  uint64_t j;
  int i;
  int v7;
  uint64_t v8;

  for (i = 0; ; ++i)
  {
    v4 = 0;
    if ((&wctype_l_props)[2 * i])
      v4 = _platform_strcmp((&wctype_l_props)[2 * i], a1) != 0;
    if (!v4)
      break;
  }
  if (LODWORD((&wctype_l_props)[2 * i + 1]))
    return (wctype_t)(&wctype_l_props)[2 * i + 1];
  if (a2)
  {
    if (a2 == (locale_t)-1)
      a2 = (locale_t)&__global_locale;
  }
  else
  {
    a2 = (locale_t)&__c_locale;
  }
  v8 = *(_QWORD *)(*((_QWORD *)a2 + 166) + 120);
  v7 = *(_DWORD *)(v8 + 3196);
  if (v7 > 0)
  {
    for (j = *(_QWORD *)(v8 + 3200); ; j += 20)
    {
      v2 = v7--;
      if (v2 <= 0)
        break;
      if (!_platform_strncmp(j, a1, 14))
        return *(_DWORD *)(j + 16);
    }
  }
  return 0;
}

wctype_t wctype(const char *a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return wctype_l(a1, v5);
  else
    return wctype_l(a1, (locale_t)__global_locale);
}

int wcwidth(__int32 a1)
{
  char v1;
  char v2;
  _QWORD *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return __wcwidth_l(a1, v5);
  else
    return __wcwidth_l(a1, __global_locale);
}

int wcwidth_l(__int32 a1, locale_t a2)
{
  locale_t v3;

  v3 = a2;
  if (!a2)
    return __wcwidth_l(a1, __c_locale);
  if (a2 == (locale_t)-1)
    v3 = (locale_t)__global_locale;
  return __wcwidth_l(a1, v3);
}

FILE *__cdecl open_memstream(char **__bufp, size_t *__sizep)
{
  FILE *v3;
  uint64_t v4;
  int v5;
  char ***v6;

  if (__bufp && __sizep)
  {
    *__bufp = (char *)malloc_type_calloc(1, 1, 2178562898);
    if (*__bufp)
    {
      v6 = (char ***)malloc_type_malloc(32, 0x10900405C4C9827);
      if (v6)
      {
        *v6 = __bufp;
        v6[1] = (char **)__sizep;
        v6[2] = 0;
        v6[3] = 0;
        memstream_update((uint64_t)v6);
        v3 = funopen(v6, 0, (int (__cdecl *)(void *, const char *, int))memstream_write, (fpos_t (__cdecl *)(void *, fpos_t, int))memstream_seek, (int (__cdecl *)(void *))memstream_close);
        if (v3)
        {
          fwide(v3, -1);
          return v3;
        }
        else
        {
          v5 = *__error();
          free(v6);
          free(*__bufp);
          *__bufp = 0;
          *__error() = v5;
          return 0;
        }
      }
      else
      {
        v4 = *__error();
        free(*__bufp);
        *__bufp = 0;
        *__error() = v4;
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

uint64_t memstream_update(uint64_t result)
{
  uint64_t v1;
  BOOL v2;

  v2 = 0;
  if (*(uint64_t *)(result + 16) >= 0)
    v2 = *(_QWORD *)(result + 24) >= 0;
  if (!v2)
    __assert_rtn("memstream_update", "open_memstream.c", 96, "ms->len >= 0 && ms->offset >= 0");
  if (*(_QWORD *)(result + 16) >= *(_QWORD *)(result + 24))
    v1 = *(_QWORD *)(result + 24);
  else
    v1 = *(_QWORD *)(result + 16);
  **(_QWORD **)(result + 8) = v1;
  return result;
}

uint64_t memstream_write(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t v4;

  if (memstream_grow(a1, a1[3] + a3))
  {
    v4 = a1[2] - a1[3];
    if (a3 < v4)
      v4 = a3;
    j___platform_memmove(*(_QWORD *)*a1 + a1[3], a2, v4);
    a1[3] += v4;
    memstream_update((uint64_t)a1);
    fprintf(__stderrp, "MS: write(%p, %d) = %zd\n", a1, a3, v4);
    return v4;
  }
  else
  {
    return -1;
  }
}

uint64_t memstream_seek(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t v4;

  v4 = a1[3];
  if (!a3)
  {
    if (a2 < 0)
      __assert_rtn("memstream_seek", "open_memstream.c", 136, "pos >= 0");
    a1[3] = a2;
    goto LABEL_18;
  }
  if (a3 == 1)
  {
    if (a2)
      __assert_rtn("memstream_seek", "open_memstream.c", 141, "pos == 0");
    goto LABEL_18;
  }
  if (a3 != 2)
  {
LABEL_18:
    memstream_update((uint64_t)a1);
    fprintf(__stderrp, "MS: seek(%p, %jd, %d) %jd -> %jd\n", a1, a2, a3, v4, a1[3]);
    return a1[3];
  }
  if (a2 >= 0)
  {
    if (0x7FFFFFFFFFFFFFFFLL - a1[2] < a2)
    {
      fprintf(__stderrp, "MS: bad SEEK_END: pos %jd, len %zd\n", a2, a1[2]);
      *__error() = 84;
      return -1;
    }
LABEL_17:
    a1[3] = a1[2] + a2;
    goto LABEL_18;
  }
  if (a2 + a1[2] >= 0)
    goto LABEL_17;
  fprintf(__stderrp, "MS: bad SEEK_END: pos %jd, len %zd\n", a2, a1[2]);
  *__error() = 22;
  return -1;
}

uint64_t memstream_close(void *a1)
{
  free(a1);
  return 0;
}

uint64_t memstream_grow(_QWORD *a1, unint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (a2 <= 0x7FFFFFFFFFFFFFFELL)
    v6 = a2;
  else
    v6 = 0x7FFFFFFFFFFFFFFELL;
  if (v6 <= a1[2])
  {
    return 1;
  }
  else
  {
    v2 = a1[2];
    if ((unsigned __int128)(v2 * (__int128)15) >> 64 == (15 * v2) >> 63)
      v5 = 15 * v2 / 10;
    else
      v5 = 0x7FFFFFFFFFFFFFFELL;
    if (v5 <= v6)
      v4 = v6;
    else
      v4 = v5;
    v7 = malloc_type_realloc(*(_QWORD *)*a1, v4 + 1, 4255314169);
    if (v7)
    {
      fprintf(__stderrp, "MS: %p growing from %zd to %zd\n", a1, a1[2], v4);
      _platform_bzero(v7 + a1[2] + 1, v4 - a1[2]);
      *(_QWORD *)*a1 = v7;
      a1[2] = v4;
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

void link_addr(const char *a1, sockaddr_dl *a2)
{
  char *v2;
  unsigned int v3;
  char *v4;
  char *sdl_data;

  sdl_data = a2->sdl_data;
  v4 = (char *)(&a2->sdl_len + a2->sdl_len);
  v3 = 0;
  _platform_bzero(&a2->sdl_family, a2->sdl_len - 1);
  a2->sdl_family = 18;
  do
  {
    if ((*a1 < 48 || *a1 > 57) && (*a1 < 97 || *a1 > 102) && (*a1 < 65 || *a1 > 70))
    {
      if (*a1)
      {
        if (v3 || (*a1 < 65 || *a1 > 90) && (*a1 < 97 || *a1 > 122))
          v3 |= 8u;
        else
          v3 = 12;
      }
      else
      {
        v3 |= 4u;
      }
    }
    ++a1;
    if (v3 <= 0xCuLL)
      __asm { BR              X8 }
    v3 = 3;
    v2 = sdl_data++;
    *v2 = 0;
  }
  while (sdl_data < v4);
  a2->sdl_alen = (_BYTE)sdl_data - ((_BYTE)a2 + 8 + a2->sdl_nlen);
  if ((unint64_t)((int)sdl_data - (int)a2) > 0x14)
    a2->sdl_len = (_BYTE)sdl_data - (_BYTE)a2;
}

char *__cdecl link_ntoa(const sockaddr_dl *a1)
{
  char *v1;
  char *v2;
  char *v3;
  int v5;
  char *v6;
  char *v7;
  int v8;
  char *v9;

  v9 = link_ntoa_obuf;
  v7 = &a1->sdl_data[a1->sdl_nlen];
  v6 = &v7[a1->sdl_alen];
  v5 = 1;
  if ((unint64_t)(a1->sdl_nlen + 3 * a1->sdl_alen) < 0x40)
  {
    if (a1->sdl_nlen)
    {
      bcopy(a1->sdl_data, link_ntoa_obuf, a1->sdl_nlen);
      v9 = &link_ntoa_obuf[a1->sdl_nlen];
      if (a1->sdl_alen)
      {
        ++v9;
        link_ntoa_obuf[a1->sdl_nlen] = 58;
      }
    }
    while (v7 < v6)
    {
      if (v5)
      {
        v5 = 0;
      }
      else
      {
        v1 = v9++;
        *v1 = 46;
      }
      v2 = v7++;
      v8 = *v2;
      if (v8 <= 0xF)
      {
        v3 = v9++;
        *v3 = hexlist[*v2];
      }
      else
      {
        v9[1] = hexlist[v8 & 0xF];
        *v9 = hexlist[v8 >> 4];
        v9 += 2;
      }
    }
  }
  *v9 = 0;
  return link_ntoa_obuf;
}

uint64_t recv_NOCANCEL(unsigned int a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  return __recvfrom_nocancel(a1, a2, a3, a4, 0);
}

uint64_t send_NOCANCEL(unsigned int a1, uint64_t a2, uint64_t a3, unsigned int a4)
{
  return __sendto_nocancel(a1, a2, a3, a4, 0, 0);
}

int sockatmark(int a1)
{
  _DWORD v2[2];

  v2[1] = a1;
  v2[0] = 0;
  if (ioctl(a1, 0x40047307uLL, v2) == -1)
    return -1;
  else
    return v2[0];
}

nl_catd catopen(const char *a1, int a2)
{
  char *v2;
  char *v3;
  char v4;
  char *v5;
  unint64_t v6;
  uint64_t v7;
  char v8;
  char *v9;
  int v11;
  int v12;
  stat v13;
  char *v14;
  char *v15;
  void *v16;
  char *v17;
  const char *v18;
  char *v19;
  char *__stringp;
  void *v21;
  char *__s1;
  char *v23;
  int v24;
  int v25;
  int v26;
  const char *v27;
  char v29[1024];

  v27 = a1;
  v26 = a2;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  __s1 = 0;
  v21 = 0;
  __stringp = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  _platform_memset(&v13, 0, 144);
  if (v27 && *v27)
  {
    if (_platform_strchr(v27, 47))
      return (nl_catd)loadCat(v27);
    if (v26 == 1)
      __s1 = (char *)querylocale(4, 0);
    else
      __s1 = getenv("LANG");
    if (!__s1
      || !*__s1
      || (unint64_t)_platform_strlen(__s1) > 0x1F
      || *__s1 == 46 && (!__s1[1] || __s1[1] == 46 && !__s1[2])
      || _platform_strchr(__s1, 47))
    {
      __s1 = "C";
    }
    v17 = strdup(__s1);
    v16 = v17;
    if (!v17)
      return (nl_catd)-1;
    __stringp = (char *)_platform_strchr(v17, 64);
    if (__stringp)
      *__stringp = 0;
    v14 = (char *)&unk_D495D;
    v15 = (char *)&unk_D495D;
    __stringp = (char *)_platform_strchr(v17, 95);
    if (__stringp)
    {
      v2 = __stringp++;
      *v2 = 0;
      v17 = __stringp;
      v15 = __stringp;
    }
    __stringp = (char *)_platform_strchr(v17, 46);
    if (__stringp)
    {
      v3 = __stringp++;
      *v3 = 0;
      v14 = __stringp;
    }
    v23 = getenv("NLSPATH");
    if (!v23 || issetugid())
      v23 = "/usr/share/nls/%L/%N.cat:/usr/share/nls/%N/%L:/usr/local/share/nls/%L/%N.cat:/usr/local/share/nls/%N/%L";
    __stringp = strdup(v23);
    v21 = __stringp;
    if (!__stringp)
    {
      v24 = *__error();
      free(v16);
      v12 = v24;
      *__error() = v12;
      return (nl_catd)-1;
    }
    while (1)
    {
      v23 = strsep(&__stringp, ":");
      if (!v23)
      {
        free(v16);
        free(v21);
        *__error() = 2;
        return (nl_catd)-1;
      }
      v19 = v29;
      if (!*v23)
        break;
      while (*v23)
      {
        if (*v23 == 37)
        {
          v11 = v23[1];
          switch(v11)
          {
            case '%':
              ++v23;
LABEL_48:
              if ((unint64_t)(v19 - v29) >= 0x3FF)
                goto LABEL_52;
              v4 = *v23;
              v5 = v19++;
              *v5 = v4;
              goto LABEL_56;
            case 'L':
              v18 = __s1;
              break;
            case 'N':
              v18 = v27;
              break;
            case 'c':
              v18 = v14;
              break;
            case 'l':
              v18 = (const char *)v16;
              break;
            case 't':
              v18 = v15;
              break;
            default:
              goto LABEL_48;
          }
          ++v23;
          goto LABEL_51;
        }
        if ((unint64_t)(v19 - v29) >= 0x3FF)
        {
LABEL_52:
          free(v16);
          free(v21);
          *__error() = 63;
          return (nl_catd)-1;
        }
        v8 = *v23;
        v9 = v19++;
        *v9 = v8;
LABEL_56:
        ++v23;
      }
      *v19 = 0;
      if (!stat(v29, &v13))
      {
        free(v16);
        free(v21);
        return (nl_catd)loadCat(v29);
      }
    }
    v18 = v27;
    --v23;
LABEL_51:
    v25 = 1023 - (v19 - v29);
    v6 = _platform_strlcpy(v19, v18, v25);
    if (v6 >= v25)
      goto LABEL_52;
    v7 = _platform_strlen(v18);
    v19 += v7;
    goto LABEL_56;
  }
  *__error() = 22;
  return (nl_catd)-1;
}

uint64_t loadCat(const char *a1)
{
  FILE *v1;
  uint64_t v2;
  int v4;
  FILE *v5;
  const char *v6;
  int v7;
  FILE *v8;
  const char *v9;
  unsigned int v10;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  off_t v15;
  int i;
  uint64_t v17;
  FILE **v18;
  __int128 v21;
  __int128 v22;

  v21 = 0u;
  v22 = 0u;
  v18 = (FILE **)malloc_type_malloc(32, 0x1020040DE3E3027);
  if (!v18)
    return -1;
  v11 = open_NOCANCEL(a1, 0x1000000);
  if (v11 == -1)
  {
    v12 = *__error();
    free(v18);
    *__error() = v12;
    return -1;
  }
  else
  {
    v1 = fdopen(v11, "r");
    *v18 = v1;
    if (v1)
    {
      if (fread(&v21, 0x20uLL, 1uLL, *v18) == 1 && !_platform_strncmp(&v21, "*nazgul*", 8))
      {
        if (_OSSwapInt32(DWORD2(v21)) == 1)
        {
          if (_OSSwapInt32(DWORD1(v22)))
          {
            *((_DWORD *)v18 + 2) = _OSSwapInt32(DWORD1(v22));
            v2 = malloc_type_malloc(40 * *((int *)v18 + 2), 0x10B2040D468A13DLL);
            v18[2] = (FILE *)v2;
            if (v2)
            {
              v15 = _OSSwapInt64(*((unint64_t *)&v22 + 1));
              for (i = 0; i < *((_DWORD *)v18 + 2); ++i)
              {
                if (fseeko(*v18, v15, 0) == -1
                  || (v17 = (uint64_t)v18[2] + 40 * i, fread((void *)v17, 0x28uLL, 1uLL, *v18) != 1))
                {
                  __nls_free_resources((uint64_t)v18, i);
                  fclose(*v18);
                  fprintf(__stderrp, "%s: corrupt file.", _errowner);
                  free(v18);
                  *__error() = 79;
                  return -1;
                }
                if (*(_DWORD *)(v17 + 36))
                  --i;
                else
                  *(_DWORD *)(v17 + 36) = 1;
                v15 = _OSSwapInt64(*(_QWORD *)(v17 + 4));
              }
              return (uint64_t)v18;
            }
            else
            {
              v14 = *__error();
              fclose(*v18);
              fprintf(__stderrp, "%s: no more memory.", _errowner);
              free(v18);
              *__error() = v14;
              return -1;
            }
          }
          else
          {
            fclose(*v18);
            free(v18);
            v5 = __stderrp;
            v6 = _errowner;
            v4 = _OSSwapInt32(DWORD1(v22));
            fprintf(v5, "%s: %s has %d sets!\n", v6, a1, v4);
            *__error() = 79;
            return -1;
          }
        }
        else
        {
          fclose(*v18);
          free(v18);
          v10 = _OSSwapInt32(DWORD2(v21));
          if (_OSSwapInt32(v10) == 1)
          {
            fprintf(__stderrp, "%s: %s is the wrong byte ordering.\n", _errowner, a1);
          }
          else
          {
            v8 = __stderrp;
            v9 = _errowner;
            v7 = _OSSwapInt32(DWORD2(v21));
            fprintf(v8, "%s: %s is version %d, we need %d.\n", v9, a1, v7, 1);
          }
          *__error() = 79;
          return -1;
        }
      }
      else
      {
        fclose(*v18);
        fprintf(__stderrp, "%s: corrupt file.", _errowner);
        free(v18);
        *__error() = 79;
        return -1;
      }
    }
    else
    {
      v13 = *__error();
      close_NOCANCEL(v11);
      free(v18);
      *__error() = v13;
      return -1;
    }
  }
}

char *__cdecl catgets(nl_catd a1, int a2, int a3, const char *a4)
{
  unsigned int *v4;
  unsigned int *v7;

  if (!a1 || a1 == (nl_catd)-1)
    return (char *)a4;
  v4 = MCGetSet((uint64_t)a1, a2);
  v7 = MCGetMsg((uint64_t)v4, a3);
  if (v7)
    return *(char **)(v7 + 1);
  else
    return (char *)a4;
}

unsigned int *MCGetMsg(uint64_t a1, int a2)
{
  int v3;
  int v4;
  signed int v5;
  signed int v6;
  unsigned int *v7;

  if (!a1 || *(_DWORD *)(a1 + 36) || a2 <= 0)
    return 0;
  v6 = 0;
  if (a2 - 1 >= _OSSwapInt32(*(_DWORD *)(a1 + 32)))
  {
    v5 = _OSSwapInt32(*(_DWORD *)(a1 + 32));
    v4 = v5 / 2;
  }
  else
  {
    v4 = a2 - 1;
    v5 = a2;
  }
  while (1)
  {
    v7 = (unsigned int *)(*(_QWORD *)(a1 + 12) + 16 * v4);
    if (_OSSwapInt32(*v7) == a2)
      return v7;
    if (_OSSwapInt32(*v7) >= a2)
    {
      v5 = v4;
      v3 = -1;
    }
    else
    {
      v6 = v4 + 1;
      if (v5 > v4 + a2 - _OSSwapInt32(*v7) + 1)
        v5 = v4 + a2 - _OSSwapInt32(*v7) + 1;
      v3 = 1;
    }
    if (v6 >= v5)
      break;
    if (v5 - v6 == 1)
      v4 += v3;
    else
      v4 += (v5 - v6) / 2 * v3;
  }
  return 0;
}

unsigned int *MCGetSet(uint64_t a1, int a2)
{
  int v3;
  int v4;
  signed int v5;
  signed int v6;
  unsigned int *v7;

  if (!a1 || a2 <= 0)
    return 0;
  v6 = 0;
  if (a2 - 1 >= *(_DWORD *)(a1 + 8))
  {
    v5 = *(_DWORD *)(a1 + 8);
    v4 = v5 / 2;
  }
  else
  {
    v4 = a2 - 1;
    v5 = a2;
  }
  while (1)
  {
    v7 = (unsigned int *)(*(_QWORD *)(a1 + 16) + 40 * v4);
    if (_OSSwapInt32(*v7) == a2)
      break;
    if (_OSSwapInt32(*v7) >= a2)
    {
      v5 = v4;
      v3 = -1;
    }
    else
    {
      v6 = v4 + 1;
      if (v5 > v4 + a2 - _OSSwapInt32(*v7) + 1)
        v5 = v4 + a2 - _OSSwapInt32(*v7) + 1;
      v3 = 1;
    }
    if (v6 >= v5)
      return 0;
    if (v5 - v6 == 1)
      v4 += v3;
    else
      v4 += (v5 - v6) / 2 * v3;
  }
  if (v7[9] && (int)loadSet((FILE **)a1, (uint64_t)v7) <= 0)
    return 0;
  else
    return v7;
}

int catclose(nl_catd a1)
{
  if (a1 && a1 != (nl_catd)-1)
  {
    fclose((FILE *)a1->__data);
    __nls_free_resources((uint64_t)a1, a1->__size);
    free(a1);
    return 0;
  }
  else
  {
    *__error() = 9;
    return -1;
  }
}

void __nls_free_resources(uint64_t a1, int a2)
{
  int i;
  uint64_t v3;

  for (i = 0; i < a2; ++i)
  {
    v3 = *(_QWORD *)(a1 + 16) + 40 * i;
    if (!*(_DWORD *)(v3 + 36))
    {
      free(*(void **)(v3 + 20));
      free(*(void **)(v3 + 12));
    }
  }
  free(*(void **)(a1 + 16));
}

uint64_t loadSet(FILE **a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  unsigned int v6;
  unint64_t __offseta;
  FILE *__stream;
  unsigned int v9;
  void *v10;
  unsigned int v11;
  off_t v12;
  FILE *v13;
  int v14;
  int v15;
  int v16;
  unsigned int i;
  uint64_t v18;

  v13 = *a1;
  v12 = _OSSwapInt64(*(_QWORD *)(a2 + 20));
  if (fseeko(v13, v12, 0) == -1)
  {
    return 0;
  }
  else
  {
    v11 = _OSSwapInt32(*(_DWORD *)(a2 + 28));
    v2 = malloc_type_malloc(v11, 877879142);
    *(_QWORD *)(a2 + 20) = v2;
    if (v2)
    {
      v10 = *(void **)(a2 + 20);
      v9 = _OSSwapInt32(*(_DWORD *)(a2 + 28));
      if (fread(v10, v9, 1uLL, *a1) != 1
        || (__stream = *a1, __offseta = _OSSwapInt64(*(_QWORD *)(a2 + 12)), fseeko(__stream, __offseta, 0) == -1))
      {
        v14 = *__error();
        free(*(void **)(a2 + 20));
        *__error() = v14;
        return 0;
      }
      else
      {
        v6 = _OSSwapInt32(*(_DWORD *)(a2 + 32));
        v3 = malloc_type_malloc(16 * v6, 0x10B2040ACE959A4);
        *(_QWORD *)(a2 + 12) = v3;
        if (v3)
        {
          for (i = 0; i < _OSSwapInt32(*(_DWORD *)(a2 + 32)); ++i)
          {
            v18 = *(_QWORD *)(a2 + 12) + 16 * (int)i;
            if (fread((void *)v18, 0x10uLL, 1uLL, *a1) != 1)
            {
              v16 = *__error();
              free(*(void **)(a2 + 12));
              free(*(void **)(a2 + 20));
              *__error() = v16;
              return 0;
            }
            if (*(_DWORD *)(v18 + 12))
            {
              --i;
            }
            else
            {
              v5 = *(_QWORD *)(a2 + 20);
              *(_QWORD *)(v18 + 4) = v5 + _OSSwapInt64(*(_QWORD *)(v18 + 4));
            }
          }
          *(_DWORD *)(a2 + 36) = 0;
          return 1;
        }
        else
        {
          v15 = *__error();
          free(*(void **)(a2 + 20));
          *__error() = v15;
          return -1;
        }
      }
    }
    else
    {
      return -1;
    }
  }
}

unint64_t _OSSwapInt64(unint64_t a1)
{
  return bswap64(a1);
}

void flockfile(FILE *a1)
{
  int v1;

  v1 = *__error();
  pthread_mutex_lock((pthread_mutex_t *)((char *)a1->_extra + 8));
  *__error() = v1;
}

void _flockfile_debug_stub(FILE *a1)
{
  flockfile(a1);
}

int ftrylockfile(FILE *a1)
{
  int v2;
  int v3;

  v3 = 0;
  v2 = *__error();
  if (pthread_mutex_trylock((pthread_mutex_t *)((char *)a1->_extra + 8)))
    v3 = -1;
  *__error() = v2;
  return v3;
}

void funlockfile(FILE *a1)
{
  int v1;

  v1 = *__error();
  pthread_mutex_unlock((pthread_mutex_t *)((char *)a1->_extra + 8));
  *__error() = v1;
}

int asprintf(char **a1, const char *a2, ...)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return vasprintf_l(a1, v7, a2, va);
  else
    return vasprintf_l(a1, (locale_t)&__global_locale, a2, va);
}

int asprintf_l(char **a1, locale_t a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return vasprintf_l(a1, a2, a3, va);
}

void clearerr(FILE *a1)
{
  flockfile(a1);
  a1->_flags &= 0xFF9Fu;
  funlockfile(a1);
}

uint64_t clearerr_unlocked(uint64_t result)
{
  *(_WORD *)(result + 16) &= 0xFF9Fu;
  return result;
}

int dprintf(int a1, const char *a2, ...)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return vdprintf_l(a1, v7, a2, va);
  else
    return vdprintf_l(a1, (locale_t)__global_locale, a2, va);
}

int dprintf_l(int a1, locale_t a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return vdprintf_l(a1, a2, a3, va);
}

int fclose(FILE *a1)
{
  int v2;
  int v3;

  v2 = 0;
  libc_hooks_will_write((uint64_t)a1, 152);
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  if (a1)
  {
    if (a1->_flags)
    {
      flockfile(a1);
      v3 = __sflush((uint64_t)a1);
      if (v3 < 0)
        v2 = *__error();
      if (a1->_close && ((int (*)(void *))a1->_close)(a1->_cookie) < 0)
      {
        v3 = -1;
        v2 = *__error();
      }
      if ((a1->_flags & 0x80u) != 0)
        free(a1->_bf._base);
      if (a1->_ub._base)
      {
        if (a1->_ub._base != a1->_ubuf)
          free(a1->_ub._base);
        a1->_ub._base = 0;
      }
      if (a1->_lb._base)
      {
        free(a1->_lb._base);
        a1->_lb._base = 0;
      }
      a1->_file = -1;
      a1->_w = 0;
      a1->_r = 0;
      funlockfile(a1);
      __sfprelease((uint64_t)a1);
      if (v2)
        *__error() = v2;
      return v3;
    }
    else
    {
      *__error() = 9;
      return -1;
    }
  }
  else
  {
    *__error() = 14;
    return -1;
  }
}

uint64_t libc_hooks_will_write(uint64_t result, uint64_t a2)
{
  if (off_E9740)
    return off_E9740(result, a2);
  return result;
}

FILE *__cdecl fdopen(int a1, const char *a2)
{
  int v3;
  int v4;
  int v5;
  FILE *v6;
  char *v7;
  int v8;

  v8 = a1;
  v7 = (char *)a2;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a2);
  if (v8 < 0x8000)
  {
    v5 = __sflags(v7, &v4);
    if (v5)
    {
      v3 = fcntl_NOCANCEL(v8, 3);
      if (v3 >= 0)
      {
        if ((v3 & 3) == 2 || (v3 & 3) == (v4 & 3))
        {
          v6 = (FILE *)__sfp(1);
          if (v6)
          {
            v6->_flags = v5;
            if ((v4 & 8) != 0 && (v3 & 8) == 0)
              v6->_flags |= 0x100u;
            v6->_file = v8;
            v6->_cookie = v6;
            v6->_read = (int (__cdecl *)(void *, char *, int))__sread;
            v6->_write = (int (__cdecl *)(void *, const char *, int))__swrite;
            v6->_seek = (fpos_t (__cdecl *)(void *, fpos_t, int))__sseek;
            v6->_close = (int (__cdecl *)(void *))__sclose;
            return v6;
          }
          else
          {
            return 0;
          }
        }
        else
        {
          *__error() = 22;
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 24;
    return 0;
  }
}

int feof(FILE *a1)
{
  _BOOL4 v2;

  flockfile(a1);
  v2 = (a1->_flags & 0x20) != 0;
  funlockfile(a1);
  return v2;
}

BOOL feof_unlocked(uint64_t a1)
{
  return (*(_WORD *)(a1 + 16) & 0x20) != 0;
}

int ferror(FILE *a1)
{
  _BOOL4 v2;

  flockfile(a1);
  v2 = (a1->_flags & 0x40) != 0;
  funlockfile(a1);
  return v2;
}

BOOL ferror_unlocked(uint64_t a1)
{
  return (*(_WORD *)(a1 + 16) & 0x40) != 0;
}

int fflush(FILE *a1)
{
  int v2;

  if (!a1)
    return _fwalk((uint64_t (*)(uint64_t *))sflush_locked);
  libc_hooks_will_write((uint64_t)a1, 152);
  flockfile(a1);
  v2 = __sflush((uint64_t)a1);
  funlockfile(a1);
  return v2;
}

uint64_t sflush_locked(FILE *a1)
{
  unsigned int v2;

  flockfile(a1);
  v2 = __sflush((uint64_t)a1);
  funlockfile(a1);
  return v2;
}

uint64_t __sflush(uint64_t a1)
{
  int v2;
  int v3;
  int v4;
  signed int v5;
  __int16 v6;
  unint64_t v7;

  v6 = *(_WORD *)(a1 + 16);
  v7 = *(_QWORD *)(a1 + 24);
  if (!v7)
    return 0;
  if ((v6 & 4) != 0)
  {
    if (!*(_QWORD *)(a1 + 72))
      return 0;
    v4 = *(_DWORD *)(a1 + 8);
    if (v4 > 0)
    {
      if (_sseek(a1, -v4, 1u) == -1)
      {
        if (*__error() == 29)
          return 0;
        else
          return -1;
      }
      if (*(_QWORD *)(a1 + 88))
      {
        if (*(_QWORD *)(a1 + 88) != a1 + 116)
          free(*(void **)(a1 + 88));
        *(_QWORD *)(a1 + 88) = 0;
      }
      *(_QWORD *)a1 = *(_QWORD *)(a1 + 24);
      *(_DWORD *)(a1 + 8) = 0;
      *(_WORD *)(a1 + 16) &= ~0x20u;
      _platform_memset(*(_QWORD *)(a1 + 104) + 80, 0, 128);
    }
    return 0;
  }
  if ((v6 & 8) != 0)
  {
    v5 = *(_QWORD *)a1 - v7;
    *(_QWORD *)a1 = v7;
    if ((v6 & 3) != 0)
      v2 = 0;
    else
      v2 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 12) = v2;
    while (v5 > 0)
    {
      v3 = _swrite(a1, v7, v5);
      if (v3 <= 0)
      {
        if (v7 > *(_QWORD *)a1)
          _platform_memmove(*(_QWORD *)a1, v7, v5);
        *(_QWORD *)a1 += v5;
        if ((*(_WORD *)(a1 + 16) & 2) == 0)
          *(_DWORD *)(a1 + 12) -= v5;
        *(_WORD *)(a1 + 16) |= 0x40u;
        return -1;
      }
      v5 -= v3;
      v7 += v3;
    }
  }
  return 0;
}

uint64_t __fflush(uint64_t a1)
{
  if (a1)
  {
    if ((*(_WORD *)(a1 + 16) & 0x18) != 0)
      return __sflush(a1);
    else
      return 0;
  }
  else
  {
    return _fwalk((uint64_t (*)(uint64_t *))sflush_locked);
  }
}

int fgetc(FILE *a1)
{
  int v1;
  unsigned __int8 *v2;
  int v4;

  flockfile(a1);
  v1 = a1->_r - 1;
  a1->_r = v1;
  if (v1 >= 0)
  {
    v2 = a1->_p++;
    v4 = *v2;
  }
  else
  {
    v4 = __srget(a1);
  }
  funlockfile(a1);
  return v4;
}

uint64_t __slbexpand(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  int v4;

  v4 = a2;
  if (*(int *)(a1 + 128) < a2)
  {
    if (a2 <= 0x7FFFFFFF)
    {
      v3 = malloc_type_realloc(*(_QWORD *)(a1 + 120), a2, 2879550611);
      if (v3)
      {
        *(_QWORD *)(a1 + 120) = v3;
        *(_DWORD *)(a1 + 128) = v4;
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      *__error() = 12;
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

char *__cdecl fgetln(FILE *a1, size_t *a2)
{
  int64_t v3;
  unsigned __int8 *p;
  size_t v5;
  size_t v6;
  size_t r;
  uint64_t v8;
  unsigned __int8 *v9;
  uint64_t v10;
  unsigned __int8 *v11;

  flockfile(a1);
  if (!((char)(32 * *((_BYTE *)a1->_extra + 72)) >> 5))
    *((_BYTE *)a1->_extra + 72) = *((_BYTE *)a1->_extra + 72) & 0xF8 | 7;
  if (a1->_r <= 0 && __srefill((uint64_t)a1))
  {
    *a2 = 0;
    funlockfile(a1);
    return 0;
  }
  else
  {
    v8 = _platform_memchr(a1->_p, 10, a1->_r);
    if (v8)
    {
      v9 = (unsigned __int8 *)(v8 + 1);
      p = a1->_p;
      v6 = v9 - a1->_p;
      *a2 = v6;
      a1->_flags |= 0x2000u;
      a1->_r -= v6;
      a1->_p = v9;
      funlockfile(a1);
      return (char *)p;
    }
    else
    {
      r = a1->_r;
      v5 = 0;
      while (!__slbexpand((uint64_t)a1, r + 80))
      {
        j___platform_memmove(&a1->_lb._base[v5], a1->_p, r - v5);
        v5 = r;
        if (__srefill((uint64_t)a1))
          goto LABEL_15;
        v10 = _platform_memchr(a1->_p, 10, a1->_r);
        if (v10)
        {
          v11 = (unsigned __int8 *)(v10 + 1);
          v3 = v11 - a1->_p;
          r += v3;
          if (!__slbexpand((uint64_t)a1, r))
          {
            j___platform_memmove(&a1->_lb._base[v5], a1->_p, v3);
            a1->_r -= v3;
            a1->_p = v11;
LABEL_15:
            *a2 = r;
            funlockfile(a1);
            return (char *)a1->_lb._base;
          }
          break;
        }
        r += a1->_r;
      }
      *a2 = 0;
      a1->_flags |= 0x40u;
      funlockfile(a1);
      return 0;
    }
  }
}

int fgetpos(FILE *a1, fpos_t *a2)
{
  off_t v2;

  v2 = ftello(a1);
  *a2 = v2;
  if (v2 == -1)
    return -1;
  else
    return 0;
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  uint64_t v4;
  unsigned __int8 *v5;
  unsigned __int8 *p;
  char *v7;
  unint64_t r;
  int i;

  if (a2 <= 0)
    return 0;
  libc_hooks_will_write((uint64_t)a1, a2);
  libc_hooks_will_write((uint64_t)a3, 152);
  flockfile(a3);
  if (!((char)(32 * *((_BYTE *)a3->_extra + 72)) >> 5))
    *((_BYTE *)a3->_extra + 72) = *((_BYTE *)a3->_extra + 72) & 0xF8 | 7;
  v7 = a1;
  for (i = a2 - 1; i; i -= r)
  {
    r = a3->_r;
    if (!a3->_r)
    {
      if (__srefill((uint64_t)a3))
      {
        if (v7 == a1)
        {
          funlockfile(a3);
          return 0;
        }
        break;
      }
      r = a3->_r;
    }
    p = a3->_p;
    if (r > i)
      r = i;
    v4 = _platform_memchr(p, 10, r);
    if (v4)
    {
      v5 = (unsigned __int8 *)(v4 + 1);
      a3->_r -= (_DWORD)v5 - (_DWORD)p;
      a3->_p = v5;
      j___platform_memmove(v7, p, v5 - p);
      v7[v5 - p] = 0;
      funlockfile(a3);
      return a1;
    }
    a3->_r -= r;
    a3->_p += r;
    j___platform_memmove(v7, p, r);
    v7 += r;
  }
  *v7 = 0;
  funlockfile(a3);
  return a1;
}

wint_t fgetwc(FILE *a1)
{
  char v1;
  wint_t v2;
  wint_t v4;
  void *v6;
  uint64_t v7;

  flockfile(a1);
  if ((char)(32 * *((_BYTE *)a1->_extra + 72)) >> 5)
  {
    v1 = 0;
  }
  else
  {
    *((_BYTE *)a1->_extra + 72) = *((_BYTE *)a1->_extra + 72) & 0xF8 | 1;
    v1 = 1;
  }
  if ((v1 & 1) != 0)
  {
    v6 = pthread_getspecific(__locale_key);
  }
  else
  {
    v7 = __locale_key;
    v6 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6)
    v2 = __fgetwc((uint64_t)a1, (uint64_t)v6);
  else
    v2 = __fgetwc((uint64_t)a1, (uint64_t)__global_locale);
  v4 = v2;
  funlockfile(a1);
  return v4;
}

uint64_t __fgetwc(uint64_t a1, uint64_t a2)
{
  unsigned __int8 *v2;
  uint64_t (*v5)(unsigned int *, _QWORD, _QWORD, uint64_t, uint64_t);
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;

  v10 = a1;
  v9 = a2;
  v8 = 0;
  v6 = *(_QWORD *)(a2 + 1328);
  v5 = *(uint64_t (**)(unsigned int *, _QWORD, _QWORD, uint64_t, uint64_t))(v6 + 72);
  if (*(int *)(a1 + 8) <= 0 && __srefill(v10))
  {
    return -1;
  }
  else if (*(_DWORD *)(v6 + 64) == 1)
  {
    v2 = (unsigned __int8 *)(*(_QWORD *)v10)++;
    v8 = *v2;
    --*(_DWORD *)(v10 + 8);
    return v8;
  }
  else
  {
    while (1)
    {
      v7 = v5(&v8, *(_QWORD *)v10, *(int *)(v10 + 8), *(_QWORD *)(v10 + 104) + 80, v9);
      if (v7 == -1)
      {
LABEL_13:
        *(_WORD *)(v10 + 16) |= 0x40u;
        *__error() = 92;
        return -1;
      }
      if (v7 != -2)
        break;
      if (__srefill(v10) != 0)
        goto LABEL_13;
    }
    if (v7)
    {
      *(_QWORD *)v10 += v7;
      *(_DWORD *)(v10 + 8) -= v7;
      return v8;
    }
    else
    {
      ++*(_QWORD *)v10;
      --*(_DWORD *)(v10 + 8);
      return 0;
    }
  }
}

wint_t fgetwc_l(FILE *a1, locale_t a2)
{
  wint_t v3;
  locale_t v4;

  v4 = a2;
  if (a2)
  {
    if (a2 == (locale_t)-1)
      v4 = (locale_t)__global_locale;
  }
  else
  {
    v4 = (locale_t)&__c_locale;
  }
  flockfile(a1);
  if (!((char)(32 * *((_BYTE *)a1->_extra + 72)) >> 5))
    *((_BYTE *)a1->_extra + 72) = *((_BYTE *)a1->_extra + 72) & 0xF8 | 1;
  v3 = __fgetwc((uint64_t)a1, (uint64_t)v4);
  funlockfile(a1);
  return v3;
}

__int32 *__cdecl fgetwln_l(FILE *a1, size_t *a2, locale_t a3)
{
  size_t v3;
  size_t v5;
  int v6;

  flockfile(a1);
  if (!((char)(32 * *((_BYTE *)a1->_extra + 72)) >> 5))
    *((_BYTE *)a1->_extra + 72) = *((_BYTE *)a1->_extra + 72) & 0xF8 | 1;
  v5 = 0;
  do
  {
    v6 = __fgetwc((uint64_t)a1, (uint64_t)a3);
    if (v6 == -1)
      break;
    if (a1->_lb._size <= 4 * v5 && __slbexpand((uint64_t)a1, 4 * (v5 + 512)))
      goto LABEL_10;
    v3 = v5++;
    *(_DWORD *)&a1->_lb._base[4 * v3] = v6;
  }
  while (v6 != 10);
  if (v5)
  {
    funlockfile(a1);
    *a2 = v5;
    return (__int32 *)a1->_lb._base;
  }
LABEL_10:
  funlockfile(a1);
  *a2 = 0;
  return 0;
}

__int32 *__cdecl fgetwln(FILE *a1, size_t *a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return fgetwln_l(a1, a2, v7);
  else
    return fgetwln_l(a1, a2, (locale_t)__global_locale);
}

__int32 *__cdecl fgetws_l(__int32 *a1, int a2, FILE *a3, locale_t a4)
{
  BOOL v5;
  BOOL v6;
  unint64_t v7;
  uint64_t (*v8)(__int32 *, unsigned __int8 **, unint64_t, _QWORD, char *, locale_t);
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *p;
  uint64_t v12;
  __int32 *v13;
  locale_t v14;
  FILE *v15;
  int v16;
  __int32 *v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = 0;
  v12 = 0;
  p = 0;
  if (a4)
  {
    if (v14 == (locale_t)-1)
      v14 = (locale_t)__global_locale;
  }
  else
  {
    v14 = (locale_t)&__c_locale;
  }
  v9 = *((_QWORD *)v14 + 166);
  v8 = *(uint64_t (**)(__int32 *, unsigned __int8 **, unint64_t, _QWORD, char *, locale_t))(v9 + 88);
  flockfile(v15);
  if (!((char)(32 * *((_BYTE *)v15->_extra + 72)) >> 5))
    *((_BYTE *)v15->_extra + 72) = *((_BYTE *)v15->_extra + 72) & 0xF8 | 1;
  if (v16 > 0)
  {
    if (v15->_r > 0 || !__srefill((uint64_t)v15))
    {
      v13 = v17;
      while (1)
      {
        p = v15->_p;
        v10 = _platform_memchr(v15->_p, 10, v15->_r);
        v7 = v10 ? v10 - (unint64_t)v15->_p + 1 : v15->_r;
        v12 = v8(v13, &p, v7, v16 - 1, (char *)v15->_extra + 80, v14);
        if (v12 == -1)
          break;
        if (!p)
        {
          ++v12;
          p = (unsigned __int8 *)(_platform_memchr(v15->_p, 0, v15->_r) + 1);
        }
        v15->_r -= (_DWORD)p - LODWORD(v15->_p);
        v15->_p = p;
        v16 -= v12;
        v13 += v12;
        v6 = 0;
        if (*(v13 - 1) != 10)
        {
          v6 = 0;
          if (v16 > 1)
          {
            v5 = 1;
            if (v15->_r <= 0)
              v5 = __srefill((uint64_t)v15) == 0;
            v6 = v5;
          }
        }
        if (!v6)
        {
          if (v13 != v17 && (*(unsigned int (**)(char *, locale_t))(v9 + 80))((char *)v15->_extra + 80, v14))
          {
            *v13 = 0;
            funlockfile(v15);
            return v17;
          }
          break;
        }
      }
    }
  }
  else
  {
    *__error() = 22;
  }
  funlockfile(v15);
  return 0;
}

__int32 *__cdecl fgetws(__int32 *a1, int a2, FILE *a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return fgetws_l(a1, a2, a3, v9);
  else
    return fgetws_l(a1, a2, a3, (locale_t)__global_locale);
}

int fileno(FILE *a1)
{
  int file;

  flockfile(a1);
  file = a1->_file;
  funlockfile(a1);
  return file;
}

uint64_t fileno_unlocked(uint64_t a1)
{
  return *(__int16 *)(a1 + 18);
}

uint64_t *__sfp(int a1)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t **i;
  uint64_t *v17;
  int v18;
  uint64_t *v19;
  _QWORD v22[8];

  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  if (!a1)
    goto LABEL_21;
  v14 = __scounted;
  do
  {
    v1 = v14;
    do
      v2 = __ldaxr((unint64_t *)&__scounted);
    while (v2 == v14 && __stlxr(v14 + 1, (unint64_t *)&__scounted));
    v14 = v2;
  }
  while (v2 != v1);
  v15 = v2 + 1;
  if ((uint64_t)(v2 + 1) > sysconf(26))
  {
    v13 = __scounted;
    do
    {
      v3 = v13;
      do
        v4 = __ldaxr((unint64_t *)&__scounted);
      while (v4 == v13 && __stlxr(v13 - 1, (unint64_t *)&__scounted));
      v13 = v4;
    }
    while (v4 != v3);
    *__error() = 24;
    return 0;
  }
  if (v15 < 0)
  {
    v12 = __scounted;
    do
    {
      v5 = v12;
      do
        v6 = __ldaxr((unint64_t *)&__scounted);
      while (v6 == v12 && __stlxr(v12 - 1, (unint64_t *)&__scounted));
      v12 = v6;
    }
    while (v6 != v5);
    *__error() = 84;
    return 0;
  }
  else
  {
LABEL_21:
    pthread_mutex_lock(&filelist_lock);
    for (i = &__sglue; i; i = (uint64_t **)*i)
    {
      v19 = i[2];
      v18 = *((_DWORD *)i + 2);
      while (--v18 >= 0)
      {
        if (!*((_WORD *)v19 + 8))
          goto LABEL_37;
        v19 += 19;
      }
    }
    pthread_mutex_unlock(&filelist_lock);
    v17 = (uint64_t *)moreglue(10);
    if (v17)
    {
      pthread_mutex_lock(&filelist_lock);
      *lastglue = (uint64_t)v17;
      lastglue = v17;
      v19 = (uint64_t *)v17[2];
LABEL_37:
      *((_WORD *)v19 + 8) = 1;
      pthread_mutex_unlock(&filelist_lock);
      *v19 = 0;
      *((_DWORD *)v19 + 3) = 0;
      *((_DWORD *)v19 + 2) = 0;
      v19[3] = 0;
      *((_DWORD *)v19 + 8) = 0;
      *((_DWORD *)v19 + 10) = 0;
      *((_WORD *)v19 + 9) = -1;
      v19[11] = 0;
      *((_DWORD *)v19 + 24) = 0;
      v19[15] = 0;
      *((_DWORD *)v19 + 32) = 0;
      *(_QWORD *)v19[13] = 0;
      v10 = v19[13] + 8;
      _platform_memset(v22, 0, 64);
      v22[0] = 850045858;
      j___platform_memmove(v10, v22, 64);
      *(_BYTE *)(v19[13] + 72) &= 0xF8u;
      _platform_memset(v19[13] + 80, 0, 128);
      *(_BYTE *)(v19[13] + 72) &= ~8u;
      *(_BYTE *)(v19[13] + 72) = *(_BYTE *)(v19[13] + 72) & 0xF7 | (8 * (a1 != 0));
      return v19;
    }
    else
    {
      if (a1)
      {
        v11 = __scounted;
        do
        {
          v7 = v11;
          do
            v8 = __ldaxr((unint64_t *)&__scounted);
          while (v8 == v11 && __stlxr(v11 - 1, (unint64_t *)&__scounted));
          v11 = v8;
        }
        while (v8 != v7);
      }
      return 0;
    }
  }
}

uint64_t __sinit()
{
  uint64_t v0;
  uint64_t result;
  uint64_t v2;
  uint64_t v3;
  int i;
  _QWORD v5[8];

  __cleanup = 1;
  __scounted = 3;
  for (i = 0; i < 17; ++i)
  {
    *((_QWORD *)&usual + 19 * i + 13) = (char *)&usual_extra + 208 * i;
    **((_QWORD **)&usual + 19 * i + 13) = 0;
    v3 = *((_QWORD *)&usual + 19 * i + 13) + 8;
    _platform_memset(v5, 0, 64);
    v5[0] = 850045858;
    j___platform_memmove(v3, v5, 64);
    v0 = *((_QWORD *)&usual + 19 * i + 13);
    *(_BYTE *)(v0 + 72) &= 0xF8u;
    result = _platform_memset(*((_QWORD *)&usual + 19 * i + 13) + 80, 0, 128);
    v2 = *((_QWORD *)&usual + 19 * i + 13);
    *(_BYTE *)(v2 + 72) &= ~8u;
  }
  return result;
}

uint64_t moreglue(int a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  int v7;
  _QWORD v9[8];

  v7 = a1;
  v6 = malloc_type_malloc(152 * a1 + 32 + 208 * a1, 2817365110);
  if (!v6)
    return 0;
  if ((v6 + 24) % 8uLL)
    v3 = v6 + 24 + 8 - (v6 + 24) % 8uLL;
  else
    v3 = v6 + 24;
  v5 = v3;
  v4 = v3 + 152 * v7;
  *(_QWORD *)v6 = 0;
  *(_DWORD *)(v6 + 8) = v7;
  *(_QWORD *)(v6 + 16) = v3;
  while (--v7 >= 0)
  {
    _platform_memset(v5, 0, 152);
    *(_QWORD *)(v5 + 104) = v4;
    **(_QWORD **)(v5 + 104) = 0;
    v2 = *(_QWORD *)(v5 + 104) + 8;
    _platform_memset(v9, 0, 64);
    v9[0] = 850045858;
    j___platform_memmove(v2, v9, 64);
    *(_BYTE *)(*(_QWORD *)(v5 + 104) + 72) &= 0xF8u;
    _platform_memset(*(_QWORD *)(v5 + 104) + 80, 0, 128);
    *(_BYTE *)(*(_QWORD *)(v5 + 104) + 72) &= ~8u;
    v5 += 152;
    v4 += 208;
  }
  return v6;
}

uint64_t __sfprelease(uint64_t a1)
{
  uint64_t v1;
  unint64_t v2;
  uint64_t v4;

  if ((*(_BYTE *)(*(_QWORD *)(a1 + 104) + 72) & 8) != 0)
  {
    v4 = __scounted;
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr((unint64_t *)&__scounted);
      while (v2 == v4 && __stlxr(v4 - 1, (unint64_t *)&__scounted));
      v4 = v2;
    }
    while (v2 != v1);
    *(_BYTE *)(*(_QWORD *)(a1 + 104) + 72) &= ~8u;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(*(_QWORD *)(a1 + 104) + 8));
  pthread_mutex_lock(&filelist_lock);
  *(_WORD *)(a1 + 16) = 0;
  return pthread_mutex_unlock(&filelist_lock);
}

uint64_t f_prealloc()
{
  uint64_t result;
  BOOL v1;
  int v2;
  uint64_t **i;
  uint64_t *v4;

  result = getdtablesize();
  v2 = result;
  for (i = &__sglue; ; i = (uint64_t **)*i)
  {
    v2 -= *((_DWORD *)i + 2);
    v1 = 0;
    if (v2 > 0)
      v1 = *i != 0;
    if (!v1)
      break;
  }
  if (v2 > 0)
  {
    result = moreglue(v2);
    v4 = (uint64_t *)result;
    if (result)
    {
      pthread_mutex_lock(&filelist_lock);
      *lastglue = (uint64_t)v4;
      lastglue = v4;
      return pthread_mutex_unlock(&filelist_lock);
    }
  }
  return result;
}

uint64_t _cleanup()
{
  return _fwalk((uint64_t (*)(uint64_t *))__sflush);
}

uint64_t __sflags(char *a1, int *a2)
{
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  _BYTE *v7;

  v7 = a1 + 1;
  v3 = *a1;
  switch(v3)
  {
    case 'a':
      v6 = 8;
      v5 = 1;
      v4 = 520;
      break;
    case 'r':
      v6 = 4;
      v5 = 0;
      v4 = 0;
      break;
    case 'w':
      v6 = 8;
      v5 = 1;
      v4 = 1536;
      break;
    default:
      *__error() = 22;
      return 0;
  }
  if (*v7 == 98)
    v7 = a1 + 2;
  if (*v7 == 43)
  {
    v6 = 16;
    v5 = 2;
    if (*++v7 == 98)
      ++v7;
  }
  if (*v7 == 120)
    v4 |= 0x800u;
  *a2 = v5 | v4;
  return v6;
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  unsigned int v3;
  int v4;
  int v5;
  FILE *v6;
  char *v7;
  const char *v8;

  v8 = __filename;
  v7 = (char *)__mode;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  v3 = 0;
  libc_hooks_will_read_cstring((uint64_t)__filename);
  libc_hooks_will_read_cstring((uint64_t)v7);
  v4 = __sflags(v7, (int *)&v3);
  if (!v4)
    return 0;
  v6 = (FILE *)__sfp(1);
  if (!v6)
    return 0;
  v5 = open_NOCANCEL(v8, v3);
  if (v5 >= 0)
  {
    if (v5 < 0x8000)
    {
      v6->_file = v5;
      v6->_flags = v4;
      v6->_cookie = v6;
      v6->_read = (int (__cdecl *)(void *, char *, int))__sread;
      v6->_write = (int (__cdecl *)(void *, const char *, int))__swrite;
      v6->_seek = (fpos_t (__cdecl *)(void *, fpos_t, int))__sseek;
      v6->_close = (int (__cdecl *)(void *))__sclose;
      if ((v3 & 8) != 0)
        _sseek((uint64_t)v6, 0, 2u);
      return v6;
    }
    else
    {
      v6->_flags = 0;
      close_NOCANCEL(v5);
      *__error() = 24;
      return 0;
    }
  }
  else
  {
    __sfprelease((uint64_t)v6);
    return 0;
  }
}

int fprintf(FILE *a1, const char *a2, ...)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return vfprintf_l(a1, v7, a2, va);
  else
    return vfprintf_l(a1, (locale_t)&__global_locale, a2, va);
}

int fprintf_l(FILE *a1, locale_t a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return vfprintf_l(a1, a2, a3, va);
}

int fpurge(FILE *a1)
{
  int size;
  int v3;

  flockfile(a1);
  if (a1->_flags)
  {
    if (a1->_ub._base)
    {
      if (a1->_ub._base != a1->_ubuf)
        free(a1->_ub._base);
      a1->_ub._base = 0;
    }
    a1->_p = a1->_bf._base;
    a1->_r = 0;
    if ((a1->_flags & 3) != 0)
      size = 0;
    else
      size = a1->_bf._size;
    a1->_w = size;
    v3 = 0;
  }
  else
  {
    *__error() = 9;
    v3 = -1;
  }
  funlockfile(a1);
  return v3;
}

int fputc(int a1, FILE *a2)
{
  int v2;
  unsigned __int8 *v3;
  int v7;

  flockfile(a2);
  v2 = a2->_w - 1;
  a2->_w = v2;
  if (v2 < 0 && (a2->_w < a2->_lbfsize || (char)a1 == 10))
  {
    v7 = __swbuf(a1, a2);
  }
  else
  {
    v3 = a2->_p++;
    *v3 = a1;
    v7 = a1;
  }
  funlockfile(a2);
  return v7;
}

int fputs(const char *a1, FILE *a2)
{
  const char *v3;
  uint64_t v4;
  const char **v5;
  uint64_t v6;
  int v7;
  FILE *v8;
  const char *v9;

  v9 = a1;
  v8 = a2;
  v7 = 0;
  v5 = 0;
  v6 = 0;
  v3 = 0;
  v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a1);
  libc_hooks_will_write((uint64_t)v8, 152);
  if (!v9)
    v9 = "(null)";
  v3 = v9;
  HIDWORD(v6) = _platform_strlen(v9);
  v4 = SHIDWORD(v6);
  v5 = &v3;
  LODWORD(v6) = 1;
  flockfile(v8);
  if (!((char)(32 * *((_BYTE *)v8->_extra + 72)) >> 5))
    *((_BYTE *)v8->_extra + 72) = *((_BYTE *)v8->_extra + 72) & 0xF8 | 7;
  v7 = __sfvwrite(v8, (uint64_t)&v5);
  funlockfile(v8);
  if (v7)
    return v7;
  else
    return v4;
}

uint64_t __fputwc(int a1, FILE *a2, uint64_t a3)
{
  int v3;
  unsigned __int8 v4;
  unsigned __int8 *v5;
  unint64_t v7;
  unint64_t i;
  _BYTE v9[6];
  uint64_t v10;
  FILE *v11;
  int v12;
  FILE *v14;
  int v15;
  int v16;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  if (*(_DWORD *)(*(_QWORD *)(a3 + 1328) + 64) == 1 && v12 > 0 && v12 <= 255)
  {
    v9[0] = v12;
    v7 = 1;
  }
  else
  {
    v7 = (*(uint64_t (**)(_BYTE *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(v10 + 1328) + 96))(v9, v12, (uint64_t)v11->_extra + 80, v10);
    if (v7 == -1)
    {
      v11->_flags |= 0x40u;
      return -1;
    }
  }
  for (i = 0; i < v7; ++i)
  {
    v15 = v9[i];
    v14 = v11;
    v3 = v11->_w - 1;
    v11->_w = v3;
    if (v3 < 0 && (v14->_w < v14->_lbfsize || (char)v15 == 10))
    {
      v16 = __swbuf(v15, v14);
    }
    else
    {
      v4 = v15;
      v5 = v14->_p++;
      *v5 = v4;
      v16 = v4;
    }
    if (v16 == -1)
      return -1;
  }
  return v12;
}

wint_t fputwc(__int32 a1, FILE *a2)
{
  char v2;
  wint_t v3;
  wint_t v5;
  void *v8;
  uint64_t v9;

  flockfile(a2);
  if ((char)(32 * *((_BYTE *)a2->_extra + 72)) >> 5)
  {
    v2 = 0;
  }
  else
  {
    *((_BYTE *)a2->_extra + 72) = *((_BYTE *)a2->_extra + 72) & 0xF8 | 1;
    v2 = 1;
  }
  if ((v2 & 1) != 0)
  {
    v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    v3 = __fputwc(a1, a2, (uint64_t)v8);
  else
    v3 = __fputwc(a1, a2, (uint64_t)__global_locale);
  v5 = v3;
  funlockfile(a2);
  return v5;
}

wint_t fputwc_l(__int32 a1, FILE *a2, locale_t a3)
{
  wint_t v4;
  locale_t v5;

  v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v5 = (locale_t)__global_locale;
  }
  else
  {
    v5 = (locale_t)&__c_locale;
  }
  flockfile(a2);
  if (!((char)(32 * *((_BYTE *)a2->_extra + 72)) >> 5))
    *((_BYTE *)a2->_extra + 72) = *((_BYTE *)a2->_extra + 72) & 0xF8 | 1;
  v4 = __fputwc(a1, a2, (uint64_t)v5);
  funlockfile(a2);
  return v4;
}

int fputws_l(const __int32 *a1, FILE *a2, locale_t a3)
{
  BOOL v4;
  uint64_t (*v5)(_BYTE *, const __int32 **, uint64_t, uint64_t, char *, locale_t);
  const __int32 *v6;
  _BYTE *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  locale_t v12;
  FILE *v13;
  const __int32 *v14;
  _BYTE v16[1024];

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v11 = 0;
  v9 = 0;
  v10 = 0;
  v7 = 0;
  v8 = 0;
  v6 = a1;
  if (a3)
  {
    if (v12 == (locale_t)-1)
      v12 = (locale_t)__global_locale;
  }
  else
  {
    v12 = (locale_t)&__c_locale;
  }
  v5 = *(uint64_t (**)(_BYTE *, const __int32 **, uint64_t, uint64_t, char *, locale_t))(*((_QWORD *)v12 + 166)
                                                                                               + 104);
  flockfile(v13);
  if (!((char)(32 * *((_BYTE *)v13->_extra + 72)) >> 5))
    *((_BYTE *)v13->_extra + 72) = *((_BYTE *)v13->_extra + 72) & 0xF8 | 1;
  if ((v13->_flags & 8) == 0 || (v4 = 0, !v13->_bf._base) && (v4 = 0, (v13->_flags & 0x200) == 0))
    v4 = __swsetup((uint64_t)v13) != 0;
  if (!v4)
  {
    v9 = &v7;
    LODWORD(v10) = 1;
    v7 = v16;
    while (1)
    {
      v11 = v5(v16, &v6, -1, 1024, (char *)v13->_extra + 80, v12);
      if (v11 == -1)
        break;
      HIDWORD(v10) = v11;
      v8 = (int)v11;
      if (__sfvwrite(v13, (uint64_t)&v9))
        break;
      if (!v6)
      {
        funlockfile(v13);
        return 0;
      }
    }
  }
  funlockfile(v13);
  return -1;
}

int fputws(const __int32 *a1, FILE *a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return fputws_l(a1, a2, v7);
  else
    return fputws_l(a1, a2, (locale_t)__global_locale);
}

uint64_t strtonum(const char *__numstr, uint64_t __minval, uint64_t __maxval, const char **__errstrp)
{
  int v5;
  char *__endptr;
  int v7;
  uint64_t v8;
  const char **v9;
  uint64_t v10;
  uint64_t v11;
  char *__str;
  _BYTE v13[8];
  _DWORD v14[14];

  __str = (char *)__numstr;
  v11 = __minval;
  v10 = __maxval;
  v9 = __errstrp;
  v8 = 0;
  v7 = 0;
  __endptr = 0;
  j___platform_memmove(v13, &unk_D8E68, 64);
  v14[0] = *__error();
  *__error() = 0;
  if (v11 <= v10)
  {
    v8 = strtoll(__str, &__endptr, 10);
    if (*__error() == 22 || __str == __endptr || *__endptr)
    {
      v7 = 1;
    }
    else if (v8 == 0x8000000000000000 && *__error() == 34 || v8 < v11)
    {
      v7 = 2;
    }
    else if (v8 == 0x7FFFFFFFFFFFFFFFLL && *__error() == 34 || v8 > v10)
    {
      v7 = 3;
    }
  }
  else
  {
    v7 = 1;
  }
  if (v9)
    *v9 = *(const char **)&v13[16 * v7];
  v5 = v14[4 * v7];
  *__error() = v5;
  if (v7)
    return 0;
  return v8;
}

size_t fread(void *a1, size_t a2, size_t a3, FILE *a4)
{
  size_t v5;

  libc_hooks_will_write((uint64_t)a4, 152);
  flockfile(a4);
  v5 = __fread((uint64_t)a1, a2, a3, (uint64_t)a4);
  funlockfile(a4);
  return v5;
}

unint64_t __fread(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4)
{
  signed int v5;
  int v6;
  unint64_t v7;
  uint64_t v9;
  uint64_t v11;

  v11 = a1;
  v9 = a3;
  libc_hooks_will_write(a1, a2 * a3);
  v7 = v9 * a2;
  if (!(v9 * a2))
    return 0;
  if (!((char)(32 * *(_BYTE *)(*(_QWORD *)(a4 + 104) + 72)) >> 5))
    *(_BYTE *)(*(_QWORD *)(a4 + 104) + 72) = *(_BYTE *)(*(_QWORD *)(a4 + 104) + 72) & 0xF8 | 7;
  if (*(int *)(a4 + 8) < 0)
    *(_DWORD *)(a4 + 8) = 0;
  while (v7)
  {
    if (v7 <= 0x7FFFFFFF)
      v5 = v7;
    else
      v5 = 2147482624;
    v6 = __fread0(v11, v5, (_QWORD *)a4);
    if (v6 != v5)
      return (v9 * a2 - v7 + v6) / a2;
    v11 += v5;
    v7 -= v5;
  }
  return v9;
}

uint64_t __fread0(uint64_t a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v4;
  __int128 v5;
  int v6;
  int v7;
  int v8;
  int v10;
  int v11;

  v10 = a2;
  while (1)
  {
    v7 = *((_DWORD *)a3 + 2);
    if (v10 <= v7)
      break;
    j___platform_memmove(a1, *a3, v7);
    *a3 += v7;
    a1 += v7;
    v10 -= v7;
    v6 = __srefill0((uint64_t)a3);
    if (v6 > 0)
      break;
    if (v6)
      return a2 - v10;
  }
  if ((a3[2] & 0x82) != 0 && v10 > *((_DWORD *)a3 + 8))
  {
    v5 = *(_OWORD *)(a3 + 3);
    a3[3] = a1;
    for (*((_DWORD *)a3 + 8) = v10; *((int *)a3 + 8) > 0; *((_DWORD *)a3 + 8) -= *((_DWORD *)a3 + 2))
    {
      if (__srefill1((uint64_t)a3))
      {
        v11 = *((_DWORD *)a3 + 8);
        *(_OWORD *)(a3 + 3) = v5;
        *a3 = a3[3];
        return a2 - v11;
      }
      a3[3] += *((int *)a3 + 2);
    }
    *(_OWORD *)(a3 + 3) = v5;
    v4 = *((_DWORD *)a3 + 8) * ((v10 - 1) / *((_DWORD *)a3 + 8));
    j___platform_memmove(a3[3], a1 + v4, v10 - (int)v4);
    *a3 = a3[3] + v10 - (int)v4;
    *((_DWORD *)a3 + 2) = 0;
  }
  else
  {
    while (1)
    {
      v8 = *((_DWORD *)a3 + 2);
      if (v10 <= v8)
        break;
      j___platform_memmove(a1, *a3, v8);
      *a3 += v8;
      a1 += v8;
      v10 -= v8;
      if (__srefill1((uint64_t)a3))
        return a2 - v10;
    }
    j___platform_memmove(a1, *a3, v10);
    *((_DWORD *)a3 + 2) -= v10;
    *a3 += v10;
  }
  return a2;
}

FILE *__cdecl freopen(const char *a1, const char *a2, FILE *a3)
{
  int v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int file;
  FILE *v12;
  char *v13;
  const char *v14;

  v14 = a1;
  v13 = (char *)a2;
  v12 = a3;
  file = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a1);
  libc_hooks_will_read_cstring((uint64_t)v13);
  libc_hooks_will_write((uint64_t)v12, 152);
  v9 = __sflags(v13, (int *)&v7);
  if (v9)
  {
    pthread_once(&__sdidinit, (void (*)(void))__sinit);
    flockfile(v12);
    if (v14)
    {
      if (v12->_flags)
      {
        if ((v12->_flags & 8) != 0)
          __sflush((uint64_t)v12);
        if (v12->_close)
          ((void (*)(void *))v12->_close)(v12->_cookie);
        v8 = 0;
      }
      else
      {
        v12->_flags = 32;
        v8 = 0;
      }
      file = open_NOCANCEL(v14, v7);
      if (file < 0 && v8 && (*__error() == 23 || *__error() == 24))
      {
        ((void (*)(void *))v12->_close)(v12->_cookie);
        v8 = 0;
        file = open_NOCANCEL(v14, v7);
      }
      v4 = *__error();
    }
    else
    {
      if (!v12->_flags)
      {
        funlockfile(v12);
        *__error() = 22;
        return 0;
      }
      v10 = fcntl_NOCANCEL(v12->_file, 3);
      if (v10 < 0)
        goto LABEL_7;
      if ((v10 & 3) != 2 && (v10 & 3) != (v7 & 3))
      {
        fclose(v12);
        funlockfile(v12);
        *__error() = 9;
        return 0;
      }
      if ((v12->_flags & 8) != 0)
        __sflush((uint64_t)v12);
      if (((v7 ^ v10) & 8) != 0)
      {
        v10 &= ~8u;
        v10 |= v7 & 8;
        if ((int)fcntl_NOCANCEL(v12->_file, 4) < 0)
        {
LABEL_7:
          v6 = *__error();
          fclose(v12);
          funlockfile(v12);
          *__error() = v6;
          return 0;
        }
      }
      if ((v7 & 0x400) != 0)
        ftruncate(v12->_file, 0);
      if ((v7 & 8) == 0)
        _sseek((uint64_t)v12, 0, 0);
      file = v12->_file;
      v8 = 0;
    }
    if (v8)
      ((void (*)(void *))v12->_close)(v12->_cookie);
    if ((v12->_flags & 0x80u) != 0)
      free(v12->_bf._base);
    v12->_w = 0;
    v12->_r = 0;
    v12->_p = 0;
    v12->_bf._base = 0;
    v12->_bf._size = 0;
    v12->_lbfsize = 0;
    if (v12->_ub._base)
    {
      if (v12->_ub._base != v12->_ubuf)
        free(v12->_ub._base);
      v12->_ub._base = 0;
    }
    v12->_ub._size = 0;
    if (v12->_lb._base)
    {
      free(v12->_lb._base);
      v12->_lb._base = 0;
    }
    v12->_lb._size = 0;
    *((_BYTE *)v12->_extra + 72) &= 0xF8u;
    _platform_memset((char *)v12->_extra + 80, 0, 128);
    if (file >= 0)
    {
      if (file < 0x8000)
      {
        v12->_flags = v9;
        v12->_file = file;
        v12->_cookie = v12;
        v12->_read = (int (__cdecl *)(void *, char *, int))__sread;
        v12->_write = (int (__cdecl *)(void *, const char *, int))__swrite;
        v12->_seek = (fpos_t (__cdecl *)(void *, fpos_t, int))__sseek;
        v12->_close = (int (__cdecl *)(void *))__sclose;
        if ((v7 & 8) != 0)
          _sseek((uint64_t)v12, 0, 2u);
        funlockfile(v12);
        return v12;
      }
      else
      {
        funlockfile(v12);
        __sfprelease((uint64_t)v12);
        *__error() = 24;
        return 0;
      }
    }
    else
    {
      funlockfile(v12);
      __sfprelease((uint64_t)v12);
      *__error() = v4;
      return 0;
    }
  }
  else
  {
    v5 = *__error();
    fclose(v12);
    *__error() = v5;
    return 0;
  }
}

int fscanf(FILE *a1, const char *a2, ...)
{
  char v2;
  char v3;
  int v4;
  int v6;
  _xlocale *v9;
  uint64_t v10;
  va_list va;

  va_start(va, a2);
  libc_hooks_will_write((uint64_t)a1, 152);
  flockfile(a1);
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    v4 = __svfscanf_l((int *)a1, v9, (uint64_t)a2);
  else
    v4 = __svfscanf_l((int *)a1, (_xlocale *)__global_locale, (uint64_t)a2);
  v6 = v4;
  funlockfile(a1);
  return v6;
}

int fscanf_l(FILE *a1, locale_t a2, const char *a3, ...)
{
  int v4;

  libc_hooks_will_write((uint64_t)a1, 152);
  if (a2)
  {
    if (a2 == (locale_t)-1)
      a2 = (locale_t)__global_locale;
  }
  else
  {
    a2 = (locale_t)&__c_locale;
  }
  flockfile(a1);
  v4 = __svfscanf_l((int *)a1, a2, (uint64_t)a3);
  funlockfile(a1);
  return v4;
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  int v4;
  int v5;

  v4 = *__error();
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  flockfile(a1);
  v5 = _fseeko((uint64_t)a1, a2, a3, 1);
  funlockfile(a1);
  if (!v5)
    *__error() = v4;
  return v5;
}

uint64_t _fseeko(uint64_t a1, uint64_t a2, unsigned int a3, int a4)
{
  int v5;
  int v6;
  stat v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  off_t (*v12)(uint64_t, off_t, int);
  int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;

  v16 = a1;
  v15 = a2;
  v14 = a3;
  v13 = a4;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  _platform_memset(&v7, 0, 144);
  v12 = *(off_t (**)(uint64_t, off_t, int))(v16 + 72);
  if (!v12)
  {
LABEL_2:
    *__error() = 29;
    return -1;
  }
  if (!v14)
  {
    if (v15 < 0)
      goto LABEL_34;
LABEL_16:
    v10 = 0;
    v6 = 0;
    goto LABEL_17;
  }
  if (v14 != 1)
  {
    if (v14 != 2)
      goto LABEL_34;
    goto LABEL_16;
  }
  if (_ftello(v16, &v10))
    return -1;
  if (v10 < 0)
    goto LABEL_2;
  if (v15 > 0 && v10 > 0x7FFFFFFFFFFFFFFFLL - v15)
    goto LABEL_32;
  v15 += v10;
  if (v15 < 0)
    goto LABEL_34;
  v14 = 0;
  v6 = 1;
LABEL_17:
  if (!*(_QWORD *)(v16 + 24))
    __smakebuf(v16);
  if ((*(_WORD *)(v16 + 16) & 0x81A) != 0)
    goto LABEL_59;
  if ((*(_WORD *)(v16 + 16) & 0x400) == 0)
  {
    if (v12 != __sseek
      || *(__int16 *)(v16 + 18) < 0
      || fstat(*(__int16 *)(v16 + 18), &v7)
      || (v7.st_mode & 0xF000) != 0x8000)
    {
      *(_WORD *)(v16 + 16) |= 0x800u;
      goto LABEL_59;
    }
    *(_DWORD *)(v16 + 136) = v7.st_blksize;
    *(_WORD *)(v16 + 16) |= 0x400u;
  }
  if (!v14)
  {
    v11 = v15;
    goto LABEL_35;
  }
  if (fstat(*(__int16 *)(v16 + 18), &v7))
    goto LABEL_59;
  if (v15 > 0 && v7.st_size > 0x7FFFFFFFFFFFFFFFLL - v15)
  {
LABEL_32:
    *__error() = 84;
    return -1;
  }
  v11 = v7.st_size + v15;
  if (v7.st_size + v15 < 0)
  {
LABEL_34:
    *__error() = 22;
    return -1;
  }
LABEL_35:
  if (v6 || !_ftello(v16, &v10))
  {
    if ((*(_WORD *)(v16 + 16) & 0x2000) == 0)
    {
      if (*(_QWORD *)(v16 + 88))
      {
        v10 += *(int *)(v16 + 8);
        v8 = **(_QWORD **)(v16 + 104) - *(_QWORD *)(v16 + 24);
        v10 -= v8;
        v8 += *(int *)(v16 + 112);
      }
      else
      {
        v8 = *(_QWORD *)v16 - *(_QWORD *)(v16 + 24);
        v10 -= v8;
        v8 += *(int *)(v16 + 8);
      }
      if ((uint64_t)v11 >= v10 && v11 < v10 + v8)
      {
        v5 = v11 - v10;
        *(_QWORD *)v16 = *(_QWORD *)(v16 + 24) + v11 - v10;
        *(_DWORD *)(v16 + 8) = v8 - v5;
        if (*(_QWORD *)(v16 + 88))
        {
          if (*(_QWORD *)(v16 + 88) != v16 + 116)
            free(*(void **)(v16 + 88));
          *(_QWORD *)(v16 + 88) = 0;
        }
        goto LABEL_47;
      }
    }
    v10 = v11 & ~(*(_DWORD *)(v16 + 136) - 1);
    if (_sseek(v16, v10, 0) == -1)
      goto LABEL_59;
    *(_DWORD *)(v16 + 8) = 0;
    *(_QWORD *)v16 = *(_QWORD *)(v16 + 24);
    if (*(_QWORD *)(v16 + 88))
    {
      if (*(_QWORD *)(v16 + 88) != v16 + 116)
        free(*(void **)(v16 + 88));
      *(_QWORD *)(v16 + 88) = 0;
    }
    v8 = v11 - v10;
    if (v11 != v10)
    {
      if (__srefill(v16) || *(int *)(v16 + 8) < v8)
        goto LABEL_59;
      *(_QWORD *)v16 += v8;
      *(_DWORD *)(v16 + 8) -= v8;
    }
LABEL_47:
    *(_WORD *)(v16 + 16) &= ~0x20u;
    _platform_memset(*(_QWORD *)(v16 + 104) + 80, 0, 128);
    return 0;
  }
LABEL_59:
  if (__sflush(v16))
    return -1;
  v9 = _sseek(v16, v15, v14);
  if (v9 == -1)
  {
    return -1;
  }
  else
  {
    if (*(_QWORD *)(v16 + 88))
    {
      if (*(_QWORD *)(v16 + 88) != v16 + 116)
        free(*(void **)(v16 + 88));
      *(_QWORD *)(v16 + 88) = 0;
    }
    *(_QWORD *)v16 = *(_QWORD *)(v16 + 24);
    *(_DWORD *)(v16 + 8) = 0;
    *(_WORD *)(v16 + 16) &= ~0x20u;
    _platform_memset(*(_QWORD *)(v16 + 104) + 80, 0, 128);
    return 0;
  }
}

int fseeko(FILE *__stream, off_t a2, int __whence)
{
  int v4;
  int v5;

  v4 = *__error();
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  flockfile(__stream);
  v5 = _fseeko((uint64_t)__stream, a2, __whence, 0);
  funlockfile(__stream);
  if (!v5)
    *__error() = v4;
  return v5;
}

int fsetpos(FILE *a1, const fpos_t *a2)
{
  return fseeko(a1, *a2, 0);
}

uint64_t ftell(FILE *a1)
{
  return ftello(a1);
}

off_t ftello(FILE *__stream)
{
  int v2;
  off_t v3;
  FILE *v4;

  v4 = __stream;
  v3 = 0;
  flockfile(__stream);
  v2 = _ftello((uint64_t)v4, &v3);
  funlockfile(v4);
  if (v2)
    return -1;
  if (v3 >= 0)
    return v3;
  *__error() = 29;
  return -1;
}

uint64_t _ftello(uint64_t a1, uint64_t *a2)
{
  int v3;
  uint64_t v4;
  uint64_t v5;

  if (*(_QWORD *)(a1 + 72))
  {
    if ((__ftell_conformance_fix & 1) != 0)
    {
      if ((*(_WORD *)(a1 + 16) & 4) == 0
        && (*(_WORD *)(a1 + 16) & 8) != 0
        && *(_QWORD *)a1
        && (uint64_t)(*(_QWORD *)a1 - *(_QWORD *)(a1 + 24)) > 0
        && (*(_WORD *)(a1 + 16) & 0x100) != 0)
      {
        v5 = _sseek(a1, 0, 2u);
        if (v5 == -1)
          return 1;
      }
      else if ((*(_WORD *)(a1 + 16) & 0x1000) != 0)
      {
        v5 = *(_QWORD *)(a1 + 144);
      }
      else
      {
        v5 = _sseek(a1, 0, 1u);
        if (v5 == -1)
          return 1;
      }
    }
    else
    {
      if (__sflush(a1))
        return 1;
      if ((*(_WORD *)(a1 + 16) & 0x1000) != 0)
      {
        v5 = *(_QWORD *)(a1 + 144);
      }
      else
      {
        v5 = _sseek(a1, 0, 1u);
        if (v5 == -1)
          return 1;
      }
    }
    if ((*(_WORD *)(a1 + 16) & 4) != 0)
    {
      if (*(_QWORD *)(a1 + 88))
        v3 = *(_DWORD *)(a1 + 112);
      else
        v3 = *(_DWORD *)(a1 + 8);
      v5 -= v3;
      if (v5 < 0)
      {
        *(_WORD *)(a1 + 16) |= 0x40u;
        *__error() = 5;
        return 1;
      }
      if (*(_QWORD *)(a1 + 88))
        v5 -= *(int *)(a1 + 8);
    }
    else if ((*(_WORD *)(a1 + 16) & 8) != 0)
    {
      if (*(_QWORD *)a1)
      {
        v4 = *(_QWORD *)a1 - *(_QWORD *)(a1 + 24);
        if ((__ftell_conformance_fix & 1) == 0 || v4)
        {
          if (v5 > (unint64_t)(0x7FFFFFFFFFFFFFFFLL - v4))
          {
            *__error() = 84;
            return 1;
          }
          v5 += v4;
        }
      }
    }
    *a2 = v5;
    return 0;
  }
  *__error() = 29;
  return 1;
}

FILE *__cdecl funopen(const void *a1, int (__cdecl *a2)(void *, char *, int), int (__cdecl *a3)(void *, const char *, int), fpos_t (__cdecl *a4)(void *, fpos_t, int), int (__cdecl *a5)(void *))
{
  __int16 v6;
  FILE *v7;

  if (a2)
  {
    if (a3)
      v6 = 16;
    else
      v6 = 4;
  }
  else
  {
    if (!a3)
    {
      *__error() = 22;
      return 0;
    }
    v6 = 8;
  }
  v7 = (FILE *)__sfp(0);
  if (!v7)
    return 0;
  v7->_flags = v6;
  v7->_file = -1;
  v7->_cookie = (void *)a1;
  v7->_read = a2;
  v7->_write = a3;
  v7->_seek = a4;
  v7->_close = a5;
  return v7;
}

uint64_t __sfvwrite(_QWORD *a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  signed int v7;
  signed int v8;
  unint64_t v9;
  BOOL v10;
  uint64_t v11;
  signed int v12;
  int v13;
  uint64_t v14;
  int v15;
  signed int v16;
  int v17;
  signed int v18;
  uint64_t *v19;
  uint64_t v20;
  unint64_t v21;

  if (*(_DWORD *)(a2 + 12))
  {
    if ((a1[2] & 8) == 0 || (v10 = 0, !a1[3]) && (v10 = 0, (a1[2] & 0x200) == 0))
      v10 = __swsetup((uint64_t)a1) != 0;
    if (v10)
    {
      return -1;
    }
    else
    {
      v20 = **(_QWORD **)a2;
      v21 = *(_QWORD *)(*(_QWORD *)a2 + 8);
      v19 = (uint64_t *)(*(_QWORD *)a2 + 16);
      if ((a1[2] & 2) != 0)
      {
        while (1)
        {
          while (!v21)
          {
            v20 = *v19;
            v21 = v19[1];
            v19 += 2;
          }
          v2 = v21 >= 0x7FFFFFFF ? _swrite((uint64_t)a1, v20, 0x7FFFFFFFu) : _swrite((uint64_t)a1, v20, v21);
          if (v2 <= 0)
            break;
          v20 += v2;
          v21 -= v2;
          v3 = *(_DWORD *)(a2 + 12) - v2;
          *(_DWORD *)(a2 + 12) = v3;
          if (!v3)
            return 0;
        }
LABEL_70:
        *((_WORD *)a1 + 8) |= 0x40u;
        return -1;
      }
      else
      {
        if ((a1[2] & 1) == 0)
        {
          while (1)
          {
            while (!v21)
            {
              v20 = *v19;
              v21 = v19[1];
              v19 += 2;
            }
            if ((a1[2] & 0x4200) == 0x4200 && *((int *)a1 + 3) < v21)
            {
              v11 = *a1 - a1[3];
              *((_DWORD *)a1 + 3) = v21 + 128;
              *((_DWORD *)a1 + 8) = v11 + v21 + 128;
              a1[3] = reallocf((void *)a1[3], *((_DWORD *)a1 + 8) + 1);
              if (!a1[3])
                goto LABEL_70;
              *a1 = a1[3] + v11;
            }
            v15 = *((_DWORD *)a1 + 3);
            if ((a1[2] & 0x200) != 0)
            {
              if (v21 < v15)
                v15 = v21;
              if (v15 > 0)
              {
                j___platform_memmove(*a1, v20, v15);
                *((_DWORD *)a1 + 3) -= v15;
                *a1 += v15;
              }
              v15 = v21;
            }
            else if (*a1 <= a1[3] || v21 <= v15)
            {
              v16 = *((_DWORD *)a1 + 8);
              if (v21 < v16)
              {
                v15 = v21;
                j___platform_memmove(*a1, v20, (int)v21);
                *((_DWORD *)a1 + 3) -= v21;
                *a1 += (int)v21;
              }
              else
              {
                if (v16)
                {
                  if (v16 * (v21 / v16) >= 0x7FFFFFFF)
                    LODWORD(v9) = 0x7FFFFFFF;
                  else
                    v9 = v16 * (v21 / v16);
                  v16 = v9;
                }
                v15 = _swrite((uint64_t)a1, v20, v16);
                if (v15 <= 0)
                  goto LABEL_70;
              }
            }
            else
            {
              j___platform_memmove(*a1, v20, v15);
              *a1 += v15;
              if (__fflush((uint64_t)a1))
                goto LABEL_70;
            }
            v20 += v15;
            v21 -= v15;
            v4 = *(_DWORD *)(a2 + 12) - v15;
            *(_DWORD *)(a2 + 12) = v4;
            if (!v4)
              return 0;
          }
        }
        v13 = 0;
        v12 = 0;
        do
        {
          while (!v21)
          {
            v13 = 0;
            v20 = *v19;
            v21 = v19[1];
            v19 += 2;
          }
          if (!v13)
          {
            v14 = _platform_memchr(v20, 10, v21);
            if (v14)
              v8 = v14 + 1 - v20;
            else
              v8 = v21 + 1;
            v12 = v8;
            v13 = 1;
          }
          if (v21 >= v12)
            v7 = v12;
          else
            v7 = v21;
          v17 = *((_DWORD *)a1 + 3) + *((_DWORD *)a1 + 8);
          if (*a1 <= a1[3] || v7 <= v17)
          {
            v18 = *((_DWORD *)a1 + 8);
            if (v7 < v18)
            {
              v17 = v7;
              j___platform_memmove(*a1, v20, v7);
              *((_DWORD *)a1 + 3) -= v7;
              *a1 += v7;
            }
            else
            {
              v17 = _swrite((uint64_t)a1, v20, v18);
              if (v17 <= 0)
                goto LABEL_70;
            }
          }
          else
          {
            j___platform_memmove(*a1, v20, v17);
            *a1 += v17;
            if (__fflush((uint64_t)a1))
              goto LABEL_70;
          }
          v12 -= v17;
          if (!v12)
          {
            if (__fflush((uint64_t)a1))
              goto LABEL_70;
            v13 = 0;
          }
          v20 += v17;
          v21 -= v17;
          v5 = *(_DWORD *)(a2 + 12) - v17;
          *(_DWORD *)(a2 + 12) = v5;
        }
        while (v5);
        return 0;
      }
    }
  }
  else
  {
    return 0;
  }
}

uint64_t _fwalk(uint64_t (*a1)(uint64_t *))
{
  uint64_t **i;
  unsigned int v3;
  int v4;
  uint64_t *v5;

  v3 = 0;
  for (i = &__sglue; i; i = (uint64_t **)*i)
  {
    v5 = i[2];
    v4 = *((_DWORD *)i + 2);
    while (--v4 >= 0)
    {
      if (*((__int16 *)v5 + 8) > 0)
        v3 |= a1(v5);
      v5 += 19;
    }
  }
  return v3;
}

int fwide(FILE *a1, int a2)
{
  char v2;
  int v4;

  flockfile(a1);
  if (a2 && !((char)(32 * *((_BYTE *)a1->_extra + 72)) >> 5))
  {
    if (a2 > 0)
      v2 = 1;
    else
      v2 = -1;
    *((_BYTE *)a1->_extra + 72) = *((_BYTE *)a1->_extra + 72) & 0xF8 | v2 & 7;
  }
  v4 = (char)(32 * *((_BYTE *)a1->_extra + 72)) >> 5;
  funlockfile(a1);
  return v4;
}

int fwprintf(FILE *a1, const __int32 *a2, ...)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return vfwprintf_l(a1, v7, a2, va);
  else
    return vfwprintf_l(a1, (locale_t)__global_locale, a2, va);
}

int fwprintf_l(FILE *a1, locale_t a2, const __int32 *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return vfwprintf_l(a1, a2, a3, va);
}

size_t fwrite(const void *a1, size_t a2, size_t a3, FILE *a4)
{
  int v5;
  const void *v6;
  uint64_t v7;
  const void **v8;
  uint64_t v9;
  unint64_t i;
  size_t v11;
  FILE *v12;
  size_t v13;
  size_t v14;
  char *v15;

  v15 = (char *)a1;
  v14 = a2;
  v13 = a3;
  v12 = a4;
  i = 0;
  v8 = 0;
  v9 = 0;
  v6 = 0;
  v7 = 0;
  v11 = a3 * a2;
  if (!(a3 * a2))
    return 0;
  v8 = &v6;
  LODWORD(v9) = 1;
  libc_hooks_will_write((uint64_t)v12, 152);
  flockfile(v12);
  if (!((char)(32 * *((_BYTE *)v12->_extra + 72)) >> 5))
    *((_BYTE *)v12->_extra + 72) = *((_BYTE *)v12->_extra + 72) & 0xF8 | 7;
  for (i = v11; i; i -= v5)
  {
    if (i <= 0x7FFFFFFF)
      v5 = i;
    else
      v5 = 2147482624;
    v6 = v15;
    v7 = v5;
    HIDWORD(v9) = v5;
    libc_hooks_will_read((uint64_t)v15, v5);
    if (__sfvwrite(v12, (uint64_t)&v8))
    {
      v13 = (v11 - i + v5 - SHIDWORD(v9)) / v14;
      break;
    }
    v15 += v5;
  }
  funlockfile(v12);
  return v13;
}

int fwscanf(FILE *a1, const __int32 *a2, ...)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return vfwscanf_l(a1, v7, a2, va);
  else
    return vfwscanf_l(a1, (locale_t)__global_locale, a2, va);
}

int fwscanf_l(FILE *a1, locale_t a2, const __int32 *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return vfwscanf_l(a1, a2, a3, va);
}

int getc(FILE *a1)
{
  int v1;
  unsigned __int8 *v2;
  int v4;

  flockfile(a1);
  v1 = a1->_r - 1;
  a1->_r = v1;
  if (v1 >= 0)
  {
    v2 = a1->_p++;
    v4 = *v2;
  }
  else
  {
    v4 = __srget(a1);
  }
  funlockfile(a1);
  return v4;
}

int getc_unlocked(FILE *a1)
{
  int v1;
  unsigned __int8 *v2;

  v1 = a1->_r - 1;
  a1->_r = v1;
  if (v1 < 0)
    return __srget(a1);
  v2 = a1->_p++;
  return *v2;
}

int getchar(void)
{
  int v0;
  unsigned __int8 *v1;
  int v3;

  flockfile(__stdinp);
  v0 = __stdinp->_r - 1;
  __stdinp->_r = v0;
  if (v0 >= 0)
  {
    v1 = __stdinp->_p++;
    v3 = *v1;
  }
  else
  {
    v3 = __srget(__stdinp);
  }
  funlockfile(__stdinp);
  return v3;
}

int getchar_unlocked(void)
{
  int v0;
  unsigned __int8 *v1;

  v0 = *(int *)((char *)&dword_8 + (_QWORD)__stdinp) - 1;
  *(int *)((char *)&dword_8 + (_QWORD)__stdinp) = v0;
  if (v0 < 0)
    return __srget(__stdinp);
  v1 = __stdinp->_p++;
  return *v1;
}

ssize_t getdelim(char **__linep, size_t *__linecapp, int __delimiter, FILE *__stream)
{
  ssize_t v5;
  unsigned __int8 *v6;
  FILE *v7;
  unsigned int v8;
  uint64_t *v9;
  uint64_t *v10;

  v10 = (uint64_t *)__linep;
  v9 = (uint64_t *)__linecapp;
  v8 = __delimiter;
  v7 = __stream;
  v6 = 0;
  v5 = 0;
  flockfile(__stream);
  if (!((char)(32 * *((_BYTE *)v7->_extra + 72)) >> 5))
    *((_BYTE *)v7->_extra + 72) = *((_BYTE *)v7->_extra + 72) & 0xF8 | 7;
  if (!v10 || !v9)
  {
    *__error() = 22;
LABEL_24:
    v7->_flags |= 0x40u;
    funlockfile(v7);
    return -1;
  }
  if (!*v10)
    *v9 = 0;
  if (v7->_r <= 0 && __srefill((uint64_t)v7))
  {
    if ((v7->_flags & 0x40) != 0 || expandtofit(v10, 1uLL, v9))
      goto LABEL_24;
    funlockfile(v7);
    *(_BYTE *)*v10 = 0;
    return -1;
  }
  else
  {
    v5 = 0;
    while (1)
    {
      v6 = (unsigned __int8 *)_platform_memchr(v7->_p, v8, v7->_r);
      if (v6)
        break;
      if (sappend(v10, &v5, v9, (uint64_t)v7->_p, v7->_r))
        goto LABEL_24;
      if (__srefill((uint64_t)v7))
      {
        if ((v7->_flags & 0x40) != 0)
          goto LABEL_24;
        goto LABEL_23;
      }
    }
    if (sappend(v10, &v5, v9, (uint64_t)v7->_p, ++v6 - v7->_p))
      goto LABEL_24;
    v7->_r -= (_DWORD)v6 - LODWORD(v7->_p);
    v7->_p = v6;
LABEL_23:
    *(_BYTE *)(*v10 + v5) = 0;
    funlockfile(v7);
    return v5;
  }
}

uint64_t expandtofit(uint64_t *a1, unint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v5;

  if (a2 <= 0x8000000000000000)
  {
    if (a2 > *a3)
    {
      if (a2 == 0x8000000000000000)
      {
        v5 = 0x8000000000000000;
        v3 = malloc_type_realloc(*a1, 0x8000000000000000, 2045016469);
      }
      else
      {
        v5 = p2roundup(a2);
        v3 = malloc_type_realloc(*a1, v5, 2045016469);
      }
      if (!v3)
        return -1;
      *a3 = v5;
      *a1 = v3;
    }
    return 0;
  }
  *__error() = 84;
  return -1;
}

uint64_t sappend(uint64_t *a1, _QWORD *a2, uint64_t *a3, uint64_t a4, uint64_t a5)
{
  BOOL v5;
  uint64_t v7;

  v5 = __CFADD__(a5, *a2);
  v7 = a5 + *a2;
  if (v5 || (((uint64_t)((unint64_t)(v7 == -1) << 63) >> 63) | (v7 == -1)) != 0)
  {
    *__error() = 84;
    return -1;
  }
  else if (expandtofit(a1, v7 + 1, a3))
  {
    return -1;
  }
  else
  {
    j___platform_memmove(*a1 + *a2, a4, a5);
    *a2 += a5;
    return 0;
  }
}

uint64_t p2roundup(uint64_t a1)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = a1;
  if (((a1 - 1) & a1) != 0)
  {
    v3 = (a1 - 1) | ((unint64_t)(a1 - 1) >> 1) | (((a1 - 1) | ((unint64_t)(a1 - 1) >> 1)) >> 2);
    v4 = v3 | (v3 >> 4) | ((v3 | (v3 >> 4)) >> 8);
    return (v4 | (v4 >> 16) | ((v4 | (v4 >> 16)) >> 32)) + 1;
  }
  return v2;
}

ssize_t getline(char **__linep, size_t *__linecapp, FILE *__stream)
{
  return getdelim(__linep, __linecapp, 10, __stream);
}

char *__cdecl gets(char *a1)
{
  int v1;
  unsigned __int8 *v2;
  char *v3;
  int v5;
  char *i;

  flockfile(__stdinp);
  if (!((char)(32 * *((_BYTE *)&stru_20.fileoff + *(_QWORD *)&stru_68.sectname[(_QWORD)__stdinp])) >> 5))
    *((_BYTE *)&stru_20.fileoff + *(_QWORD *)&stru_68.sectname[(_QWORD)__stdinp]) = *((_BYTE *)&stru_20.fileoff
                                                                                    + *(_QWORD *)&stru_68.sectname[(_QWORD)__stdinp]) & 0xF8 | 7;
  if (!gets_warned)
  {
    write_NOCANCEL(2, "warning: this program uses gets(), which is unsafe.\n", 52);
    gets_warned = 1;
  }
  for (i = a1; ; ++i)
  {
    v1 = *(int *)((char *)&dword_8 + (_QWORD)__stdinp) - 1;
    *(int *)((char *)&dword_8 + (_QWORD)__stdinp) = v1;
    if (v1 >= 0)
    {
      v2 = __stdinp->_p++;
      v5 = *v2;
    }
    else
    {
      v5 = __srget(__stdinp);
    }
    if (v5 == 10)
      break;
    if (v5 == -1)
    {
      if (i == a1)
      {
        funlockfile(__stdinp);
        return 0;
      }
      break;
    }
    v3 = i;
    *v3 = v5;
  }
  *i = 0;
  funlockfile(__stdinp);
  return a1;
}

int getw(FILE *a1)
{
  int v3;
  FILE *v4;

  v4 = a1;
  v3 = 0;
  if (fread(&v3, 4uLL, 1uLL, a1) == 1)
    return v3;
  else
    return -1;
}

wint_t getwc(FILE *a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return fgetwc_l(a1, v5);
  else
    return fgetwc_l(a1, (locale_t)__global_locale);
}

wint_t getwc_l(FILE *a1, locale_t a2)
{
  return fgetwc_l(a1, a2);
}

wint_t getwchar(void)
{
  char v0;
  char v1;
  FILE *v3;
  _xlocale *v4;
  uint64_t v5;

  v3 = __stdinp;
  if (v0)
    v1 = 1;
  else
    v1 = 0;
  if ((v1 & 1) != 0)
  {
    v4 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v5 = __locale_key;
    v4 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v5);
  }
  if (v4)
    return fgetwc_l(v3, v4);
  else
    return fgetwc_l(v3, (locale_t)__global_locale);
}

wint_t getwchar_l(locale_t a1)
{
  return fgetwc_l(__stdinp, a1);
}

uint64_t __smakebuf(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  v9 = result;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  if ((*(_WORD *)(result + 16) & 2) != 0)
  {
    v1 = v9 + 119;
    *(_QWORD *)v9 = v9 + 119;
    *(_QWORD *)(v9 + 24) = v1;
    *(_DWORD *)(v9 + 32) = 1;
    return result;
  }
  v7 = __swhatbuf(v9, &v6, &v5);
  if (*(__int16 *)(v9 + 18) >= 0)
  {
    result = __senvbuf(v9, (uint64_t *)&v6, &v5);
    v7 |= result;
    if ((v7 & 2) != 0)
    {
      *(_WORD *)(v9 + 16) |= 2u;
      v2 = v9 + 119;
      *(_QWORD *)v9 = v9 + 119;
      *(_QWORD *)(v9 + 24) = v2;
      *(_DWORD *)(v9 + 32) = 1;
      return result;
    }
    if (!v6)
      v6 = 1024;
  }
  if (v5)
  {
    if (isatty(*(__int16 *)(v9 + 18)))
    {
      v7 |= 1u;
      if (v6 > 0x1000)
      {
        v6 = 4096;
        *(_DWORD *)(v9 + 136) = 4096;
      }
    }
  }
  result = malloc_type_malloc(v6, 520473714);
  v8 = result;
  if (result)
  {
    __cleanup = 1;
    v7 |= 0x80u;
    v4 = v8;
    *(_QWORD *)v9 = v8;
    *(_QWORD *)(v9 + 24) = v4;
    *(_DWORD *)(v9 + 32) = v6;
    *(_WORD *)(v9 + 16) |= v7;
  }
  else
  {
    *(_WORD *)(v9 + 16) |= 2u;
    v3 = v9 + 119;
    *(_QWORD *)v9 = v9 + 119;
    *(_QWORD *)(v9 + 24) = v3;
    *(_DWORD *)(v9 + 32) = 1;
  }
  return result;
}

uint64_t __swhatbuf(uint64_t a1, _QWORD *a2, _DWORD *a3)
{
  BOOL v5;
  blksize_t st_blksize;
  stat v7;
  _DWORD *v8;
  _QWORD *v9;
  uint64_t v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  _platform_memset(&v7, 0, 144);
  if (*(__int16 *)(v10 + 18) >= 0 && fstat(*(__int16 *)(v10 + 18), &v7) >= 0)
  {
    *v8 = (v7.st_mode & 0xF000) == 0x2000;
    if (v7.st_blksize > 0)
    {
      if (v7.st_blksize <= 0x1000000)
        st_blksize = v7.st_blksize;
      else
        st_blksize = 0x1000000;
      *v9 = st_blksize;
      *(_DWORD *)(v10 + 136) = st_blksize;
      v5 = 0;
      if ((v7.st_mode & 0xF000) == 0x8000)
        v5 = *(_QWORD *)(v10 + 72) == (_QWORD)__sseek;
      if (v5)
        return 1024;
      else
        return 2048;
    }
    else
    {
      *v9 = 1024;
      return 2048;
    }
  }
  else
  {
    *v8 = 0;
    *v9 = 1024;
    return 2048;
  }
}

uint64_t __senvbuf(uint64_t a1, uint64_t *a2, _DWORD *a3)
{
  uint64_t v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  char *v8;

  v7 = 0;
  v8 = __getevp(*(__int16 *)(a1 + 18));
  if (!v8 || !*v8)
    return 0;
  v6 = (*v8 - 48);
  if (v6 <= 0x45)
    __asm { BR              X8 }
  while (isdigit(*v8))
    v7 = 10 * v7 + *v8++ - 48;
  v5 = *v8;
  if (*v8 && v5 != 66)
  {
    if (v5 == 75)
    {
LABEL_15:
      ++v8;
      v7 <<= 10;
      goto LABEL_16;
    }
    if (v5 != 77)
    {
      if (v5 != 107)
        return 0;
      goto LABEL_15;
    }
    ++v8;
    v7 <<= 20;
  }
LABEL_16:
  if (*v8 == 66)
    ++v8;
  if (!*v8)
  {
    *a3 = 0;
    if (v7 <= 0x1000000)
      v4 = v7;
    else
      v4 = 0x1000000;
    *a2 = v4;
  }
  return 0;
}

char *__getevp(int a1)
{
  if (__getevp_predicate != -1)
    _os_once(&__getevp_predicate, 0, __evpinit);
  if (a1)
  {
    if (a1 == 1)
    {
      if (__stdout_evp)
        return &__stdout_evp;
    }
    else if (a1 == 2 && __stderr_evp)
    {
      return &__stderr_evp;
    }
  }
  else if (__stdin_evp)
  {
    return &__stdin_evp;
  }
  if (__fallback_evp)
    return &__fallback_evp;
  else
    return 0;
}

char *__evpinit()
{
  __loadevp("STDBUF", (uint64_t)&__fallback_evp);
  __loadevp("STDBUF0", (uint64_t)&__stdin_evp);
  __loadevp("STDBUF1", (uint64_t)&__stdout_evp);
  __loadevp("STDBUF2", (uint64_t)&__stderr_evp);
  __loadevp("_STDBUF_I", (uint64_t)&__stdin_evp);
  __loadevp("_STDBUF_O", (uint64_t)&__stdout_evp);
  return __loadevp("_STDBUF_E", (uint64_t)&__stderr_evp);
}

char *__loadevp(const char *a1, uint64_t a2)
{
  char *result;

  result = getenv(a1);
  if (result)
    return (char *)_platform_strlcpy(a2, result, 16);
  return result;
}

int mkostemps(char *path, int slen, int oflags)
{
  int v5;
  int v6;
  int v7;
  char *v8;

  v8 = path;
  v7 = slen;
  v6 = oflags;
  v5 = 0;
  if ((oflags & 0xFEFFFFC7) != 0)
  {
    *__error() = 22;
    return -1;
  }
  else if (find_temp_path(-2, v8, v7, 1, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mkostemps_action, (uint64_t)&v6, (uint64_t)&v5))
  {
    return v5;
  }
  else
  {
    return -1;
  }
}

uint64_t find_temp_path(int a1, char *a2, int a3, char a4, uint64_t (*a5)(_QWORD, char *, uint64_t, uint64_t), uint64_t a6, uint64_t a7)
{
  char v7;
  char *v8;
  char v10;
  int v11;
  BOOL v12;
  int v13;
  stat v14;
  char *v15;
  char *j;
  char *v17;
  char *i;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t (*v22)(_QWORD, char *, uint64_t, uint64_t);
  char v23;
  int v24;
  char *v25;
  int v26;
  _BYTE v28[1024];

  v26 = a1;
  v25 = a2;
  v24 = a3;
  v23 = a4 & 1;
  v22 = a5;
  v21 = a6;
  v20 = a7;
  v19 = 0;
  i = 0;
  v17 = 0;
  j = 0;
  v15 = 0;
  _platform_memset(&v14, 0, 144);
  if (v24 < 0)
    goto LABEL_2;
  for (i = v25; *i; ++i)
    ;
  if (i - v25 >= 1024)
  {
    *__error() = 63;
    return 0;
  }
  i -= v24;
  v17 = i;
  if (--i < v25 || _platform_strchr(v17, 47))
  {
LABEL_2:
    *__error() = 22;
    return 0;
  }
  else
  {
    while (1)
    {
      v12 = 0;
      if (i >= v25)
        v12 = *i == 88;
      if (!v12)
        break;
      v7 = padchar[arc4random_uniform(0x3Eu)];
      v8 = i--;
      *v8 = v7;
    }
    v19 = i + 1;
    j___platform_memmove(v28, i + 1, v17 - (i + 1));
    if ((v23 & 1) != 0)
    {
      while (i > v25)
      {
        if (*i == 47)
        {
          *i = 0;
          v13 = fstatat(v26, v25, &v14, 0);
          *i = 47;
          if (v13)
            return 0;
          if ((v14.st_mode & 0xF000) != 0x4000)
          {
            *__error() = 20;
            return 0;
          }
          break;
        }
        --i;
      }
    }
LABEL_24:
    v11 = v22(v26, v25, v21, v20);
    if (v11)
    {
      if (v11 == 2)
      {
        return 0;
      }
      else
      {
        i = v19;
        for (j = v28; ; ++j)
        {
          if (i == v17)
          {
            *__error() = 17;
            return 0;
          }
          v15 = (char *)_platform_strchr("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", *i);
          if (!v15)
            break;
          if (*++v15)
            v10 = *v15;
          else
            v10 = padchar[0];
          *i = v10;
          if (*i != *j)
            goto LABEL_24;
          ++i;
        }
        *__error() = 5;
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
}

uint64_t _mkostemps_action(unsigned int a1, uint64_t a2, int *a3, int *a4)
{
  int v6;
  int v7;

  if (a3)
    v6 = *a3;
  else
    v6 = 0;
  v7 = openat_NOCANCEL(a1, a2, v6 | 0xA02u);
  if (v7 < 0)
  {
    if (*__error() == 17)
      return 1;
    else
      return 2;
  }
  else
  {
    *a4 = v7;
    return 0;
  }
}

int mkostempsat_np(int dfd, char *path, int slen, int oflags)
{
  int v6;
  int v7;
  int v8;
  char *v9;
  int v10;

  v10 = dfd;
  v9 = path;
  v8 = slen;
  v7 = oflags;
  v6 = 0;
  if ((oflags & 0xFEFFFFC7) != 0)
  {
    *__error() = 22;
    return -1;
  }
  else if (find_temp_path(v10, v9, v8, 1, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mkostemps_action, (uint64_t)&v7, (uint64_t)&v6))
  {
    return v6;
  }
  else
  {
    return -1;
  }
}

int mkstemps(char *a1, int a2)
{
  _DWORD v4[2];
  char *v5;

  v5 = a1;
  v4[1] = a2;
  v4[0] = 0;
  if (find_temp_path(-2, a1, a2, 1, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mkostemps_action, 0, (uint64_t)v4))return v4[0];
  else
    return -1;
}

int mkstempsat_np(int dfd, char *path, int slen)
{
  _DWORD v5[2];
  char *v6;
  int v7;

  v7 = dfd;
  v6 = path;
  v5[1] = slen;
  v5[0] = 0;
  if (find_temp_path(dfd, path, slen, 1, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mkostemps_action, 0, (uint64_t)v5))return v5[0];
  else
    return -1;
}

int mkostemp(char *path, int oflags)
{
  int v4;
  int v5;
  char *v6;

  v6 = path;
  v5 = oflags;
  v4 = 0;
  if ((oflags & 0xFEFFFFC7) != 0)
  {
    *__error() = 22;
    return -1;
  }
  else if (find_temp_path(-2, v6, 0, 1, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mkostemps_action, (uint64_t)&v5, (uint64_t)&v4))
  {
    return v4;
  }
  else
  {
    return -1;
  }
}

int mkstemp(char *a1)
{
  int v3;
  char *v4;

  v4 = a1;
  v3 = 0;
  if (find_temp_path(-2, a1, 0, 1, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mkostemps_action, 0, (uint64_t)&v3))return v3;
  else
    return -1;
}

char *__cdecl mkdtemp(char *a1)
{
  if (find_temp_path(-2, a1, 0, 1, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mkdtemp_action, 0, 0))return a1;
  else
    return 0;
}

uint64_t _mkdtemp_action(int a1, const char *a2)
{
  if (mkdirat(a1, a2, 0x1C0u))
  {
    if (*__error() == 17)
      return 1;
    else
      return 2;
  }
  else
  {
    return 0;
  }
}

char *__cdecl mkdtempat_np(int dfd, char *path)
{
  if (find_temp_path(dfd, path, 0, 1, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mkdtemp_action, 0, 0))return path;
  else
    return 0;
}

char *_mktemp(char *a1)
{
  if (find_temp_path(-2, a1, 0, 0, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mktemp_action, 0, 0))return a1;
  else
    return 0;
}

uint64_t _mktemp_action(int a1, const char *a2, uint64_t a3, uint64_t a4)
{
  stat v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  int v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = a4;
  _platform_memset(&v6, 0, 144);
  if (fstatat(v10, v9, &v6, 32))
  {
    if (*__error() == 2)
      return 0;
    else
      return 2;
  }
  else
  {
    return 1;
  }
}

char *__cdecl mktemp(char *a1)
{
  return _mktemp(a1);
}

int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
{
  _DWORD v5[3];
  char *v6;
  _DWORD v7[2];

  v6 = path;
  v5[2] = dpclass;
  v5[1] = dpflags;
  v5[0] = 0;
  v7[0] = dpclass;
  v7[1] = dpflags;
  if (find_temp_path(-2, path, 0, 1, (uint64_t (*)(_QWORD, char *, uint64_t, uint64_t))_mkstemp_dprotected_np_action, (uint64_t)v7, (uint64_t)v5))return v5[0];
  else
    return -1;
}

uint64_t _mkstemp_dprotected_np_action(int a1, const char *a2, int *a3, int *a4)
{
  int v6;

  if (a1 != -2)
    __assert_rtn("_mkstemp_dprotected_np_action", "mktemp.c", 321, "dfd == AT_FDCWD");
  v6 = open_dprotected_np(a2, 2562, *a3, a3[1], 384);
  if (v6 < 0)
  {
    if (*__error() == 17)
      return 1;
    else
      return 2;
  }
  else
  {
    *a4 = v6;
    return 0;
  }
}

int rpmatch(const char *a1)
{
  char *v1;
  char *v2;
  int v4;
  regex_t v5;
  regex_t v6;
  const char *v7;

  v7 = a1;
  memset(&v6, 0, sizeof(v6));
  memset(&v5, 0, sizeof(v5));
  v1 = nl_langinfo(52);
  if (regcomp(&v6, v1, 5))
    return -1;
  v2 = nl_langinfo(53);
  if (regcomp(&v5, v2, 5))
  {
    regfree(&v6);
    return -1;
  }
  else
  {
    if (regexec(&v6, v7, 0, 0, 0))
    {
      if (regexec(&v5, v7, 0, 0, 0))
        v4 = -1;
      else
        v4 = 0;
    }
    else
    {
      v4 = 1;
    }
    regfree(&v6);
    regfree(&v5);
    return v4;
  }
}

BOOL __find_arguments(char *a1, _DWORD *a2, uint64_t *a3)
{
  char *v3;
  BOOL v5;
  unint64_t v6;
  BOOL v7;
  void *v8[6];
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  char *v14;
  uint64_t *v15;
  _DWORD *v16;
  char *v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  _platform_memset(v8, 0, 56);
  v14 = v17;
  inittypes((uint64_t)v8);
  v11 = 0;
  do
  {
    while (1)
    {
      v13 = *v14;
      v7 = 0;
      if (v13)
        v7 = v13 != 37;
      if (!v7)
        break;
      ++v14;
    }
    if (!v13)
      break;
    ++v14;
    v10 = 0;
    v9 = 0;
    v3 = v14++;
    v13 = *v3;
    v6 = (v13 - 32);
    if (v6 <= 0x5A)
      __asm { BR              X8 }
  }
  while (v13);
  build_arg_table((uint64_t)v8, v16, v15);
  freetypes(v8);
  v5 = 1;
  if (!v11)
    return *v15 == 0;
  return v5;
}

uint64_t inittypes(uint64_t result)
{
  int i;

  *(_QWORD *)result = result + 8;
  *(_DWORD *)(result + 40) = 8;
  *(_DWORD *)(result + 44) = 0;
  *(_DWORD *)(result + 48) = 1;
  for (i = 0; i < 8; ++i)
    *(_DWORD *)(*(_QWORD *)result + 4 * i) = 0;
  return result;
}

uint64_t addaster(_DWORD *a1, _BYTE **a2)
{
  int v3;
  int v4;
  _BYTE *i;

  v4 = 0;
  for (i = *a2; ((char)*i - 48) <= 9; ++i)
    v4 = 10 * v4 + (char)*i - 48;
  if (*i != 36)
  {
    if (addtype(a1, 2))
      return -1;
    return 0;
  }
  v3 = a1[12];
  a1[12] = v4;
  if (!addtype(a1, 2))
  {
    a1[12] = v3;
    *a2 = i + 1;
    return 0;
  }
  return -1;
}

uint64_t addtype(_DWORD *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;

  if (_ensurespace(a1))
  {
    return -1;
  }
  else
  {
    v2 = *(_QWORD *)a1;
    v3 = (int)a1[12]++;
    *(_DWORD *)(v2 + 4 * v3) = a2;
    return 0;
  }
}

uint64_t addsarg(_DWORD *a1, __int16 a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (_ensurespace(a1))
  {
    return -1;
  }
  else
  {
    if ((a2 & 0x1000) != 0)
    {
      v2 = *(_QWORD *)a1;
      v3 = (int)a1[12]++;
      *(_DWORD *)(v2 + 4 * v3) = 16;
    }
    else if ((a2 & 0x400) != 0)
    {
      v4 = *(_QWORD *)a1;
      v5 = (int)a1[12]++;
      *(_DWORD *)(v4 + 4 * v5) = 13;
    }
    else if ((a2 & 0x800) != 0)
    {
      v6 = *(_QWORD *)a1;
      v7 = (int)a1[12]++;
      *(_DWORD *)(v6 + 4 * v7) = 11;
    }
    else if ((a2 & 0x20) != 0)
    {
      v8 = *(_QWORD *)a1;
      v9 = (int)a1[12]++;
      *(_DWORD *)(v8 + 4 * v9) = 8;
    }
    else
    {
      v10 = *(_QWORD *)a1;
      v11 = (int)a1[12]++;
      if ((a2 & 0x10) != 0)
        *(_DWORD *)(v10 + 4 * v11) = 5;
      else
        *(_DWORD *)(v10 + 4 * v11) = 2;
    }
    return 0;
  }
}

uint64_t adduarg(_DWORD *a1, __int16 a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (_ensurespace(a1))
  {
    return -1;
  }
  else
  {
    if ((a2 & 0x1000) != 0)
    {
      v2 = *(_QWORD *)a1;
      v3 = (int)a1[12]++;
      *(_DWORD *)(v2 + 4 * v3) = 17;
    }
    else if ((a2 & 0x400) != 0)
    {
      v4 = *(_QWORD *)a1;
      v5 = (int)a1[12]++;
      *(_DWORD *)(v4 + 4 * v5) = 14;
    }
    else if ((a2 & 0x800) != 0)
    {
      v6 = *(_QWORD *)a1;
      v7 = (int)a1[12]++;
      *(_DWORD *)(v6 + 4 * v7) = 14;
    }
    else if ((a2 & 0x20) != 0)
    {
      v8 = *(_QWORD *)a1;
      v9 = (int)a1[12]++;
      *(_DWORD *)(v8 + 4 * v9) = 9;
    }
    else
    {
      v10 = *(_QWORD *)a1;
      v11 = (int)a1[12]++;
      if ((a2 & 0x10) != 0)
        *(_DWORD *)(v10 + 4 * v11) = 6;
      else
        *(_DWORD *)(v10 + 4 * v11) = 3;
    }
    return 0;
  }
}

uint64_t build_arg_table(uint64_t result, _DWORD *a2, uint64_t *a3)
{
  _DWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  _OWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _DWORD *v28;
  _QWORD *v29;
  int i;
  uint64_t v33;

  v33 = result;
  if (*(int *)(result + 44) < 8
    || (result = malloc_type_malloc(16 * (*(_DWORD *)(result + 44) + 1), 0x1092040C99D0F4CLL), (*a3 = result) != 0))
  {
    *(_DWORD *)*a3 = 0;
    for (i = 1; i <= *(_DWORD *)(v33 + 44); ++i)
    {
      switch(*(_DWORD *)(*(_QWORD *)v33 + 4 * i))
      {
        case 0:
          v3 = a2;
          a2 += 2;
          *(_DWORD *)(*a3 + 16 * i) = *v3;
          break;
        case 1:
          v5 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v5;
          break;
        case 2:
          v6 = a2;
          a2 += 2;
          *(_DWORD *)(*a3 + 16 * i) = *v6;
          break;
        case 3:
          v7 = a2;
          a2 += 2;
          *(_DWORD *)(*a3 + 16 * i) = *v7;
          break;
        case 4:
          v8 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v8;
          break;
        case 5:
          v9 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v9;
          break;
        case 6:
          v10 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v10;
          break;
        case 7:
          v11 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v11;
          break;
        case 8:
          v12 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v12;
          break;
        case 9:
          v13 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v13;
          break;
        case 0xA:
          v14 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v14;
          break;
        case 0xB:
          v15 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v15;
          break;
        case 0xC:
          v16 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v16;
          break;
        case 0xD:
          v18 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v18;
          break;
        case 0xE:
          v17 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v17;
          break;
        case 0xF:
          v19 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v19;
          break;
        case 0x10:
          v20 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v20;
          break;
        case 0x11:
          v21 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v21;
          break;
        case 0x12:
          v22 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v22;
          break;
        case 0x13:
          v27 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v27;
          break;
        case 0x14:
          v26 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v26;
          break;
        case 0x15:
          v4 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v4;
          break;
        case 0x16:
          v23 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v23;
          break;
        case 0x17:
          v24 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v24;
          break;
        case 0x18:
          v28 = a2;
          a2 += 2;
          *(_DWORD *)(*a3 + 16 * i) = *v28;
          break;
        case 0x19:
          v29 = a2;
          a2 += 2;
          *(_QWORD *)(*a3 + 16 * i) = *v29;
          break;
        case 0x1A:
          v25 = (_OWORD *)(((unint64_t)a2 + 15) & 0xFFFFFFFFFFFFFFF0);
          a2 = v25 + 1;
          *(_OWORD *)(*a3 + 16 * i) = *v25;
          break;
        default:
          continue;
      }
    }
  }
  return result;
}

void freetypes(void **a1)
{
  if (*a1 != a1 + 1)
    free(*a1);
}

BOOL __find_warguments(int *a1, _DWORD *a2, uint64_t *a3)
{
  int *v3;
  BOOL v5;
  unint64_t v6;
  BOOL v7;
  void *v8[6];
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int *v14;
  uint64_t *v15;
  _DWORD *v16;
  int *v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  _platform_memset(v8, 0, 56);
  v14 = v17;
  inittypes((uint64_t)v8);
  v11 = 0;
  do
  {
    while (1)
    {
      v13 = *v14;
      v7 = 0;
      if (v13)
        v7 = v13 != 37;
      if (!v7)
        break;
      ++v14;
    }
    if (!v13)
      break;
    ++v14;
    v10 = 0;
    v9 = 0;
    v3 = v14++;
    v13 = *v3;
    v6 = (v13 - 32);
    if (v6 <= 0x5A)
      __asm { BR              X8 }
  }
  while (v13);
  build_arg_table((uint64_t)v8, v16, v15);
  freetypes(v8);
  v5 = 1;
  if (!v11)
    return *v15 == 0;
  return v5;
}

uint64_t addwaster(_DWORD *a1, _DWORD **a2)
{
  int v3;
  int v4;
  _DWORD *i;

  v4 = 0;
  for (i = *a2; (*i - 48) <= 9; ++i)
    v4 = 10 * v4 + *i - 48;
  if (*i != 36)
  {
    if (addtype(a1, 2))
      return -1;
    return 0;
  }
  v3 = a1[12];
  a1[12] = v4;
  if (!addtype(a1, 2))
  {
    a1[12] = v3;
    *a2 = i + 1;
    return 0;
  }
  return -1;
}

uint64_t _ensurespace(_DWORD *a1)
{
  if (a1[12] >= a1[10] && __grow_type_table((uint64_t)a1))
  {
    return -1;
  }
  else
  {
    if (a1[12] > a1[11])
      a1[11] = a1[12];
    return 0;
  }
}

uint64_t __grow_type_table(uint64_t a1)
{
  int v2;
  int i;
  void *v4;
  int v5;
  const void *v6;

  v6 = *(const void **)a1;
  v5 = *(_DWORD *)(a1 + 40);
  v2 = 2 * v5;
  if (2 * v5 < *(_DWORD *)(a1 + 48) + 1)
    v2 = *(_DWORD *)(a1 + 48) + 1;
  if (v5 == 8)
  {
    v4 = (void *)malloc_type_malloc(4 * v2, 0x100004052888210);
    if (!v4)
      return -1;
    bcopy(v6, v4, 0x20uLL);
  }
  else
  {
    v4 = (void *)malloc_type_realloc(v6, 4 * v2, 0x100004052888210);
    if (!v4)
      return -1;
  }
  for (i = v5; i < v2; ++i)
    *((_DWORD *)v4 + i) = 0;
  *(_QWORD *)a1 = v4;
  *(_DWORD *)(a1 + 40) = v2;
  return 0;
}

int printf(const char *a1, ...)
{
  char v1;
  char v2;
  FILE *v4;
  _xlocale *v6;
  uint64_t v7;
  va_list va;

  va_start(va, a1);
  v4 = __stdoutp;
  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v6 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v7 = __locale_key;
    v6 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6)
    return vfprintf_l(v4, v6, a1, va);
  else
    return vfprintf_l(v4, (locale_t)__global_locale, a1, va);
}

int printf_l(locale_t a1, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return vfprintf_l(__stdoutp, a1, a2, va);
}

int putc(int a1, FILE *a2)
{
  int v2;
  unsigned __int8 *v3;
  int v7;

  flockfile(a2);
  v2 = a2->_w - 1;
  a2->_w = v2;
  if (v2 < 0 && (a2->_w < a2->_lbfsize || (char)a1 == 10))
  {
    v7 = __swbuf(a1, a2);
  }
  else
  {
    v3 = a2->_p++;
    *v3 = a1;
    v7 = a1;
  }
  funlockfile(a2);
  return v7;
}

int putc_unlocked(int a1, FILE *a2)
{
  int v2;
  unsigned __int8 *v3;

  v2 = a2->_w - 1;
  a2->_w = v2;
  if (v2 < 0 && (a2->_w < a2->_lbfsize || (char)a1 == 10))
    return __swbuf(a1, a2);
  v3 = a2->_p++;
  *v3 = a1;
  return a1;
}

int putchar(int a1)
{
  int v1;
  unsigned __int8 *v2;
  FILE *v4;
  int v6;

  v4 = __stdoutp;
  flockfile(__stdoutp);
  v1 = v4->_w - 1;
  v4->_w = v1;
  if (v1 < 0 && (v4->_w < v4->_lbfsize || (char)a1 == 10))
  {
    v6 = __swbuf(a1, v4);
  }
  else
  {
    v2 = v4->_p++;
    *v2 = a1;
    v6 = a1;
  }
  funlockfile(v4);
  return v6;
}

int putchar_unlocked(int a1)
{
  int v1;
  unsigned __int8 *v2;
  FILE *v4;

  v4 = __stdoutp;
  v1 = __stdoutp->_w - 1;
  __stdoutp->_w = v1;
  if (v1 < 0 && (v4->_w < v4->_lbfsize || (char)a1 == 10))
    return __swbuf(a1, v4);
  v2 = v4->_p++;
  *v2 = a1;
  return a1;
}

int puts(const char *a1)
{
  int v1;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  const char *v7;
  _QWORD v8[4];

  v7 = a1;
  v6 = 0;
  v5 = 0;
  v3 = 0;
  v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a1);
  if (!v7)
    v7 = "(null)";
  v8[0] = v7;
  v5 = _platform_strlen(v7);
  v8[1] = v5;
  v8[2] = "\n";
  v8[3] = 1;
  HIDWORD(v4) = v5 + 1;
  v3 = v8;
  LODWORD(v4) = 2;
  flockfile(__stdoutp);
  if (!((char)(32 * *((_BYTE *)&stru_20.fileoff + *(_QWORD *)&stru_68.sectname[(_QWORD)__stdoutp])) >> 5))
    *((_BYTE *)&stru_20.fileoff + *(_QWORD *)&stru_68.sectname[(_QWORD)__stdoutp]) = *((_BYTE *)&stru_20.fileoff
                                                                                     + *(_QWORD *)&stru_68.sectname[(_QWORD)__stdoutp]) & 0xF8 | 7;
  if (__sfvwrite(__stdoutp, (uint64_t)&v3))
    v1 = -1;
  else
    v1 = 10;
  v6 = v1;
  funlockfile(__stdoutp);
  return v6;
}

int putw(int a1, FILE *a2)
{
  _QWORD v3[2];
  _QWORD v4[2];
  int v5;
  FILE *v6;
  int v7;

  v7 = a1;
  v6 = a2;
  v5 = 0;
  v3[0] = &v7;
  v3[1] = 4;
  v4[0] = v3;
  v4[1] = 0x400000001;
  flockfile(a2);
  v5 = __sfvwrite(v6, (uint64_t)v4);
  funlockfile(v6);
  return v5;
}

wint_t putwc(__int32 a1, FILE *a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return fputwc_l(a1, a2, v7);
  else
    return fputwc_l(a1, a2, (locale_t)__global_locale);
}

wint_t putwc_l(__int32 a1, FILE *a2, locale_t a3)
{
  return fputwc_l(a1, a2, a3);
}

wint_t putwchar(__int32 a1)
{
  char v1;
  char v2;
  FILE *v5;
  _xlocale *v6;
  uint64_t v7;

  v5 = __stdoutp;
  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v6 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v7 = __locale_key;
    v6 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6)
    return fputwc_l(a1, v5, v6);
  else
    return fputwc_l(a1, v5, (locale_t)__global_locale);
}

wint_t putwchar_l(__int32 a1, locale_t a2)
{
  return fputwc_l(a1, __stdoutp, a2);
}

uint64_t __srefill0(uint64_t a1)
{
  int v1;

  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  if (!((char)(32 * *(_BYTE *)(*(_QWORD *)(a1 + 104) + 72)) >> 5))
    *(_BYTE *)(*(_QWORD *)(a1 + 104) + 72) = *(_BYTE *)(*(_QWORD *)(a1 + 104) + 72) & 0xF8 | 7;
  *(_DWORD *)(a1 + 8) = 0;
  if ((*(_WORD *)(a1 + 16) & 0x20) != 0)
  {
    return -1;
  }
  else
  {
    if ((*(_WORD *)(a1 + 16) & 4) != 0)
    {
      if (*(_QWORD *)(a1 + 88))
      {
        if (*(_QWORD *)(a1 + 88) != a1 + 116)
          free(*(void **)(a1 + 88));
        *(_QWORD *)(a1 + 88) = 0;
        v1 = *(_DWORD *)(a1 + 112);
        *(_DWORD *)(a1 + 8) = v1;
        if (v1)
        {
          *(_QWORD *)a1 = **(_QWORD **)(a1 + 104);
          return 0;
        }
      }
    }
    else
    {
      if ((*(_WORD *)(a1 + 16) & 0x10) == 0)
      {
        *__error() = 9;
        *(_WORD *)(a1 + 16) |= 0x40u;
        return -1;
      }
      if ((*(_WORD *)(a1 + 16) & 8) != 0)
      {
        if (__sflush(a1))
          return -1;
        *(_WORD *)(a1 + 16) &= ~8u;
        *(_DWORD *)(a1 + 12) = 0;
        *(_DWORD *)(a1 + 40) = 0;
      }
      *(_WORD *)(a1 + 16) |= 4u;
    }
    if (!*(_QWORD *)(a1 + 24))
      __smakebuf(a1);
    if ((*(_WORD *)(a1 + 16) & 3) != 0)
    {
      *(_WORD *)(a1 + 16) |= 0x8000u;
      _fwalk((uint64_t (*)(uint64_t *))lflush);
      *(_WORD *)(a1 + 16) &= ~0x8000u;
      if ((*(_WORD *)(a1 + 16) & 9) == 9)
        __sflush(a1);
    }
    return 1;
  }
}

uint64_t lflush(FILE *a1)
{
  unsigned int v2;

  v2 = 0;
  if ((a1->_flags & 9) == 9)
  {
    flockfile(a1);
    v2 = __sflush((uint64_t)a1);
    funlockfile(a1);
  }
  return v2;
}

uint64_t __srefill1(uint64_t a1)
{
  *(_QWORD *)a1 = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 8) = _sread(a1, *(_QWORD *)a1, *(_DWORD *)(a1 + 32));
  *(_WORD *)(a1 + 16) &= ~0x2000u;
  if (*(int *)(a1 + 8) > 0)
  {
    return 0;
  }
  else
  {
    if (*(_DWORD *)(a1 + 8))
    {
      *(_DWORD *)(a1 + 8) = 0;
      *(_WORD *)(a1 + 16) |= 0x40u;
    }
    else
    {
      *(_WORD *)(a1 + 16) |= 0x20u;
    }
    return -1;
  }
}

uint64_t __srefill(uint64_t a1)
{
  int v2;

  v2 = __srefill0(a1);
  if (v2 > 0)
    return __srefill1(a1);
  else
    return v2;
}

int remove(const char *a1)
{
  stat v2;
  const char *v3;

  v3 = a1;
  _platform_memset(&v2, 0, 144);
  if (lstat(v3, &v2) < 0)
    return -1;
  if ((v2.st_mode & 0xF000) == 0x4000)
    return rmdir(v3);
  return unlink(v3);
}

void rewind(FILE *a1)
{
  int v1;

  v1 = *__error();
  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  flockfile(a1);
  if (!_fseeko((uint64_t)a1, 0, 0, 1))
    *__error() = v1;
  a1->_flags &= 0xFF9Fu;
  funlockfile(a1);
}

int __srget(FILE *a1)
{
  unsigned __int8 *v1;

  if (__srefill((uint64_t)a1))
    return -1;
  --a1->_r;
  v1 = a1->_p++;
  return *v1;
}

int scanf(const char *a1, ...)
{
  char v1;
  char v2;
  int v3;
  int *v5;
  int v6;
  _xlocale *v8;
  uint64_t v9;

  flockfile(__stdinp);
  v5 = (int *)__stdinp;
  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v8 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    v3 = __svfscanf_l(v5, v8, (uint64_t)a1);
  else
    v3 = __svfscanf_l(v5, (_xlocale *)__global_locale, (uint64_t)a1);
  v6 = v3;
  funlockfile(__stdinp);
  return v6;
}

int scanf_l(locale_t a1, const char *a2, ...)
{
  int v3;
  _xlocale *v5;

  v5 = a1;
  if (a1)
  {
    if (a1 == (locale_t)-1)
      v5 = (_xlocale *)__global_locale;
  }
  else
  {
    v5 = (_xlocale *)&__c_locale;
  }
  flockfile(__stdinp);
  v3 = __svfscanf_l((int *)__stdinp, v5, (uint64_t)a2);
  funlockfile(__stdinp);
  return v3;
}

void setbuf(FILE *a1, char *a2)
{
  int v2;

  if (a2)
    v2 = 0;
  else
    v2 = 2;
  setvbuf(a1, a2, v2, 0x400uLL);
}

void setbuffer(FILE *a1, char *a2, int a3)
{
  int v3;

  if (a2)
    v3 = 0;
  else
    v3 = 2;
  setvbuf(a1, a2, v3, a3);
}

int setlinebuf(FILE *a1)
{
  return setvbuf(a1, 0, 1, 0);
}

int setvbuf(FILE *a1, char *a2, int a3, size_t a4)
{
  int v4;
  unsigned __int8 *nbuf;
  unsigned __int8 *v6;
  int v8;
  size_t v9;
  int flags;
  int v11;
  size_t v12;
  unsigned int v13;
  unsigned __int8 *v14;
  FILE *v15;

  v15 = a1;
  v14 = (unsigned __int8 *)a2;
  v13 = a3;
  v12 = a4;
  v11 = 0;
  flags = 0;
  v9 = 0;
  v8 = 0;
  if (a3 != 2 && (v13 > 1 || (v12 & 0x80000000) != 0))
    return -1;
  libc_hooks_will_write((uint64_t)v15, 152);
  libc_hooks_will_write((uint64_t)v14, v12);
  flockfile(v15);
  v11 = 0;
  __sflush((uint64_t)v15);
  if (v15->_ub._base)
  {
    if (v15->_ub._base != v15->_ubuf)
      free(v15->_ub._base);
    v15->_ub._base = 0;
  }
  v15->_lbfsize = 0;
  v15->_r = 0;
  flags = v15->_flags;
  if ((flags & 0x80u) != 0)
    free(v15->_bf._base);
  flags &= 0xFFFFE35C;
  if (v13 == 2)
  {
LABEL_19:
    v15->_flags = flags | 2;
    v15->_w = 0;
    nbuf = v15->_nbuf;
    v15->_p = v15->_nbuf;
    v15->_bf._base = nbuf;
    v15->_bf._size = 1;
    funlockfile(v15);
    return v11;
  }
  v4 = __swhatbuf((uint64_t)v15, &v9, &v8);
  flags |= v4;
  if (!v12)
  {
    v14 = 0;
    v12 = v9;
  }
  if (!v14)
  {
    v14 = (unsigned __int8 *)malloc_type_malloc(v12, 989133389);
    if (!v14)
    {
      v11 = -1;
      if (v12 != v9)
      {
        v12 = v9;
        v14 = (unsigned __int8 *)malloc_type_malloc(v9, 2888471919);
      }
    }
    if (!v14)
      goto LABEL_19;
    flags |= 0x80u;
  }
  if (v12 != v9)
    flags |= 0x800u;
  if (v13 == 1)
    flags |= 1u;
  v15->_flags = flags;
  v6 = v14;
  v15->_p = v14;
  v15->_bf._base = v6;
  v15->_bf._size = v12;
  if ((flags & 8) != 0)
  {
    if ((flags & 1) != 0)
    {
      v15->_w = 0;
      v15->_lbfsize = -v15->_bf._size;
    }
    else
    {
      v15->_w = v12;
    }
  }
  else
  {
    v15->_w = 0;
  }
  __cleanup = 1;
  funlockfile(v15);
  return v11;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;
  va_list va;

  va_start(va, __format);
  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return vsnprintf_l(__str, __size, v9, __format, va);
  else
    return vsnprintf_l(__str, __size, (locale_t)__global_locale, __format, va);
}

int snprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  return vsnprintf_l(a1, a2, a3, a4, va);
}

int sprintf(char *a1, const char *a2, ...)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return vsprintf_l(a1, v7, a2, va);
  else
    return vsprintf_l(a1, (locale_t)&__global_locale, a2, va);
}

int sprintf_l(char *a1, locale_t a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return vsprintf_l(a1, a2, a3, va);
}

int sscanf(const char *a1, const char *a2, ...)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return vsscanf_l(a1, v7, a2, va);
  else
    return vsscanf_l(a1, (locale_t)__global_locale, a2, va);
}

int sscanf_l(const char *a1, locale_t a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return vsscanf_l(a1, a2, a3, va);
}

uint64_t __sread(uint64_t a1, uint64_t a2, int a3)
{
  return read_NOCANCEL(*(__int16 *)(a1 + 18), a2, a3);
}

uint64_t __swrite(uint64_t a1, uint64_t a2, int a3)
{
  return write_NOCANCEL(*(__int16 *)(a1 + 18), a2, a3);
}

off_t __sseek(uint64_t a1, off_t a2, int a3)
{
  return lseek(*(__int16 *)(a1 + 18), a2, a3);
}

uint64_t __sclose(uint64_t a1)
{
  return close_NOCANCEL(*(__int16 *)(a1 + 18));
}

uint64_t _sread(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v4;

  v4 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(a1 + 64))(*(_QWORD *)(a1 + 48), a2, a3);
  if (v4 <= 0)
  {
    if (v4 < 0)
      *(_WORD *)(a1 + 16) &= ~0x1000u;
  }
  else if ((*(_WORD *)(a1 + 16) & 0x1000) != 0)
  {
    if (*(_QWORD *)(a1 + 144) > 0x7FFFFFFFFFFFFFFFLL - v4)
      *(_WORD *)(a1 + 16) &= ~0x1000u;
    else
      *(_QWORD *)(a1 + 144) += v4;
  }
  return v4;
}

uint64_t _swrite(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v4;
  int v5;

  if ((*(_WORD *)(a1 + 16) & 0x100) != 0)
  {
    v4 = *__error();
    if (_sseek(a1, 0, 2u) == -1 && (*(_WORD *)(a1 + 16) & 0x400) != 0)
      return -1;
    *__error() = v4;
  }
  v5 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(a1 + 80))(*(_QWORD *)(a1 + 48), a2, a3);
  if (v5 < 0)
  {
    *(_WORD *)(a1 + 16) &= ~0x1000u;
  }
  else if ((*(_WORD *)(a1 + 16) & 0x1100) == 0x1100 && *(_QWORD *)(a1 + 144) <= 0x7FFFFFFFFFFFFFFFLL - v5)
  {
    *(_QWORD *)(a1 + 144) += v5;
  }
  else
  {
    *(_WORD *)(a1 + 16) &= ~0x1000u;
  }
  return v5;
}

uint64_t _sseek(uint64_t a1, uint64_t a2, unsigned int a3)
{
  int v4;
  int v5;
  uint64_t v6;

  v5 = *__error();
  *__error() = 0;
  v6 = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(a1 + 72))(*(_QWORD *)(a1 + 48), a2, a3);
  v4 = *__error();
  if (!*__error())
    *__error() = v5;
  if (v6 >= 0)
  {
    if ((*(_WORD *)(a1 + 16) & 0x400) != 0)
    {
      *(_WORD *)(a1 + 16) |= 0x1000u;
      *(_QWORD *)(a1 + 144) = v6;
    }
  }
  else
  {
    if (v4)
    {
      if (v4 == 29)
        *(_WORD *)(a1 + 16) &= ~0x100u;
    }
    else
    {
      if (a2 || a3 != 1)
      {
        if (*(_QWORD *)(a1 + 88))
        {
          if (*(_QWORD *)(a1 + 88) != a1 + 116)
            free(*(void **)(a1 + 88));
          *(_QWORD *)(a1 + 88) = 0;
        }
        *(_QWORD *)a1 = *(_QWORD *)(a1 + 24);
        *(_DWORD *)(a1 + 8) = 0;
        *(_WORD *)(a1 + 16) &= ~0x20u;
      }
      *(_WORD *)(a1 + 16) |= 0x40u;
      *__error() = 22;
    }
    *(_WORD *)(a1 + 16) &= ~0x1000u;
    return -1;
  }
  return v6;
}

int swprintf(__int32 *a1, size_t a2, const __int32 *a3, ...)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;
  va_list va;

  va_start(va, a3);
  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return vswprintf_l(a1, a2, v9, a3, va);
  else
    return vswprintf_l(a1, a2, (locale_t)__global_locale, a3, va);
}

int swprintf_l(__int32 *a1, size_t n, locale_t a3, const __int32 *a4, ...)
{
  va_list va;

  va_start(va, a4);
  return vswprintf_l(a1, n, a3, a4, va);
}

int swscanf(const __int32 *a1, const __int32 *a2, ...)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;
  va_list va;

  va_start(va, a2);
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return vswscanf_l(a1, v7, a2, va);
  else
    return vswscanf_l(a1, (locale_t)__global_locale, a2, va);
}

int swscanf_l(const __int32 *a1, locale_t a2, const __int32 *a3, ...)
{
  va_list va;

  va_start(va, a3);
  return vswscanf_l(a1, a2, a3, va);
}

char *__cdecl tempnam(const char *__dir, const char *__prefix)
{
  const char *v2;
  const char *v3;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  int v11;

  libc_hooks_will_read_cstring((uint64_t)__dir);
  libc_hooks_will_read_cstring((uint64_t)__prefix);
  v5 = (char *)malloc_type_malloc(1024, 3176662310);
  if (!v5)
    return 0;
  if (!__prefix)
    __prefix = "tmp.";
  if (__dir && !access(__dir, 2))
  {
    v2 = __dir[_platform_strlen(__dir) - 1] == 47 ? (const char *)&unk_D495D : "/";
    snprintf(v5, 0x400uLL, "%s%s%sXXXXXX", __dir, v2, __prefix);
    v6 = _mktemp(v5);
    if (v6)
      return v6;
  }
  if (!access("/var/tmp/", 2))
  {
    snprintf(v5, 0x400uLL, "%s%sXXXXXX", "/var/tmp/", __prefix);
    v7 = _mktemp(v5);
    if (v7)
      return v7;
  }
  if (!issetugid())
  {
    v8 = getenv("TMPDIR");
    if (v8)
    {
      if (!access(v8, 2))
      {
        v3 = v8[_platform_strlen(v8) - 1] == 47 ? (const char *)&unk_D495D : "/";
        snprintf(v5, 0x400uLL, "%s%s%sXXXXXX", v8, v3, __prefix);
        v9 = _mktemp(v5);
        if (v9)
          return v9;
      }
    }
  }
  snprintf(v5, 0x400uLL, "%s%sXXXXXX", "/tmp/", __prefix);
  v10 = _mktemp(v5);
  if (v10)
    return v10;
  v11 = *__error();
  free(v5);
  *__error() = v11;
  return 0;
}

FILE *tmpfile(void)
{
  uint64_t v0;
  const char *v1;
  int v3;
  char *v4;
  char *v5;
  int v6;
  unsigned int v7;
  FILE *v8;
  sigset_t v9;
  sigset_t v10;

  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  if (!issetugid())
    v4 = getenv("TMPDIR");
  if (!v4)
    v4 = "/tmp/";
  if (!*v4)
    return 0;
  v0 = _platform_strlen(v4);
  v1 = (const char *)&unk_D495D;
  if (v4[v0 - 1] != 47)
    v1 = "/";
  asprintf(&v5, "%s%s%s", v4, v1, "tmp.XXXXXX");
  if (!v5)
    return 0;
  v10 = -1;
  sigprocmask(1, &v10, &v9);
  v7 = mkstemp(v5);
  if (v7 != -1)
    unlink(v5);
  free(v5);
  sigprocmask(3, &v9, 0);
  if (v7 == -1)
    return 0;
  v8 = fdopen(v7, "w+");
  if (v8)
    return v8;
  v6 = *__error();
  close_NOCANCEL(v7);
  v3 = v6;
  *__error() = v3;
  return 0;
}

char *__cdecl tmpnam(char *a1)
{
  char *v2;

  v2 = a1;
  if (a1)
    goto LABEL_6;
  if (!pthread_once(&tmpnam_buf_control, (void (*)(void))tmpnam_buf_allocate) && tmpnam_buf)
  {
    v2 = (char *)tmpnam_buf;
LABEL_6:
    libc_hooks_will_write((uint64_t)v2, 1024);
    snprintf(v2, 0x400uLL, "%stmp.%lu.XXXXXX", "/var/tmp/", tmpnam_tmpcount);
    ++tmpnam_tmpcount;
    return _mktemp(v2);
  }
  return 0;
}

uint64_t tmpnam_buf_allocate()
{
  uint64_t result;

  result = malloc_type_malloc(1024, 3215933616);
  tmpnam_buf = result;
  return result;
}

int ungetc(int a1, FILE *a2)
{
  int v3;

  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  flockfile(a2);
  if (!((char)(32 * *((_BYTE *)a2->_extra + 72)) >> 5))
    *((_BYTE *)a2->_extra + 72) = *((_BYTE *)a2->_extra + 72) & 0xF8 | 7;
  v3 = __ungetc(a1, (uint64_t)a2);
  funlockfile(a2);
  return v3;
}

uint64_t __ungetc(int a1, uint64_t a2)
{
  unsigned __int8 *v2;
  unsigned __int8 v5;

  v5 = a1;
  if (a1 == -1)
  {
    return -1;
  }
  else
  {
    if ((*(_WORD *)(a2 + 16) & 4) == 0)
    {
      if ((*(_WORD *)(a2 + 16) & 0x10) == 0)
        return -1;
      if ((*(_WORD *)(a2 + 16) & 8) != 0)
      {
        if (__sflush(a2))
          return -1;
        *(_WORD *)(a2 + 16) &= ~8u;
        *(_DWORD *)(a2 + 12) = 0;
        *(_DWORD *)(a2 + 40) = 0;
      }
      *(_WORD *)(a2 + 16) |= 4u;
    }
    if (*(_QWORD *)(a2 + 88))
    {
      if (*(_DWORD *)(a2 + 8) >= *(_DWORD *)(a2 + 96) && __submore(a2))
      {
        return -1;
      }
      else
      {
        v2 = (unsigned __int8 *)(*(_QWORD *)a2 - 1);
        *(_QWORD *)a2 = v2;
        *v2 = v5;
        ++*(_DWORD *)(a2 + 8);
        return v5;
      }
    }
    else
    {
      *(_WORD *)(a2 + 16) &= ~0x20u;
      if (*(_QWORD *)(a2 + 24)
        && *(_QWORD *)a2 > *(_QWORD *)(a2 + 24)
        && *(unsigned __int8 *)(*(_QWORD *)a2 - 1) == v5)
      {
        --*(_QWORD *)a2;
        ++*(_DWORD *)(a2 + 8);
        return v5;
      }
      else
      {
        *(_DWORD *)(a2 + 112) = *(_DWORD *)(a2 + 8);
        **(_QWORD **)(a2 + 104) = *(_QWORD *)a2;
        *(_QWORD *)(a2 + 88) = a2 + 116;
        *(_DWORD *)(a2 + 96) = 3;
        *(_BYTE *)(a2 + 118) = v5;
        *(_QWORD *)a2 = a2 + 118;
        *(_DWORD *)(a2 + 8) = 1;
        return v5;
      }
    }
  }
}

uint64_t __submore(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int i;
  int v6;

  if (*(_QWORD *)(a1 + 88) == a1 + 116)
  {
    v2 = malloc_type_malloc(1024, 1577454624);
    if (v2)
    {
      *(_QWORD *)(a1 + 88) = v2;
      *(_DWORD *)(a1 + 96) = 1024;
      v3 = v2 + 1021;
      for (i = 3; --i >= 0; *(_BYTE *)(v3 + i) = *(_BYTE *)(a1 + 116 + i))
        ;
      *(_QWORD *)a1 = v3;
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 96);
    v4 = malloc_type_realloc(*(_QWORD *)(a1 + 88), 2 * v6, 496016451);
    if (v4)
    {
      j___platform_memmove(v4 + v6, v4, v6);
      *(_QWORD *)a1 = v4 + v6;
      *(_QWORD *)(a1 + 88) = v4;
      *(_DWORD *)(a1 + 96) = 2 * v6;
      return 0;
    }
    else
    {
      return -1;
    }
  }
}

uint64_t __ungetwc(unsigned int a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  _BYTE v6[6];
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;

  v9 = a1;
  v8 = a2;
  v7 = a3;
  if (a1 == -1)
  {
    return -1;
  }
  else
  {
    v5 = (*(uint64_t (**)(_BYTE *, _QWORD, uint64_t, uint64_t))(*(_QWORD *)(v7 + 1328) + 96))(v6, v9, *(_QWORD *)(v8 + 104) + 80, v7);
    if (v5 == -1)
    {
      *(_WORD *)(v8 + 16) |= 0x40u;
      return -1;
    }
    else
    {
      while (v5--)
      {
        if (__ungetc(v6[v5], v8) == -1)
          return -1;
      }
      return v9;
    }
  }
}

wint_t ungetwc(wint_t a1, FILE *a2)
{
  char v2;
  wint_t v3;
  wint_t v5;
  void *v8;
  uint64_t v9;

  flockfile(a2);
  if ((char)(32 * *((_BYTE *)a2->_extra + 72)) >> 5)
  {
    v2 = 0;
  }
  else
  {
    *((_BYTE *)a2->_extra + 72) = *((_BYTE *)a2->_extra + 72) & 0xF8 | 1;
    v2 = 1;
  }
  if ((v2 & 1) != 0)
  {
    v8 = pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    v3 = __ungetwc(a1, (uint64_t)a2, (uint64_t)v8);
  else
    v3 = __ungetwc(a1, (uint64_t)a2, (uint64_t)__global_locale);
  v5 = v3;
  funlockfile(a2);
  return v5;
}

wint_t ungetwc_l(wint_t a1, FILE *a2, locale_t a3)
{
  wint_t v4;
  locale_t v5;

  v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v5 = (locale_t)__global_locale;
  }
  else
  {
    v5 = (locale_t)&__c_locale;
  }
  flockfile(a2);
  if (!((char)(32 * *((_BYTE *)a2->_extra + 72)) >> 5))
    *((_BYTE *)a2->_extra + 72) = *((_BYTE *)a2->_extra + 72) & 0xF8 | 1;
  v4 = __ungetwc(a1, (uint64_t)a2, (uint64_t)v5);
  funlockfile(a2);
  return v4;
}

uint64_t _vasprintf(uint64_t a1, pthread_rwlock_t *a2, void **a3, _xlocale *a4, char *a5, int *a6)
{
  _BYTE *v7;
  int v8;
  __int16 v9;
  __int16 v10;
  void *v11;
  int v12;
  uint64_t *v13;
  int v14;
  int *v15;
  char *v16;
  _xlocale *v17;
  void **v18;
  pthread_rwlock_t *v19;
  uint64_t v20;
  _QWORD v22[8];
  uint64_t v23;
  uint64_t v24;

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = a4;
  v16 = a5;
  v15 = a6;
  v14 = 0;
  _platform_memset(&v7, 0, 152);
  _platform_memset(&v23, 0, 208);
  v13 = &v23;
  v23 = 0;
  _platform_memset(v22, 0, 64);
  v22[0] = 850045858;
  j___platform_memmove(&v24, v22, 64);
  *((_BYTE *)v13 + 72) &= 0xF8u;
  _platform_memset(v13 + 10, 0, 128);
  *((_BYTE *)v13 + 72) &= ~8u;
  v10 = -1;
  v9 = 16904;
  v7 = (_BYTE *)malloc_type_malloc(128, 54168867);
  v11 = v7;
  if (v7)
  {
    v8 = 127;
    v12 = 127;
    *((_BYTE *)v13 + 72) &= 0xF8u;
    _platform_memset(v13 + 10, 0, 128);
    v14 = __v2printf(v20, v19, (uint64_t)&v7, v17, v16, v15);
    if (v14 >= 0)
    {
      *v7 = 0;
      *v18 = v11;
      return v14;
    }
    else
    {
      free(v11);
      *v18 = 0;
      *__error() = 12;
      return -1;
    }
  }
  else
  {
    *v18 = 0;
    *__error() = 12;
    return -1;
  }
}

int vasprintf_l(char **a1, locale_t a2, const char *a3, va_list a4)
{
  return _vasprintf(-1, 0, (void **)a1, a2, (char *)a3, (int *)a4);
}

int vasprintf(char **a1, const char *a2, va_list a3)
{
  char v3;
  char v4;
  void *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return _vasprintf(-1, 0, a1, v9, a2, a3);
  else
    return _vasprintf(-1, 0, a1, &__global_locale, a2, a3);
}

uint64_t _vdprintf(uint64_t a1, pthread_rwlock_t *a2, int a3, _xlocale *a4, char *a5, int *a6)
{
  int v8;
  _BYTE *v9;
  int v10;
  __int16 v11;
  __int16 v12;
  _BYTE *v13;
  int v14;
  _QWORD *v15;
  uint64_t (*v16)(uint64_t, uint64_t, int);
  uint64_t *v17;
  int *v18;
  char *v19;
  _xlocale *v20;
  int v21;
  pthread_rwlock_t *v22;
  uint64_t v23;
  _QWORD v25[8];
  uint64_t v26;
  uint64_t v27;
  _BYTE v28[1024];

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v19 = a5;
  v18 = a6;
  _platform_memset(&v9, 0, 152);
  _platform_memset(&v26, 0, 208);
  v17 = &v26;
  v26 = 0;
  _platform_memset(v25, 0, 64);
  v25[0] = 850045858;
  j___platform_memmove(&v27, v25, 64);
  *((_BYTE *)v17 + 72) &= 0xF8u;
  _platform_memset(v17 + 10, 0, 128);
  *((_BYTE *)v17 + 72) &= ~8u;
  if (v21 < 0x8000)
  {
    v9 = v28;
    v10 = 1024;
    v11 = 8;
    v12 = v21;
    v15 = &v9;
    v16 = __swrite;
    v13 = v28;
    v14 = 1024;
    *((_BYTE *)v17 + 72) &= 0xF8u;
    _platform_memset(v17 + 10, 0, 128);
    v8 = __v2printf(v23, v22, (uint64_t)&v9, v20, v19, v18);
    if (v8 >= 0)
    {
      if (__fflush((uint64_t)&v9))
        return -1;
      else
        return v8;
    }
    else
    {
      return v8;
    }
  }
  else
  {
    *__error() = 24;
    return -1;
  }
}

int vdprintf_l(int a1, locale_t a2, const char *a3, va_list a4)
{
  return _vdprintf(-1, 0, a1, a2, (char *)a3, (int *)a4);
}

int vdprintf(int a1, const char *a2, va_list a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return _vdprintf(-1, 0, a1, v9, (char *)a2, (int *)a3);
  else
    return _vdprintf(-1, 0, a1, (_xlocale *)__global_locale, (char *)a2, (int *)a3);
}

int vfprintf_l(FILE *a1, locale_t a2, const char *a3, va_list a4)
{
  int v5;

  libc_hooks_will_write((uint64_t)a1, 152);
  flockfile(a1);
  v5 = __xvprintf(-1, 0, (uint64_t)a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4);
  funlockfile(a1);
  return v5;
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  char v3;
  char v4;
  int v5;
  int v7;
  void *v11;
  uint64_t v12;

  libc_hooks_will_write((uint64_t)a1, 152);
  flockfile(a1);
  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v11 = pthread_getspecific(__locale_key);
  }
  else
  {
    v12 = __locale_key;
    v11 = *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11)
    v5 = __xvprintf(-1, 0, (uint64_t)a1, (uint64_t)v11, (uint64_t)a2, (uint64_t)a3);
  else
    v5 = __xvprintf(-1, 0, (uint64_t)a1, (uint64_t)&__global_locale, (uint64_t)a2, (uint64_t)a3);
  v7 = v5;
  funlockfile(a1);
  return v7;
}

BOOL __printf_is_memory_read_only(vm_address_t a1, vm_address_t a2)
{
  BOOL v3;
  mach_port_t object_name;
  mach_msg_type_number_t infoCnt;
  int v6[9];
  vm_size_t v7;
  vm_address_t v8[3];

  v8[2] = a1;
  v8[1] = a2;
  v8[0] = a1;
  v7 = 0;
  _platform_memset(v6, 0, 36);
  infoCnt = 9;
  object_name = 0;
  v3 = 0;
  if (!vm_region_64(mach_task_self_, v8, &v7, 9, v6, &infoCnt, &object_name))
    return (v6[0] & 2) == 0;
  return v3;
}

uint64_t __vfprintf(uint64_t a1, _xlocale *a2, char *a3, int *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  int *v15;
  char *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  int *v20;
  char *v21;
  char *v22;
  uint64_t v23;
  __int32 *v24;
  uint64_t v25;
  int *v26;
  uint64_t v27;
  int64_t *v28;
  uint64_t v29;
  int64_t *v30;
  uint64_t v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  int64_t *v36;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  int *v40;
  uint64_t v41;
  int *v42;
  uint64_t v43;
  double *v44;
  uint64_t v45;
  uint64_t v46;
  double *v47;
  uint64_t v48;
  uint64_t v49;
  double *v50;
  int v51;
  uint64_t v52;
  double *v53;
  int v54;
  const char *v55;
  const char *v56;
  int v57;
  uint64_t v58;
  uint64_t *v59;
  vm_address_t v60;
  uint64_t v61;
  int64_t *v62;
  uint64_t v63;
  int64_t *v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  int64_t *v70;
  uint64_t v71;
  int *v72;
  uint64_t v73;
  int *v74;
  uint64_t v75;
  unsigned int *v76;
  uint64_t v77;
  int64_t *v78;
  uint64_t v79;
  const __int32 **v80;
  uint64_t v81;
  uint64_t *v82;
  uint64_t v83;
  int64_t *v84;
  uint64_t v85;
  int64_t *v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  int64_t *v92;
  uint64_t v93;
  int *v94;
  uint64_t v95;
  int *v96;
  uint64_t v97;
  unsigned int *v98;
  uint64_t v99;
  int64_t *v100;
  uint64_t v101;
  int64_t *v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t *v106;
  uint64_t v107;
  int64_t *v108;
  uint64_t v109;
  int *v110;
  uint64_t v111;
  int *v112;
  uint64_t v113;
  unsigned int *v114;
  int v115;
  uint64_t v116;
  _OWORD *v117;
  char v118;
  uint64_t v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v130;
  uint64_t v131;
  __int128 v132;
  unsigned int v133;
  int64_t v134;
  int v135;
  int64_t v136;
  int v137;
  int64_t v138;
  int64_t v139;
  int64_t v140;
  int64_t v141;
  int64_t v142;
  int64_t v143;
  int64_t v144;
  int64_t v145;
  int64_t v146;
  unsigned int v147;
  int64_t v148;
  int v149;
  int64_t v150;
  int v151;
  int64_t v152;
  int64_t v153;
  int64_t v154;
  int64_t v155;
  int64_t v156;
  int64_t v157;
  int64_t v158;
  int64_t v159;
  int64_t v160;
  unint64_t v161;
  uint64_t v162;
  const __int32 *v163;
  int64_t v164;
  unsigned int v165;
  int64_t v166;
  int v167;
  int64_t v168;
  int v169;
  int64_t v170;
  int64_t v171;
  int64_t v172;
  int64_t v173;
  int64_t v174;
  int64_t v175;
  int64_t v176;
  int64_t v177;
  int64_t v178;
  char *v179;
  uint64_t v180;
  double v181;
  double v182;
  double v183;
  double v184;
  int v185;
  int64_t v186;
  int v187;
  int64_t v188;
  int v189;
  int64_t v190;
  int64_t v191;
  int64_t v192;
  int64_t v193;
  int64_t v194;
  int64_t v195;
  int64_t v196;
  int64_t v197;
  int64_t v198;
  int v199;
  __int32 v200;
  int v201;
  int v202;
  int v203;
  int v204;
  BOOL v205;
  int v206;
  int v207;
  int v208;
  char *v209;
  int v210;
  int v211;
  char *v212;
  int v213;
  int v214;
  int j;
  unsigned int v216;
  int v217;
  int v218;
  int64_t v219;
  uint64_t v220;
  uint64_t v221;
  int64_t v222;
  int64_t v223;
  unsigned int v224;
  int v225;
  int v226;
  int64_t v227;
  uint64_t v228;
  uint64_t v229;
  int64_t v230;
  int64_t v231;
  unint64_t v232;
  uint64_t v233;
  const __int32 *v234;
  const __int32 *v235;
  int64_t v236;
  unsigned int v237;
  int v238;
  int v239;
  int64_t v240;
  uint64_t v241;
  uint64_t v242;
  int64_t v243;
  int64_t v244;
  uint64_t *v245;
  int v246;
  uint64_t *v247;
  char v248;
  uint64_t *v249;
  __int16 v250;
  uint64_t *v251;
  uint64_t v252;
  uint64_t *v253;
  uint64_t v254;
  uint64_t *v255;
  uint64_t v256;
  uint64_t *v257;
  uint64_t v258;
  uint64_t *v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t *v262;
  double v263;
  double v264;
  double v265;
  double v266;
  int v267;
  int v268;
  int v269;
  int64_t v270;
  uint64_t v271;
  uint64_t v272;
  int64_t v273;
  int64_t v274;
  int v275;
  __int32 v276;
  size_t v277;
  int v278;
  int v279;
  int v280;
  int v281;
  int v282;
  int v283;
  void *v284;
  int *v285;
  _BYTE v286[12];
  char v287;
  char v288;
  _OWORD v289[9];
  uint64_t v290;
  void *v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  int v295;
  unsigned int v296;
  int64_t v297;
  int64_t v298;
  char v299;
  unint64_t v300;
  __int128 v301;
  uint64_t v302;
  int v303;
  int v304;
  unint64_t v305;
  char v306;
  int v307;
  double v308;
  int v309;
  int v310;
  char *decimal_point;
  BOOL only;
  __int128 v313;
  __int128 v314;
  uint64_t v315;
  char v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  int v320;
  uint64_t i;
  uint64_t v322;
  uint64_t v323;
  int v324;
  char *v325;
  int *v326;
  char *v327;
  locale_t v328;
  uint64_t v329;
  _BYTE v330[34];
  mbstate_t v331;
  _BYTE v332[128];
  char v333[32];
  char v334[8];

  v329 = a1;
  v328 = a2;
  v327 = a3;
  v326 = a4;
  v324 = 0;
  v323 = 0;
  v322 = 0;
  i = 0;
  v320 = 0;
  v319 = 0;
  v318 = 0;
  v317 = 0;
  v316 = 0;
  v315 = 0;
  v314 = 0u;
  v313 = 0u;
  only = 0;
  decimal_point = 0;
  v310 = 0;
  v309 = 0;
  v308 = 0.0;
  v307 = 0;
  v306 = 0;
  v305 = 0;
  v304 = 0;
  v303 = 0;
  v302 = 0;
  v301 = 0uLL;
  v300 = 0;
  v299 = 0;
  v298 = 0;
  v297 = 0;
  v296 = 0;
  v295 = 0;
  v294 = 0;
  v293 = 0;
  v292 = 0;
  v291 = 0;
  v290 = 0;
  memset(v289, 0, sizeof(v289));
  v284 = 0;
  v325 = a3;
  *(_QWORD *)&v286[4] = 0;
  *(_DWORD *)v286 = 1;
  v285 = a4;
  io_init((uint64_t)v289, a1);
  v319 = 0;
  v302 = 0;
  decimal_point = localeconv_l(v328)->decimal_point;
  if (decimal_point[1])
    v206 = _platform_strlen(decimal_point);
  else
    v206 = 1;
  v310 = v206;
  while (1)
  {
LABEL_5:
    i = (uint64_t)v325;
    while (1)
    {
      v324 = *v325;
      v205 = 0;
      if (v324)
        v205 = v324 != 37;
      if (!v205)
        break;
      ++v325;
    }
    v323 = (uint64_t)&v325[-i];
    if (v325 != (char *)i)
    {
      if (v319 + v323 >= 0x7FFFFFFF)
        goto LABEL_12;
      if (io_print((uint64_t)v289, i, v323, (uint64_t)v328))
        goto LABEL_656;
      v319 += v323;
    }
    if (!v324)
      break;
    v300 = (unint64_t)v325++;
    v320 = 0;
    v295 = 0;
    v318 = 0;
    v317 = -1;
    *(_QWORD *)&v314 = 0;
    v316 = 0;
    v288 = 0;
    v299 = 88;
    while (2)
    {
      v11 = v325++;
      v324 = *v11;
LABEL_18:
      switch(v324)
      {
        case ' ':
          if (!v316)
            v316 = 32;
          continue;
        case '#':
          v320 |= 1u;
          continue;
        case '\'':
          v320 |= 0x200u;
          continue;
        case '*':
          v322 = 0;
          for (i = (uint64_t)v325; (*(char *)i - 48) <= 9; ++i)
            v322 = 10 * v322 + *(char *)i - 48;
          if (*(_BYTE *)i == 36)
          {
            v283 = *(_DWORD *)v286;
            if (!*(_QWORD *)&v286[4])
            {
              *(_QWORD *)&v286[4] = v332;
              if (__find_arguments(v327, v285, (uint64_t *)&v286[4]))
              {
                v319 = -1;
                goto LABEL_656;
              }
            }
            *(_DWORD *)v286 = v322;
            if (*(_QWORD *)&v286[4])
            {
              v12 = *(int *)v286;
              ++*(_DWORD *)v286;
              v204 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v12);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v13 = v326;
              v326 += 2;
              v282 = *v13;
              v204 = v282;
            }
            v318 = v204;
            *(_DWORD *)v286 = v283;
            v325 = (char *)++i;
          }
          else
          {
            if (*(_QWORD *)&v286[4])
            {
              v14 = *(int *)v286;
              ++*(_DWORD *)v286;
              v203 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v14);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v15 = v326;
              v326 += 2;
              v281 = *v15;
              v203 = v281;
            }
            v318 = v203;
          }
          if (v318 < 0)
          {
            v318 = -v318;
LABEL_41:
            v320 |= 4u;
          }
          continue;
        case '+':
          v316 = 43;
          continue;
        case ',':
        case ':':
        case ';':
        case '_':
          v299 = v324;
          continue;
        case '-':
          goto LABEL_41;
        case '.':
          v16 = v325++;
          v324 = *v16;
          if (v324 != 42)
          {
            v317 = 0;
            while ((v324 - 48) <= 9)
            {
              v317 = 10 * v317 + v324 - 48;
              v21 = v325++;
              v324 = *v21;
            }
            goto LABEL_18;
          }
          v322 = 0;
          for (i = (uint64_t)v325; (*(char *)i - 48) <= 9; ++i)
            v322 = 10 * v322 + *(char *)i - 48;
          if (*(_BYTE *)i == 36)
          {
            v280 = *(_DWORD *)v286;
            if (!*(_QWORD *)&v286[4])
            {
              *(_QWORD *)&v286[4] = v332;
              if (__find_arguments(v327, v285, (uint64_t *)&v286[4]))
              {
                v319 = -1;
                goto LABEL_656;
              }
            }
            *(_DWORD *)v286 = v322;
            if (*(_QWORD *)&v286[4])
            {
              v17 = *(int *)v286;
              ++*(_DWORD *)v286;
              v202 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v17);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v18 = v326;
              v326 += 2;
              v279 = *v18;
              v202 = v279;
            }
            v317 = v202;
            *(_DWORD *)v286 = v280;
            v325 = (char *)++i;
          }
          else
          {
            if (*(_QWORD *)&v286[4])
            {
              v19 = *(int *)v286;
              ++*(_DWORD *)v286;
              v201 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v19);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v20 = v326;
              v326 += 2;
              v278 = *v20;
              v201 = v278;
            }
            v317 = v201;
          }
          continue;
        case '0':
          v320 |= 0x80u;
          continue;
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          v323 = 0;
          do
          {
            v323 = 10 * v323 + v324 - 48;
            v22 = v325++;
            v324 = *v22;
          }
          while ((v324 - 48) < 0xA);
          if (v324 != 36)
          {
            v318 = v323;
            goto LABEL_18;
          }
          *(_DWORD *)v286 = v323;
          if (!*(_QWORD *)&v286[4])
          {
            *(_QWORD *)&v286[4] = v332;
            if (__find_arguments(v327, v285, (uint64_t *)&v286[4]))
            {
              v319 = -1;
              goto LABEL_656;
            }
          }
          continue;
        case 'A':
        case 'a':
          if ((v320 & 0x4000) != 0)
          {
            v320 |= 0x100u;
            goto LABEL_466;
          }
          if (v324 == 97)
          {
            v288 = 120;
            v291 = &__vfprintf_xdigs_lower;
            v306 = 112;
          }
          else
          {
            v288 = 88;
            v291 = &__vfprintf_xdigs_upper;
            v306 = 80;
          }
          if ((v317 & 0x8000000000000000) == 0)
            ++v317;
          if (v302)
            __freedtoa(v302);
          if ((v320 & 8) != 0)
          {
            if (*(_QWORD *)&v286[4])
            {
              v43 = *(int *)v286;
              ++*(_DWORD *)v286;
              v184 = *(double *)(*(_QWORD *)&v286[4] + 16 * v43);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v44 = (double *)v326;
              v326 += 2;
              v266 = *v44;
              v184 = v266;
            }
            v308 = v184;
            __hldtoa((uint64_t)v291, v317, (uint64_t)&v307, &v309, v184);
            i = v45;
            v302 = v45;
          }
          else
          {
            if (*(_QWORD *)&v286[4])
            {
              v46 = *(int *)v286;
              ++*(_DWORD *)v286;
              v183 = *(double *)(*(_QWORD *)&v286[4] + 16 * v46);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v47 = (double *)v326;
              v326 += 2;
              v265 = *v47;
              v183 = v265;
            }
            v308 = v183;
            __hdtoa(v183, (uint64_t)v291, v317, (uint64_t)&v307, &v309);
            i = v48;
            v302 = v48;
          }
          if (v317 < 0)
            v317 = v305 - i;
          if (v307 == 0x7FFFFFFF)
            v288 = 0;
          goto LABEL_204;
        case 'C':
          v320 |= 0x10u;
          goto LABEL_85;
        case 'D':
          v320 |= 0x10u;
          goto LABEL_99;
        case 'E':
        case 'e':
          if ((v320 & 0x4000) != 0)
          {
            v320 |= 0x100u;
            goto LABEL_466;
          }
          v306 = v324;
          if (v317 < 0)
            v317 = 7;
          else
            ++v317;
          goto LABEL_184;
        case 'F':
        case 'f':
          if ((v320 & 0x4000) != 0)
          {
            v320 |= 0x100u;
            goto LABEL_466;
          }
          v306 = 0;
          goto LABEL_184;
        case 'G':
        case 'g':
          if ((v320 & 0x4000) != 0)
          {
            v320 |= 0x100u;
          }
          else
          {
            v306 = v324 - 2;
            if (!v317)
              v317 = 1;
LABEL_184:
            if (v317 < 0)
              v317 = 6;
            if (v302)
              __freedtoa(v302);
            if ((v320 & 8) != 0)
            {
              if (*(_QWORD *)&v286[4])
              {
                v49 = *(int *)v286;
                ++*(_DWORD *)v286;
                v182 = *(double *)(*(_QWORD *)&v286[4] + 16 * v49);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v50 = (double *)v326;
                v326 += 2;
                v264 = *v50;
                v182 = v264;
              }
              v308 = v182;
              if (v306)
                v51 = 2;
              else
                v51 = 3;
              i = (uint64_t)__ldtoa(&v308, v51, v317, &v307, &v309, &v305);
              v302 = i;
            }
            else
            {
              if (*(_QWORD *)&v286[4])
              {
                v52 = *(int *)v286;
                ++*(_DWORD *)v286;
                v181 = *(double *)(*(_QWORD *)&v286[4] + 16 * v52);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v53 = (double *)v326;
                v326 += 2;
                v263 = *v53;
                v181 = v263;
              }
              v308 = v181;
              if (v306)
                v54 = 2;
              else
                v54 = 3;
              i = (uint64_t)__dtoa(v54, v317, &v307, &v309, &v305, v181);
              v302 = i;
              if (v307 == 9999)
                v307 = 0x7FFFFFFF;
            }
LABEL_204:
            if (v309)
              v316 = 45;
            if (v307 == 0x7FFFFFFF)
            {
              if (*(_BYTE *)i == 78)
              {
                v55 = "nan";
                if (v324 <= 96)
                  v55 = "NAN";
                i = (uint64_t)v55;
                v316 = 0;
              }
              else
              {
                v56 = "inf";
                if (v324 <= 96)
                  v56 = "INF";
                i = (uint64_t)v56;
              }
              v293 = 3;
              v320 &= ~0x80u;
            }
            else
            {
              v320 |= 0x100u;
              v303 = v305 - i;
              if (v324 == 103 || v324 == 71)
              {
                if (v307 < -3 || v307 > v317)
                {
                  if ((v320 & 1) == 0)
                    v317 = v303;
                }
                else
                {
                  v306 = 0;
                  if ((v320 & 1) != 0)
                    v317 -= v307;
                  else
                    v317 = v303 - v307;
                  if (v317 < 0)
                    v317 = 0;
                }
              }
              if (v306)
              {
                v304 = exponent(v334, v307 - 1, v306);
                v293 = v304 + v317;
                if (v317 > 1 || (v320 & 1) != 0)
                  v293 += v310;
              }
              else
              {
                if (v307 < 1)
                  v293 = 1;
                else
                  v293 = v307;
                if (v317 || (v320 & 1) != 0)
                  v293 += v317 + v310;
                if ((v320 & 0x200) != 0 && v307 >= 1)
                {
                  v57 = grouping_init((uint64_t)&v313, v307, v328);
                  v293 += v57;
                }
              }
            }
          }
          goto LABEL_466;
        case 'L':
          v320 |= 8u;
          continue;
        case 'O':
          v320 |= 0x10u;
          goto LABEL_266;
        case 'S':
          v320 |= 0x10u;
          goto LABEL_319;
        case 'U':
          v320 |= 0x10u;
          goto LABEL_340;
        case 'X':
          v291 = &__vfprintf_xdigs_upper;
          goto LABEL_389;
        case 'c':
LABEL_85:
          if ((v320 & 0x4000) != 0)
            goto LABEL_466;
          if ((v320 & 0x10) != 0)
          {
            v277 = 0;
            memset(&v331, 0, sizeof(v331));
            i = (uint64_t)v333;
            if (*(_QWORD *)&v286[4])
            {
              v23 = *(int *)v286;
              ++*(_DWORD *)v286;
              v200 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v23);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v24 = v326;
              v326 += 2;
              v276 = *v24;
              v200 = v276;
            }
            v277 = wcrtomb_l(v333, v200, &v331, v328);
            if (v277 == -1)
            {
              *(_WORD *)(v329 + 16) |= 0x40u;
              goto LABEL_656;
            }
            v293 = (int)v277;
          }
          else
          {
            if (*(_QWORD *)&v286[4])
            {
              v25 = *(int *)v286;
              ++*(_DWORD *)v286;
              v199 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v25);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v26 = v326;
              v326 += 2;
              v275 = *v26;
              LOBYTE(v199) = v275;
            }
            i = (uint64_t)v333;
            v333[0] = v199;
            v293 = 1;
          }
          v316 = 0;
          goto LABEL_466;
        case 'd':
        case 'i':
LABEL_99:
          if ((v320 & 0x4000) != 0)
            goto LABEL_466;
          if ((v320 & 0x1C20) != 0)
          {
            if ((v320 & 0x1000) != 0)
            {
              if (*(_QWORD *)&v286[4])
              {
                v27 = *(int *)v286;
                ++*(_DWORD *)v286;
                v198 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v27);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v28 = (int64_t *)v326;
                v326 += 2;
                v274 = *v28;
                v198 = v274;
              }
              v197 = v198;
            }
            else
            {
              if ((v320 & 0x400) != 0)
              {
                if (*(_QWORD *)&v286[4])
                {
                  v29 = *(int *)v286;
                  ++*(_DWORD *)v286;
                  v196 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v29);
                }
                else
                {
                  *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                  v30 = (int64_t *)v326;
                  v326 += 2;
                  v273 = *v30;
                  v196 = v273;
                }
                v195 = v196;
              }
              else
              {
                if ((v320 & 0x800) != 0)
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v31 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v194 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v31);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v32 = (uint64_t *)v326;
                    v326 += 2;
                    v272 = *v32;
                    v194 = v272;
                  }
                  v193 = v194;
                }
                else
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v33 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v192 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v33);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v34 = (uint64_t *)v326;
                    v326 += 2;
                    v271 = *v34;
                    v192 = v271;
                  }
                  v193 = v192;
                }
                v195 = v193;
              }
              v197 = v195;
            }
            v297 = v197;
            if (v197 < 0)
            {
              v297 = -v297;
              v316 = 45;
            }
          }
          else
          {
            if ((v320 & 0x10) != 0)
            {
              if (*(_QWORD *)&v286[4])
              {
                v35 = *(int *)v286;
                ++*(_DWORD *)v286;
                v191 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v35);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v36 = (int64_t *)v326;
                v326 += 2;
                v270 = *v36;
                v191 = v270;
              }
              v190 = v191;
            }
            else
            {
              if ((v320 & 0x40) != 0)
              {
                if (*(_QWORD *)&v286[4])
                {
                  v37 = *(int *)v286;
                  ++*(_DWORD *)v286;
                  v189 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v37);
                }
                else
                {
                  *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                  v38 = v326;
                  v326 += 2;
                  v269 = *v38;
                  LOWORD(v189) = v269;
                }
                v188 = (__int16)v189;
              }
              else
              {
                if ((v320 & 0x2000) != 0)
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v39 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v187 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v39);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v40 = v326;
                    v326 += 2;
                    v268 = *v40;
                    LOBYTE(v187) = v268;
                  }
                  v186 = (char)v187;
                }
                else
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v41 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v185 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v41);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v42 = v326;
                    v326 += 2;
                    v267 = *v42;
                    v185 = v267;
                  }
                  v186 = v185;
                }
                v188 = v186;
              }
              v190 = v188;
            }
            v298 = v190;
            if (v190 < 0)
            {
              v298 = -v298;
              v316 = 45;
            }
          }
          v296 = 10;
          goto LABEL_443;
        case 'h':
          if ((v320 & 0x40) != 0)
          {
            v320 &= ~0x40u;
            v320 |= 0x2000u;
          }
          else
          {
            v320 |= 0x40u;
          }
          continue;
        case 'j':
          v320 |= 0x1000u;
          continue;
        case 'l':
          if ((v320 & 0x10) != 0)
          {
            v320 &= ~0x10u;
            v320 |= 0x20u;
          }
          else
          {
            v320 |= 0x10u;
          }
          continue;
        case 'n':
          v262 = 0;
          if (*(_QWORD *)&v286[4])
          {
            v58 = *(int *)v286;
            ++*(_DWORD *)v286;
            v180 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v58);
          }
          else
          {
            *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
            v59 = (uint64_t *)v326;
            v326 += 2;
            v261 = *v59;
            v180 = v261;
          }
          v262 = (uint64_t *)v180;
          if (v180)
          {
            if (!only)
            {
              v179 = v327;
              v60 = _platform_strlen(v327);
              only = __printf_is_memory_read_only((vm_address_t)v179, v60);
            }
            if (!only)
            {
              _os_crash((uint64_t)"%%n used in a non-immutable format string");
              __break(1u);
              JUMPOUT(0x711FCLL);
            }
            if ((v320 & 0x20) != 0)
            {
              v260 = v319;
              v259 = v262;
              libc_hooks_will_write((uint64_t)v262, 8);
              *v259 = v260;
            }
            else if ((v320 & 0x400) != 0)
            {
              v258 = v319;
              v257 = v262;
              libc_hooks_will_write((uint64_t)v262, 8);
              *v257 = v258;
            }
            else if ((v320 & 0x800) != 0)
            {
              v256 = v319;
              v255 = v262;
              libc_hooks_will_write((uint64_t)v262, 8);
              *v255 = v256;
            }
            else if ((v320 & 0x1000) != 0)
            {
              v254 = v319;
              v253 = v262;
              libc_hooks_will_write((uint64_t)v262, 8);
              *v253 = v254;
            }
            else if ((v320 & 0x10) != 0)
            {
              v252 = v319;
              v251 = v262;
              libc_hooks_will_write((uint64_t)v262, 8);
              *v251 = v252;
            }
            else if ((v320 & 0x40) != 0)
            {
              v250 = v319;
              v249 = v262;
              libc_hooks_will_write((uint64_t)v262, 2);
              *(_WORD *)v249 = v250;
            }
            else if ((v320 & 0x2000) != 0)
            {
              v248 = v319;
              v247 = v262;
              libc_hooks_will_write((uint64_t)v262, 1);
              *(_BYTE *)v247 = v248;
            }
            else
            {
              v246 = v319;
              v245 = v262;
              libc_hooks_will_write((uint64_t)v262, 4);
              *(_DWORD *)v245 = v246;
            }
          }
          goto LABEL_5;
        case 'o':
LABEL_266:
          if ((v320 & 0x4000) != 0)
            goto LABEL_466;
          if ((v320 & 0x1C20) != 0)
          {
            if ((v320 & 0x1000) != 0)
            {
              if (*(_QWORD *)&v286[4])
              {
                v61 = *(int *)v286;
                ++*(_DWORD *)v286;
                v178 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v61);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v62 = (int64_t *)v326;
                v326 += 2;
                v244 = *v62;
                v178 = v244;
              }
              v177 = v178;
            }
            else
            {
              if ((v320 & 0x400) != 0)
              {
                if (*(_QWORD *)&v286[4])
                {
                  v63 = *(int *)v286;
                  ++*(_DWORD *)v286;
                  v176 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v63);
                }
                else
                {
                  *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                  v64 = (int64_t *)v326;
                  v326 += 2;
                  v243 = *v64;
                  v176 = v243;
                }
                v175 = v176;
              }
              else
              {
                if ((v320 & 0x800) != 0)
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v65 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v174 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v65);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v66 = (uint64_t *)v326;
                    v326 += 2;
                    v242 = *v66;
                    v174 = v242;
                  }
                  v173 = v174;
                }
                else
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v67 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v172 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v67);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v68 = (uint64_t *)v326;
                    v326 += 2;
                    v241 = *v68;
                    v172 = v241;
                  }
                  v173 = v172;
                }
                v175 = v173;
              }
              v177 = v175;
            }
            v297 = v177;
          }
          else
          {
            if ((v320 & 0x10) != 0)
            {
              if (*(_QWORD *)&v286[4])
              {
                v69 = *(int *)v286;
                ++*(_DWORD *)v286;
                v171 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v69);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v70 = (int64_t *)v326;
                v326 += 2;
                v240 = *v70;
                v171 = v240;
              }
              v170 = v171;
            }
            else
            {
              if ((v320 & 0x40) != 0)
              {
                if (*(_QWORD *)&v286[4])
                {
                  v71 = *(int *)v286;
                  ++*(_DWORD *)v286;
                  v169 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v71);
                }
                else
                {
                  *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                  v72 = v326;
                  v326 += 2;
                  v239 = *v72;
                  LOWORD(v169) = v239;
                }
                v168 = (unsigned __int16)v169;
              }
              else
              {
                if ((v320 & 0x2000) != 0)
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v73 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v167 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v73);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v74 = v326;
                    v326 += 2;
                    v238 = *v74;
                    LOBYTE(v167) = v238;
                  }
                  v166 = v167;
                }
                else
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v75 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v165 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v75);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v76 = (unsigned int *)v326;
                    v326 += 2;
                    v237 = *v76;
                    v165 = v237;
                  }
                  v166 = v165;
                }
                v168 = v166;
              }
              v170 = v168;
            }
            v298 = v170;
          }
          v296 = 8;
          goto LABEL_442;
        case 'p':
          if ((v320 & 0x4000) != 0)
            goto LABEL_466;
          if (*(_QWORD *)&v286[4])
          {
            v77 = *(int *)v286;
            ++*(_DWORD *)v286;
            v164 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v77);
          }
          else
          {
            *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
            v78 = (int64_t *)v326;
            v326 += 2;
            v236 = *v78;
            v164 = v236;
          }
          v297 = v164;
          v296 = 16;
          v291 = &__vfprintf_xdigs_lower;
          v320 |= 0x1000u;
          v288 = 120;
          goto LABEL_442;
        case 'q':
          v320 |= 0x20u;
          continue;
        case 's':
LABEL_319:
          if ((v320 & 0x10) != 0)
          {
            v235 = 0;
            free(v284);
            if (*(_QWORD *)&v286[4])
            {
              v79 = *(int *)v286;
              ++*(_DWORD *)v286;
              v163 = *(const __int32 **)(*(_QWORD *)&v286[4] + 16 * v79);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v80 = (const __int32 **)v326;
              v326 += 2;
              v234 = *v80;
              v163 = v234;
            }
            v235 = v163;
            if (v163)
            {
              v284 = __wcsconv(v235, v317, v328);
              if (!v284)
              {
                *(_WORD *)(v329 + 16) |= 0x40u;
                goto LABEL_656;
              }
              i = (uint64_t)v284;
            }
            else
            {
              v284 = 0;
              i = (uint64_t)"(null)";
            }
          }
          else
          {
            if (*(_QWORD *)&v286[4])
            {
              v81 = *(int *)v286;
              ++*(_DWORD *)v286;
              v162 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v81);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v82 = (uint64_t *)v326;
              v326 += 2;
              v233 = *v82;
              v162 = v233;
            }
            i = v162;
            if (!v162)
              i = (uint64_t)"(null)";
          }
          v232 = 0;
          if (v317 < 0)
            v161 = _platform_strlen(i);
          else
            v161 = _platform_strnlen(i, v317);
          v232 = v161;
          if (v161 > 0x7FFFFFFE)
          {
            v319 = -1;
            goto LABEL_656;
          }
          v293 = v232;
          libc_hooks_will_read(i, v232);
          v316 = 0;
LABEL_466:
          if ((v320 & 0x4000) != 0)
          {
            j = 0;
            v214 = 0;
            v213 = 0;
            v212 = 0;
            v211 = 0;
            v210 = 0;
            v209 = 0;
            v208 = 0;
            if (*(_QWORD *)&v286[4])
            {
              v116 = *(int *)v286;
              ++*(_DWORD *)v286;
              v132 = *(_OWORD *)(*(_QWORD *)&v286[4] + 16 * v116);
            }
            else
            {
              *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
              v117 = (_OWORD *)(((unint64_t)v326 + 15) & 0xFFFFFFFFFFFFFFF0);
              v326 = (int *)(v117 + 1);
              v132 = *v117;
            }
            v301 = v132;
            if ((unint64_t)&v325[~v300 + 2] > 0x21)
              v212 = (char *)malloc_type_malloc(&v325[~v300 + 3], 4148367965);
            else
              v212 = v330;
            if (v299 == 88)
            {
              if (v324 == 99)
                v299 = 0;
              else
                v299 = 32;
            }
            v214 = 0;
            for (j = 0; j < (uint64_t)&v325[~v300]; ++j)
            {
              switch(*(_BYTE *)(v300 + j))
              {
                case '*':
                  if (*(_BYTE *)(v300 + j - 1) == 46)
                    v210 = 1;
                  else
                    v211 = 1;
                  goto LABEL_483;
                case ',':
                case ':':
                case ';':
                case '_':
                case 'h':
                case 'l':
                case 'v':
                  continue;
                default:
LABEL_483:
                  v118 = *(_BYTE *)(v300 + j);
                  v119 = v214++;
                  v212[v119] = v118;
                  break;
              }
            }
            if ((v320 & 0x40) != 0)
            {
              if (v324 == 99)
              {
                v207 = 1;
              }
              else if (v324 == 112)
              {
                v207 = 4;
              }
              else
              {
                v120 = v214++;
                v212[v120] = 104;
                v207 = 1;
              }
              v213 = 8;
              goto LABEL_513;
            }
            if ((v320 & 0x10) != 0)
            {
              v213 = 4;
              if (v324 == 112)
                v121 = 5;
              else
                v121 = 2;
              v207 = v121;
              goto LABEL_513;
            }
            if (v324 != 65 && v324 != 69 && v324 != 71)
            {
              if (v324 == 88)
                goto LABEL_508;
              if (v324 != 97)
              {
                if (v324 == 99)
                  goto LABEL_509;
                if (v324 == 100)
                  goto LABEL_508;
                if ((v324 - 101) >= 3)
                {
                  if (v324 != 112)
                  {
LABEL_508:
                    v122 = v214++;
                    v212[v122] = 104;
                    v123 = v214++;
                    v212[v123] = 104;
                  }
LABEL_509:
                  v213 = 16;
                  if (v324 == 112)
                    v124 = 3;
                  else
                    v124 = 0;
                  v207 = v124;
                  goto LABEL_513;
                }
              }
            }
            v213 = 4;
            v207 = 6;
LABEL_513:
            v125 = v214++;
            v212[v125] = v324;
            v126 = v214++;
            v212[v126] = 0;
            if (v211)
            {
              if (v210)
              {
                switch(v207)
                {
                  case 0:
                  case 3:
                    v208 = asprintf_l(&v209, v328, v212, v318, v317, v301);
                    break;
                  case 1:
                  case 4:
                    v208 = asprintf_l(&v209, v328, v212, v318, v317, (unsigned __int16)v301);
                    break;
                  case 2:
                  case 5:
                    v208 = asprintf_l(&v209, v328, v212, v318, v317, v301);
                    break;
                  case 6:
                    v208 = asprintf_l(&v209, v328, v212, v318, v317, *(float *)&v301);
                    break;
                  default:
                    break;
                }
                v319 += v208;
                if (io_print((uint64_t)v289, (uint64_t)v209, v208, (uint64_t)v328)
                  || io_flush((_QWORD **)v289, (uint64_t)v328))
                {
                  goto LABEL_656;
                }
                free(v209);
                for (j = 1; j < v213; ++j)
                {
                  if (v299 && io_print((uint64_t)v289, (uint64_t)&v299, 1, (uint64_t)v328))
                    goto LABEL_656;
                  switch(v207)
                  {
                    case 0:
                    case 3:
                      v208 = asprintf_l(&v209, v328, v212, v318, v317, *((unsigned __int8 *)&v301 + j));
                      break;
                    case 1:
                    case 4:
                      v208 = asprintf_l(&v209, v328, v212, v318, v317, *((unsigned __int16 *)&v301 + j));
                      break;
                    case 2:
                    case 5:
                      v208 = asprintf_l(&v209, v328, v212, v318, v317, *((unsigned int *)&v301 + j));
                      break;
                    case 6:
                      v208 = asprintf_l(&v209, v328, v212, v318, v317, *((float *)&v301 + j));
                      break;
                    default:
                      break;
                  }
                  v319 += v208;
                  if (io_print((uint64_t)v289, (uint64_t)v209, v208, (uint64_t)v328)
                    || io_flush((_QWORD **)v289, (uint64_t)v328))
                  {
                    goto LABEL_656;
                  }
                  free(v209);
                }
              }
              else
              {
                switch(v207)
                {
                  case 0:
                  case 3:
                    v208 = asprintf_l(&v209, v328, v212, v318, v301);
                    break;
                  case 1:
                  case 4:
                    v208 = asprintf_l(&v209, v328, v212, v318, (unsigned __int16)v301);
                    break;
                  case 2:
                  case 5:
                    v208 = asprintf_l(&v209, v328, v212, v318, v301);
                    break;
                  case 6:
                    v208 = asprintf_l(&v209, v328, v212, v318, *(float *)&v301);
                    break;
                  default:
                    break;
                }
                v319 += v208;
                if (io_print((uint64_t)v289, (uint64_t)v209, v208, (uint64_t)v328)
                  || io_flush((_QWORD **)v289, (uint64_t)v328))
                {
                  goto LABEL_656;
                }
                free(v209);
                for (j = 1; j < v213; ++j)
                {
                  if (v299 && io_print((uint64_t)v289, (uint64_t)&v299, 1, (uint64_t)v328))
                    goto LABEL_656;
                  switch(v207)
                  {
                    case 0:
                    case 3:
                      v208 = asprintf_l(&v209, v328, v212, v318, *((unsigned __int8 *)&v301 + j));
                      break;
                    case 1:
                    case 4:
                      v208 = asprintf_l(&v209, v328, v212, v318, *((unsigned __int16 *)&v301 + j));
                      break;
                    case 2:
                    case 5:
                      v208 = asprintf_l(&v209, v328, v212, v318, *((unsigned int *)&v301 + j));
                      break;
                    case 6:
                      v208 = asprintf_l(&v209, v328, v212, v318, *((float *)&v301 + j));
                      break;
                    default:
                      break;
                  }
                  v319 += v208;
                  if (io_print((uint64_t)v289, (uint64_t)v209, v208, (uint64_t)v328)
                    || io_flush((_QWORD **)v289, (uint64_t)v328))
                  {
                    goto LABEL_656;
                  }
                  free(v209);
                }
              }
            }
            else if (v210)
            {
              switch(v207)
              {
                case 0:
                case 3:
                  v208 = asprintf_l(&v209, v328, v212, v317, v301);
                  break;
                case 1:
                case 4:
                  v208 = asprintf_l(&v209, v328, v212, v317, (unsigned __int16)v301);
                  break;
                case 2:
                case 5:
                  v208 = asprintf_l(&v209, v328, v212, v317, v301);
                  break;
                case 6:
                  v208 = asprintf_l(&v209, v328, v212, v317, *(float *)&v301);
                  break;
                default:
                  break;
              }
              v319 += v208;
              if (io_print((uint64_t)v289, (uint64_t)v209, v208, (uint64_t)v328)
                || io_flush((_QWORD **)v289, (uint64_t)v328))
              {
                goto LABEL_656;
              }
              free(v209);
              for (j = 1; j < v213; ++j)
              {
                if (v299 && io_print((uint64_t)v289, (uint64_t)&v299, 1, (uint64_t)v328))
                  goto LABEL_656;
                switch(v207)
                {
                  case 0:
                  case 3:
                    v208 = asprintf_l(&v209, v328, v212, v317, *((unsigned __int8 *)&v301 + j));
                    break;
                  case 1:
                  case 4:
                    v208 = asprintf_l(&v209, v328, v212, v317, *((unsigned __int16 *)&v301 + j));
                    break;
                  case 2:
                  case 5:
                    v208 = asprintf_l(&v209, v328, v212, v317, *((unsigned int *)&v301 + j));
                    break;
                  case 6:
                    v208 = asprintf_l(&v209, v328, v212, v317, *((float *)&v301 + j));
                    break;
                  default:
                    break;
                }
                v319 += v208;
                if (io_print((uint64_t)v289, (uint64_t)v209, v208, (uint64_t)v328)
                  || io_flush((_QWORD **)v289, (uint64_t)v328))
                {
                  goto LABEL_656;
                }
                free(v209);
              }
            }
            else
            {
              switch(v207)
              {
                case 0:
                case 3:
                  v208 = asprintf_l(&v209, v328, v212, v301);
                  break;
                case 1:
                case 4:
                  v208 = asprintf_l(&v209, v328, v212, (unsigned __int16)v301);
                  break;
                case 2:
                case 5:
                  v208 = asprintf_l(&v209, v328, v212, v301);
                  break;
                case 6:
                  v208 = asprintf_l(&v209, v328, v212, *(float *)&v301);
                  break;
                default:
                  break;
              }
              v319 += v208;
              if (io_print((uint64_t)v289, (uint64_t)v209, v208, (uint64_t)v328)
                || io_flush((_QWORD **)v289, (uint64_t)v328))
              {
                goto LABEL_656;
              }
              free(v209);
              for (j = 1; j < v213; ++j)
              {
                if (v299 && io_print((uint64_t)v289, (uint64_t)&v299, 1, (uint64_t)v328))
                  goto LABEL_656;
                switch(v207)
                {
                  case 0:
                  case 3:
                    v208 = asprintf_l(&v209, v328, v212, *((unsigned __int8 *)&v301 + j));
                    break;
                  case 1:
                  case 4:
                    v208 = asprintf_l(&v209, v328, v212, *((unsigned __int16 *)&v301 + j));
                    break;
                  case 2:
                  case 5:
                    v208 = asprintf_l(&v209, v328, v212, *((unsigned int *)&v301 + j));
                    break;
                  case 6:
                    v208 = asprintf_l(&v209, v328, v212, *((float *)&v301 + j));
                    break;
                  default:
                    break;
                }
                v319 += v208;
                if (io_print((uint64_t)v289, (uint64_t)v209, v208, (uint64_t)v328)
                  || io_flush((_QWORD **)v289, (uint64_t)v328))
                {
                  goto LABEL_656;
                }
                free(v209);
              }
            }
            if (v212 != v330)
              free(v212);
            goto LABEL_5;
          }
          if (v295 <= v293)
            v131 = v293;
          else
            v131 = v295;
          v294 = v131;
          if (v316)
            ++v294;
          if (v288)
            v294 += 2;
          if (v318 <= v294)
            v130 = v294;
          else
            v130 = v318;
          v292 = v130;
          if (v319 + v130 >= 0x7FFFFFFF)
          {
LABEL_12:
            v319 = -1;
            *__error() = 84;
            goto LABEL_656;
          }
          if ((v320 & 0x84) == 0
            && io_pad((uint64_t)v289, (int)v318 - (int)v294, (uint64_t)&blanks, (uint64_t)v328))
          {
            goto LABEL_656;
          }
          if (v316 && io_print((uint64_t)v289, (uint64_t)&v316, 1, (uint64_t)v328))
            goto LABEL_656;
          if (v288)
          {
            v287 = 48;
            if (io_print((uint64_t)v289, (uint64_t)&v287, 2, (uint64_t)v328))
              goto LABEL_656;
          }
          if ((v320 & 0x84) == 0x80
            && io_pad((uint64_t)v289, (int)v318 - (int)v294, (uint64_t)&zeroes, (uint64_t)v328))
          {
            goto LABEL_656;
          }
          if ((v320 & 0x100) != 0)
          {
            if (v306)
            {
              if (v317 > 1 || (v320 & 1) != 0)
              {
                v127 = i++;
                if (io_print((uint64_t)v289, v127, 1, (uint64_t)v328)
                  || io_print((uint64_t)v289, (uint64_t)decimal_point, v310, (uint64_t)v328)
                  || io_print((uint64_t)v289, i, v303 - 1, (uint64_t)v328)
                  || io_pad((uint64_t)v289, (int)v317 - v303, (uint64_t)&zeroes, (uint64_t)v328))
                {
                  goto LABEL_656;
                }
              }
              else if (io_print((uint64_t)v289, i, 1, (uint64_t)v328))
              {
                goto LABEL_656;
              }
              if (io_print((uint64_t)v289, (uint64_t)v334, v304, (uint64_t)v328))
                goto LABEL_656;
            }
            else
            {
              if (v307 > 0)
              {
                if ((_QWORD)v314)
                {
                  v323 = (int)grouping_print((uint64_t)&v313, (uint64_t)v289, i, v305, (uint64_t)v328);
                  if (v323 < 0)
                    goto LABEL_656;
                  i += v323;
                }
                else
                {
                  if (io_printandpad((uint64_t)v289, i, v305, v307, (uint64_t)&zeroes, (uint64_t)v328))
                    goto LABEL_656;
                  i += v307;
                }
                if ((v317 || (v320 & 1) != 0)
                  && io_print((uint64_t)v289, (uint64_t)decimal_point, v310, (uint64_t)v328))
                {
                  goto LABEL_656;
                }
              }
              else
              {
                if (io_print((uint64_t)v289, (uint64_t)&zeroes, 1, (uint64_t)v328)
                  || (v317 || (v320 & 1) != 0)
                  && io_print((uint64_t)v289, (uint64_t)decimal_point, v310, (uint64_t)v328)
                  || io_pad((uint64_t)v289, -v307, (uint64_t)&zeroes, (uint64_t)v328))
                {
                  goto LABEL_656;
                }
                v317 += v307;
              }
              if (io_printandpad((uint64_t)v289, i, v305, v317, (uint64_t)&zeroes, (uint64_t)v328))
                goto LABEL_656;
            }
          }
          else
          {
            if (io_pad((uint64_t)v289, v295 - (int)v293, (uint64_t)&zeroes, (uint64_t)v328))
              goto LABEL_656;
            if ((_QWORD)v314)
            {
              if ((grouping_print((uint64_t)&v313, (uint64_t)v289, i, (unint64_t)v334, (uint64_t)v328) & 0x80000000) != 0)
                goto LABEL_656;
            }
            else if (io_print((uint64_t)v289, i, v293, (uint64_t)v328))
            {
              goto LABEL_656;
            }
          }
          if ((v320 & 4) != 0
            && io_pad((uint64_t)v289, (int)v318 - (int)v294, (uint64_t)&blanks, (uint64_t)v328))
          {
            goto LABEL_656;
          }
          v319 += v292;
          if (io_flush((_QWORD **)v289, (uint64_t)v328))
            goto LABEL_656;
          break;
        case 't':
          v320 |= 0x800u;
          continue;
        case 'u':
LABEL_340:
          if ((v320 & 0x4000) != 0)
            goto LABEL_466;
          if ((v320 & 0x1C20) != 0)
          {
            if ((v320 & 0x1000) != 0)
            {
              if (*(_QWORD *)&v286[4])
              {
                v83 = *(int *)v286;
                ++*(_DWORD *)v286;
                v160 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v83);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v84 = (int64_t *)v326;
                v326 += 2;
                v231 = *v84;
                v160 = v231;
              }
              v159 = v160;
            }
            else
            {
              if ((v320 & 0x400) != 0)
              {
                if (*(_QWORD *)&v286[4])
                {
                  v85 = *(int *)v286;
                  ++*(_DWORD *)v286;
                  v158 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v85);
                }
                else
                {
                  *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                  v86 = (int64_t *)v326;
                  v326 += 2;
                  v230 = *v86;
                  v158 = v230;
                }
                v157 = v158;
              }
              else
              {
                if ((v320 & 0x800) != 0)
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v87 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v156 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v87);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v88 = (uint64_t *)v326;
                    v326 += 2;
                    v229 = *v88;
                    v156 = v229;
                  }
                  v155 = v156;
                }
                else
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v89 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v154 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v89);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v90 = (uint64_t *)v326;
                    v326 += 2;
                    v228 = *v90;
                    v154 = v228;
                  }
                  v155 = v154;
                }
                v157 = v155;
              }
              v159 = v157;
            }
            v297 = v159;
          }
          else
          {
            if ((v320 & 0x10) != 0)
            {
              if (*(_QWORD *)&v286[4])
              {
                v91 = *(int *)v286;
                ++*(_DWORD *)v286;
                v153 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v91);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v92 = (int64_t *)v326;
                v326 += 2;
                v227 = *v92;
                v153 = v227;
              }
              v152 = v153;
            }
            else
            {
              if ((v320 & 0x40) != 0)
              {
                if (*(_QWORD *)&v286[4])
                {
                  v93 = *(int *)v286;
                  ++*(_DWORD *)v286;
                  v151 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v93);
                }
                else
                {
                  *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                  v94 = v326;
                  v326 += 2;
                  v226 = *v94;
                  LOWORD(v151) = v226;
                }
                v150 = (unsigned __int16)v151;
              }
              else
              {
                if ((v320 & 0x2000) != 0)
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v95 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v149 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v95);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v96 = v326;
                    v326 += 2;
                    v225 = *v96;
                    LOBYTE(v149) = v225;
                  }
                  v148 = v149;
                }
                else
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v97 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v147 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v97);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v98 = (unsigned int *)v326;
                    v326 += 2;
                    v224 = *v98;
                    v147 = v224;
                  }
                  v148 = v147;
                }
                v150 = v148;
              }
              v152 = v150;
            }
            v298 = v152;
          }
          v296 = 10;
          goto LABEL_442;
        case 'v':
          v320 |= 0x4000u;
          continue;
        case 'x':
          v291 = &__vfprintf_xdigs_lower;
LABEL_389:
          if ((v320 & 0x4000) != 0)
            goto LABEL_466;
          if ((v320 & 0x1C20) != 0)
          {
            if ((v320 & 0x1000) != 0)
            {
              if (*(_QWORD *)&v286[4])
              {
                v99 = *(int *)v286;
                ++*(_DWORD *)v286;
                v146 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v99);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v100 = (int64_t *)v326;
                v326 += 2;
                v223 = *v100;
                v146 = v223;
              }
              v145 = v146;
            }
            else
            {
              if ((v320 & 0x400) != 0)
              {
                if (*(_QWORD *)&v286[4])
                {
                  v101 = *(int *)v286;
                  ++*(_DWORD *)v286;
                  v144 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v101);
                }
                else
                {
                  *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                  v102 = (int64_t *)v326;
                  v326 += 2;
                  v222 = *v102;
                  v144 = v222;
                }
                v143 = v144;
              }
              else
              {
                if ((v320 & 0x800) != 0)
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v103 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v142 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v103);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v104 = (uint64_t *)v326;
                    v326 += 2;
                    v221 = *v104;
                    v142 = v221;
                  }
                  v141 = v142;
                }
                else
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v105 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v140 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v105);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v106 = (uint64_t *)v326;
                    v326 += 2;
                    v220 = *v106;
                    v140 = v220;
                  }
                  v141 = v140;
                }
                v143 = v141;
              }
              v145 = v143;
            }
            v297 = v145;
          }
          else
          {
            if ((v320 & 0x10) != 0)
            {
              if (*(_QWORD *)&v286[4])
              {
                v107 = *(int *)v286;
                ++*(_DWORD *)v286;
                v139 = *(_QWORD *)(*(_QWORD *)&v286[4] + 16 * v107);
              }
              else
              {
                *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                v108 = (int64_t *)v326;
                v326 += 2;
                v219 = *v108;
                v139 = v219;
              }
              v138 = v139;
            }
            else
            {
              if ((v320 & 0x40) != 0)
              {
                if (*(_QWORD *)&v286[4])
                {
                  v109 = *(int *)v286;
                  ++*(_DWORD *)v286;
                  v137 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v109);
                }
                else
                {
                  *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                  v110 = v326;
                  v326 += 2;
                  v218 = *v110;
                  LOWORD(v137) = v218;
                }
                v136 = (unsigned __int16)v137;
              }
              else
              {
                if ((v320 & 0x2000) != 0)
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v111 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v135 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v111);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v112 = v326;
                    v326 += 2;
                    v217 = *v112;
                    LOBYTE(v135) = v217;
                  }
                  v134 = v135;
                }
                else
                {
                  if (*(_QWORD *)&v286[4])
                  {
                    v113 = *(int *)v286;
                    ++*(_DWORD *)v286;
                    v133 = *(_DWORD *)(*(_QWORD *)&v286[4] + 16 * v113);
                  }
                  else
                  {
                    *(_QWORD *)v286 = (*(_DWORD *)v286 + 1);
                    v114 = (unsigned int *)v326;
                    v326 += 2;
                    v216 = *v114;
                    v133 = v216;
                  }
                  v134 = v133;
                }
                v136 = v134;
              }
              v138 = v136;
            }
            v298 = v138;
          }
          v296 = 16;
          if ((v320 & 1) == 0)
            goto LABEL_441;
          if ((v320 & 0x1C20) != 0)
          {
            if (!v297)
              goto LABEL_441;
          }
          else if (!v298)
          {
            goto LABEL_441;
          }
          v288 = v324;
LABEL_441:
          v320 &= ~0x200u;
LABEL_442:
          v316 = 0;
LABEL_443:
          v295 = v317;
          if ((v317 & 0x80000000) == 0)
            v320 &= ~0x80u;
          i = (uint64_t)v334;
          if ((v320 & 0x1C20) != 0)
          {
            if (v297 || v317 || (v320 & 1) != 0 && v296 == 8)
              i = (uint64_t)__ujtoa(v297, i, v296, v320 & 1, (uint64_t)v291, v8, v9, v10);
          }
          else if (v298 || v317 || (v320 & 1) != 0 && v296 == 8)
          {
            i = (uint64_t)__ultoa(v298, i, v296, v320 & 1, (uint64_t)v291, v8, v9, v10);
          }
          v293 = (uint64_t)&v333[-i + 32];
          if (v293 >= 33)
            abort_report_np((uint64_t)"%s:%s:%u: size (%zd) > BUF (%d)", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"vfprintf.c");
          if ((v320 & 0x200) != 0 && v293)
          {
            v115 = grouping_init((uint64_t)&v313, v293, v328);
            v293 += v115;
          }
          goto LABEL_466;
        case 'z':
          v320 |= 0x400u;
          continue;
        default:
          if (!v324)
            goto LABEL_655;
          i = (uint64_t)v333;
          v333[0] = v324;
          v293 = 1;
          v316 = 0;
          goto LABEL_466;
      }
      break;
    }
  }
LABEL_655:
  io_flush((_QWORD **)v289, (uint64_t)v328);
LABEL_656:
  if (v302)
    __freedtoa(v302);
  free(v284);
  if ((*(_WORD *)(v329 + 16) & 0x40) != 0)
    v319 = -1;
  if (*(_QWORD *)&v286[4] && *(_BYTE **)&v286[4] != v332)
    free(*(void **)&v286[4]);
  if (v319 < 0 || v319 >= 0x7FFFFFFF)
    return -1;
  else
    return v319;
}

uint64_t io_init(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = result + 24;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_QWORD *)result = a2;
  return result;
}

uint64_t io_print(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  int v4;

  *(_QWORD *)(a1 + 24 + 16 * *(int *)(a1 + 16)) = a2;
  *(_QWORD *)(a1 + 24 + 16 * *(int *)(a1 + 16) + 8) = a3;
  *(_DWORD *)(a1 + 20) += a3;
  v4 = *(_DWORD *)(a1 + 16) + 1;
  *(_DWORD *)(a1 + 16) = v4;
  if (v4 < 8)
    return 0;
  else
    return __sprint(*(_QWORD **)a1, a4, a1 + 8);
}

uint64_t exponent(_BYTE *a1, int a2, char a3)
{
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v10;
  _BYTE *v11;
  char v12;
  int v13;
  _BYTE *v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v10 = 0;
  v11 = a1 + 1;
  *a1 = a3;
  if (v13 >= 0)
  {
    v4 = v11++;
    *v4 = 43;
  }
  else
  {
    v13 = -v13;
    v3 = v11++;
    *v3 = 45;
  }
  v10 = &v10;
  if (v13 <= 9)
  {
    if (v12 == 101 || v12 == 69)
    {
      v7 = v11++;
      *v7 = 48;
    }
    v8 = v11++;
    *v8 = v13 + 48;
  }
  else
  {
    do
    {
      *--v10 = v13 % 10 + 48;
      v13 /= 10;
    }
    while (v13 > 9);
    *--v10 = v13 + 48;
    while (v10 < (_BYTE *)&v10)
    {
      v5 = v10++;
      LOBYTE(v5) = *v5;
      v6 = v11++;
      *v6 = (_BYTE)v5;
    }
  }
  return v11 - v14;
}

uint64_t grouping_init(uint64_t a1, int a2, _xlocale *a3)
{
  lconv *v4;

  v4 = localeconv_l(a3);
  *(_QWORD *)(a1 + 16) = __fix_nogrouping(v4->grouping);
  *(_QWORD *)a1 = v4->thousands_sep;
  *(_DWORD *)(a1 + 8) = _platform_strlen(*(_QWORD *)a1);
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 24) = a2;
  while (**(_BYTE **)(a1 + 16) != 127 && *(_DWORD *)(a1 + 24) > **(char **)(a1 + 16))
  {
    *(_DWORD *)(a1 + 24) -= **(char **)(a1 + 16);
    if (*(_BYTE *)(*(_QWORD *)(a1 + 16) + 1))
    {
      ++*(_DWORD *)(a1 + 28);
      ++*(_QWORD *)(a1 + 16);
    }
    else
    {
      ++*(_DWORD *)(a1 + 32);
    }
  }
  return ((*(_DWORD *)(a1 + 28) + *(_DWORD *)(a1 + 32)) * *(_DWORD *)(a1 + 8));
}

char *__wcsconv(const __int32 *a1, int a2, _xlocale *a3)
{
  __int32 *v3;
  size_t v5;
  size_t v6;
  size_t v7;
  char *v8;
  __int32 *v9;
  char v10[6];
  locale_t v11;
  int v12;
  const __int32 *v13;
  mbstate_t v15;

  v13 = a1;
  v12 = a2;
  v11 = a3;
  _platform_memset(&v15, 0, 128);
  v9 = 0;
  if (v12 >= 0)
  {
    if (v12 >= 128)
    {
      v5 = 0;
      v9 = (__int32 *)v13;
      j___platform_memmove(&v15, &__wcsconv_initial, 128);
      while (1)
      {
        v3 = v9++;
        v7 = wcrtomb_l(v10, *v3, &v15, v11);
        if (!v7 || v7 == -1 || v5 + v7 > v12)
          break;
        v5 += v7;
      }
    }
    else
    {
      v5 = v12;
    }
  }
  else
  {
    v9 = (__int32 *)v13;
    j___platform_memmove(&v15, &__wcsconv_initial, 128);
    v5 = wcsrtombs_l(0, (const __int32 **)&v9, 0, &v15, v11);
    if (v5 == -1)
      return 0;
  }
  v8 = (char *)malloc_type_malloc(v5 + 1, 262474977);
  if (!v8)
    return 0;
  v9 = (__int32 *)v13;
  j___platform_memmove(&v15, &__wcsconv_initial, 128);
  v6 = wcsrtombs_l(v8, (const __int32 **)&v9, v5, &v15, v11);
  if (v6 == -1)
  {
    free(v8);
    return 0;
  }
  else
  {
    v8[v6] = 0;
    return v8;
  }
}

_BYTE *__ujtoa(unint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return __ultoa(a1, a2, a3, a4, a5, a6, a7, a8);
}

_BYTE *__ultoa(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int64_t v9;
  _BYTE *v10;
  unint64_t v11;

  v11 = a1;
  v10 = (_BYTE *)a2;
  if ((_DWORD)a3 == 8)
  {
    do
    {
      *--v10 = (v11 & 7) + 48;
      v11 >>= 3;
    }
    while (v11);
    if ((_DWORD)a4 && *v10 != 48)
      *--v10 = 48;
    return v10;
  }
  if ((_DWORD)a3 != 10)
  {
    if ((_DWORD)a3 != 16)
      abort_report_np((uint64_t)"%s:%s:%u: __ultoa: invalid base=%d", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"printfcommon.h");
    do
    {
      *--v10 = *(_BYTE *)(a5 + (v11 & 0xF));
      v11 >>= 4;
    }
    while (v11);
    return v10;
  }
  if (a1 >= 0xA)
  {
    if (a1 <= 0x7FFFFFFFFFFFFFFFLL)
    {
      v9 = a1;
    }
    else
    {
      v10 = (_BYTE *)(a2 - 1);
      *(_BYTE *)(a2 - 1) = a1 % 0xA + 48;
      v9 = a1 / 0xA;
    }
    do
    {
      *--v10 = v9 % 10 + 48;
      v9 /= 10;
    }
    while (v9);
    return v10;
  }
  *(_BYTE *)(a2 - 1) = a1 + 48;
  return (_BYTE *)(a2 - 1);
}

uint64_t io_flush(_QWORD **a1, uint64_t a2)
{
  return __sprint(*a1, a2, (uint64_t)(a1 + 1));
}

uint64_t io_pad(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  int v5;

  while (a2 > 0)
  {
    if (a2 < 16)
      v5 = a2;
    else
      v5 = 16;
    if (io_print(a1, a3, v5, a4))
      return -1;
    a2 -= v5;
  }
  return 0;
}

uint64_t grouping_print(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  BOOL v6;
  int v7;
  unint64_t i;

  v7 = a3;
  if (io_printandpad(a2, a3, a4, *(_DWORD *)(a1 + 24), (uint64_t)&zeroes, a5))
  {
    return -1;
  }
  else
  {
    for (i = a3 + *(int *)(a1 + 24); ; i += **(char **)(a1 + 16))
    {
      v6 = 1;
      if (*(int *)(a1 + 28) <= 0)
        v6 = *(_DWORD *)(a1 + 32) > 0;
      if (!v6)
        break;
      if (*(int *)(a1 + 32) <= 0)
      {
        --*(_QWORD *)(a1 + 16);
        --*(_DWORD *)(a1 + 28);
      }
      else
      {
        --*(_DWORD *)(a1 + 32);
      }
      if (io_print(a2, *(_QWORD *)a1, *(_DWORD *)(a1 + 8), a5))
        return -1;
      if (io_printandpad(a2, i, a4, **(char **)(a1 + 16), (uint64_t)&zeroes, a5))
        return -1;
    }
    if (i > a4)
      LODWORD(i) = a4;
    return (i - v7);
  }
}

uint64_t io_printandpad(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6)
{
  int v7;

  v7 = a3 - a2;
  if (a3 - (int)a2 > a4)
    v7 = a4;
  if (v7 <= 0)
  {
    v7 = 0;
    return io_pad(a1, a4 - v7, a5, a6);
  }
  if (!io_print(a1, a2, v7, a6))
    return io_pad(a1, a4 - v7, a5, a6);
  return -1;
}

uint64_t __sprint(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;

  if (*(_DWORD *)(a3 + 12))
  {
    v3 = __sfvwrite(a1, a3);
    *(_DWORD *)(a3 + 12) = 0;
    *(_DWORD *)(a3 + 8) = 0;
    return v3;
  }
  else
  {
    *(_DWORD *)(a3 + 8) = 0;
    return 0;
  }
}

int vfscanf(FILE *__stream, const char *__format, va_list a3)
{
  char v3;
  char v4;
  _xlocale *v6;
  int v7;
  _xlocale *v10;
  uint64_t v11;

  libc_hooks_will_write((uint64_t)__stream, 152);
  flockfile(__stream);
  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v10 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v11 = __locale_key;
    v10 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v11);
  }
  if (v10)
    v6 = v10;
  else
    v6 = (_xlocale *)__global_locale;
  v7 = __svfscanf_l((int *)__stream, v6, (uint64_t)__format);
  funlockfile(__stream);
  return v7;
}

uint64_t __svfscanf_l(int *a1, _xlocale *a2, uint64_t a3)
{
  unsigned __int8 *v3;
  unint64_t v5;
  BOOL v6;
  int i;
  int v8;
  unsigned __int8 *v9;
  _BYTE v14[135];

  v9 = (unsigned __int8 *)a3;
  _platform_memset(v14, 0, 128);
  libc_hooks_will_write((uint64_t)a2, 1472);
  libc_hooks_will_read_cstring(a3);
  if (a2)
  {
    if (a2 == (_xlocale *)-1)
      a2 = (_xlocale *)__global_locale;
  }
  else
  {
    a2 = (_xlocale *)&__c_locale;
  }
  if (!((char)(32 * *(_BYTE *)(*((_QWORD *)a1 + 13) + 72)) >> 5))
    *(_BYTE *)(*((_QWORD *)a1 + 13) + 72) = *(_BYTE *)(*((_QWORD *)a1 + 13) + 72) & 0xF8 | 7;
  for (i = 0; ; ++i)
  {
    while (1)
    {
      v3 = v9++;
      v8 = *v3;
      if (!*v3)
        return 0;
      if (!isspace_l(v8, a2))
        break;
      while (1)
      {
        if (a1[2] > 0 || (v6 = 0, !__srefill((uint64_t)a1)))
          v6 = isspace_l(**(unsigned __int8 **)a1, a2) != 0;
        if (!v6)
          break;
        ++i;
        --a1[2];
        ++*(_QWORD *)a1;
      }
    }
    if (v8 == 37)
      break;
    if (a1[2] <= 0 && __srefill((uint64_t)a1))
      return -1;
    if (**(unsigned __int8 **)a1 != v8)
      return 0;
    --a1[2];
    ++*(_QWORD *)a1;
  }
  v5 = *v9;
  if (v5 <= 0x7A)
    __asm { BR              X8 }
  return 0;
}

int vfscanf_l(FILE *a1, locale_t a2, const char *a3, va_list a4)
{
  int v5;

  libc_hooks_will_write((uint64_t)a1, 152);
  if (a2)
  {
    if (a2 == (locale_t)-1)
      a2 = (locale_t)__global_locale;
  }
  else
  {
    a2 = (locale_t)&__c_locale;
  }
  flockfile(a1);
  v5 = __svfscanf_l((int *)a1, a2, (uint64_t)a3);
  funlockfile(a1);
  return v5;
}

unsigned __int8 *__sccl(uint64_t a1, unsigned __int8 *a2, _xlocale *a3)
{
  unsigned __int8 *v3;
  int v5;
  int i;
  unsigned int v7;
  char v8;
  int v9;
  int v10;
  unsigned __int8 *v12;

  v12 = a2 + 1;
  v10 = *a2;
  if (v10 == 94)
  {
    v7 = 1;
    v12 = a2 + 2;
    v10 = a2[1];
  }
  else
  {
    v7 = 0;
  }
  _platform_memset(a1, v7, 256);
  if (!v10)
    return v12 - 1;
  v8 = 1 - v7;
LABEL_7:
  while (2)
  {
    *(_BYTE *)(a1 + v10) = v8;
    while (1)
    {
      v3 = v12++;
      v5 = *v3;
      if (!*v3)
        return v12 - 1;
      if (v5 != 45)
        break;
      v9 = *v12;
      if (v9 == 93)
        goto LABEL_18;
      if (*(_BYTE *)(*((_QWORD *)a3 + 165) + 64))
      {
        if (v9 < v10)
          goto LABEL_18;
      }
      else if ((int)__collate_range_cmp(v9, v10, a3) < 0)
      {
LABEL_18:
        v10 = 45;
        goto LABEL_7;
      }
      ++v12;
      if (*(_BYTE *)(*((_QWORD *)a3 + 165) + 64))
      {
        do
          *(_BYTE *)(a1 + ++v10) = v8;
        while (v10 < v9);
      }
      else
      {
        for (i = 0; i < 256; ++i)
        {
          if ((int)__collate_range_cmp(v10, i, a3) < 0 && (int)__collate_range_cmp(i, v9, a3) <= 0)
            *(_BYTE *)(a1 + i) = v8;
        }
      }
      v10 = v9;
    }
    if (v5 != 93)
    {
      v10 = *v3;
      continue;
    }
    return v12;
  }
}

uint64_t parsefloat(uint64_t a1, unsigned __int8 **a2, uint64_t a3, _xlocale *a4)
{
  BOOL v5;
  size_t v6;
  unsigned __int8 *v7;
  unsigned __int8 *v8;

  localeconv_l(a4);
  if (a3)
    v6 = a3 + 1;
  else
    v6 = 513;
  v7 = (unsigned __int8 *)__parsefloat_buf(v6);
  if (v7)
  {
    v8 = v7;
    v5 = 1;
    if (a3)
      v5 = v7 < &v7[v6 - 1];
    if (v5)
      JUMPOUT(0x7818CLL);
    while (v7 - 1 < --v8)
      __ungetc(*v8, a1);
    *v7 = 0;
    *a2 = v7;
  }
  else
  {
    *a2 = 0;
  }
  return 0;
}

int __svfscanf(FILE *a1, const char *a2, va_list a3)
{
  char v3;
  char v4;
  _xlocale *v6;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    v6 = v9;
  else
    v6 = (_xlocale *)__global_locale;
  return __svfscanf_l((int *)a1, v6, (uint64_t)a2);
}

void *__parsefloat_buf(size_t a1)
{
  uint64_t v2;
  void *__ptr;
  void *__ptra;

  if (__parsefloat_buf_parsefloat_tsd_key == -1)
  {
    pthread_mutex_lock(&__parsefloat_buf_parsefloat_tsd_lock);
    if (__parsefloat_buf_parsefloat_tsd_key == -1)
    {
      __parsefloat_buf_parsefloat_tsd_key = 15;
      pthread_key_init_np(15, &_free);
    }
    pthread_mutex_unlock(&__parsefloat_buf_parsefloat_tsd_lock);
  }
  __ptr = pthread_getspecific(__parsefloat_buf_parsefloat_tsd_key);
  if (__ptr)
  {
    if (a1 > __parsefloat_buf_bsiz)
    {
      __ptr = reallocf(__ptr, a1);
      pthread_setspecific(__parsefloat_buf_parsefloat_tsd_key, __ptr);
      if (!__ptr)
      {
        __parsefloat_buf_bsiz = 0;
        return 0;
      }
      __parsefloat_buf_bsiz = a1;
    }
    return __ptr;
  }
  if (a1 <= 0x201)
    v2 = 513;
  else
    v2 = a1;
  __parsefloat_buf_bsiz = v2;
  __ptra = (void *)malloc_type_malloc(v2, 3079468584);
  if (__ptra)
  {
    pthread_setspecific(__parsefloat_buf_parsefloat_tsd_key, __ptra);
    return __ptra;
  }
  else
  {
    __parsefloat_buf_bsiz = 0;
    return 0;
  }
}

int vfwprintf_l(FILE *a1, locale_t a2, const __int32 *a3, __darwin_va_list a4)
{
  int v5;
  _xlocale *v8;

  v8 = a2;
  if (a2)
  {
    if (a2 == (locale_t)-1)
      v8 = (_xlocale *)__global_locale;
  }
  else
  {
    v8 = (_xlocale *)&__c_locale;
  }
  flockfile(a1);
  if ((a1->_flags & 0x1A) == 0xA && a1->_file >= 0)
    v5 = __sbprintf((uint64_t)a1, v8, (int *)a3, a4);
  else
    v5 = __vfwprintf((uint64_t)a1, v8, (int *)a3, a4);
  funlockfile(a1);
  return v5;
}

uint64_t __sbprintf(uint64_t a1, _xlocale *a2, int *a3, _DWORD *a4)
{
  BOOL v5;
  _BYTE *v6;
  int v7;
  __int16 v8;
  __int16 v9;
  _BYTE *v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  int v16;
  _DWORD *v17;
  int *v18;
  _xlocale *v19;
  uint64_t v20;
  _QWORD v22[8];
  uint64_t v23;
  uint64_t v24;
  _BYTE v25[1024];

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = a4;
  v16 = 0;
  _platform_memset(&v6, 0, 152);
  _platform_memset(&v23, 0, 208);
  v15 = &v23;
  v23 = 0;
  _platform_memset(v22, 0, 64);
  v22[0] = 850045858;
  j___platform_memmove(&v24, v22, 64);
  *((_BYTE *)v15 + 72) &= 0xF8u;
  _platform_memset(v15 + 10, 0, 128);
  *((_BYTE *)v15 + 72) &= ~8u;
  if ((*(_WORD *)(v20 + 16) & 8) == 0
    || (v5 = 0, !*(_QWORD *)(v20 + 24)) && (v5 = 0, (*(_WORD *)(v20 + 16) & 0x200) == 0))
  {
    v5 = __swsetup(v20) != 0;
  }
  if (v5)
  {
    return -1;
  }
  else
  {
    v8 = *(_WORD *)(v20 + 16) & 0xFFFD;
    v9 = *(_WORD *)(v20 + 18);
    v13 = *(_QWORD *)(v20 + 48);
    v14 = *(_QWORD *)(v20 + 80);
    *((_BYTE *)v15 + 72) = v15[9] & 0xF8 | ((char)(32 * *(_BYTE *)(*(_QWORD *)(v20 + 104) + 72)) >> 5) & 7;
    j___platform_memmove(v15 + 10, *(_QWORD *)(v20 + 104) + 80, 128);
    v6 = v25;
    v10 = v25;
    v7 = 1024;
    v11 = 1024;
    v12 = 0;
    v16 = __vfwprintf((uint64_t)&v6, v19, v18, v17);
    if (v16 >= 0 && __fflush((uint64_t)&v6))
      v16 = -1;
    if ((v8 & 0x40) != 0)
      *(_WORD *)(v20 + 16) |= 0x40u;
    return v16;
  }
}

uint64_t __vfwprintf(uint64_t a1, _xlocale *a2, int *a3, _DWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  int *v15;
  int *v16;
  uint64_t v17;
  int *v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  int *v26;
  wint_t v27;
  uint64_t v28;
  int64_t *v29;
  uint64_t v30;
  int64_t *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  int64_t *v37;
  uint64_t v38;
  int *v39;
  uint64_t v40;
  int *v41;
  uint64_t v42;
  int *v43;
  uint64_t v44;
  double *v45;
  char *v46;
  uint64_t v47;
  double *v48;
  char *v49;
  uint64_t v50;
  double *v51;
  int v52;
  uint64_t v53;
  double *v54;
  int v55;
  char *v56;
  char *v57;
  int inited;
  uint64_t v59;
  uint64_t **v60;
  uint64_t v61;
  int64_t *v62;
  uint64_t v63;
  int64_t *v64;
  uint64_t v65;
  uint64_t *v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  int64_t *v70;
  uint64_t v71;
  int *v72;
  uint64_t v73;
  int *v74;
  uint64_t v75;
  unsigned int *v76;
  uint64_t v77;
  int64_t *v78;
  uint64_t v79;
  __int32 **v80;
  uint64_t v81;
  char **v82;
  uint64_t v83;
  int64_t *v84;
  uint64_t v85;
  int64_t *v86;
  uint64_t v87;
  uint64_t *v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  int64_t *v92;
  uint64_t v93;
  int *v94;
  uint64_t v95;
  int *v96;
  uint64_t v97;
  unsigned int *v98;
  uint64_t v99;
  int64_t *v100;
  uint64_t v101;
  int64_t *v102;
  uint64_t v103;
  uint64_t *v104;
  uint64_t v105;
  uint64_t *v106;
  uint64_t v107;
  int64_t *v108;
  uint64_t v109;
  int *v110;
  uint64_t v111;
  int *v112;
  uint64_t v113;
  unsigned int *v114;
  int v115;
  uint64_t v116;
  _OWORD *v117;
  __int32 v118;
  uint64_t v119;
  uint64_t v120;
  int v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  __int32 *v127;
  uint64_t v130;
  uint64_t v131;
  __int128 v132;
  unsigned int v133;
  int64_t v134;
  int v135;
  int64_t v136;
  int v137;
  int64_t v138;
  int64_t v139;
  int64_t v140;
  int64_t v141;
  int64_t v142;
  int64_t v143;
  int64_t v144;
  int64_t v145;
  int64_t v146;
  unsigned int v147;
  int64_t v148;
  int v149;
  int64_t v150;
  int v151;
  int64_t v152;
  int64_t v153;
  int64_t v154;
  int64_t v155;
  int64_t v156;
  int64_t v157;
  int64_t v158;
  int64_t v159;
  int64_t v160;
  char *v161;
  __int32 *v162;
  int64_t v163;
  unsigned int v164;
  int64_t v165;
  int v166;
  int64_t v167;
  int v168;
  int64_t v169;
  int64_t v170;
  int64_t v171;
  int64_t v172;
  int64_t v173;
  int64_t v174;
  int64_t v175;
  int64_t v176;
  int64_t v177;
  uint64_t *v178;
  double v179;
  double v180;
  double v181;
  double v182;
  int v183;
  int64_t v184;
  int v185;
  int64_t v186;
  int v187;
  int64_t v188;
  int64_t v189;
  int64_t v190;
  int64_t v191;
  int64_t v192;
  int64_t v193;
  int64_t v194;
  int64_t v195;
  int64_t v196;
  int v197;
  int v198;
  int v199;
  int v200;
  int v201;
  int v202;
  BOOL v203;
  BOOL v204;
  int v205;
  int v206;
  char *v207;
  int v208;
  int v209;
  char *v210;
  int v211;
  int v212;
  int j;
  unsigned int v214;
  int v215;
  int v216;
  int64_t v217;
  uint64_t v218;
  uint64_t v219;
  int64_t v220;
  int64_t v221;
  unsigned int v222;
  int v223;
  int v224;
  int64_t v225;
  uint64_t v226;
  uint64_t v227;
  int64_t v228;
  int64_t v229;
  char *v230;
  char *v231;
  __int32 *v232;
  int64_t v233;
  unsigned int v234;
  int v235;
  int v236;
  int64_t v237;
  uint64_t v238;
  uint64_t v239;
  int64_t v240;
  int64_t v241;
  uint64_t *v242;
  uint64_t *v243;
  double v244;
  double v245;
  double v246;
  double v247;
  int v248;
  int v249;
  int v250;
  int64_t v251;
  uint64_t v252;
  uint64_t v253;
  int64_t v254;
  int64_t v255;
  int v256;
  int v257;
  int v258;
  int v259;
  int v260;
  int v261;
  int v262;
  int v263;
  void *v264;
  _DWORD *v265;
  _BYTE v266[12];
  _OWORD v267[9];
  uint64_t v268;
  const char *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  int v273;
  unsigned int v274;
  int64_t v275;
  int64_t v276;
  int v277;
  __int32 *v278;
  __int128 v279;
  char *v280;
  int v281;
  int v282;
  uint64_t v283;
  char v284;
  int v285;
  double v286;
  int v287;
  int decpt;
  _OWORD v289[2];
  int v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  int v294;
  __int32 *i;
  uint64_t v296;
  uint64_t v297;
  int v298;
  __int32 *v299;
  _DWORD *v300;
  int *v301;
  locale_t v302;
  uint64_t v303;
  _BYTE v305[34];
  _BYTE v306[128];
  int v307;
  int v308;
  _DWORD v309[32];
  _DWORD v310[8];

  v303 = a1;
  v302 = a2;
  v301 = a3;
  v300 = a4;
  v299 = 0;
  v298 = 0;
  v297 = 0;
  v296 = 0;
  i = 0;
  v294 = 0;
  v293 = 0;
  v292 = 0;
  v291 = 0;
  v290 = 0;
  memset(v289, 0, sizeof(v289));
  decpt = 0;
  v287 = 0;
  v286 = 0.0;
  v285 = 0;
  v284 = 0;
  v283 = 0;
  v282 = 0;
  v281 = 0;
  v280 = 0;
  v279 = 0uLL;
  v278 = 0;
  v277 = 0;
  v276 = 0;
  v275 = 0;
  v274 = 0;
  v273 = 0;
  v272 = 0;
  v271 = 0;
  v270 = 0;
  v269 = 0;
  v268 = 0;
  memset(v267, 0, sizeof(v267));
  memset(v266, 0, sizeof(v266));
  v265 = 0;
  v264 = 0;
  if ((*(_WORD *)(a1 + 16) & 8) == 0
    || (v204 = 0, !*(_QWORD *)(v303 + 24)) && (v204 = 0, (*(_WORD *)(v303 + 16) & 0x200) == 0))
  {
    v204 = __swsetup(v303) != 0;
  }
  if (v204)
  {
    *__error() = 9;
    return -1;
  }
  else
  {
    if ((*(_BYTE *)(*(_QWORD *)(v303 + 104) + 72) & 7) == 0)
      *(_BYTE *)(*(_QWORD *)(v303 + 104) + 72) = *(_BYTE *)(*(_QWORD *)(v303 + 104) + 72) & 0xF8 | 1;
    v264 = 0;
    v299 = v301;
    *(_QWORD *)&v266[4] = 0;
    *(_DWORD *)v266 = 1;
    v265 = v300;
    io_init((uint64_t)v267, v303);
    v293 = 0;
    decpt = get_decpt(v302);
    while (1)
    {
LABEL_10:
      i = v299;
      while (1)
      {
        v298 = *v299;
        v203 = 0;
        if (v298)
          v203 = v298 != 37;
        if (!v203)
          break;
        ++v299;
      }
      v297 = v299 - i;
      if (v297)
      {
        if (v293 + v297 >= 0x80000000)
          goto LABEL_597;
        if (io_print_0((uint64_t)v267, (uint64_t)i, v297, v302))
          goto LABEL_644;
        v293 += v297;
      }
      if (!v298)
        break;
      v278 = v299++;
      v294 = 0;
      v273 = 0;
      v292 = 0;
      v291 = -1;
      *((_QWORD *)&v289[0] + 1) = 0;
      v290 = 0;
      v308 = 0;
      v277 = 88;
      while (2)
      {
        v11 = v299++;
        v298 = *v11;
LABEL_23:
        switch(v298)
        {
          case ' ':
            if (!v290)
              v290 = 32;
            continue;
          case '#':
            v294 |= 1u;
            continue;
          case '\'':
            v294 |= 0x200u;
            continue;
          case '*':
            v296 = 0;
            for (i = v299; (*i - 48) <= 9; ++i)
              v296 = 10 * v296 + *i - 48;
            if (*i == 36)
            {
              v263 = *(_DWORD *)v266;
              if (!*(_QWORD *)&v266[4])
              {
                *(_QWORD *)&v266[4] = v306;
                if (__find_warguments(v301, v265, (uint64_t *)&v266[4]))
                {
                  v293 = -1;
                  goto LABEL_644;
                }
              }
              *(_DWORD *)v266 = v296;
              if (*(_QWORD *)&v266[4])
              {
                v12 = *(int *)v266;
                ++*(_DWORD *)v266;
                v202 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v12);
              }
              else
              {
                *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                v13 = v300;
                v300 += 2;
                v262 = *v13;
                v202 = v262;
              }
              v292 = v202;
              *(_DWORD *)v266 = v263;
              v299 = ++i;
            }
            else
            {
              if (*(_QWORD *)&v266[4])
              {
                v14 = *(int *)v266;
                ++*(_DWORD *)v266;
                v201 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v14);
              }
              else
              {
                *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                v15 = v300;
                v300 += 2;
                v261 = *v15;
                v201 = v261;
              }
              v292 = v201;
            }
            if (v292 < 0)
            {
              v292 = -v292;
LABEL_46:
              v294 |= 4u;
            }
            continue;
          case '+':
            v290 = 43;
            continue;
          case ',':
          case ':':
          case ';':
          case '_':
            v277 = v298;
            continue;
          case '-':
            goto LABEL_46;
          case '.':
            v16 = v299++;
            v298 = *v16;
            if (v298 != 42)
            {
              v291 = 0;
              while ((v298 - 48) <= 9)
              {
                v291 = 10 * v291 + v298 - 48;
                v21 = v299++;
                v298 = *v21;
              }
              goto LABEL_23;
            }
            v296 = 0;
            for (i = v299; (*i - 48) <= 9; ++i)
              v296 = 10 * v296 + *i - 48;
            if (*i == 36)
            {
              v260 = *(_DWORD *)v266;
              if (!*(_QWORD *)&v266[4])
              {
                *(_QWORD *)&v266[4] = v306;
                if (__find_warguments(v301, v265, (uint64_t *)&v266[4]))
                {
                  v293 = -1;
                  goto LABEL_644;
                }
              }
              *(_DWORD *)v266 = v296;
              if (*(_QWORD *)&v266[4])
              {
                v17 = *(int *)v266;
                ++*(_DWORD *)v266;
                v200 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v17);
              }
              else
              {
                *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                v18 = v300;
                v300 += 2;
                v259 = *v18;
                v200 = v259;
              }
              v291 = v200;
              *(_DWORD *)v266 = v260;
              v299 = ++i;
            }
            else
            {
              if (*(_QWORD *)&v266[4])
              {
                v19 = *(int *)v266;
                ++*(_DWORD *)v266;
                v199 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v19);
              }
              else
              {
                *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                v20 = v300;
                v300 += 2;
                v258 = *v20;
                v199 = v258;
              }
              v291 = v199;
            }
            continue;
          case '0':
            v294 |= 0x80u;
            continue;
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            v297 = 0;
            do
            {
              v297 = 10 * v297 + v298 - 48;
              v22 = v299++;
              v298 = *v22;
            }
            while ((v298 - 48) < 0xA);
            if (v298 != 36)
            {
              v292 = v297;
              goto LABEL_23;
            }
            *(_DWORD *)v266 = v297;
            if (!*(_QWORD *)&v266[4])
            {
              *(_QWORD *)&v266[4] = v306;
              if (__find_warguments(v301, v265, (uint64_t *)&v266[4]))
              {
                v293 = -1;
                goto LABEL_644;
              }
            }
            continue;
          case 'A':
          case 'a':
            if ((v294 & 0x4000) != 0)
            {
              v294 |= 0x100u;
              goto LABEL_462;
            }
            if (v298 == 97)
            {
              v308 = 120;
              v269 = (const char *)&__vfwprintf_xdigs_lower;
              v284 = 112;
            }
            else
            {
              v308 = 88;
              v269 = "0123456789ABCDEFn";
              v284 = 80;
            }
            if ((v291 & 0x8000000000000000) == 0)
              ++v291;
            if ((v294 & 8) != 0)
            {
              if (*(_QWORD *)&v266[4])
              {
                v44 = *(int *)v266;
                ++*(_DWORD *)v266;
                v182 = *(double *)(*(_QWORD *)&v266[4] + 16 * v44);
              }
              else
              {
                *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                v45 = (double *)v300;
                v300 += 2;
                v247 = *v45;
                v182 = v247;
              }
              v286 = v182;
              __hldtoa((uint64_t)v269, v291, (uint64_t)&v285, &v287, v182);
              v280 = v46;
            }
            else
            {
              if (*(_QWORD *)&v266[4])
              {
                v47 = *(int *)v266;
                ++*(_DWORD *)v266;
                v181 = *(double *)(*(_QWORD *)&v266[4] + 16 * v47);
              }
              else
              {
                *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                v48 = (double *)v300;
                v300 += 2;
                v246 = *v48;
                v181 = v246;
              }
              v286 = v181;
              __hdtoa(v181, (uint64_t)v269, v291, (uint64_t)&v285, &v287);
              v280 = v49;
            }
            if (v291 < 0)
              v291 = v283 - (_QWORD)v280;
            if (v285 == 0x7FFFFFFF)
              v308 = 0;
            free(v264);
            v281 = v283 - (_DWORD)v280;
            v264 = __mbsconv(v280, -1, v302);
            i = (__int32 *)v264;
            __freedtoa((uint64_t)v280);
            goto LABEL_204;
          case 'C':
            v294 |= 0x10u;
            goto LABEL_90;
          case 'D':
            v294 |= 0x10u;
            goto LABEL_102;
          case 'E':
          case 'e':
            if ((v294 & 0x4000) != 0)
            {
              v294 |= 0x100u;
              goto LABEL_462;
            }
            v284 = v298;
            if (v291 < 0)
              v291 = 7;
            else
              ++v291;
            goto LABEL_185;
          case 'F':
          case 'f':
            if ((v294 & 0x4000) != 0)
            {
              v294 |= 0x100u;
              goto LABEL_462;
            }
            v284 = 0;
            goto LABEL_185;
          case 'G':
          case 'g':
            if ((v294 & 0x4000) != 0)
            {
              v294 |= 0x100u;
            }
            else
            {
              v284 = v298 - 2;
              if (!v291)
                v291 = 1;
LABEL_185:
              if (v291 < 0)
                v291 = 6;
              free(v264);
              if ((v294 & 8) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v50 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v180 = *(double *)(*(_QWORD *)&v266[4] + 16 * v50);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v51 = (double *)v300;
                  v300 += 2;
                  v245 = *v51;
                  v180 = v245;
                }
                v286 = v180;
                if (v284)
                  v52 = 2;
                else
                  v52 = 3;
                v280 = (char *)__ldtoa(&v286, v52, v291, &v285, &v287, &v283);
              }
              else
              {
                if (*(_QWORD *)&v266[4])
                {
                  v53 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v179 = *(double *)(*(_QWORD *)&v266[4] + 16 * v53);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v54 = (double *)v300;
                  v300 += 2;
                  v244 = *v54;
                  v179 = v244;
                }
                v286 = v179;
                if (v284)
                  v55 = 2;
                else
                  v55 = 3;
                v280 = (char *)__dtoa(v55, v291, &v285, &v287, &v283, v179);
                if (v285 == 9999)
                  v285 = 0x7FFFFFFF;
              }
              v281 = v283 - (_DWORD)v280;
              v264 = __mbsconv(v280, -1, v302);
              i = (__int32 *)v264;
              __freedtoa((uint64_t)v280);
LABEL_204:
              if (v287)
                v290 = 45;
              if (v285 == 0x7FFFFFFF)
              {
                if (*i == 78)
                {
                  v56 = "n";
                  if (v298 <= 96)
                    v56 = "N";
                  i = (__int32 *)v56;
                  v290 = 0;
                }
                else
                {
                  v57 = "i";
                  if (v298 <= 96)
                    v57 = "I";
                  i = (__int32 *)v57;
                }
                v271 = 3;
                v294 &= ~0x80u;
              }
              else
              {
                v294 |= 0x100u;
                if (v298 == 103 || v298 == 71)
                {
                  if (v285 < -3 || v285 > v291)
                  {
                    if ((v294 & 1) == 0)
                      v291 = v281;
                  }
                  else
                  {
                    v284 = 0;
                    if ((v294 & 1) != 0)
                      v291 -= v285;
                    else
                      v291 = v281 - v285;
                    if (v291 < 0)
                      v291 = 0;
                  }
                }
                if (v284)
                {
                  v282 = exponent_0(v310, v285 - 1, v284);
                  v271 = v282 + v291;
                  if (v291 > 1 || (v294 & 1) != 0)
                    ++v271;
                }
                else
                {
                  if (v285 < 1)
                    v271 = 1;
                  else
                    v271 = v285;
                  if (v291 || (v294 & 1) != 0)
                    v271 += v291 + 1;
                  if ((v294 & 0x200) != 0 && v285 >= 1)
                  {
                    inited = grouping_init_0((uint64_t)v289, v285, v302);
                    v271 += inited;
                  }
                }
              }
            }
            goto LABEL_462;
          case 'L':
            v294 |= 8u;
            continue;
          case 'O':
            v294 |= 0x10u;
            goto LABEL_262;
          case 'S':
            v294 |= 0x10u;
            goto LABEL_315;
          case 'U':
            v294 |= 0x10u;
            goto LABEL_336;
          case 'X':
            v269 = "0123456789ABCDEFn";
            goto LABEL_385;
          case 'c':
LABEL_90:
            if ((v294 & 0x4000) == 0)
            {
              if ((v294 & 0x10) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v23 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v198 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v23);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v24 = v300;
                  v300 += 2;
                  v257 = *v24;
                  v198 = v257;
                }
                i = v309;
                v309[0] = v198;
              }
              else
              {
                if (*(_QWORD *)&v266[4])
                {
                  v25 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v197 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v25);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v26 = v300;
                  v300 += 2;
                  v256 = *v26;
                  v197 = v256;
                }
                v27 = btowc_l(v197, v302);
                i = v309;
                v309[0] = v27;
              }
              v271 = 1;
              v290 = 0;
            }
            goto LABEL_462;
          case 'd':
          case 'i':
LABEL_102:
            if ((v294 & 0x4000) != 0)
              goto LABEL_462;
            if ((v294 & 0x1C20) != 0)
            {
              if ((v294 & 0x1000) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v28 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v196 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v28);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v29 = (int64_t *)v300;
                  v300 += 2;
                  v255 = *v29;
                  v196 = v255;
                }
                v195 = v196;
              }
              else
              {
                if ((v294 & 0x400) != 0)
                {
                  if (*(_QWORD *)&v266[4])
                  {
                    v30 = *(int *)v266;
                    ++*(_DWORD *)v266;
                    v194 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v30);
                  }
                  else
                  {
                    *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                    v31 = (int64_t *)v300;
                    v300 += 2;
                    v254 = *v31;
                    v194 = v254;
                  }
                  v193 = v194;
                }
                else
                {
                  if ((v294 & 0x800) != 0)
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v32 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v192 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v32);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v33 = (uint64_t *)v300;
                      v300 += 2;
                      v253 = *v33;
                      v192 = v253;
                    }
                    v191 = v192;
                  }
                  else
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v34 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v190 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v34);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v35 = (uint64_t *)v300;
                      v300 += 2;
                      v252 = *v35;
                      v190 = v252;
                    }
                    v191 = v190;
                  }
                  v193 = v191;
                }
                v195 = v193;
              }
              v275 = v195;
              if (v195 < 0)
              {
                v275 = -v275;
                v290 = 45;
              }
            }
            else
            {
              if ((v294 & 0x10) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v36 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v189 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v36);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v37 = (int64_t *)v300;
                  v300 += 2;
                  v251 = *v37;
                  v189 = v251;
                }
                v188 = v189;
              }
              else
              {
                if ((v294 & 0x40) != 0)
                {
                  if (*(_QWORD *)&v266[4])
                  {
                    v38 = *(int *)v266;
                    ++*(_DWORD *)v266;
                    v187 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v38);
                  }
                  else
                  {
                    *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                    v39 = v300;
                    v300 += 2;
                    v250 = *v39;
                    LOWORD(v187) = v250;
                  }
                  v186 = (__int16)v187;
                }
                else
                {
                  if ((v294 & 0x2000) != 0)
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v40 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v185 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v40);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v41 = v300;
                      v300 += 2;
                      v249 = *v41;
                      LOBYTE(v185) = v249;
                    }
                    v184 = (char)v185;
                  }
                  else
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v42 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v183 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v42);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v43 = v300;
                      v300 += 2;
                      v248 = *v43;
                      v183 = v248;
                    }
                    v184 = v183;
                  }
                  v186 = v184;
                }
                v188 = v186;
              }
              v276 = v188;
              if (v188 < 0)
              {
                v276 = -v276;
                v290 = 45;
              }
            }
            v274 = 10;
            goto LABEL_439;
          case 'h':
            if ((v294 & 0x40) != 0)
            {
              v294 &= ~0x40u;
              v294 |= 0x2000u;
            }
            else
            {
              v294 |= 0x40u;
            }
            continue;
          case 'j':
            v294 |= 0x1000u;
            continue;
          case 'l':
            if ((v294 & 0x10) != 0)
            {
              v294 &= ~0x10u;
              v294 |= 0x20u;
            }
            else
            {
              v294 |= 0x10u;
            }
            continue;
          case 'n':
            v243 = 0;
            if (*(_QWORD *)&v266[4])
            {
              v59 = *(int *)v266;
              ++*(_DWORD *)v266;
              v178 = *(uint64_t **)(*(_QWORD *)&v266[4] + 16 * v59);
            }
            else
            {
              *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
              v60 = (uint64_t **)v300;
              v300 += 2;
              v242 = *v60;
              v178 = v242;
            }
            v243 = v178;
            if (v178)
            {
              if ((v294 & 0x20) != 0)
              {
                *v243 = v293;
              }
              else if ((v294 & 0x400) != 0)
              {
                *v243 = v293;
              }
              else if ((v294 & 0x800) != 0)
              {
                *v243 = v293;
              }
              else if ((v294 & 0x1000) != 0)
              {
                *v243 = v293;
              }
              else if ((v294 & 0x10) != 0)
              {
                *v243 = v293;
              }
              else if ((v294 & 0x40) != 0)
              {
                *(_WORD *)v243 = v293;
              }
              else if ((v294 & 0x2000) != 0)
              {
                *(_BYTE *)v243 = v293;
              }
              else
              {
                *(_DWORD *)v243 = v293;
              }
            }
            goto LABEL_10;
          case 'o':
LABEL_262:
            if ((v294 & 0x4000) != 0)
              goto LABEL_462;
            if ((v294 & 0x1C20) != 0)
            {
              if ((v294 & 0x1000) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v61 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v177 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v61);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v62 = (int64_t *)v300;
                  v300 += 2;
                  v241 = *v62;
                  v177 = v241;
                }
                v176 = v177;
              }
              else
              {
                if ((v294 & 0x400) != 0)
                {
                  if (*(_QWORD *)&v266[4])
                  {
                    v63 = *(int *)v266;
                    ++*(_DWORD *)v266;
                    v175 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v63);
                  }
                  else
                  {
                    *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                    v64 = (int64_t *)v300;
                    v300 += 2;
                    v240 = *v64;
                    v175 = v240;
                  }
                  v174 = v175;
                }
                else
                {
                  if ((v294 & 0x800) != 0)
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v65 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v173 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v65);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v66 = (uint64_t *)v300;
                      v300 += 2;
                      v239 = *v66;
                      v173 = v239;
                    }
                    v172 = v173;
                  }
                  else
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v67 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v171 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v67);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v68 = (uint64_t *)v300;
                      v300 += 2;
                      v238 = *v68;
                      v171 = v238;
                    }
                    v172 = v171;
                  }
                  v174 = v172;
                }
                v176 = v174;
              }
              v275 = v176;
            }
            else
            {
              if ((v294 & 0x10) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v69 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v170 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v69);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v70 = (int64_t *)v300;
                  v300 += 2;
                  v237 = *v70;
                  v170 = v237;
                }
                v169 = v170;
              }
              else
              {
                if ((v294 & 0x40) != 0)
                {
                  if (*(_QWORD *)&v266[4])
                  {
                    v71 = *(int *)v266;
                    ++*(_DWORD *)v266;
                    v168 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v71);
                  }
                  else
                  {
                    *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                    v72 = v300;
                    v300 += 2;
                    v236 = *v72;
                    LOWORD(v168) = v236;
                  }
                  v167 = (unsigned __int16)v168;
                }
                else
                {
                  if ((v294 & 0x2000) != 0)
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v73 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v166 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v73);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v74 = v300;
                      v300 += 2;
                      v235 = *v74;
                      LOBYTE(v166) = v235;
                    }
                    v165 = v166;
                  }
                  else
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v75 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v164 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v75);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v76 = v300;
                      v300 += 2;
                      v234 = *v76;
                      v164 = v234;
                    }
                    v165 = v164;
                  }
                  v167 = v165;
                }
                v169 = v167;
              }
              v276 = v169;
            }
            v274 = 8;
            goto LABEL_438;
          case 'p':
            if ((v294 & 0x4000) != 0)
              goto LABEL_462;
            if (*(_QWORD *)&v266[4])
            {
              v77 = *(int *)v266;
              ++*(_DWORD *)v266;
              v163 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v77);
            }
            else
            {
              *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
              v78 = (int64_t *)v300;
              v300 += 2;
              v233 = *v78;
              v163 = v233;
            }
            v275 = v163;
            v274 = 16;
            v269 = (const char *)&__vfwprintf_xdigs_lower;
            v294 |= 0x1000u;
            v308 = 120;
            goto LABEL_438;
          case 'q':
            v294 |= 0x20u;
            continue;
          case 's':
LABEL_315:
            if ((v294 & 0x10) != 0)
            {
              if (*(_QWORD *)&v266[4])
              {
                v79 = *(int *)v266;
                ++*(_DWORD *)v266;
                v162 = *(__int32 **)(*(_QWORD *)&v266[4] + 16 * v79);
              }
              else
              {
                *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                v80 = (__int32 **)v300;
                v300 += 2;
                v232 = *v80;
                v162 = v232;
              }
              i = v162;
              if (!v162)
                i = (__int32 *)"(";
            }
            else
            {
              v231 = 0;
              free(v264);
              if (*(_QWORD *)&v266[4])
              {
                v81 = *(int *)v266;
                ++*(_DWORD *)v266;
                v161 = *(char **)(*(_QWORD *)&v266[4] + 16 * v81);
              }
              else
              {
                *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                v82 = (char **)v300;
                v300 += 2;
                v230 = *v82;
                v161 = v230;
              }
              v231 = v161;
              if (v161)
              {
                v264 = __mbsconv(v231, v291, v302);
                if (!v264)
                {
                  *(_WORD *)(v303 + 16) |= 0x40u;
                  goto LABEL_644;
                }
                i = (__int32 *)v264;
              }
              else
              {
                v264 = 0;
                i = (__int32 *)"(";
              }
            }
            v271 = wcslen(i);
            if (v271 >= 0x7FFFFFFF)
              goto LABEL_597;
            if ((v291 & 0x8000000000000000) == 0 && v291 < v271)
              v271 = v291;
            v290 = 0;
LABEL_462:
            if ((v294 & 0x4000) != 0)
            {
              j = 0;
              v212 = 0;
              v211 = 0;
              v210 = 0;
              v209 = 0;
              v208 = 0;
              v207 = 0;
              v206 = 0;
              if (*(_QWORD *)&v266[4])
              {
                v116 = *(int *)v266;
                ++*(_DWORD *)v266;
                v132 = *(_OWORD *)(*(_QWORD *)&v266[4] + 16 * v116);
              }
              else
              {
                *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                v117 = (_OWORD *)(((unint64_t)v300 + 15) & 0xFFFFFFFFFFFFFFF0);
                v300 = v117 + 1;
                v132 = *v117;
              }
              v279 = v132;
              if ((unint64_t)((((char *)v299 - (char *)v278 - 4) >> 2) + 2) > 0x21)
                v210 = (char *)malloc_type_malloc((((char *)v299 - (char *)v278 - 4) >> 2) + 3, 4062482863);
              else
                v210 = v305;
              if (v277 == 88)
              {
                if (v298 == 99)
                  v277 = 0;
                else
                  v277 = 32;
              }
              v212 = 0;
              for (j = 0; j < ((char *)v299 - (char *)v278 - 4) >> 2; ++j)
              {
                switch(v278[j])
                {
                  case '*':
                    if (v278[j - 1] == 46)
                      v208 = 1;
                    else
                      v209 = 1;
                    goto LABEL_479;
                  case ',':
                  case ':':
                  case ';':
                  case '_':
                  case 'h':
                  case 'l':
                  case 'v':
                    continue;
                  default:
LABEL_479:
                    v118 = v278[j];
                    v119 = v212++;
                    v210[v119] = v118;
                    break;
                }
              }
              if ((v294 & 0x40) != 0)
              {
                if (v298 == 99)
                {
                  v205 = 1;
                }
                else if (v298 == 112)
                {
                  v205 = 4;
                }
                else
                {
                  v120 = v212++;
                  v210[v120] = 104;
                  v205 = 1;
                }
                v211 = 8;
                goto LABEL_509;
              }
              if ((v294 & 0x10) != 0)
              {
                v211 = 4;
                if (v298 == 112)
                  v121 = 5;
                else
                  v121 = 2;
                v205 = v121;
                goto LABEL_509;
              }
              if (v298 != 65 && v298 != 69 && v298 != 71)
              {
                if (v298 == 88)
                  goto LABEL_504;
                if (v298 != 97)
                {
                  if (v298 == 99)
                    goto LABEL_505;
                  if (v298 == 100)
                    goto LABEL_504;
                  if ((v298 - 101) >= 3)
                  {
                    if (v298 != 112)
                    {
LABEL_504:
                      v122 = v212++;
                      v210[v122] = 104;
                      v123 = v212++;
                      v210[v123] = 104;
                    }
LABEL_505:
                    v211 = 16;
                    if (v298 == 112)
                      v124 = 3;
                    else
                      v124 = 0;
                    v205 = v124;
                    goto LABEL_509;
                  }
                }
              }
              v211 = 4;
              v205 = 6;
LABEL_509:
              v125 = v212++;
              v210[v125] = v298;
              v126 = v212++;
              v210[v126] = 0;
              if (v209)
              {
                if (v208)
                {
                  switch(v205)
                  {
                    case 0:
                    case 3:
                      v206 = asprintf_l(&v207, v302, v210, v292, v291, v279);
                      break;
                    case 1:
                    case 4:
                      v206 = asprintf_l(&v207, v302, v210, v292, v291, (unsigned __int16)v279);
                      break;
                    case 2:
                    case 5:
                      v206 = asprintf_l(&v207, v302, v210, v292, v291, v279);
                      break;
                    case 6:
                      v206 = asprintf_l(&v207, v302, v210, v292, v291, *(float *)&v279);
                      break;
                    default:
                      break;
                  }
                  v293 += v206;
                  if (io_print_0((uint64_t)v267, (uint64_t)v207, v206, v302))
                    goto LABEL_644;
                  free(v207);
                  for (j = 1; j < v211; ++j)
                  {
                    if (v277 && io_print_0((uint64_t)v267, (uint64_t)&v277, 1, v302))
                      goto LABEL_644;
                    switch(v205)
                    {
                      case 0:
                      case 3:
                        v206 = asprintf_l(&v207, v302, v210, v292, v291, *((unsigned __int8 *)&v279 + j));
                        break;
                      case 1:
                      case 4:
                        v206 = asprintf_l(&v207, v302, v210, v292, v291, *((unsigned __int16 *)&v279 + j));
                        break;
                      case 2:
                      case 5:
                        v206 = asprintf_l(&v207, v302, v210, v292, v291, *((unsigned int *)&v279 + j));
                        break;
                      case 6:
                        v206 = asprintf_l(&v207, v302, v210, v292, v291, *((float *)&v279 + j));
                        break;
                      default:
                        break;
                    }
                    v293 += v206;
                    if (io_print_0((uint64_t)v267, (uint64_t)v207, v206, v302))
                      goto LABEL_644;
                    free(v207);
                  }
                }
                else
                {
                  switch(v205)
                  {
                    case 0:
                    case 3:
                      v206 = asprintf_l(&v207, v302, v210, v292, v279);
                      break;
                    case 1:
                    case 4:
                      v206 = asprintf_l(&v207, v302, v210, v292, (unsigned __int16)v279);
                      break;
                    case 2:
                    case 5:
                      v206 = asprintf_l(&v207, v302, v210, v292, v279);
                      break;
                    case 6:
                      v206 = asprintf_l(&v207, v302, v210, v292, *(float *)&v279);
                      break;
                    default:
                      break;
                  }
                  v293 += v206;
                  if (io_print_0((uint64_t)v267, (uint64_t)v207, v206, v302))
                    goto LABEL_644;
                  free(v207);
                  for (j = 1; j < v211; ++j)
                  {
                    if (v277 && io_print_0((uint64_t)v267, (uint64_t)&v277, 1, v302))
                      goto LABEL_644;
                    switch(v205)
                    {
                      case 0:
                      case 3:
                        v206 = asprintf_l(&v207, v302, v210, v292, *((unsigned __int8 *)&v279 + j));
                        break;
                      case 1:
                      case 4:
                        v206 = asprintf_l(&v207, v302, v210, v292, *((unsigned __int16 *)&v279 + j));
                        break;
                      case 2:
                      case 5:
                        v206 = asprintf_l(&v207, v302, v210, v292, *((unsigned int *)&v279 + j));
                        break;
                      case 6:
                        v206 = asprintf_l(&v207, v302, v210, v292, *((float *)&v279 + j));
                        break;
                      default:
                        break;
                    }
                    v293 += v206;
                    if (io_print_0((uint64_t)v267, (uint64_t)v207, v206, v302))
                      goto LABEL_644;
                    free(v207);
                  }
                }
              }
              else if (v208)
              {
                switch(v205)
                {
                  case 0:
                  case 3:
                    v206 = asprintf_l(&v207, v302, v210, v291, v279);
                    break;
                  case 1:
                  case 4:
                    v206 = asprintf_l(&v207, v302, v210, v291, (unsigned __int16)v279);
                    break;
                  case 2:
                  case 5:
                    v206 = asprintf_l(&v207, v302, v210, v291, v279);
                    break;
                  case 6:
                    v206 = asprintf_l(&v207, v302, v210, v291, *(float *)&v279);
                    break;
                  default:
                    break;
                }
                v293 += v206;
                if (io_print_0((uint64_t)v267, (uint64_t)v207, v206, v302))
                  goto LABEL_644;
                free(v207);
                for (j = 1; j < v211; ++j)
                {
                  if (v277 && io_print_0((uint64_t)v267, (uint64_t)&v277, 1, v302))
                    goto LABEL_644;
                  switch(v205)
                  {
                    case 0:
                    case 3:
                      v206 = asprintf_l(&v207, v302, v210, v291, *((unsigned __int8 *)&v279 + j));
                      break;
                    case 1:
                    case 4:
                      v206 = asprintf_l(&v207, v302, v210, v291, *((unsigned __int16 *)&v279 + j));
                      break;
                    case 2:
                    case 5:
                      v206 = asprintf_l(&v207, v302, v210, v291, *((unsigned int *)&v279 + j));
                      break;
                    case 6:
                      v206 = asprintf_l(&v207, v302, v210, v291, *((float *)&v279 + j));
                      break;
                    default:
                      break;
                  }
                  v293 += v206;
                  if (io_print_0((uint64_t)v267, (uint64_t)v207, v206, v302))
                    goto LABEL_644;
                  free(v207);
                }
              }
              else
              {
                switch(v205)
                {
                  case 0:
                  case 3:
                    v206 = asprintf_l(&v207, v302, v210, v279);
                    break;
                  case 1:
                  case 4:
                    v206 = asprintf_l(&v207, v302, v210, (unsigned __int16)v279);
                    break;
                  case 2:
                  case 5:
                    v206 = asprintf_l(&v207, v302, v210, v279);
                    break;
                  case 6:
                    v206 = asprintf_l(&v207, v302, v210, *(float *)&v279);
                    break;
                  default:
                    break;
                }
                v293 += v206;
                if (io_print_0((uint64_t)v267, (uint64_t)v207, v206, v302))
                  goto LABEL_644;
                free(v207);
                for (j = 1; j < v211; ++j)
                {
                  if (v277 && io_print_0((uint64_t)v267, (uint64_t)&v277, 1, v302))
                    goto LABEL_644;
                  switch(v205)
                  {
                    case 0:
                    case 3:
                      v206 = asprintf_l(&v207, v302, v210, *((unsigned __int8 *)&v279 + j));
                      break;
                    case 1:
                    case 4:
                      v206 = asprintf_l(&v207, v302, v210, *((unsigned __int16 *)&v279 + j));
                      break;
                    case 2:
                    case 5:
                      v206 = asprintf_l(&v207, v302, v210, *((unsigned int *)&v279 + j));
                      break;
                    case 6:
                      v206 = asprintf_l(&v207, v302, v210, *((float *)&v279 + j));
                      break;
                    default:
                      break;
                  }
                  v293 += v206;
                  if (io_print_0((uint64_t)v267, (uint64_t)v207, v206, v302))
                    goto LABEL_644;
                  free(v207);
                }
              }
              if (v210 != v305)
                free(v210);
              goto LABEL_10;
            }
            if (v273 <= v271)
              v131 = v271;
            else
              v131 = v273;
            v272 = v131;
            if (v290)
              ++v272;
            if (v308)
              v272 += 2;
            if (v292 <= v272)
              v130 = v272;
            else
              v130 = v292;
            v270 = v130;
            if (v293 + v130 >= 0x80000000)
            {
LABEL_597:
              v293 = -1;
              *__error() = 84;
              goto LABEL_644;
            }
            if ((v294 & 0x84) == 0 && io_pad_0((uint64_t)v267, (int)v292 - (int)v272, (uint64_t)" ", v302))
              goto LABEL_644;
            if (v290 && io_print_0((uint64_t)v267, (uint64_t)&v290, 1, v302))
              goto LABEL_644;
            if (v308)
            {
              v307 = 48;
              if (io_print_0((uint64_t)v267, (uint64_t)&v307, 2, v302))
                goto LABEL_644;
            }
            if ((v294 & 0x84) == 0x80
              && io_pad_0((uint64_t)v267, (int)v292 - (int)v272, (uint64_t)"0", v302))
            {
              goto LABEL_644;
            }
            if ((v294 & 0x100) != 0)
            {
              if (v284)
              {
                if (v291 > 1 || (v294 & 1) != 0)
                {
                  v127 = i++;
                  v309[0] = *v127;
                  v309[1] = decpt;
                  if (io_print_0((uint64_t)v267, (uint64_t)v309, 2, v302)
                    || io_print_0((uint64_t)v267, (uint64_t)i, v281 - 1, v302)
                    || io_pad_0((uint64_t)v267, (int)v291 - v281, (uint64_t)"0", v302))
                  {
                    goto LABEL_644;
                  }
                }
                else if (io_print_0((uint64_t)v267, (uint64_t)i, 1, v302))
                {
                  goto LABEL_644;
                }
                if (io_print_0((uint64_t)v267, (uint64_t)v310, v282, v302))
                  goto LABEL_644;
              }
              else
              {
                if (v285 > 0)
                {
                  if (*((_QWORD *)&v289[0] + 1))
                  {
                    v297 = (int)grouping_print_0((uint64_t)v289, (uint64_t)v267, (uint64_t)i, (unint64_t)v264 + 4 * v281, v302);
                    if (v297 < 0)
                      goto LABEL_644;
                    i += v297;
                  }
                  else
                  {
                    if (io_printandpad_0((uint64_t)v267, (uint64_t)i, (uint64_t)v264 + 4 * v281, v285, (uint64_t)"0", v302))goto LABEL_644;
                    i += v285;
                  }
                  if ((v291 || (v294 & 1) != 0) && io_print_0((uint64_t)v267, (uint64_t)&decpt, 1, v302))
                    goto LABEL_644;
                }
                else
                {
                  if (io_print_0((uint64_t)v267, (uint64_t)"0", 1, v302)
                    || (v291 || (v294 & 1) != 0) && io_print_0((uint64_t)v267, (uint64_t)&decpt, 1, v302)
                    || io_pad_0((uint64_t)v267, -v285, (uint64_t)"0", v302))
                  {
                    goto LABEL_644;
                  }
                  v291 += v285;
                }
                if (io_printandpad_0((uint64_t)v267, (uint64_t)i, (uint64_t)v264 + 4 * v281, v291, (uint64_t)"0", v302))goto LABEL_644;
              }
            }
            else
            {
              if (io_pad_0((uint64_t)v267, v273 - (int)v271, (uint64_t)"0", v302))
                goto LABEL_644;
              if (*((_QWORD *)&v289[0] + 1))
              {
                if ((grouping_print_0((uint64_t)v289, (uint64_t)v267, (uint64_t)i, (unint64_t)v310, v302) & 0x80000000) != 0)
                  goto LABEL_644;
              }
              else if (io_print_0((uint64_t)v267, (uint64_t)i, v271, v302))
              {
                goto LABEL_644;
              }
            }
            if ((v294 & 4) != 0 && io_pad_0((uint64_t)v267, (int)v292 - (int)v272, (uint64_t)" ", v302))
              goto LABEL_644;
            v293 += v270;
            if (io_flush_0((_QWORD **)v267, v302))
              goto LABEL_644;
            break;
          case 't':
            v294 |= 0x800u;
            continue;
          case 'u':
LABEL_336:
            if ((v294 & 0x4000) != 0)
              goto LABEL_462;
            if ((v294 & 0x1C20) != 0)
            {
              if ((v294 & 0x1000) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v83 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v160 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v83);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v84 = (int64_t *)v300;
                  v300 += 2;
                  v229 = *v84;
                  v160 = v229;
                }
                v159 = v160;
              }
              else
              {
                if ((v294 & 0x400) != 0)
                {
                  if (*(_QWORD *)&v266[4])
                  {
                    v85 = *(int *)v266;
                    ++*(_DWORD *)v266;
                    v158 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v85);
                  }
                  else
                  {
                    *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                    v86 = (int64_t *)v300;
                    v300 += 2;
                    v228 = *v86;
                    v158 = v228;
                  }
                  v157 = v158;
                }
                else
                {
                  if ((v294 & 0x800) != 0)
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v87 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v156 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v87);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v88 = (uint64_t *)v300;
                      v300 += 2;
                      v227 = *v88;
                      v156 = v227;
                    }
                    v155 = v156;
                  }
                  else
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v89 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v154 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v89);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v90 = (uint64_t *)v300;
                      v300 += 2;
                      v226 = *v90;
                      v154 = v226;
                    }
                    v155 = v154;
                  }
                  v157 = v155;
                }
                v159 = v157;
              }
              v275 = v159;
            }
            else
            {
              if ((v294 & 0x10) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v91 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v153 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v91);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v92 = (int64_t *)v300;
                  v300 += 2;
                  v225 = *v92;
                  v153 = v225;
                }
                v152 = v153;
              }
              else
              {
                if ((v294 & 0x40) != 0)
                {
                  if (*(_QWORD *)&v266[4])
                  {
                    v93 = *(int *)v266;
                    ++*(_DWORD *)v266;
                    v151 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v93);
                  }
                  else
                  {
                    *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                    v94 = v300;
                    v300 += 2;
                    v224 = *v94;
                    LOWORD(v151) = v224;
                  }
                  v150 = (unsigned __int16)v151;
                }
                else
                {
                  if ((v294 & 0x2000) != 0)
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v95 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v149 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v95);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v96 = v300;
                      v300 += 2;
                      v223 = *v96;
                      LOBYTE(v149) = v223;
                    }
                    v148 = v149;
                  }
                  else
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v97 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v147 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v97);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v98 = v300;
                      v300 += 2;
                      v222 = *v98;
                      v147 = v222;
                    }
                    v148 = v147;
                  }
                  v150 = v148;
                }
                v152 = v150;
              }
              v276 = v152;
            }
            v274 = 10;
            goto LABEL_438;
          case 'v':
            v294 |= 0x4000u;
            continue;
          case 'x':
            v269 = (const char *)&__vfwprintf_xdigs_lower;
LABEL_385:
            if ((v294 & 0x4000) != 0)
              goto LABEL_462;
            if ((v294 & 0x1C20) != 0)
            {
              if ((v294 & 0x1000) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v99 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v146 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v99);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v100 = (int64_t *)v300;
                  v300 += 2;
                  v221 = *v100;
                  v146 = v221;
                }
                v145 = v146;
              }
              else
              {
                if ((v294 & 0x400) != 0)
                {
                  if (*(_QWORD *)&v266[4])
                  {
                    v101 = *(int *)v266;
                    ++*(_DWORD *)v266;
                    v144 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v101);
                  }
                  else
                  {
                    *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                    v102 = (int64_t *)v300;
                    v300 += 2;
                    v220 = *v102;
                    v144 = v220;
                  }
                  v143 = v144;
                }
                else
                {
                  if ((v294 & 0x800) != 0)
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v103 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v142 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v103);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v104 = (uint64_t *)v300;
                      v300 += 2;
                      v219 = *v104;
                      v142 = v219;
                    }
                    v141 = v142;
                  }
                  else
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v105 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v140 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v105);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v106 = (uint64_t *)v300;
                      v300 += 2;
                      v218 = *v106;
                      v140 = v218;
                    }
                    v141 = v140;
                  }
                  v143 = v141;
                }
                v145 = v143;
              }
              v275 = v145;
            }
            else
            {
              if ((v294 & 0x10) != 0)
              {
                if (*(_QWORD *)&v266[4])
                {
                  v107 = *(int *)v266;
                  ++*(_DWORD *)v266;
                  v139 = *(_QWORD *)(*(_QWORD *)&v266[4] + 16 * v107);
                }
                else
                {
                  *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                  v108 = (int64_t *)v300;
                  v300 += 2;
                  v217 = *v108;
                  v139 = v217;
                }
                v138 = v139;
              }
              else
              {
                if ((v294 & 0x40) != 0)
                {
                  if (*(_QWORD *)&v266[4])
                  {
                    v109 = *(int *)v266;
                    ++*(_DWORD *)v266;
                    v137 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v109);
                  }
                  else
                  {
                    *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                    v110 = v300;
                    v300 += 2;
                    v216 = *v110;
                    LOWORD(v137) = v216;
                  }
                  v136 = (unsigned __int16)v137;
                }
                else
                {
                  if ((v294 & 0x2000) != 0)
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v111 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v135 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v111);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v112 = v300;
                      v300 += 2;
                      v215 = *v112;
                      LOBYTE(v135) = v215;
                    }
                    v134 = v135;
                  }
                  else
                  {
                    if (*(_QWORD *)&v266[4])
                    {
                      v113 = *(int *)v266;
                      ++*(_DWORD *)v266;
                      v133 = *(_DWORD *)(*(_QWORD *)&v266[4] + 16 * v113);
                    }
                    else
                    {
                      *(_QWORD *)v266 = (*(_DWORD *)v266 + 1);
                      v114 = v300;
                      v300 += 2;
                      v214 = *v114;
                      v133 = v214;
                    }
                    v134 = v133;
                  }
                  v136 = v134;
                }
                v138 = v136;
              }
              v276 = v138;
            }
            v274 = 16;
            if ((v294 & 1) == 0)
              goto LABEL_437;
            if ((v294 & 0x1C20) != 0)
            {
              if (!v275)
                goto LABEL_437;
            }
            else if (!v276)
            {
              goto LABEL_437;
            }
            v308 = v298;
LABEL_437:
            v294 &= ~0x200u;
LABEL_438:
            v290 = 0;
LABEL_439:
            v273 = v291;
            if ((v291 & 0x80000000) == 0)
              v294 &= ~0x80u;
            i = v310;
            if ((v294 & 0x1C20) != 0)
            {
              if (v275 || v291 || (v294 & 1) != 0 && v274 == 8)
                i = __ujtoa_0(v275, (uint64_t)i, v274, v294 & 1, (uint64_t)v269, v8, v9, v10);
            }
            else if (v276 || v291 || (v294 & 1) != 0 && v274 == 8)
            {
              i = __ultoa_0(v276, (uint64_t)i, v274, v294 & 1, (uint64_t)v269, v8, v9, v10);
            }
            v271 = ((char *)v309 - (char *)i + 128) >> 2;
            if (v271 >= 33)
              abort_report_np((uint64_t)"%s:%s:%u: size (%zd) > BUF (%d)", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"vfwprintf.c");
            if ((v294 & 0x200) != 0 && v271)
            {
              v115 = grouping_init_0((uint64_t)v289, v271, v302);
              v271 += v115;
            }
            goto LABEL_462;
          case 'z':
            v294 |= 0x400u;
            continue;
          default:
            if (!v298)
              goto LABEL_643;
            i = v309;
            v309[0] = v298;
            v271 = 1;
            v290 = 0;
            goto LABEL_462;
        }
        break;
      }
    }
LABEL_643:
    io_flush_0((_QWORD **)v267, v302);
LABEL_644:
    free(v264);
    if ((*(_WORD *)(v303 + 16) & 0x40) != 0)
      v293 = -1;
    if (*(_QWORD *)&v266[4] && *(_BYTE **)&v266[4] != v306)
      free(*(void **)&v266[4]);
    if (v293 < 0 || v293 >= 0x7FFFFFFF)
      return -1;
    else
      return v293;
  }
}

int vfwprintf(FILE *a1, const __int32 *a2, __darwin_va_list a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return vfwprintf_l(a1, v9, a2, a3);
  else
    return vfwprintf_l(a1, (locale_t)__global_locale, a2, a3);
}

uint64_t get_decpt(_xlocale *a1)
{
  lconv *v1;
  unsigned int v3;
  locale_t v4;
  mbstate_t v5;

  v4 = a1;
  _platform_memset(&v5, 0, 128);
  v3 = 0;
  j___platform_memmove(&v5, &initial_mbs, 128);
  v1 = localeconv_l(v4);
  if ((unint64_t)(int)mbrtowc_l((__int32 *)&v3, v1->decimal_point, *(int *)(*((_QWORD *)v4 + 166) + 64), &v5, v4) >= 0xFFFFFFFFFFFFFFFELL)return 46;
  return v3;
}

uint64_t io_print_0(uint64_t a1, uint64_t a2, int a3, _xlocale *a4)
{
  int v4;

  *(_QWORD *)(a1 + 24 + 16 * *(int *)(a1 + 16)) = a2;
  *(_QWORD *)(a1 + 24 + 16 * *(int *)(a1 + 16) + 8) = a3;
  *(_DWORD *)(a1 + 20) += a3;
  v4 = *(_DWORD *)(a1 + 16) + 1;
  *(_DWORD *)(a1 + 16) = v4;
  if (v4 < 8)
    return 0;
  else
    return __sprint_0(*(_QWORD **)a1, a4, a1 + 8);
}

__int32 *__mbsconv(char *a1, int a2, _xlocale *a3)
{
  int v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char *v9;
  __int32 *v10;
  __int32 *v11;
  mbstate_t v16;

  _platform_memset(&v16, 0, 128);
  v4 = *(_DWORD *)(*((_QWORD *)a3 + 166) + 64);
  if (!a1)
    return 0;
  if (a2 < 0)
  {
    v7 = _platform_strlen(a1);
    v5 = 0;
  }
  else
  {
    v8 = a1;
    v5 = 0;
    v6 = 0;
    v7 = 0;
    j___platform_memmove(&v16, &initial_mbs, 128);
    while (v6 != a2)
    {
      v5 = mbrlen_l(v8, v4, &v16, a3);
      if (!v5 || v5 >= 0xFFFFFFFFFFFFFFFELL)
        break;
      v8 += v5;
      ++v6;
      v7 += v5;
    }
    if (v5 >= 0xFFFFFFFFFFFFFFFELL)
      return 0;
  }
  v11 = (__int32 *)malloc_type_malloc(4 * (v7 + 1), 0x100004052888210);
  if (!v11)
    return 0;
  v10 = v11;
  v9 = a1;
  j___platform_memmove(&v16, &initial_mbs, 128);
  while (v7)
  {
    v5 = mbrtowc_l(v10, v9, v7, &v16, a3);
    if (!v5 || v5 >= 0xFFFFFFFFFFFFFFFELL)
      break;
    ++v10;
    v9 += v5;
    v7 -= v5;
  }
  if (v5 < 0xFFFFFFFFFFFFFFFELL)
  {
    *v10 = 0;
    return v11;
  }
  else
  {
    free(v11);
    return 0;
  }
}

uint64_t exponent_0(_DWORD *a1, int a2, int a3)
{
  uint64_t *v3;
  _DWORD *v4;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t *v8;
  uint64_t *v9;
  _DWORD *v10;
  int v11;
  uint64_t v12;

  v11 = a2;
  *a1 = a3;
  if (a2 >= 0)
  {
    v10 = a1 + 2;
    a1[1] = 43;
  }
  else
  {
    v11 = -a2;
    v10 = a1 + 2;
    a1[1] = 45;
  }
  v8 = &v12;
  if (v11 <= 9)
  {
    if (a3 == 101 || a3 == 69)
    {
      v5 = v10++;
      *v5 = 48;
    }
    v6 = v10++;
    *v6 = v11 + 48;
  }
  else
  {
    do
    {
      v8 = (uint64_t *)((char *)v8 - 4);
      *(_DWORD *)v8 = v11 % 10 + 48;
      v11 /= 10;
    }
    while (v11 > 9);
    v9 = (uint64_t *)((char *)v8 - 4);
    *(_DWORD *)v9 = v11 + 48;
    while (v9 < &v12)
    {
      v3 = v9;
      v9 = (uint64_t *)((char *)v9 + 4);
      v4 = v10++;
      *v4 = *(_DWORD *)v3;
    }
  }
  return v10 - a1;
}

uint64_t grouping_init_0(uint64_t a1, int a2, _xlocale *a3)
{
  lconv *v3;

  v3 = localeconv_l(a3);
  *(_QWORD *)(a1 + 8) = __fix_nogrouping(v3->grouping);
  *(_DWORD *)a1 = get_thousep(a3);
  *(_DWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 20) = 0;
  *(_DWORD *)(a1 + 16) = a2;
  while (**(_BYTE **)(a1 + 8) != 127 && *(_DWORD *)(a1 + 16) > **(char **)(a1 + 8))
  {
    *(_DWORD *)(a1 + 16) -= **(char **)(a1 + 8);
    if (*(_BYTE *)(*(_QWORD *)(a1 + 8) + 1))
    {
      ++*(_DWORD *)(a1 + 20);
      ++*(_QWORD *)(a1 + 8);
    }
    else
    {
      ++*(_DWORD *)(a1 + 24);
    }
  }
  return (*(_DWORD *)(a1 + 20) + *(_DWORD *)(a1 + 24));
}

_DWORD *__ujtoa_0(unint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return __ultoa_0(a1, a2, a3, a4, a5, a6, a7, a8);
}

_DWORD *__ultoa_0(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v8;
  int64_t v10;
  _DWORD *v11;
  unint64_t v12;

  v12 = a1;
  v11 = (_DWORD *)a2;
  if ((_DWORD)a3 == 8)
  {
    do
    {
      *--v11 = (v12 & 7) + 48;
      v12 >>= 3;
    }
    while (v12);
    if ((_DWORD)a4 && *v11 != 48)
    {
      v8 = v11--;
      *(v8 - 1) = 48;
    }
    return v11;
  }
  if ((_DWORD)a3 != 10)
  {
    if ((_DWORD)a3 != 16)
      abort_report_np((uint64_t)"%s:%s:%u: __ultoa: invalid base=%d", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"printfcommon.h");
    do
    {
      *--v11 = *(char *)(a5 + (v12 & 0xF));
      v12 >>= 4;
    }
    while (v12);
    return v11;
  }
  if (a1 >= 0xA)
  {
    if (a1 <= 0x7FFFFFFFFFFFFFFFLL)
    {
      v10 = a1;
    }
    else
    {
      v11 = (_DWORD *)(a2 - 4);
      *(_DWORD *)(a2 - 4) = a1 % 0xA + 48;
      v10 = a1 / 0xA;
    }
    do
    {
      *--v11 = v10 % 10 + 48;
      v10 /= 10;
    }
    while (v10);
    return v11;
  }
  *(_DWORD *)(a2 - 4) = a1 + 48;
  return (_DWORD *)(a2 - 4);
}

uint64_t io_pad_0(uint64_t a1, int a2, uint64_t a3, _xlocale *a4)
{
  int v5;

  while (a2 > 0)
  {
    if (a2 < 16)
      v5 = a2;
    else
      v5 = 16;
    if (io_print_0(a1, a3, v5, a4))
      return -1;
    a2 -= v5;
  }
  return 0;
}

uint64_t grouping_print_0(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, _xlocale *a5)
{
  BOOL v6;
  unint64_t i;

  if (io_printandpad_0(a2, a3, a4, *(_DWORD *)(a1 + 16), (uint64_t)"0", a5))
  {
    return -1;
  }
  else
  {
    for (i = a3 + 4 * *(int *)(a1 + 16); ; i += 4 * **(char **)(a1 + 8))
    {
      v6 = 1;
      if (*(int *)(a1 + 20) <= 0)
        v6 = *(_DWORD *)(a1 + 24) > 0;
      if (!v6)
        break;
      if (*(int *)(a1 + 24) <= 0)
      {
        --*(_QWORD *)(a1 + 8);
        --*(_DWORD *)(a1 + 20);
      }
      else
      {
        --*(_DWORD *)(a1 + 24);
      }
      if (io_print_0(a2, a1, 1, a5))
        return -1;
      if (io_printandpad_0(a2, i, a4, **(char **)(a1 + 8), (uint64_t)"0", a5))
        return -1;
    }
    if (i > a4)
      i = a4;
    return ((uint64_t)(i - a3) / 4);
  }
}

uint64_t io_printandpad_0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, _xlocale *a6)
{
  int v7;

  v7 = (a3 - a2) / 4;
  if (v7 > a4)
    v7 = a4;
  if (v7 <= 0)
  {
    v7 = 0;
    return io_pad_0(a1, a4 - v7, a5, a6);
  }
  if (!io_print_0(a1, a2, v7, a6))
    return io_pad_0(a1, a4 - v7, a5, a6);
  return -1;
}

uint64_t io_flush_0(_QWORD **a1, _xlocale *a2)
{
  return __sprint_0(*a1, a2, (uint64_t)(a1 + 1));
}

uint64_t __sprint_0(_QWORD *a1, _xlocale *a2, uint64_t a3)
{
  int v4;
  int i;
  uint64_t v6;
  uint64_t *v7;

  v7 = *(uint64_t **)a3;
  while (*(_DWORD *)(a3 + 12))
  {
    v6 = *v7;
    v4 = v7[1];
    for (i = 0; i < v4; ++i)
    {
      if (__xfputwc(*(_DWORD *)(v6 + 4 * i), a1, a2) == -1)
        return -1;
    }
    *(_DWORD *)(a3 + 12) -= v4;
    v7 += 2;
  }
  *(_DWORD *)(a3 + 8) = 0;
  return 0;
}

uint64_t __xfputwc(__int32 a1, _QWORD *a2, _xlocale *a3)
{
  size_t v5;
  char *v6;
  size_t v7;
  char **v8;
  uint64_t v9;
  char v10[6];
  locale_t v11;
  _QWORD *v12;
  __int32 v13;
  mbstate_t v15;

  v13 = a1;
  v12 = a2;
  v11 = a3;
  _platform_memset(&v15, 0, 128);
  v8 = 0;
  v9 = 0;
  v6 = 0;
  v7 = 0;
  if ((v12[2] & 0x200) != 0)
  {
    j___platform_memmove(&v15, &initial_mbs, 128);
    v5 = wcrtomb_l(v10, v13, &v15, v11);
    if (v5 == -1)
    {
      *((_WORD *)v12 + 8) |= 0x40u;
      return -1;
    }
    else
    {
      v8 = &v6;
      HIDWORD(v9) = v5;
      LODWORD(v9) = 1;
      v6 = v10;
      v7 = v5;
      if (__sfvwrite(v12, (uint64_t)&v8) == -1)
        return -1;
      else
        return v13;
    }
  }
  else
  {
    return __fputwc(v13, (FILE *)v12, (uint64_t)v11);
  }
}

uint64_t get_thousep(_xlocale *a1)
{
  lconv *v1;
  unsigned int v3;
  locale_t v4;
  mbstate_t v5;

  v4 = a1;
  _platform_memset(&v5, 0, 128);
  v3 = 0;
  j___platform_memmove(&v5, &initial_mbs, 128);
  v1 = localeconv_l(v4);
  if ((unint64_t)(int)mbrtowc_l((__int32 *)&v3, v1->thousands_sep, *(int *)(*((_QWORD *)v4 + 166) + 64), &v5, v4) >= 0xFFFFFFFFFFFFFFFELL)return 0;
  return v3;
}

int vfwscanf(FILE *a1, const __int32 *a2, __darwin_va_list a3)
{
  char v3;
  _xlocale *v5;
  int v6;
  _xlocale *v9;
  uint64_t v10;

  flockfile(a1);
  if ((char)(32 * *((_BYTE *)a1->_extra + 72)) >> 5)
  {
    v3 = 0;
  }
  else
  {
    *((_BYTE *)a1->_extra + 72) = *((_BYTE *)a1->_extra + 72) & 0xF8 | 1;
    v3 = 1;
  }
  if ((v3 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    v5 = v9;
  else
    v5 = (_xlocale *)__global_locale;
  v6 = __vfwscanf((uint64_t)a1, v5, (wint_t *)a2);
  funlockfile(a1);
  return v6;
}

uint64_t __vfwscanf(uint64_t a1, _xlocale *a2, wint_t *a3)
{
  wint_t *v3;
  unint64_t v5;
  BOOL v6;
  wint_t v7;
  int i;
  wint_t v9;
  wint_t v10;
  mbstate_t v15;

  _platform_memset(&v15, 0, 128);
  for (i = 0; ; ++i)
  {
    while (1)
    {
      v3 = a3++;
      v9 = *v3;
      if (!*v3)
        return 0;
      if (!iswspace_l(v9, a2))
        break;
      while (1)
      {
        v10 = __fgetwc(a1, (uint64_t)a2);
        v6 = 0;
        if (v10 != -1)
          v6 = iswspace_l(v10, a2) != 0;
        if (!v6)
          break;
        ++i;
      }
      if (v10 != -1)
        __ungetwc(v10, a1, (uint64_t)a2);
    }
    if (v9 == 37)
      break;
    v7 = __fgetwc(a1, (uint64_t)a2);
    if (v7 == -1)
      return -1;
    if (v7 != v9)
    {
      __ungetwc(v7, a1, (uint64_t)a2);
      return 0;
    }
  }
  v5 = *a3;
  if (v5 <= 0x7A)
    __asm { BR              X8 }
  return 0;
}

int vfwscanf_l(FILE *a1, locale_t a2, const __int32 *a3, __darwin_va_list a4)
{
  int v5;
  _xlocale *v7;

  v7 = a2;
  if (a2)
  {
    if (a2 == (locale_t)-1)
      v7 = (_xlocale *)__global_locale;
  }
  else
  {
    v7 = (_xlocale *)&__c_locale;
  }
  flockfile(a1);
  if (!((char)(32 * *((_BYTE *)a1->_extra + 72)) >> 5))
    *((_BYTE *)a1->_extra + 72) = *((_BYTE *)a1->_extra + 72) & 0xF8 | 1;
  v5 = __vfwscanf((uint64_t)a1, v7, (wint_t *)a3);
  funlockfile(a1);
  return v5;
}

uint64_t parsefloat_0(uint64_t a1, unsigned int **a2, uint64_t a3, _xlocale *a4)
{
  lconv *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v13;
  uint64_t v14;
  unsigned int *v15;
  __int32 v16;
  wint_t v17;
  unsigned int v18;
  int v19;
  unsigned int *v20;
  char *v21;
  size_t v22;
  locale_t v23;
  uint64_t v24;
  unsigned int **v25;
  uint64_t v26;
  mbstate_t v28;

  v26 = a1;
  v25 = a2;
  v24 = a3;
  v23 = a4;
  _platform_memset(&v28, 0, 128);
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  j___platform_memmove(&v28, &initial_mbs_0, 128);
  v4 = localeconv();
  v22 = mbrtowc_l(&v16, v4->decimal_point, *(int *)(*((_QWORD *)v23 + 166) + 64), &v28, v23);
  if (v22 >= 0xFFFFFFFFFFFFFFFELL)
    v16 = 46;
  if (v24)
    v14 = v24 + 1;
  else
    v14 = 513;
  v15 = (unsigned int *)__parsefloat_buf(4 * v14);
  if (v15)
  {
    v21 = (char *)(v15 - 1);
    v17 = -1;
    v20 = v15;
    v13 = 1;
    if (v24)
      v13 = v20 < &v15[v14 - 1];
    if (v13)
    {
      v17 = __fgetwc(v26, (uint64_t)v23);
      if (v17 != -1)
      {
        if (v18 <= 9uLL)
          __asm { BR              X8 }
        abort_report_np((uint64_t)"%s:%s:%u: unknown state %d", v5, v6, v7, v8, v9, v10, v11, (uint64_t)"vfwscanf.c");
      }
    }
    while (v21 < (char *)--v20)
      __ungetwc(*v20, v26, (uint64_t)v23);
    v21 += 4;
    *(_DWORD *)v21 = 0;
    *v25 = v15;
    return ((v21 - (char *)v15) / 4);
  }
  else
  {
    *v25 = 0;
    return 0;
  }
}

int vprintf(const char *a1, va_list a2)
{
  char v2;
  char v3;
  FILE *v5;
  _xlocale *v8;
  uint64_t v9;

  v5 = __stdoutp;
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v8 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    return vfprintf_l(v5, v8, a1, a2);
  else
    return vfprintf_l(v5, (locale_t)__global_locale, a1, a2);
}

int vprintf_l(locale_t a1, const char *a2, va_list a3)
{
  return vfprintf_l(__stdoutp, a1, a2, a3);
}

int vscanf(const char *__format, va_list a2)
{
  char v2;
  char v3;
  _xlocale *v5;
  int *v6;
  int v7;
  _xlocale *v9;
  uint64_t v10;

  flockfile(__stdinp);
  v6 = (int *)__stdinp;
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    v5 = v9;
  else
    v5 = (_xlocale *)__global_locale;
  v7 = __svfscanf_l(v6, v5, (uint64_t)__format);
  funlockfile(__stdinp);
  return v7;
}

int vscanf_l(locale_t a1, const char *a2, va_list a3)
{
  int v4;
  _xlocale *v6;

  v6 = a1;
  if (a1)
  {
    if (a1 == (locale_t)-1)
      v6 = (_xlocale *)__global_locale;
  }
  else
  {
    v6 = (_xlocale *)&__c_locale;
  }
  flockfile(__stdinp);
  v4 = __svfscanf_l((int *)__stdinp, v6, (uint64_t)a2);
  funlockfile(__stdinp);
  return v4;
}

uint64_t _vsnprintf(uint64_t a1, pthread_rwlock_t *a2, char *a3, unint64_t a4, _xlocale *a5, char *a6, int *a7)
{
  char *v8;
  int v9;
  __int16 v10;
  __int16 v11;
  char *v12;
  int v13;
  uint64_t *v14;
  char v15;
  unsigned int v16;
  unint64_t v17;
  int *v18;
  char *v19;
  _xlocale *v20;
  unint64_t v21;
  char *v22;
  pthread_rwlock_t *v23;
  uint64_t v24;
  _QWORD v25[8];
  uint64_t v26;
  uint64_t v27;

  v24 = a1;
  v23 = a2;
  v22 = a3;
  v21 = a4;
  v20 = a5;
  v19 = a6;
  v18 = a7;
  v17 = 0;
  v16 = 0;
  _platform_memset(&v8, 0, 152);
  _platform_memset(&v26, 0, 208);
  v14 = &v26;
  v26 = 0;
  _platform_memset(v25, 0, 64);
  v25[0] = 850045858;
  j___platform_memmove(&v27, v25, 64);
  *((_BYTE *)v14 + 72) &= 0xF8u;
  _platform_memset(v14 + 10, 0, 128);
  *((_BYTE *)v14 + 72) &= ~8u;
  v17 = v21;
  if (v21)
    --v21;
  if (v21 > 0x7FFFFFFF)
    v21 = 0x7FFFFFFFLL;
  if (!v21)
  {
    if (v17)
      *v22 = 0;
    v22 = &v15;
    v21 = 1;
  }
  v11 = -1;
  v10 = 520;
  v8 = v22;
  v12 = v22;
  v9 = v21;
  v13 = v21;
  *((_BYTE *)v14 + 72) &= 0xF8u;
  _platform_memset(v14 + 10, 0, 128);
  v16 = __v2printf(v24, v23, (uint64_t)&v8, v20, v19, v18);
  if (v17)
    *v8 = 0;
  return v16;
}

int vsnprintf_l(char *a1, size_t a2, locale_t a3, const char *a4, va_list a5)
{
  return _vsnprintf(-1, 0, a1, a2, a3, (char *)a4, (int *)a5);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  char v4;
  char v5;
  _xlocale *v11;
  uint64_t v12;

  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v12 = __locale_key;
    v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11)
    return _vsnprintf(-1, 0, __str, __size, v11, (char *)__format, (int *)a4);
  else
    return _vsnprintf(-1, 0, __str, __size, (_xlocale *)__global_locale, (char *)__format, (int *)a4);
}

int vsprintf_l(char *a1, locale_t a2, const char *a3, va_list a4)
{
  char *v5;
  int v6;
  __int16 v7;
  __int16 v8;
  char *v9;
  int v10;
  uint64_t *v11;
  int v12;
  va_list v13;
  const char *v14;
  locale_t v15;
  char *v16;
  _QWORD v17[8];
  uint64_t v18;
  uint64_t v19;

  v16 = a1;
  v15 = a2;
  v14 = a3;
  v13 = a4;
  v12 = 0;
  _platform_memset(&v5, 0, 152);
  _platform_memset(&v18, 0, 208);
  v11 = &v18;
  v18 = 0;
  _platform_memset(v17, 0, 64);
  v17[0] = 850045858;
  j___platform_memmove(&v19, v17, 64);
  *((_BYTE *)v11 + 72) &= 0xF8u;
  _platform_memset(v11 + 10, 0, 128);
  *((_BYTE *)v11 + 72) &= ~8u;
  v8 = -1;
  v7 = 520;
  v5 = v16;
  v9 = v16;
  v6 = 0x7FFFFFFF;
  v10 = 0x7FFFFFFF;
  *((_BYTE *)v11 + 72) &= 0xF8u;
  _platform_memset(v11 + 10, 0, 128);
  v12 = __v2printf(-1, 0, &v5, v15, v14, v13);
  *v5 = 0;
  return v12;
}

int vsprintf(char *a1, const char *a2, va_list a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return vsprintf_l(a1, v9, a2, a3);
  else
    return vsprintf_l(a1, (locale_t)__global_locale, a2, a3);
}

int vsscanf_l(const char *a1, locale_t a2, const char *a3, va_list a4)
{
  const char *v5;
  int v6;
  __int16 v7;
  __int16 v8;
  const char *v9;
  int v10;
  uint64_t (*v11)();
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  va_list v15;
  const char *v16;
  _xlocale *v17;
  const char *v18;
  _QWORD v19[8];
  uint64_t v20;
  uint64_t v21;

  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a4;
  _platform_memset(&v5, 0, 152);
  _platform_memset(&v20, 0, 208);
  v13 = &v20;
  v20 = 0;
  _platform_memset(v19, 0, 64);
  v19[0] = 850045858;
  j___platform_memmove(&v21, v19, 64);
  *((_BYTE *)v13 + 72) &= 0xF8u;
  _platform_memset(v13 + 10, 0, 128);
  *((_BYTE *)v13 + 72) &= ~8u;
  libc_hooks_will_read_cstring((uint64_t)v18);
  v8 = -1;
  v7 = 4;
  v5 = v18;
  v9 = v18;
  v6 = _platform_strlen(v18);
  v10 = v6;
  v11 = eofread;
  v12 = 0;
  v14 = 0;
  *((_BYTE *)v13 + 72) &= 0xF8u;
  _platform_memset(v13 + 10, 0, 128);
  return __svfscanf_l((int *)&v5, v17, (uint64_t)v16);
}

uint64_t eofread()
{
  return 0;
}

int vsscanf(const char *__str, const char *__format, va_list a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return vsscanf_l(__str, v9, __format, a3);
  else
    return vsscanf_l(__str, (locale_t)__global_locale, __format, a3);
}

int vswprintf_l(__int32 *a1, size_t n, locale_t a3, const __int32 *a4, __darwin_va_list a5)
{
  size_t v6;
  int v7;
  int v8;
  const char *v9;
  _BYTE *v10;
  int v11;
  __int16 v12;
  __int16 v13;
  void *v14;
  int v15;
  uint64_t *v16;
  _DWORD *v17;
  int *v18;
  locale_t v19;
  size_t v20;
  __int32 *v21;
  _QWORD v23[8];
  uint64_t v24;
  uint64_t v25;
  mbstate_t v26;

  v21 = a1;
  v20 = n;
  v19 = a3;
  v18 = (int *)a4;
  v17 = a5;
  _platform_memset(&v26, 0, 128);
  _platform_memset(&v10, 0, 152);
  v9 = 0;
  _platform_memset(&v24, 0, 208);
  v16 = &v24;
  v24 = 0;
  _platform_memset(v23, 0, 64);
  v23[0] = 850045858;
  j___platform_memmove(&v25, v23, 64);
  *((_BYTE *)v16 + 72) &= 0xF8u;
  _platform_memset(v16 + 10, 0, 128);
  *((_BYTE *)v16 + 72) &= ~8u;
  if (v19)
  {
    if (v19 == (locale_t)-1)
      v19 = (locale_t)__global_locale;
  }
  else
  {
    v19 = (locale_t)&__c_locale;
  }
  if (v20)
  {
    v13 = -1;
    v12 = 16904;
    v10 = (_BYTE *)malloc_type_malloc(128, 1203847619);
    v14 = v10;
    if (v10)
    {
      v11 = 127;
      v15 = 127;
      *((_BYTE *)v16 + 72) &= 0xF8u;
      _platform_memset(v16 + 10, 0, 128);
      v8 = __vfwprintf((uint64_t)&v10, v19, v18, v17);
      if (v8 >= 0)
      {
        *v10 = 0;
        v9 = (const char *)v14;
        j___platform_memmove(&v26, &vswprintf_l_initial, 128);
        v6 = mbsrtowcs_l(v21, &v9, v20, &v26, v19);
        free(v14);
        if (v6 == -1)
        {
          *__error() = 92;
          return -1;
        }
        else if (v6 == v20)
        {
          v21[v20 - 1] = 0;
          *__error() = 84;
          return -1;
        }
        else
        {
          return v8;
        }
      }
      else
      {
        v7 = *__error();
        free(v14);
        *__error() = v7;
        return -1;
      }
    }
    else
    {
      *__error() = 12;
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int vswprintf(__int32 *a1, size_t a2, const __int32 *a3, __darwin_va_list a4)
{
  char v4;
  char v5;
  _xlocale *v11;
  uint64_t v12;

  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v12 = __locale_key;
    v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11)
    return vswprintf_l(a1, a2, v11, a3, a4);
  else
    return vswprintf_l(a1, a2, (locale_t)__global_locale, a3, a4);
}

int vswscanf_l(const __int32 *a1, locale_t a2, const __int32 *a3, __darwin_va_list a4)
{
  size_t v4;
  __int32 *v6;
  int v7;
  size_t v8;
  char *v9;
  char *v10;
  int v11;
  __int16 v12;
  __int16 v13;
  char *v14;
  int v15;
  uint64_t (*v16)();
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  __darwin_va_list v20;
  wint_t *v21;
  locale_t v22;
  __int32 *v23;
  _QWORD v25[8];
  uint64_t v26;
  uint64_t v27;
  mbstate_t v28;

  v23 = (__int32 *)a1;
  v22 = a2;
  v21 = (wint_t *)a3;
  v20 = a4;
  _platform_memset(&v28, 0, 128);
  _platform_memset(&v10, 0, 152);
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  _platform_memset(&v26, 0, 208);
  v18 = &v26;
  v26 = 0;
  _platform_memset(v25, 0, 64);
  v25[0] = 850045858;
  j___platform_memmove(&v27, v25, 64);
  *((_BYTE *)v18 + 72) &= 0xF8u;
  _platform_memset(v18 + 10, 0, 128);
  *((_BYTE *)v18 + 72) &= ~8u;
  if (v22)
  {
    if (v22 == (locale_t)-1)
      v22 = (locale_t)__global_locale;
  }
  else
  {
    v22 = (locale_t)&__c_locale;
  }
  v4 = wcslen(v23);
  v9 = (char *)malloc_type_malloc(v4 * *(int *)(*((_QWORD *)v22 + 166) + 64) + 1, 86788924);
  if (!v9)
    return -1;
  j___platform_memmove(&v28, &vswscanf_l_initial, 128);
  v6 = v23;
  v8 = wcsrtombs_l(v9, (const __int32 **)&v6, 0xFFFFFFFFFFFFFFFFLL, &v28, v22);
  if (v8 == -1)
  {
    free(v9);
    return -1;
  }
  else
  {
    v13 = -1;
    v12 = 4;
    v10 = v9;
    v14 = v9;
    v11 = v8;
    v15 = v8;
    v16 = eofread_0;
    v17 = 0;
    v19 = 0;
    *((_BYTE *)v18 + 72) &= 0xF8u;
    _platform_memset(v18 + 10, 0, 128);
    v7 = __vfwscanf((uint64_t)&v10, v22, v21);
    free(v9);
    return v7;
  }
}

uint64_t eofread_0()
{
  return 0;
}

int vswscanf(const __int32 *a1, const __int32 *a2, __darwin_va_list a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return vswscanf_l(a1, v9, a2, a3);
  else
    return vswscanf_l(a1, (locale_t)__global_locale, a2, a3);
}

int vwprintf(const __int32 *a1, __darwin_va_list a2)
{
  char v2;
  char v3;
  FILE *v5;
  _xlocale *v8;
  uint64_t v9;

  v5 = __stdoutp;
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v8 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    return vfwprintf_l(v5, v8, a1, a2);
  else
    return vfwprintf_l(v5, (locale_t)__global_locale, a1, a2);
}

int vwprintf_l(locale_t a1, const __int32 *a2, __darwin_va_list a3)
{
  return vfwprintf_l(__stdoutp, a1, a2, a3);
}

int vwscanf(const __int32 *a1, __darwin_va_list a2)
{
  char v2;
  char v3;
  FILE *v5;
  _xlocale *v8;
  uint64_t v9;

  v5 = __stdinp;
  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v8 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v9 = __locale_key;
    v8 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v9);
  }
  if (v8)
    return vfwscanf_l(v5, v8, a1, a2);
  else
    return vfwscanf_l(v5, (locale_t)__global_locale, a1, a2);
}

int vwscanf_l(locale_t a1, const __int32 *a2, __darwin_va_list a3)
{
  return vfwscanf_l(__stdinp, a1, a2, a3);
}

int __swbuf(int a1, FILE *a2)
{
  unsigned __int8 *v2;
  BOOL v4;
  int v5;
  unsigned __int8 v7;

  v7 = a1;
  a2->_w = a2->_lbfsize;
  if ((a2->_flags & 8) == 0 || (v4 = 0, !a2->_bf._base) && (v4 = 0, (a2->_flags & 0x200) == 0))
    v4 = __swsetup((uint64_t)a2) != 0;
  if (v4)
  {
    *__error() = 9;
    return -1;
  }
  else
  {
    if (!((char)(32 * *((_BYTE *)a2->_extra + 72)) >> 5))
      *((_BYTE *)a2->_extra + 72) = *((_BYTE *)a2->_extra + 72) & 0xF8 | 7;
    v5 = a2->_p - a2->_bf._base;
    if (v5 >= a2->_bf._size)
    {
      if (__fflush((uint64_t)a2))
        return -1;
      v5 = 0;
    }
    --a2->_w;
    v2 = a2->_p++;
    *v2 = v7;
    if ((v5 + 1 == a2->_bf._size || (a2->_flags & 1) != 0 && v7 == 10) && __fflush((uint64_t)a2))
      return -1;
    else
      return v7;
  }
}

int wprintf(const __int32 *a1, ...)
{
  char v1;
  char v2;
  FILE *v4;
  _xlocale *v6;
  uint64_t v7;
  va_list va;

  va_start(va, a1);
  v4 = __stdoutp;
  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v6 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v7 = __locale_key;
    v6 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6)
    return vfwprintf_l(v4, v6, a1, va);
  else
    return vfwprintf_l(v4, (locale_t)__global_locale, a1, va);
}

int wprintf_l(locale_t a1, const __int32 *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return vfwprintf_l(__stdoutp, a1, a2, va);
}

int wscanf(const __int32 *a1, ...)
{
  char v1;
  char v2;
  FILE *v4;
  _xlocale *v6;
  uint64_t v7;
  va_list va;

  va_start(va, a1);
  v4 = __stdinp;
  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v6 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v7 = __locale_key;
    v6 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v7);
  }
  if (v6)
    return vfwscanf_l(v4, v6, a1, va);
  else
    return vfwscanf_l(v4, (locale_t)__global_locale, a1, va);
}

int wscanf_l(locale_t a1, const __int32 *a2, ...)
{
  va_list va;

  va_start(va, a2);
  return vfwscanf_l(__stdinp, a1, a2, va);
}

uint64_t __swsetup(uint64_t a1)
{
  int v2;

  pthread_once(&__sdidinit, (void (*)(void))__sinit);
  if ((*(_WORD *)(a1 + 16) & 8) == 0)
  {
    if ((*(_WORD *)(a1 + 16) & 0x10) == 0)
    {
      *__error() = 9;
      *(_WORD *)(a1 + 16) |= 0x40u;
      return -1;
    }
    if ((*(_WORD *)(a1 + 16) & 4) != 0)
    {
      if (*(_QWORD *)(a1 + 88))
      {
        if (*(_QWORD *)(a1 + 88) != a1 + 116)
          free(*(void **)(a1 + 88));
        *(_QWORD *)(a1 + 88) = 0;
      }
      *(_WORD *)(a1 + 16) &= 0xFFDBu;
      *(_DWORD *)(a1 + 8) = 0;
      *(_QWORD *)a1 = *(_QWORD *)(a1 + 24);
    }
    *(_WORD *)(a1 + 16) |= 8u;
  }
  if (!*(_QWORD *)(a1 + 24))
    __smakebuf(a1);
  if ((*(_WORD *)(a1 + 16) & 1) != 0)
  {
    *(_DWORD *)(a1 + 12) = 0;
    *(_DWORD *)(a1 + 40) = -*(_DWORD *)(a1 + 32);
  }
  else
  {
    if ((*(_WORD *)(a1 + 16) & 2) != 0)
      v2 = 0;
    else
      v2 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(a1 + 12) = v2;
  }
  return 0;
}

FILE *__cdecl open_wmemstream(__int32 **__bufp, size_t *__sizep)
{
  FILE *v3;
  uint64_t v4;
  int v5;
  __int32 ***v6;

  if (__bufp && __sizep)
  {
    *__bufp = (__int32 *)malloc_type_calloc(1, 4, 0x100004052888210);
    if (*__bufp)
    {
      v6 = (__int32 ***)malloc_type_malloc(160, 0x1090040970F6AABLL);
      if (v6)
      {
        *v6 = __bufp;
        v6[1] = (__int32 **)__sizep;
        v6[2] = 0;
        v6[3] = 0;
        _platform_memset(v6 + 4, 0, 128);
        wmemstream_update((uint64_t)v6);
        v3 = funopen(v6, 0, (int (__cdecl *)(void *, const char *, int))wmemstream_write, (fpos_t (__cdecl *)(void *, fpos_t, int))wmemstream_seek, (int (__cdecl *)(void *))wmemstream_close);
        if (v3)
        {
          fwide(v3, 1);
          return v3;
        }
        else
        {
          v5 = *__error();
          free(v6);
          free(*__bufp);
          *__bufp = 0;
          *__error() = v5;
          return 0;
        }
      }
      else
      {
        v4 = *__error();
        free(*__bufp);
        *__bufp = 0;
        *__error() = v4;
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return 0;
  }
}

uint64_t wmemstream_update(uint64_t result)
{
  uint64_t v1;
  BOOL v2;

  v2 = 0;
  if (*(uint64_t *)(result + 16) >= 0)
    v2 = *(_QWORD *)(result + 24) >= 0;
  if (!v2)
    __assert_rtn("wmemstream_update", "open_wmemstream.c", 86, "ms->len >= 0 && ms->offset >= 0");
  if (*(_QWORD *)(result + 16) >= *(_QWORD *)(result + 24))
    v1 = *(_QWORD *)(result + 24);
  else
    v1 = *(_QWORD *)(result + 16);
  **(_QWORD **)(result + 8) = v1;
  return result;
}

uint64_t wmemstream_write(_QWORD *a1, const char *a2, int a3)
{
  BOOL v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  const char *v10;

  v10 = a2;
  v9 = a3;
  v6 = wbuflen((uint64_t)(a1 + 4), a2, a3);
  if (v6 >= 0)
  {
    if (wmemstream_grow((uint64_t **)a1, a1[3] + v6))
    {
      v7 = 0;
      while (1)
      {
        v4 = 0;
        if (v9 > 0)
          v4 = a1[3] < a1[2];
        if (!v4)
          break;
        v5 = mbrtowc((__int32 *)(*(_QWORD *)*a1 + 4 * a1[3]), v10, v9, (mbstate_t *)(a1 + 4));
        if (v5 == -1)
        {
          if (!v7)
            goto LABEL_2;
          break;
        }
        if (!v5)
          v5 = 1;
        if (v5 == -2)
        {
          v7 += v9;
          v9 = 0;
        }
        else
        {
          v7 += v5;
          v10 += v5;
          v9 -= v5;
          ++a1[3];
        }
      }
      wmemstream_update((uint64_t)a1);
      fprintf(__stderrp, "WMS: write(%p, %d) = %zd\n", a1, v9, v7);
      return v7;
    }
    else
    {
      return -1;
    }
  }
  else
  {
LABEL_2:
    *__error() = 92;
    return -1;
  }
}

uint64_t wmemstream_seek(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t v4;

  v4 = a1[3];
  if (a3)
  {
    if (a3 == 1)
    {
      if (a2)
        __assert_rtn("wmemstream_seek", "open_wmemstream.c", 188, "pos == 0");
    }
    else if (a3 == 2)
    {
      if (a2 >= 0)
      {
        if (0x7FFFFFFFFFFFFFFFLL - a1[2] < a2)
        {
          fprintf(__stderrp, "WMS: bad SEEK_END: pos %jd, len %zd\n", a2, a1[2]);
          *__error() = 84;
          return -1;
        }
      }
      else if (a2 + a1[2] < 0)
      {
        fprintf(__stderrp, "WMS: bad SEEK_END: pos %jd, len %zd\n", a2, a1[2]);
        *__error() = 22;
        return -1;
      }
      a1[3] = a1[2] + a2;
    }
  }
  else
  {
    if (a2 < 0)
      __assert_rtn("wmemstream_seek", "open_wmemstream.c", 183, "pos >= 0");
    a1[3] = a2;
  }
  if (a1[3] != v4)
    _platform_memset(a1 + 4, 0, 128);
  wmemstream_update((uint64_t)a1);
  fprintf(__stderrp, "WMS: seek(%p, %jd, %d) %jd -> %jd\n", a1, a2, a3, v4, a1[3]);
  return a1[3];
}

uint64_t wmemstream_close(void *a1)
{
  free(a1);
  return 0;
}

uint64_t wbuflen(uint64_t a1, const char *a2, int a3)
{
  uint64_t v4;
  size_t v5;
  mbstate_t v10;

  _platform_memset(&v10, 0, 128);
  v4 = 0;
  j___platform_memmove(&v10, a1, 128);
  while (a3 > 0)
  {
    v5 = mbrlen(a2, a3, &v10);
    if (v5 == -1)
      return -1;
    if (v5 == -2)
      break;
    if (!v5)
      v5 = 1;
    a3 -= v5;
    a2 += v5;
    ++v4;
  }
  return v4;
}

uint64_t wmemstream_grow(uint64_t **a1, unint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  if (a2 <= 0x1FFFFFFFFFFFFFFELL)
    v3 = a2;
  else
    v3 = 0x1FFFFFFFFFFFFFFELL;
  if (v3 <= (uint64_t)a1[2])
  {
    return 1;
  }
  else
  {
    v4 = reallocarray_DARWIN_EXTSN(**a1, v3 + 1, 4);
    if (v4)
    {
      fprintf(__stderrp, "WMS: %p growing from %zd to %zd\n", a1, (size_t)a1[2], v3);
      wmemset((__int32 *)(v4 + 4 * (_QWORD)a1[2] + 4), 0, v3 - (_QWORD)a1[2]);
      **a1 = v4;
      a1[2] = (uint64_t *)v3;
      return 1;
    }
    else
    {
      return 0;
    }
  }
}

char *__cdecl asctime_r(const tm *a1, char *a2)
{
  const char *v2;
  char *v4;
  const char *v5;
  char v9[72];
  char v10[13];

  if (a1->tm_wday <= 6u)
    v5 = (char *)&asctime_r_wday_name + 3 * a1->tm_wday;
  else
    v5 = "???";
  if (a1->tm_mon < 0xCu)
    v4 = &asctime_r_mon_name[3 * a1->tm_mon];
  else
    v4 = "???";
  strftime_l(v10, 0xDuLL, "%Y", a1, 0);
  if ((unint64_t)_platform_strlen(v10) > 4)
    v2 = "%.3s %.3s%3d %2.2d:%2.2d:%2.2d     %s\n";
  else
    v2 = "%.3s %.3s%3d %2.2d:%2.2d:%2.2d %-4s\n";
  sprintf(v9, v2, v5, v4, a1->tm_mday, a1->tm_hour, a1->tm_min, a1->tm_sec, v10);
  if ((unint64_t)_platform_strlen(v9) < 0x1A || a2 == (char *)&buf_asctime)
  {
    _platform_strcpy(a2, v9);
    return a2;
  }
  else
  {
    *__error() = 84;
    return 0;
  }
}

char *__cdecl asctime(const tm *a1)
{
  return asctime_r(a1, buf_asctime);
}

double difftime(time_t a1, time_t a2)
{
  if (a1 < 0 == a2 < 0)
    return (double)(a1 - a2);
  if (a1 < 0)
    return -(double)(unint64_t)(a2 - a1);
  return (double)(unint64_t)(a1 - a2);
}

int ftime(timeb *a1)
{
  timeval v2;
  uint64_t v3;
  timeb *v4;

  v4 = a1;
  v3 = 0;
  v2.tv_sec = 0;
  *(_QWORD *)&v2.tv_usec = 0;
  if (gettimeofday(&v2, &v3) < 0)
    return -1;
  v4->millitm = v2.tv_usec / 1000;
  v4->time = v2.tv_sec;
  v4->timezone = v3;
  v4->dstflag = WORD2(v3);
  return 0;
}

void tzsetwall(void)
{
  tzsetwall_basic(0);
}

void tzsetwall_basic(int a1)
{
  tzsetwall_check_default_file_timestamp();
  if (!a1)
    pthread_rwlock_rdlock(&lcl_rwlock);
  if (lcl_is_set >= 0)
  {
    pthread_rwlock_unlock(&lcl_rwlock);
    pthread_rwlock_wrlock(&lcl_rwlock);
    lcl_is_set = -1;
    if (tzload(0, (uint64_t)&lclmem, 1))
      gmtload((uint64_t)&lclmem);
    settzname();
    pthread_rwlock_unlock(&lcl_rwlock);
    if (a1)
      pthread_rwlock_rdlock(&lcl_rwlock);
  }
  else if (!a1)
  {
    pthread_rwlock_unlock(&lcl_rwlock);
  }
}

void _st_tzset_basic(int a1)
{
  char *v1;

  v1 = getenv("TZ");
  if (v1)
  {
    if (!a1)
      pthread_rwlock_rdlock(&lcl_rwlock);
    if (lcl_is_set <= 0 || _platform_strcmp(&lcl_TZname, v1))
    {
      pthread_rwlock_unlock(&lcl_rwlock);
      pthread_rwlock_wrlock(&lcl_rwlock);
      LOBYTE(lcl_is_set) = (unint64_t)_platform_strlen(v1) < 0x100;
      lcl_is_set = lcl_is_set;
      if ((_BYTE)lcl_is_set)
        _platform_strcpy(&lcl_TZname, v1);
      if (*v1)
      {
        if (tzload(v1, (uint64_t)&lclmem, 1)
          && (*v1 == 58 || tzparse(v1, (uint64_t)&lclmem, 0)))
        {
          gmtload((uint64_t)&lclmem);
        }
      }
      else
      {
        lclmem = 0;
        dword_E071C = 0;
        dword_E0720 = 0;
        dword_E3168 = 0;
        qword_E3160[0] = 0;
        dword_E316C = 0;
        _platform_strcpy(byte_E4960, "UTC");
      }
      settzname();
      pthread_rwlock_unlock(&lcl_rwlock);
      if (a1)
        pthread_rwlock_rdlock(&lcl_rwlock);
    }
    else if (!a1)
    {
      pthread_rwlock_unlock(&lcl_rwlock);
    }
  }
  else
  {
    tzsetwall_basic(a1);
  }
}

uint64_t tzload(const char *a1, uint64_t a2, int a3)
{
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  BOOL v19;
  BOOL v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  uint64_t v28;
  int v29;
  int v30;
  char *__s1;
  stat v32;
  int v33;
  char *v34;
  unsigned int v35;
  int NOCANCEL;
  int i;
  unsigned int v38;
  int j;
  char *v40;
  int v41;
  uint64_t v42;
  const char *v43;

  v43 = a1;
  v42 = a2;
  v41 = a3;
  v40 = 0;
  j = 0;
  v38 = 0;
  i = 0;
  NOCANCEL = 0;
  v34 = 0;
  v35 = -1;
  *(_DWORD *)(a2 + 20) = 0;
  *(_DWORD *)(v42 + 16) = 0;
  if (v43 && issetugid() && (*v43 == 58 && v43[1] == 47 || *v43 == 47 || _platform_strchr(v43, 46)))
    v43 = 0;
  if (!v43)
    v43 = "/var/db/timezone/localtime";
  v33 = 0;
  _platform_memset(&v32, 0, 144);
  __s1 = (char *)malloc_type_malloc(1025, 3339627481);
  if (!__s1)
    goto LABEL_132;
  if (*v43 == 58)
    ++v43;
  LOBYTE(v33) = *v43 == 47;
  v33 = v33;
  if ((_BYTE)v33)
  {
LABEL_19:
    if (v33 && access(v43, 4))
      goto LABEL_22;
    v38 = open_NOCANCEL(v43, 0);
    if (v38 == -1)
      goto LABEL_22;
    if (fstat(v38, &v32) < 0 || (v32.st_mode & 0xF000) != 0x8000)
    {
      free(__s1);
      close_NOCANCEL(v38);
      return -1;
    }
    free(__s1);
    v34 = (char *)malloc_type_malloc(41448, 0x1000040BE76E700);
    if (!v34 || (NOCANCEL = read_NOCANCEL(v38, v34, 41448), (int)close_NOCANCEL(v38) < 0) || NOCANCEL <= 0)
    {
LABEL_132:
      free(v34);
      return v35;
    }
    for (i = 4; i <= 8; i *= 2)
    {
      v30 = detzcode(v34 + 24);
      v29 = detzcode(v34 + 20);
      *(_DWORD *)v42 = detzcode(v34 + 28);
      *(_DWORD *)(v42 + 4) = detzcode(v34 + 32);
      *(_DWORD *)(v42 + 8) = detzcode(v34 + 36);
      *(_DWORD *)(v42 + 12) = detzcode(v34 + 40);
      v40 = v34 + 44;
      if (*(_DWORD *)v42 > 0x32u
        || *(int *)(v42 + 8) <= 0
        || *(int *)(v42 + 8) > 256
        || *(_DWORD *)(v42 + 4) > 0x4B0u
        || *(_DWORD *)(v42 + 12) > 0x32u
        || v30 != *(_DWORD *)(v42 + 8) && v30
        || v29 != *(_DWORD *)(v42 + 8) && v29
        || NOCANCEL - (v40 - v34) < *(_DWORD *)(v42 + 4) * i
                                  + *(_DWORD *)(v42 + 4)
                                  + 6 * *(_DWORD *)(v42 + 8)
                                  + *(_DWORD *)(v42 + 12)
                                  + *(_DWORD *)v42 * (i + 4)
                                  + v30
                                  + v29)
      {
        goto LABEL_132;
      }
      for (j = 0; j < *(_DWORD *)(v42 + 4); ++j)
      {
        if (i == 4)
          v22 = detzcode(v40);
        else
          v22 = detzcode64(v40);
        *(_QWORD *)(v42 + 24 + 8 * j) = v22;
        v40 += i;
      }
      for (j = 0; j < *(_DWORD *)(v42 + 4); ++j)
      {
        v3 = v40++;
        *(_BYTE *)(v42 + 9624 + j) = *v3;
        if (*(unsigned __int8 *)(v42 + 9624 + j) >= *(int *)(v42 + 8))
          goto LABEL_132;
      }
      for (j = 0; j < *(_DWORD *)(v42 + 8); ++j)
      {
        v28 = v42 + 10824 + 24 * j;
        *(_QWORD *)v28 = detzcode(v40);
        v40 += 4;
        v4 = v40++;
        *(_DWORD *)(v28 + 8) = *v4;
        if (*(_DWORD *)(v28 + 8) >= 2u)
          goto LABEL_132;
        v5 = v40++;
        *(_DWORD *)(v28 + 12) = *v5;
        if (*(int *)(v28 + 12) < 0 || *(_DWORD *)(v28 + 12) > *(_DWORD *)(v42 + 12))
          goto LABEL_132;
      }
      for (j = 0; j < *(_DWORD *)(v42 + 12); *(_BYTE *)(v42 + 16968 + j++) = *v6)
        v6 = v40++;
      *(_BYTE *)(v42 + 16968 + j) = 0;
      for (j = 0; j < *(_DWORD *)v42; ++j)
      {
        v27 = (uint64_t *)(v42 + 17480 + 16 * j);
        if (i == 4)
          v21 = detzcode(v40);
        else
          v21 = detzcode64(v40);
        *v27 = v21;
        v40 += i;
        v27[1] = detzcode(v40);
        v40 += 4;
      }
      for (j = 0; j < *(_DWORD *)(v42 + 8); ++j)
      {
        v26 = v42 + 10824 + 24 * j;
        if (v30)
        {
          v7 = v40++;
          *(_DWORD *)(v26 + 16) = *v7;
          if (*(_DWORD *)(v26 + 16) >= 2u)
            goto LABEL_132;
        }
        else
        {
          *(_DWORD *)(v26 + 16) = 0;
        }
      }
      for (j = 0; j < *(_DWORD *)(v42 + 8); ++j)
      {
        v25 = v42 + 10824 + 24 * j;
        if (v29)
        {
          v8 = v40++;
          *(_DWORD *)(v25 + 20) = *v8;
          if (*(_DWORD *)(v25 + 20) >= 2u)
            goto LABEL_132;
        }
        else
        {
          *(_DWORD *)(v25 + 20) = 0;
        }
      }
      for (j = 0; j < *(_DWORD *)(v42 + 4) - 2; ++j)
      {
        if (*(_QWORD *)(v42 + 24 + 8 * j) > *(_QWORD *)(v42 + 24 + 8 * (j + 1)))
        {
          *(_DWORD *)(v42 + 4) = ++j;
          break;
        }
      }
      if (!v34[4])
        break;
      NOCANCEL -= (_DWORD)v40 - (_DWORD)v34;
      for (j = 0; j < NOCANCEL; ++j)
        v34[j] = v40[j];
      if (i >= 8)
        break;
    }
    if (v41 && NOCANCEL > 2 && *v34 == 10 && v34[NOCANCEL - 1] == 10 && *(_DWORD *)(v42 + 8) + 2 <= 256)
    {
      v24 = (char *)malloc_type_malloc(18280, 0x10000402151C985);
      if (!v24)
        goto LABEL_132;
      v34[NOCANCEL - 1] = 0;
      if (!tzparse(v34 + 1, (uint64_t)v24, 0)
        && *((_DWORD *)v24 + 2) == 2
        && *(_DWORD *)(v42 + 12) + *((_DWORD *)v24 + 3) <= 50)
      {
        for (j = 0; j < 2; ++j)
          *(_DWORD *)&v24[24 * j + 10836] += *(_DWORD *)(v42 + 12);
        for (j = 0; j < *((_DWORD *)v24 + 3); ++j)
        {
          v9 = v24[j + 16968];
          v10 = v42 + 16968;
          v11 = (int)(*(_DWORD *)(v42 + 12))++;
          *(_BYTE *)(v10 + v11) = v9;
        }
        for (j = 0; ; ++j)
        {
          v20 = 0;
          if (j < *((_DWORD *)v24 + 1))
            v20 = *(_QWORD *)&v24[8 * j + 24] <= *(_QWORD *)(v42 + 24 + 8 * (*(_DWORD *)(v42 + 4) - 1));
          if (!v20)
            break;
        }
        while (1)
        {
          v19 = 0;
          if (j < *((_DWORD *)v24 + 1))
            v19 = *(_DWORD *)(v42 + 4) < 1200;
          if (!v19)
            break;
          *(_QWORD *)(v42 + 24 + 8 * *(int *)(v42 + 4)) = *(_QWORD *)&v24[8 * j + 24];
          *(_BYTE *)(v42 + 9624 + (int)(*(_DWORD *)(v42 + 4))++) = *(_DWORD *)(v42 + 8) + v24[j++ + 9624];
        }
        v12 = v42 + 10824;
        v13 = (int)(*(_DWORD *)(v42 + 8))++;
        v14 = v12 + 24 * v13;
        *(_OWORD *)v14 = *(_OWORD *)(v24 + 10824);
        *(_QWORD *)(v14 + 16) = *((_QWORD *)v24 + 1355);
        v15 = v42 + 10824;
        v16 = (int)(*(_DWORD *)(v42 + 8))++;
        v17 = v15 + 24 * v16;
        *(_OWORD *)v17 = *((_OWORD *)v24 + 678);
        *(_QWORD *)(v17 + 16) = *((_QWORD *)v24 + 1358);
      }
      free(v24);
    }
    if (*(int *)(v42 + 4) > 1)
    {
      for (j = 1; j < *(_DWORD *)(v42 + 4); ++j)
      {
        if (typesequiv(v42, *(unsigned __int8 *)(v42 + 9624 + j), *(unsigned __int8 *)(v42 + 9624))
          && differ_by_repeat(*(_QWORD *)(v42 + 24 + 8 * j), *(_QWORD *)(v42 + 24)))
        {
          *(_DWORD *)(v42 + 16) = 1;
          break;
        }
      }
      for (j = *(_DWORD *)(v42 + 4) - 2; j >= 0; --j)
      {
        if (typesequiv(v42, *(unsigned __int8 *)(v42 + 9624 + *(_DWORD *)(v42 + 4) - 1), *(unsigned __int8 *)(v42 + 9624 + j))&& differ_by_repeat(*(_QWORD *)(v42 + 24 + 8 * (*(_DWORD *)(v42 + 4) - 1)), *(_QWORD *)(v42 + 24 + 8 * j)))
        {
          *(_DWORD *)(v42 + 20) = 1;
          break;
        }
      }
    }
    v35 = 0;
    goto LABEL_132;
  }
  v40 = "/var/db/timezone/zoneinfo";
  v23 = _platform_strlen("/var/db/timezone/zoneinfo") + 1;
  if ((unint64_t)(v23 + _platform_strlen(v43)) < 0x400)
  {
    _platform_strcpy(__s1, v40);
    strcat(__s1, "/");
    strcat(__s1, v43);
    if (_platform_strchr(v43, 46))
      v33 = 1;
    v43 = __s1;
    goto LABEL_19;
  }
LABEL_22:
  free(__s1);
  return -1;
}

uint64_t tzparse(char *a1, uint64_t a2, int a3)
{
  char *v3;
  uint64_t *v4;
  _BYTE *v5;
  uint64_t *v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t *v9;
  _BYTE *v10;
  _BYTE *v11;
  BOOL v13;
  BOOL v14;
  int v15;
  int j;
  int k;
  int m;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int i;
  _QWORD v24[3];
  _QWORD v25[3];
  int v26;
  uint64_t v27;
  _BYTE *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  _BYTE *v32;
  unint64_t v33;
  char *v34;
  char *v35;
  int v36;
  uint64_t v37;
  char *v38;

  v38 = a1;
  v37 = a2;
  v36 = a3;
  v35 = 0;
  v33 = 0;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 0;
  v26 = 0;
  v34 = 0;
  if (a3)
  {
    v35 = v38;
    v33 = _platform_strlen(v38);
    v38 += v33;
    if (v33 >= 0x200)
      v33 = 511;
    v31 = 0;
  }
  else
  {
    v38 = getzname(v38, &v35, &v33);
    if (!*v38)
      return -1;
    v38 = getoffset(v38, &v31);
    if (!v38)
      return -1;
  }
  v26 = tzload("posixrules", v37, 0);
  if (v26)
    *(_DWORD *)v37 = 0;
  if (*v38)
  {
    if (*v38 == 60)
    {
      v34 = ++v38;
      v38 = getqzname(v38, 62);
      if (*v38 != 62)
        return -1;
      v32 = (_BYTE *)(v38 - v34);
      ++v38;
    }
    else
    {
      v34 = v38;
      v38 = getzname(v38, &v34, &v32);
    }
    if (!*v38 || *v38 == 44 || *v38 == 59)
    {
      v30 = v31 - 3600;
    }
    else
    {
      v38 = getoffset(v38, &v30);
      if (!v38)
        return -1;
    }
    if (!*v38 && v26)
      v38 = ",M4.1.0,M10.5.0";
    if (*v38 == 44 || *v38 == 59)
    {
      memset(v25, 0, sizeof(v25));
      memset(v24, 0, sizeof(v24));
      ++v38;
      v38 = getrule(v38, (uint64_t)v25);
      if (!v38)
        return -1;
      v3 = v38++;
      if (*v3 != 44)
        return -1;
      v38 = getrule(v38, (uint64_t)v24);
      if (!v38)
        return -1;
      if (*v38)
        return -1;
      *(_DWORD *)(v37 + 8) = 2;
      *(_QWORD *)(v37 + 10824) = -v30;
      *(_DWORD *)(v37 + 10832) = 1;
      *(_DWORD *)(v37 + 10836) = v33 + 1;
      *(_QWORD *)(v37 + 10848) = -v31;
      *(_DWORD *)(v37 + 10856) = 0;
      *(_DWORD *)(v37 + 10860) = 0;
      v29 = (uint64_t *)(v37 + 24);
      v28 = (_BYTE *)(v37 + 9624);
      v22 = 0;
      *(_DWORD *)(v37 + 4) = 0;
      for (i = 1970; *(_DWORD *)(v37 + 4) + 2 <= 1200; ++i)
      {
        v21 = transtime(v22, i, (int *)v25, v31);
        v20 = transtime(v22, i, (int *)v24, v30);
        v4 = v29++;
        if (v21 <= v20)
        {
          *v4 = v21;
          v8 = v28++;
          *v8 = 0;
          v9 = v29++;
          *v9 = v20;
          v10 = v28++;
          *v10 = 1;
        }
        else
        {
          *v4 = v20;
          v5 = v28++;
          *v5 = 1;
          v6 = v29++;
          *v6 = v21;
          v7 = v28++;
          *v7 = 0;
        }
        *(_DWORD *)(v37 + 4) += 2;
        v14 = 0;
        if (!(i % 4))
        {
          v13 = 1;
          if (!(i % 100))
            v13 = i % 400 == 0;
          v14 = v13;
        }
        if (v22 + 86400 * *((int *)&year_lengths + v14) <= v22)
          break;
        v22 += 86400 * *((int *)&year_lengths + v14);
      }
    }
    else
    {
      if (*v38)
        return -1;
      v19 = 0;
      for (j = 0; j < *(_DWORD *)(v37 + 4); ++j)
      {
        if (!*(_DWORD *)(v37 + 10824 + 24 * *(unsigned __int8 *)(v37 + 9624 + j) + 8))
        {
          v19 = -*(_QWORD *)(v37 + 10824 + 24 * *(unsigned __int8 *)(v37 + 9624 + j));
          break;
        }
      }
      for (k = 0;
            k < *(_DWORD *)(v37 + 4) && !*(_DWORD *)(v37 + 10824 + 24 * *(unsigned __int8 *)(v37 + 9624 + k) + 8);
      for (m = 0; m < *(_DWORD *)(v37 + 4); ++m)
      {
        v15 = *(unsigned __int8 *)(v37 + 9624 + m);
        *(_BYTE *)(v37 + 9624 + m) = *(_DWORD *)(v37 + 10824 + 24 * *(unsigned __int8 *)(v37 + 9624 + m) + 8);
        if (!*(_DWORD *)(v37 + 10824 + 24 * v15 + 20))
          *(_QWORD *)(v37 + 24 + 8 * m) += v31 - v19;
        if (!*(_DWORD *)(v37 + 10824 + 24 * v15 + 8))
          v19 = -*(_QWORD *)(v37 + 10824 + 24 * v15);
      }
      *(_QWORD *)(v37 + 10824) = -v31;
      *(_DWORD *)(v37 + 10832) = 0;
      *(_DWORD *)(v37 + 10836) = 0;
      *(_QWORD *)(v37 + 10848) = -v30;
      *(_DWORD *)(v37 + 10856) = 1;
      *(_DWORD *)(v37 + 10860) = v33 + 1;
      *(_DWORD *)(v37 + 8) = 2;
    }
  }
  else
  {
    v32 = 0;
    *(_DWORD *)(v37 + 8) = 1;
    *(_DWORD *)(v37 + 4) = 0;
    *(_QWORD *)(v37 + 10824) = -v31;
    *(_DWORD *)(v37 + 10832) = 0;
    *(_DWORD *)(v37 + 10836) = 0;
  }
  *(_DWORD *)(v37 + 12) = v33 + 1;
  if (v32)
    *(_DWORD *)(v37 + 12) += (_DWORD)v32 + 1;
  if ((unint64_t)*(int *)(v37 + 12) <= 0x200)
  {
    v27 = v37 + 16968;
    _platform_strncpy(v37 + 16968, v35, v33);
    v27 += v33;
    v11 = (_BYTE *)v27++;
    *v11 = 0;
    if (v32)
    {
      _platform_strncpy(v27, v34, v32);
      v32[v27] = 0;
    }
    return 0;
  }
  else
  {
    return -1;
  }
}

uint64_t gmtload(uint64_t a1)
{
  uint64_t result;

  result = tzload("UTC", a1, 1);
  if ((_DWORD)result)
    return tzparse("UTC", a1, 1);
  return result;
}

unint64_t settzname()
{
  unint64_t result;
  BOOL v1;
  char *v2;
  uint64_t *v3;
  unsigned __int8 *v4;
  int v5;
  int v6;
  int i;
  int j;

  tzname[0] = "   ";
  off_DD878 = "   ";
  daylight = 0;
  result = _st_set_timezone(0);
  __darwin_altzone = 0;
  if (dword_E071C || dword_E0720 != 1)
  {
    v6 = dword_E071C - 1;
    v4 = (unsigned __int8 *)&unk_E2CB0;
  }
  else
  {
    v6 = 0;
    v4 = (unsigned __int8 *)&unk_D495D;
  }
  v5 = 7;
  while (1)
  {
    v1 = 0;
    if (v6 >= 0)
      v1 = v5 != 0;
    if (!v1)
      break;
    v3 = &qword_E3160[3 * v4[v6]];
    if ((v5 & 4) != 0 && *((_DWORD *)v3 + 2))
    {
      v5 &= ~4u;
      daylight = 1;
    }
    if (*((_DWORD *)v3 + 2))
    {
      if ((v5 & 2) != 0)
      {
        v5 &= ~2u;
        off_DD878 = &byte_E4960[*((int *)v3 + 3)];
        __darwin_altzone = -*v3;
      }
    }
    else if ((v5 & 1) != 0)
    {
      v5 &= ~1u;
      tzname[0] = &byte_E4960[*((int *)v3 + 3)];
      result = _st_set_timezone(-*v3);
    }
    if (!v6)
    {
      if ((v5 & 2) != 0)
        __darwin_altzone = -*v3;
      if ((v5 & 1) != 0)
        result = _st_set_timezone(-*v3);
    }
    --v6;
  }
  for (i = 0; i < unk_E0724; ++i)
  {
    result = _platform_strchr("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 :+-._", byte_E4960[i]);
    if (!result)
      byte_E4960[i] = 95;
  }
  for (j = 0; j < dword_E0720; ++j)
  {
    v2 = &byte_E4960[SHIDWORD(qword_E3160[3 * j + 1])];
    result = _platform_strlen(v2);
    if (result > 0xFF)
    {
      result = _platform_strcmp(v2, "Local time zone must be set--see zic manual page");
      if ((_DWORD)result)
        v2[255] = 0;
    }
  }
  return result;
}

void tzset(void)
{
  _st_tzset_basic(0);
}

uint64_t _st_localsub(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int *v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v13 = *a1;
  v17 = &lclmem;
  if (unk_E0728 && v13 < *((_QWORD *)v17 + 3) || v17[5] && v13 > *(_QWORD *)&v17[2 * v17[1] + 4])
  {
    v12 = v13;
    if (v13 >= *((_QWORD *)v17 + 3))
      v10 = v13 - *(_QWORD *)&v17[2 * v17[1] + 4];
    else
      v10 = *((_QWORD *)v17 + 3) - v13;
    v9 = (v10 - 1) / 400 / 31556952 + 1;
    v11 = 0x2F0605980 * v9;
    if (v13 >= *((_QWORD *)v17 + 3))
      v12 -= v11;
    else
      v12 += v11;
    if (v12 >= *((_QWORD *)v17 + 3) && v12 <= *(_QWORD *)&v17[2 * v17[1] + 4])
    {
      v14 = _st_localsub(&v12, v19, v18);
      if (v14 != v18)
        return v14;
      v7 = *(int *)(v18 + 20);
      v8 = v13 >= *((_QWORD *)v17 + 3) ? v7 + 400 * v9 : v7 - 400 * v9;
      *(_DWORD *)(v18 + 20) = v8;
      if (*(_DWORD *)(v18 + 20) == v8)
        return v14;
      else
        return 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if (v17[1] && v13 >= *((_QWORD *)v17 + 3))
    {
      v6 = 1;
      v5 = v17[1];
      while (v6 < v5)
      {
        v4 = (v6 + v5) >> 1;
        if (v13 >= *(_QWORD *)&v17[2 * v4 + 6])
          v6 = v4 + 1;
        else
          v5 = (v6 + v5) >> 1;
      }
      v15 = *((unsigned __int8 *)v17 + v6 + 9623);
    }
    else
    {
      v15 = 0;
      while (v17[6 * v15 + 2708])
      {
        if (++v15 >= v17[2])
        {
          v15 = 0;
          break;
        }
      }
    }
    v16 = &v17[6 * v15 + 2706];
    v14 = timesub(&v13, *(_QWORD *)v16, v17, v18);
    if (v14)
    {
      *(_DWORD *)(v18 + 32) = v16[2];
      tzname[*(int *)(v18 + 32)] = (char *)v17 + v16[3] + 16968;
      *(_QWORD *)(v18 + 48) = (char *)v17 + v16[3] + 16968;
      return v14;
    }
    else
    {
      return 0;
    }
  }
}

uint64_t timesub(_QWORD *a1, uint64_t a2, int *a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  BOOL v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  char *v16;
  int v17;
  uint64_t j;
  uint64_t v19;
  uint64_t i;
  uint64_t v21;
  uint64_t v22;
  int *v23;

  v17 = 0;
  v15 = 0;
  v14 = 0;
  v13 = *a3;
  while (--v13 >= 0)
  {
    v23 = &a3[4 * v13 + 4370];
    if (*a1 >= *(_QWORD *)v23)
    {
      if (*a1 == *(_QWORD *)v23)
      {
        if (v13 || (v11 = 1, *((uint64_t *)v23 + 1) <= 0))
          v11 = *((_QWORD *)v23 + 1) > *(_QWORD *)&a3[4 * v13 + 4368];
        v14 = v11;
        if (v11)
        {
          while (1)
          {
            v10 = 0;
            if (v13 > 0)
            {
              v10 = 0;
              if (*(_QWORD *)&a3[4 * v13 + 4370] == *(_QWORD *)&a3[4 * v13 + 4366] + 1)
                v10 = *(_QWORD *)&a3[4 * v13 + 4372] == *(_QWORD *)&a3[4 * v13 + 4368] + 1;
            }
            if (!v10)
              break;
            ++v14;
            --v13;
          }
        }
      }
      v15 = *((_QWORD *)v23 + 1);
      break;
    }
  }
  v22 = *a1 / 86400;
  for (i = *a1 % 86400 + a2 - v15; i < 0; i += 86400)
    --v22;
  while (i >= 86400)
  {
    i -= 86400;
    ++v22;
  }
  *(_DWORD *)(a4 + 8) = i / 3600;
  v21 = i % 3600;
  *(_DWORD *)(a4 + 4) = v21 / 60;
  *(_DWORD *)a4 = v21 % 60 + v14;
  *(_DWORD *)(a4 + 24) = (v22 + 4) % 7;
  if (*(int *)(a4 + 24) < 0)
    *(_DWORD *)(a4 + 24) += 7;
  for (j = 1970; ; j = v12)
  {
    v9 = 1;
    if (v22 >= 0)
    {
      v8 = 0;
      if (!(j % 4))
      {
        v7 = 1;
        if (!(j % 100))
          v7 = j % 400 == 0;
        v8 = v7;
      }
      v17 = v8;
      v9 = v22 >= *((int *)&year_lengths + v8);
    }
    if (!v9)
      break;
    v12 = j + v22 / 365;
    if (v22 < 0)
      --v12;
    if (v12 - 1 < 0)
      v6 = v12 / 4 - v12 / 100 + v12 / 400 - 1;
    else
      v6 = (v12 - 1) / 4 - (v12 - 1) / 100 + (v12 - 1) / 400;
    if (j - 1 < 0)
      v5 = j / 4 - j / 100 + j / 400 - 1;
    else
      v5 = (j - 1) / 4 - (j - 1) / 100 + (j - 1) / 400;
    v22 -= 365 * (v12 - j) + v6 - v5;
  }
  v19 = j - 1900;
  if (v19 >= (uint64_t)0xFFFFFFFF80000000 && v19 <= 0x7FFFFFFF)
  {
    *(_DWORD *)(a4 + 20) = v19;
    *(_DWORD *)(a4 + 28) = v22;
    v16 = (char *)&mon_lengths + 48 * v17;
    for (*(_DWORD *)(a4 + 16) = 0; v22 >= *(int *)&v16[4 * *(int *)(a4 + 16)]; ++*(_DWORD *)(a4 + 16))
      v22 -= *(int *)&v16[4 * *(int *)(a4 + 16)];
    *(_DWORD *)(a4 + 12) = v22 + 1;
    *(_DWORD *)(a4 + 32) = 0;
    *(_QWORD *)(a4 + 40) = a2;
    return a4;
  }
  else
  {
    *__error() = 84;
    return 0;
  }
}

tm *__cdecl localtime(const time_t *a1)
{
  int v2;
  const void *v3;
  tm *v4;

  pthread_once(&localtime_once, (void (*)(void))localtime_key_init);
  if (!localtime_key_error)
  {
    v3 = pthread_getspecific(localtime_key);
    if (!v3)
    {
      v3 = (const void *)malloc_type_malloc(56, 0x10100404E507D7FLL);
      if (!v3)
        return 0;
      pthread_setspecific(localtime_key, v3);
    }
    pthread_rwlock_rdlock(&lcl_rwlock);
    _st_tzset_basic(1);
    v4 = (tm *)_st_localsub(a1, 0, (uint64_t)v3);
    pthread_rwlock_unlock(&lcl_rwlock);
    return v4;
  }
  v2 = localtime_key_error;
  *__error() = v2;
  return 0;
}

uint64_t localtime_key_init()
{
  uint64_t result;

  localtime_key = 12;
  result = pthread_key_init_np(12, &_free);
  localtime_key_error = result;
  return result;
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  tm *v4;

  pthread_rwlock_rdlock(&lcl_rwlock);
  _st_tzset_basic(1);
  v4 = (tm *)_st_localsub(a1, 0, (uint64_t)a2);
  pthread_rwlock_unlock(&lcl_rwlock);
  return v4;
}

tm *__cdecl gmtime(const time_t *a1)
{
  int v2;
  const void *v3;

  pthread_once(&gmtime_once, (void (*)(void))gmtime_key_init);
  if (!gmtime_key_error)
  {
    v3 = pthread_getspecific(gmtime_key);
    if (!v3)
    {
      v3 = (const void *)malloc_type_malloc(56, 0x10100404E507D7FLL);
      if (!v3)
        return 0;
      pthread_setspecific(gmtime_key, v3);
    }
    return (tm *)gmtsub(a1, 0, (uint64_t)v3);
  }
  v2 = gmtime_key_error;
  *__error() = v2;
  return 0;
}

uint64_t gmtime_key_init()
{
  uint64_t result;

  gmtime_key = 13;
  result = pthread_key_init_np(13, &_free);
  gmtime_key_error = result;
  return result;
}

uint64_t gmtsub(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  pthread_once(&gmt_once, (void (*)(void))gmt_init);
  v4 = timesub(a1, a2, gmtmem, a3);
  if (!v4)
    return 0;
  if (a2)
    *(_QWORD *)(a3 + 48) = "   ";
  else
    *(_QWORD *)(a3 + 48) = &unk_E9120;
  return v4;
}

tm *__cdecl gmtime_r(const time_t *a1, tm *a2)
{
  return (tm *)gmtsub(a1, 0, (uint64_t)a2);
}

uint64_t offtime(_QWORD *a1, uint64_t a2)
{
  return gmtsub(a1, a2, (uint64_t)&tm);
}

char *__cdecl ctime(const time_t *a1)
{
  const tm *v2;

  v2 = localtime(a1);
  if (v2)
    return asctime(v2);
  else
    return 0;
}

char *__cdecl ctime_r(const time_t *a1, char *a2)
{
  tm v3;
  char *v4;
  const time_t *v5;

  v5 = a1;
  v4 = a2;
  _platform_memset(&v3, 0, 56);
  if (localtime_r(v5, &v3))
    return asctime_r(&v3, v4);
  else
    return 0;
}

uint64_t _st_time1(_DWORD *a1, uint64_t (*a2)(uint64_t *a1, uint64_t a2, uint64_t a3), uint64_t a3, int a4)
{
  int *v4;
  int v5;
  uint64_t v6;
  int v8;
  int v9;
  int i;
  int k;
  int j;
  int v13;
  int v14;
  int *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t (*v19)(uint64_t *, uint64_t, uint64_t);
  _DWORD *v20;
  _DWORD v22[512];

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = a4;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  j = 0;
  k = 0;
  i = 0;
  v9 = 0;
  v8 = 0;
  if (a1)
  {
    if ((int)v20[8] > 1)
      v20[8] = 1;
    v16 = time2((uint64_t)v20, v19, v18, &v8, v17);
    if (v8)
    {
      return v16;
    }
    else
    {
      if ((int)v20[8] < 0)
        v20[8] = 0;
      v4 = &lclmem;
      if (v19 != _st_localsub)
        v4 = (int *)&gmtmem;
      v15 = v4;
      for (i = 0; i < v15[2]; ++i)
        v22[i + 256] = 0;
      v9 = 0;
      for (i = v15[1] - 1; i >= 0; --i)
      {
        if (!v22[*((unsigned __int8 *)v15 + i + 9624) + 256])
        {
          v22[*((unsigned __int8 *)v15 + i + 9624) + 256] = 1;
          v5 = *((unsigned __int8 *)v15 + i + 9624);
          v6 = v9++;
          v22[v6] = v5;
        }
      }
      for (j = 0; j < v9; ++j)
      {
        v14 = v22[j];
        if (v15[6 * v14 + 2708] == v20[8])
        {
          for (k = 0; k < v9; ++k)
          {
            v13 = v22[k];
            if (v15[6 * v13 + 2708] != v20[8])
            {
              *v20 += v15[6 * v13 + 2706] - v15[6 * v14 + 2706];
              v20[8] = v20[8] == 0;
              v16 = time2((uint64_t)v20, v19, v18, &v8, v17);
              if (v8)
                return v16;
              *v20 -= v15[6 * v13 + 2706] - v15[6 * v14 + 2706];
              v20[8] = v20[8] == 0;
            }
          }
        }
      }
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t time2(uint64_t a1, uint64_t (*a2)(uint64_t *a1, uint64_t a2, uint64_t a3), uint64_t a3, _DWORD *a4, int a5)
{
  uint64_t v7;

  v7 = time2sub(a1, a2, a3, a4, 0, a5);
  if (*a4)
    return v7;
  else
    return time2sub(a1, a2, a3, a4, 1, a5);
}

time_t mktime(tm *a1)
{
  int v2;
  time_t v3;

  v2 = *__error();
  pthread_rwlock_rdlock(&lcl_rwlock);
  _st_tzset_basic(1);
  v3 = _st_time1(a1, _st_localsub, 0, 1);
  pthread_rwlock_unlock(&lcl_rwlock);
  *__error() = v2;
  return v3;
}

time_t timelocal(tm *const a1)
{
  if (a1)
    a1->tm_isdst = -1;
  return mktime(a1);
}

time_t timegm(tm *const a1)
{
  if (a1)
    a1->tm_isdst = 0;
  return _st_time1(a1, gmtsub, 0, 1);
}

uint64_t timeoff(_DWORD *a1, uint64_t a2)
{
  if (a1)
    a1[8] = 0;
  return _st_time1(a1, gmtsub, a2, 1);
}

time_t time2posix(time_t a1)
{
  time_t v2;
  time_t v3;

  v3 = a1;
  tzset();
  v2 = v3;
  return v2 - leapcorr(&v3);
}

uint64_t leapcorr(_QWORD *a1)
{
  int v2;

  v2 = lclmem;
  while (--v2 >= 0)
  {
    if (*a1 >= qword_E4B60[2 * v2])
      return qword_E4B60[2 * v2 + 1];
  }
  return 0;
}

time_t posix2time(time_t a1)
{
  time_t v2;
  time_t v3;
  time_t v4;
  time_t v5;
  time_t v6;
  time_t v7;
  time_t v8;
  time_t v9;
  time_t v10;

  v10 = a1;
  v9 = 0;
  tzset();
  v4 = v10;
  v9 = v4 + leapcorr(&v10);
  v5 = v9;
  v6 = v5 - leapcorr(&v9);
  if (v6 >= v10)
  {
    if (v6 > v10)
    {
      do
      {
        v2 = --v9;
        v8 = v2 - leapcorr(&v9);
      }
      while (v8 > v10);
      if (v10 != v8)
        return v9 + 1;
    }
    return v9;
  }
  do
  {
    v3 = ++v9;
    v7 = v3 - leapcorr(&v9);
  }
  while (v7 < v10);
  if (v10 == v7)
    return v9;
  return v9 - 1;
}

double tzsetwall_check_default_file_timestamp()
{
  double result;
  stat v1;

  _platform_memset(&v1, 0, 144);
  if (!lstat("/var/db/timezone/localtime", &v1))
  {
    if (v1.st_mtimespec.tv_sec > (uint64_t)last_default_tzload_mtimespec
      || v1.st_mtimespec.tv_sec == (_QWORD)last_default_tzload_mtimespec
      && v1.st_mtimespec.tv_nsec > *((uint64_t *)&last_default_tzload_mtimespec + 1))
    {
      lcl_is_set = 0;
    }
    result = *(double *)&v1.st_mtimespec.tv_sec;
    last_default_tzload_mtimespec = (__int128)v1.st_mtimespec;
  }
  return result;
}

uint64_t detzcode(char *a1)
{
  uint64_t v1;
  int i;
  uint64_t v4;

  v1 = 0;
  if (*a1 < 0)
    v1 = -1;
  v4 = v1;
  for (i = 0; i < 4; ++i)
    v4 = a1[i] | (unint64_t)(v4 << 8);
  return v4;
}

uint64_t detzcode64(char *a1)
{
  uint64_t v1;
  int i;
  uint64_t v4;

  v1 = 0;
  if (*a1 < 0)
    v1 = -1;
  v4 = v1;
  for (i = 0; i < 8; ++i)
    v4 = (v4 << 8) + a1[i];
  return v4;
}

BOOL typesequiv(uint64_t a1, int a2, int a3)
{
  BOOL v4;
  uint64_t v5;
  uint64_t v6;

  if (a1 && a2 >= 0 && a2 < *(_DWORD *)(a1 + 8) && a3 >= 0 && a3 < *(_DWORD *)(a1 + 8))
  {
    v6 = a1 + 10824 + 24 * a2;
    v5 = a1 + 10824 + 24 * a3;
    v4 = 0;
    if (*(_QWORD *)v6 == *(_QWORD *)v5)
    {
      v4 = 0;
      if (*(_DWORD *)(v6 + 8) == *(_DWORD *)(v5 + 8))
      {
        v4 = 0;
        if (*(_DWORD *)(v6 + 16) == *(_DWORD *)(v5 + 16))
        {
          v4 = 0;
          if (*(_DWORD *)(v6 + 20) == *(_DWORD *)(v5 + 20))
            return _platform_strcmp(a1 + 16968 + *(int *)(v6 + 12), a1 + 16968 + *(int *)(v5 + 12)) == 0;
        }
      }
    }
    return v4;
  }
  else
  {
    return 0;
  }
}

BOOL differ_by_repeat(uint64_t a1, uint64_t a2)
{
  return a1 - a2 == 0x2F0605980;
}

char *getzname(char *a1, _QWORD *a2, _QWORD *a3)
{
  BOOL v4;
  uint64_t v5;
  char v6;
  char *v9;

  v9 = a1;
  if (*a1 == 60 && (v5 = _platform_strchr(a1, 62)) != 0)
  {
    *a2 = v9 + 1;
    *a3 = v5 - (_QWORD)v9 - 1;
    return (char *)(v5 + 1);
  }
  else
  {
    *a2 = v9;
    while (1)
    {
      v6 = *v9;
      v4 = 0;
      if (*v9)
      {
        v4 = 0;
        if ((v6 - 48) > 9)
        {
          v4 = 0;
          if (v6 != 44)
          {
            v4 = 0;
            if (v6 != 45)
              v4 = v6 != 43;
          }
        }
      }
      if (!v4)
        break;
      ++v9;
    }
    *a3 = &v9[-*a2];
    return v9;
  }
}

char *getoffset(char *a1, _QWORD *a2)
{
  int v3;
  char *v5;
  char *v6;

  v5 = a1;
  v3 = 0;
  if (*a1 == 45)
  {
    v3 = 1;
    v5 = a1 + 1;
  }
  else if (*a1 == 43)
  {
    v5 = a1 + 1;
  }
  v6 = getsecs(v5, a2);
  if (!v6)
    return 0;
  if (v3)
    *a2 = -*a2;
  return v6;
}

_BYTE *getqzname(_BYTE *a1, int a2)
{
  BOOL v3;

  while (1)
  {
    v3 = 0;
    if (*a1)
      v3 = (char)*a1 != a2;
    if (!v3)
      break;
    ++a1;
  }
  return a1;
}

char *getrule(char *a1, uint64_t a2)
{
  char *v2;
  char *v3;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;

  if (*a1 == 74)
  {
    *(_DWORD *)a2 = 0;
    v6 = getnum(a1 + 1, (int *)(a2 + 4), 1, 365);
  }
  else if (*a1 == 77)
  {
    *(_DWORD *)a2 = 2;
    v7 = getnum(a1 + 1, (int *)(a2 + 12), 1, 12);
    if (!v7)
      return 0;
    v2 = v7;
    v8 = v7 + 1;
    if (*v2 != 46)
      return 0;
    v9 = getnum(v8, (int *)(a2 + 8), 1, 5);
    if (!v9)
      return 0;
    v3 = v9;
    v10 = v9 + 1;
    if (*v3 != 46)
      return 0;
    v6 = getnum(v10, (int *)(a2 + 4), 0, 6);
  }
  else
  {
    if ((*a1 - 48) > 9)
      return 0;
    *(_DWORD *)a2 = 1;
    v6 = getnum(a1, (int *)(a2 + 4), 0, 365);
  }
  if (!v6)
    return 0;
  if (*v6 == 47)
    return getsecs(v6 + 1, (_QWORD *)(a2 + 16));
  *(_QWORD *)(a2 + 16) = 7200;
  return v6;
}

uint64_t transtime(uint64_t a1, int a2, int *a3, uint64_t a4)
{
  int v5;
  int v6;
  BOOL v7;
  BOOL v8;
  int v9;
  int v10;
  int v11;
  int i;
  int j;
  uint64_t v14;
  uint64_t v15;

  v14 = 0;
  v8 = 0;
  if (!(a2 % 4))
  {
    v7 = 1;
    if (!(a2 % 100))
      v7 = a2 % 400 == 0;
    v8 = v7;
  }
  v6 = *a3;
  if (*a3)
  {
    if (v6 == 1)
    {
      v14 = a1 + 86400 * a3[1];
    }
    else if (v6 == 2)
    {
      v15 = a1;
      for (i = 0; i < a3[3] - 1; ++i)
        v15 += 86400 * mon_lengths[12 * v8 + i];
      if (a3[3] > 2)
        v5 = a2;
      else
        v5 = a2 - 1;
      v9 = ((26 * ((a3[3] + 9) % 12 + 1) - 2) / 10 + 1 + v5 % 100 + v5 % 100 / 4 + v5 / 100 / 4 - 2 * (v5 / 100)) % 7;
      v10 = v9 + (v9 < 0 ? 7 : 0);
      v11 = a3[1] - v10 + (a3[1] - v10 < 0 ? 7 : 0);
      for (j = 1; j < a3[2] && v11 + 7 < mon_lengths[12 * v8 - 1 + a3[3]]; ++j)
        v11 += 7;
      v14 = v15 + 86400 * v11;
    }
  }
  else
  {
    v14 = a1 + 86400 * (a3[1] - 1);
    if (v8 && a3[1] >= 60)
      v14 += 86400;
  }
  return v14 + *((_QWORD *)a3 + 2) + a4;
}

char *getsecs(char *a1, _QWORD *a2)
{
  int v3;
  _QWORD *v4;
  char *v5;

  v5 = a1;
  v4 = a2;
  v3 = 0;
  v5 = getnum(a1, &v3, 0, 167);
  if (v5)
  {
    *v4 = 3600 * v3;
    if (*v5 == 58)
    {
      ++v5;
      v5 = getnum(v5, &v3, 0, 59);
      if (!v5)
        return 0;
      *v4 += 60 * v3;
      if (*v5 == 58)
      {
        ++v5;
        v5 = getnum(v5, &v3, 0, 60);
        if (!v5)
          return 0;
        *v4 += v3;
      }
    }
    return v5;
  }
  return 0;
}

char *getnum(char *a1, int *a2, int a3, int a4)
{
  int v5;
  char v6;
  char *v7;

  v7 = a1;
  if (!a1)
    return 0;
  v6 = *a1;
  if ((*a1 - 48) > 9)
    return 0;
  v5 = 0;
  do
  {
    v5 = 10 * v5 + v6 - 48;
    if (v5 > a4)
      return 0;
    v6 = *++v7;
  }
  while ((*v7 - 48) <= 9);
  if (v5 < a3)
    return 0;
  *a2 = v5;
  return v7;
}

uint64_t gmt_init()
{
  return gmtload((uint64_t)&gmtmem);
}

uint64_t time2sub(uint64_t a1, uint64_t (*a2)(uint64_t *a1, uint64_t a2, uint64_t a3), uint64_t a3, _DWORD *a4, int a5, int a6)
{
  int v7;
  int *v8;
  BOOL v10;
  BOOL v11;
  BOOL v12;
  BOOL v13;
  BOOL v14;
  BOOL v15;
  _DWORD v16[8];
  int v17;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int j;
  int i;
  int v34;
  int *v35;
  int v36;
  int v37;
  _DWORD *v38;
  uint64_t v39;
  uint64_t (*v40)(uint64_t *, uint64_t, uint64_t);
  uint64_t v41;

  v41 = a1;
  v40 = a2;
  v39 = a3;
  v38 = a4;
  v37 = a5;
  v36 = a6;
  v35 = 0;
  v34 = 0;
  i = 0;
  j = 0;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  _platform_memset(&v18, 0, 56);
  _platform_memset(v16, 0, 56);
  *v38 = 0;
  j___platform_memmove(&v18, v41, 56);
  if (v37 && normalize_overflow(&v19, (int *)&v18, 60))
    return -1;
  if (normalize_overflow(&v20, &v19, 60))
    return -1;
  if (normalize_overflow(&v21, &v20, 24))
    return -1;
  v27 = v23;
  if (long_normalize_overflow(&v27, &v22, 12))
    return -1;
  if (long_increment_overflow(&v27, 1900))
    return -1;
  while (v21 <= 0)
  {
    if (long_increment_overflow(&v27, -1))
      return -1;
    v30 = v27 + (v22 > 1);
    v15 = 0;
    if (!(v30 % 4))
    {
      v14 = 1;
      if (!(v30 % 100))
        v14 = v30 % 400 == 0;
      v15 = v14;
    }
    v21 += year_lengths[v15];
  }
  while (v21 > 366)
  {
    v30 = v27 + (v22 > 1);
    v13 = 0;
    if (!(v30 % 4))
    {
      v12 = 1;
      if (!(v30 % 100))
        v12 = v30 % 400 == 0;
      v13 = v12;
    }
    v21 -= year_lengths[v13];
    if (long_increment_overflow(&v27, 1))
      return -1;
  }
  while (1)
  {
    v11 = 0;
    if (!(v27 % 4))
    {
      v10 = 1;
      if (!(v27 % 100))
        v10 = v27 % 400 == 0;
      v11 = v10;
    }
    i = mon_lengths[12 * v11 + v22];
    if (v21 <= i)
      break;
    v21 -= i;
    if (++v22 >= 12)
    {
      v22 = 0;
      if (long_increment_overflow(&v27, 1))
        return -1;
    }
  }
  if (long_increment_overflow(&v27, -1900))
    return -1;
  v23 = v27;
  if ((int)v27 != v27)
    return -1;
  if (v23 < 0)
    return -1;
  if (v18 >= 0x3C)
  {
    if (v27 + 1900 >= 1970)
    {
      v31 = v18;
      v18 = 0;
    }
    else
    {
      if (increment_overflow((int *)&v18, -59))
        return -1;
      v31 = v18;
      v18 = 59;
    }
  }
  else
  {
    v31 = 0;
  }
  v29 = 1;
  for (i = 0; i < 63; ++i)
    v29 *= 2;
  v28 = -(v29 + 1);
  while (1)
  {
    v25 = v29 / 2 + v28 / 2;
    if (v25 >= v29)
    {
      if (v25 > v28)
        v25 = v28;
    }
    else
    {
      v25 = v29;
    }
    if (v40(&v25, v39, (uint64_t)v16))
    {
      v34 = tmcomp(v16, &v18);
    }
    else
    {
      v7 = v25 > 0 ? 1 : -1;
      v34 = v7;
    }
    if (!v34)
      break;
    if (v25 == v29)
    {
      if (++v25 <= v29)
        return -1;
      ++v29;
    }
    else if (v25 == v28)
    {
      if (--v25 >= v28)
        return -1;
      --v28;
    }
    if (v29 > v28)
      return -1;
    if (v34 <= 0)
      v29 = v25;
    else
      v28 = v25;
  }
  v8 = &lclmem;
  if (v40 != _st_localsub)
    v8 = (int *)&gmtmem;
  v35 = v8;
  if (v36 && v35[2] == 1 && v24 > 0)
    v24 = 0;
  if (v24 < 0 || v17 == v24)
  {
LABEL_101:
    v26 = v25 + v31;
    if (v26 < v25 == v31 < 0)
    {
      v25 = v26;
      if (v40(&v25, v39, v41))
      {
        *v38 = 1;
        return v25;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return -1;
    }
  }
  else
  {
    for (i = v35[2] - 1; i >= 0; --i)
    {
      if (v35[6 * i + 2708] == v24)
      {
        for (j = v35[2] - 1; j >= 0; --j)
        {
          if (v35[6 * j + 2708] != v24)
          {
            v26 = v25 + *(_QWORD *)&v35[6 * j + 2706] - *(_QWORD *)&v35[6 * i + 2706];
            if (v40(&v26, v39, (uint64_t)v16))
            {
              if (!tmcomp(v16, &v18) && v17 == v24)
              {
                v25 = v26;
                goto LABEL_101;
              }
            }
          }
        }
      }
    }
    return -1;
  }
}

BOOL normalize_overflow(int *a1, int *a2, int a3)
{
  int v4;

  if (*a2 < 0)
    v4 = -1 - (-1 - *a2) / a3;
  else
    v4 = *a2 / a3;
  *a2 -= v4 * a3;
  return increment_overflow(a1, v4);
}

BOOL long_normalize_overflow(uint64_t *a1, int *a2, int a3)
{
  int v4;

  if (*a2 < 0)
    v4 = -1 - (-1 - *a2) / a3;
  else
    v4 = *a2 / a3;
  *a2 -= v4 * a3;
  return long_increment_overflow(a1, v4);
}

BOOL long_increment_overflow(uint64_t *a1, int a2)
{
  uint64_t v3;

  v3 = *a1;
  *a1 += a2;
  return *a1 < v3 != a2 < 0;
}

BOOL increment_overflow(int *a1, int a2)
{
  int v3;

  v3 = *a1;
  *a1 += a2;
  return *a1 < v3 != a2 < 0;
}

uint64_t tmcomp(_DWORD *a1, _DWORD *a2)
{
  unsigned int v4;

  if (a1[5] == a2[5])
  {
    v4 = a1[4] - a2[4];
    if (a1[4] == a2[4])
    {
      v4 = a1[3] - a2[3];
      if (a1[3] == a2[3])
      {
        v4 = a1[2] - a2[2];
        if (a1[2] == a2[2])
        {
          v4 = a1[1] - a2[1];
          if (a1[1] == a2[1])
            return (*a1 - *a2);
        }
      }
    }
    return v4;
  }
  else if (a1[5] > a2[5])
  {
    return 1;
  }
  else
  {
    return -1;
  }
}

size_t strftime_l(char *a1, size_t a2, const char *a3, const tm *a4, locale_t a5)
{
  char *v6;
  char *v7;
  locale_t v8;

  v8 = a5;
  if (a5)
  {
    if (a5 == (locale_t)-1)
      v8 = (locale_t)__global_locale;
  }
  else
  {
    v8 = (locale_t)&__c_locale;
  }
  tzset();
  if (a3)
    v6 = (char *)a3;
  else
    v6 = "%c";
  __get_current_time_locale((uint64_t)v8);
  v7 = _st_fmt(v6, (uint64_t)a4, a1, &a1[a2]);
  if (v7 == &a1[a2])
    return 0;
  *v7 = 0;
  return v7 - a1;
}

_BYTE *_st_fmt(_BYTE *a1, uint64_t a2, _BYTE *a3, _BYTE *a4)
{
  _BYTE *v4;
  unint64_t v6;

  while (*a1)
  {
    if (*a1 == 37)
    {
      v6 = (char)*++a1;
      if (v6 <= 0x7A)
        __asm { BR              X8 }
    }
    if (a3 == a4)
      break;
    v4 = a3++;
    *v4 = *a1++;
  }
  return a3;
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  char v4;
  char v5;
  _xlocale *v11;
  uint64_t v12;

  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    v11 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v12 = __locale_key;
    v11 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v12);
  }
  if (v11)
    return strftime_l(a1, a2, a3, a4, v11);
  else
    return strftime_l(a1, a2, a3, a4, (locale_t)__global_locale);
}

_BYTE *_add(char *a1, _BYTE *a2, unint64_t a3)
{
  char *v3;
  BOOL v5;

  while (1)
  {
    v5 = 0;
    if ((unint64_t)a2 < a3)
    {
      v3 = a1++;
      LODWORD(v3) = *v3;
      *a2 = (_BYTE)v3;
      v5 = (_DWORD)v3 != 0;
    }
    if (!v5)
      break;
    ++a2;
  }
  return a2;
}

_BYTE *_yconv(int a1, int a2, int a3, int a4, _BYTE *a5, unint64_t a6, _xlocale *a7)
{
  signed int v9;
  signed int v10;
  _BYTE *v13;

  v13 = a5;
  v10 = a1 / 100 + a2 / 100 + (a1 % 100 + a2 % 100) / 100;
  v9 = (a1 % 100 + a2 % 100) % 100;
  if (v9 >= 0 || v10 <= 0)
  {
    if (v10 < 0 && v9 > 0)
    {
      v9 -= 100;
      ++v10;
    }
  }
  else
  {
    v9 += 100;
    --v10;
  }
  if (a3)
  {
    if (v10 || v9 >= 0)
      v13 = _conv(v10, "%02d", a5, a6, a7);
    else
      v13 = _add("-0", a5, a6);
  }
  if (a4)
  {
    if (v9 >= 0)
      return _conv(v9, "%02d", v13, a6, a7);
    else
      return _conv(-v9, "%02d", v13, a6, a7);
  }
  return v13;
}

_BYTE *_conv(unsigned int a1, const char *a2, _BYTE *a3, unint64_t a4, _xlocale *a5)
{
  char v8[12];

  sprintf_l(v8, a5, a2, a1);
  return _add(v8, a3, a4);
}

char *__cdecl strptime(const char *a1, const char *a2, tm *a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strptime_l(a1, a2, a3, v9);
  else
    return strptime_l(a1, a2, a3, (locale_t)__global_locale);
}

char *__cdecl strptime_l(const char *a1, const char *a2, tm *a3, locale_t a4)
{
  uint64_t tm_gmtoff;
  time_t v6;
  int v7;
  char *v8;
  _xlocale *v9;
  tm *v10;
  char *v11;
  char *v12;

  v12 = (char *)a1;
  v11 = (char *)a2;
  v10 = a3;
  v9 = a4;
  v8 = 0;
  v7 = 0;
  if (a4)
  {
    if (v9 == (_xlocale *)-1)
      v9 = (_xlocale *)__global_locale;
  }
  else
  {
    v9 = (_xlocale *)&__c_locale;
  }
  v7 = 0;
  v10->tm_zone = 0;
  v8 = _strptime0(v12, v11, v10, (uint64_t)&v7, v9, 1, 0, 85);
  if (v8)
  {
    v6 = 0;
    if (v7 == 1)
    {
      v6 = timegm(v10);
      localtime_r(&v6, v10);
    }
    else if (v7 == 2)
    {
      tm_gmtoff = v10->tm_gmtoff;
      v10->tm_gmtoff = 0;
      v6 = timeoff(v10, tm_gmtoff);
      localtime_r(&v6, v10);
    }
  }
  return v8;
}

_BYTE *_strptime0(_BYTE *a1, char *a2, _DWORD *a3, uint64_t a4, _xlocale *a5, char a6, int a7, int a8)
{
  char *v8;
  _BYTE *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  BOOL v15;
  BOOL v16;
  BOOL v17;
  BOOL v18;
  BOOL v19;
  BOOL v20;
  BOOL v21;
  BOOL v22;
  unint64_t v23;
  BOOL v24;
  BOOL v25;
  int v26;
  int v27;
  int wday_of;
  int v29;
  char v30;
  int i;
  int j;
  char *v33;
  char *v34;
  unsigned __int8 v35;
  char v36;

  __get_current_time_locale((uint64_t)a5);
  v33 = a2;
  while (*v33)
  {
    v8 = v33++;
    v35 = *v8;
    if (*v8 == 37)
    {
      v10 = v33;
      v34 = v33 + 1;
      v36 = *v10;
      if (is_zero(*v10))
      {
        v11 = v34++;
        v36 = *v11;
      }
      else if (is_plus(v36))
      {
        v30 = *v34;
        if (*v34)
        {
          if (v30 != 37 && !isspace_l(v30, a5))
          {
            v12 = v34++;
            v36 = *v12;
          }
        }
      }
      if (isdigit_l(v36, a5))
      {
        for (i = v36 - 48; ; i = 10 * i + *v13 - 48)
        {
          v24 = 0;
          if (*v34)
            v24 = isdigit_l(*v34, a5) != 0;
          if (!v24)
            break;
          v13 = v34++;
        }
        v36 = *v34;
      }
      v23 = (v36 - 37);
      if (v23 <= 0x55)
        __asm { BR              X8 }
      return 0;
    }
    if (isspace_l(v35, a5))
    {
      while (1)
      {
        v25 = 0;
        if (*a1)
          v25 = isspace_l(*a1, a5) != 0;
        if (!v25)
          break;
        ++a1;
      }
    }
    else
    {
      v9 = a1++;
      if (v35 != *v9)
        return 0;
    }
  }
  if ((a6 & 8) == 0 && (a6 & 2) != 0)
  {
    if ((a6 & 0x14) == 0x14)
    {
      v22 = 0;
      if (!((a3[5] + 1900) % 4))
      {
        v21 = 1;
        if (!((a3[5] + 1900) % 100))
          v21 = (a3[5] + 1900) % 400 == 0;
        v22 = v21;
      }
      a3[7] = _strptime0_start_of_month[13 * v22 + a3[4]] + a3[3] - 1;
      a6 |= 8u;
    }
    else if ((a6 & 0x40) != 0)
    {
      v29 = a8 != 85;
      wday_of = first_wday_of(a3[5] + 1900);
      if (!a7 && wday_of == v29)
        return 0;
      if ((a6 & 0x20) == 0)
      {
        a3[6] = v29;
        a6 |= 0x20u;
      }
      v26 = (7 - wday_of + v29) % 7;
      if (a8 == 86 && wday_of > 1 && wday_of <= 4)
        v26 -= 7;
      v27 = v26 + 7 * (a7 - 1) + (a3[6] - v29 + 7) % 7;
      if (v27 < 0)
      {
        if ((a6 & 0x20) != 0)
          return 0;
        v27 = 0;
      }
      a3[7] = v27;
      a6 |= 8u;
    }
  }
  if ((a6 & 0xA) == 0xA)
  {
    if ((a6 & 4) == 0)
    {
      for (j = 0; ; ++j)
      {
        v20 = 0;
        if (!((a3[5] + 1900) % 4))
        {
          v19 = 1;
          if (!((a3[5] + 1900) % 100))
            v19 = (a3[5] + 1900) % 400 == 0;
          v20 = v19;
        }
        if (a3[7] < _strptime0_start_of_month[13 * v20 + j])
          break;
      }
      if (j > 12)
      {
        j = 1;
        v18 = 0;
        if (!((a3[5] + 1900) % 4))
        {
          v17 = 1;
          if (!((a3[5] + 1900) % 100))
            v17 = (a3[5] + 1900) % 400 == 0;
          v18 = v17;
        }
        a3[7] -= _strptime0_start_of_month[13 * v18 + 12];
        ++a3[5];
      }
      a3[4] = j - 1;
      a6 |= 4u;
    }
    if ((a6 & 0x10) == 0)
    {
      v16 = 0;
      if (!((a3[5] + 1900) % 4))
      {
        v15 = 1;
        if (!((a3[5] + 1900) % 100))
          v15 = (a3[5] + 1900) % 400 == 0;
        v16 = v15;
      }
      a3[3] = a3[7] - _strptime0_start_of_month[13 * v16 + a3[4]] + 1;
      a6 |= 0x10u;
    }
    if ((a6 & 0x20) == 0)
      a3[6] = (int)(first_wday_of(a3[5] + 1900) + a3[7]) % 7;
  }
  return a1;
}

BOOL is_zero(char a1)
{
  return a1 == 48;
}

BOOL is_plus(char a1)
{
  return a1 == 43;
}

BOOL is_minus(char a1)
{
  return a1 == 45;
}

uint64_t first_wday_of(int a1)
{
  int v1;
  BOOL v3;
  BOOL v4;

  v4 = 0;
  if (!(a1 % 4))
  {
    v3 = 1;
    if (!(a1 % 100))
      v3 = a1 % 400 == 0;
    v4 = v3;
  }
  if (v4)
    v1 = 6;
  else
    v1 = 0;
  return ((2 * (3 - a1 / 100 % 4) + a1 % 100 + a1 % 100 / 4 + v1 + 1) % 7);
}

time_t _time32_to_time(int32_t t32)
{
  time_t result;

  *(_QWORD *)&t32 = t32;
  LODWORD(result) = t32;
  return result;
}

int32_t _time_to_time32(time_t t)
{
  return t;
}

time_t _time64_to_time(time_t t64)
{
  return t64;
}

int64_t _time_to_time64(int64_t t)
{
  return t;
}

uint64_t _time_to_long(time_t t)
{
  return _time_to_time64(t);
}

time_t _long_to_time(time_t tlong)
{
  return tlong;
}

int _time_to_int(time_t t)
{
  return t;
}

time_t _int_to_time(int tint)
{
  return _time32_to_time(tint);
}

char **__get_current_time_locale(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 1315))
    return (char **)(*(_QWORD *)(a1 + 1352) + 72);
  else
    return _C_time_locale;
}

uint64_t __time_load_locale(uint64_t a1, uint64_t a2)
{
  void *v3;
  unsigned int locale;

  if (_platform_strcmp(a1, "C")
    && _platform_strcmp(a1, "POSIX")
    && _platform_strncmp(a1, "C.", 2))
  {
    if (__time_load_locale_cache
      && *(_QWORD *)(__time_load_locale_cache + 64)
      && !_platform_strcmp(a1, *(_QWORD *)(__time_load_locale_cache + 64)))
    {
      *(_BYTE *)(a2 + 1315) = 1;
      xlocale_release(*(_QWORD *)(a2 + 1352));
      *(_QWORD *)(a2 + 1352) = __time_load_locale_cache;
      xlocale_retain((unsigned int *)__time_load_locale_cache);
      return 1;
    }
    else
    {
      v3 = (void *)malloc_type_malloc(536, 0x10D00403D7458CFLL);
      if (v3)
      {
        *(_DWORD *)v3 = 1;
        *((_QWORD *)v3 + 1) = destruct_ldpart;
        *((_QWORD *)v3 + 8) = 0;
        locale = __part_load_locale(a1, (_BYTE *)(a2 + 1315), (void **)v3 + 8, "LC_TIME", 58, 58, (uint64_t)v3 + 72);
        if (locale)
        {
          if (locale == -1)
            free(v3);
        }
        else
        {
          xlocale_release(*(_QWORD *)(a2 + 1352));
          *(_QWORD *)(a2 + 1352) = v3;
          xlocale_release(__time_load_locale_cache);
          __time_load_locale_cache = (uint64_t)v3;
          xlocale_retain((unsigned int *)v3);
        }
        return locale;
      }
      else
      {
        return -1;
      }
    }
  }
  else
  {
    *(_BYTE *)(a2 + 1315) = 0;
    xlocale_release(*(_QWORD *)(a2 + 1352));
    *(_QWORD *)(a2 + 1352) = 0;
    return 1;
  }
}

void *__cdecl memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
{
  char *v6;
  char *i;

  if (!__big_len || !__little_len)
    return 0;
  if (__big_len < __little_len)
    return 0;
  if (__little_len == 1)
    return (void *)_platform_memchr(__big, *(char *)__little, __big_len);
  v6 = (char *)__big + __big_len - __little_len;
  for (i = (char *)__big; i <= v6; ++i)
  {
    if (*i == *(char *)__little && !_platform_memcmp(i, __little, __little_len))
      return i;
  }
  return 0;
}

char *__cdecl rindex(const char *a1, int a2)
{
  char *v3;

  v3 = 0;
  while (1)
  {
    if (*a1 == (char)a2)
      v3 = (char *)a1;
    if (!*a1)
      break;
    ++a1;
  }
  return v3;
}

int strcasecmp_l(const char *a1, const char *a2, locale_t a3)
{
  const char *v3;
  const char *v4;
  int v6;
  int v7;
  _xlocale *v10;

  v10 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v10 = (_xlocale *)__global_locale;
  }
  else
  {
    v10 = (_xlocale *)&__c_locale;
  }
  while (1)
  {
    v7 = tolower_l(*(unsigned __int8 *)a1, v10);
    v3 = a2++;
    if (v7 != tolower_l(*(unsigned __int8 *)v3, v10))
      break;
    v4 = a1++;
    if (!*v4)
      return 0;
  }
  v6 = tolower_l(*(unsigned __int8 *)a1, v10);
  return v6 - tolower_l(*((unsigned __int8 *)a2 - 1), v10);
}

int strcasecmp(const char *a1, const char *a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return strcasecmp_l(a1, a2, v7);
  else
    return strcasecmp_l(a1, a2, (locale_t)__global_locale);
}

int strncasecmp_l(const char *a1, const char *a2, size_t a3, locale_t a4)
{
  const char *v4;
  const char *v5;
  int v7;
  int v8;
  _xlocale *v11;
  size_t v12;

  v12 = a3;
  v11 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v11 = (_xlocale *)__global_locale;
  }
  else
  {
    v11 = (_xlocale *)&__c_locale;
  }
  if (!a3)
    return 0;
  while (1)
  {
    v8 = tolower_l(*(unsigned __int8 *)a1, v11);
    v4 = a2++;
    if (v8 != tolower_l(*(unsigned __int8 *)v4, v11))
      break;
    v5 = a1++;
    if (*v5)
    {
      if (--v12)
        continue;
    }
    return 0;
  }
  v7 = tolower_l(*(unsigned __int8 *)a1, v11);
  return v7 - tolower_l(*((unsigned __int8 *)a2 - 1), v11);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strncasecmp_l(a1, a2, a3, v9);
  else
    return strncasecmp_l(a1, a2, a3, (locale_t)__global_locale);
}

char *__cdecl strcasestr_l(const char *a1, const char *a2, locale_t a3)
{
  const char *v3;
  int v4;
  uint64_t v6;
  char v7;
  _xlocale *v8;
  char *v9;

  v8 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v8 = (_xlocale *)__global_locale;
  }
  else
  {
    v8 = (_xlocale *)&__c_locale;
  }
  v9 = (char *)(a2 + 1);
  if (*a2)
  {
    v7 = tolower_l(*(unsigned __int8 *)a2, v8);
    v6 = _platform_strlen(v9);
    do
    {
      v3 = a1++;
      v4 = *v3;
      if (!v4)
        return 0;
    }
    while (v7 != (char)tolower_l(v4, v8) || strncasecmp_l(a1, v9, v6, v8));
    --a1;
  }
  return (char *)a1;
}

char *__cdecl strcasestr(const char *__big, const char *__little)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return strcasestr_l(__big, __little, v7);
  else
    return strcasestr_l(__big, __little, (locale_t)__global_locale);
}

int strcoll_l(const char *a1, const char *a2, locale_t a3)
{
  int v4;
  int v5;
  __int32 *v6;
  __int32 *v7;
  int v8;
  locale_t v9;

  v9 = a3;
  v7 = 0;
  v6 = 0;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v9 = (locale_t)__global_locale;
  }
  else
  {
    v9 = (locale_t)&__c_locale;
  }
  if (!*(_BYTE *)(*((_QWORD *)v9 + 165) + 64)
    && (v7 = __collate_mbstowcs((char *)a1, v9)) != 0
    && (v6 = __collate_mbstowcs((char *)a2, v9)) != 0)
  {
    v8 = wcscoll_l(v7, v6, v9);
    v5 = *__error();
    free(v7);
    free(v6);
    *__error() = v5;
    return v8;
  }
  else
  {
    v4 = *__error();
    free(v7);
    free(v6);
    *__error() = v4;
    return _platform_strcmp(a1, a2);
  }
}

int strcoll(const char *__s1, const char *__s2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return strcoll_l(__s1, __s2, v7);
  else
    return strcoll_l(__s1, __s2, (locale_t)__global_locale);
}

size_t strcspn(const char *__s, const char *__charset)
{
  _QWORD *v2;
  const char *i;
  _QWORD v7[4];

  if (!*__s)
    return 0;
  v7[0] = 1;
  memset(&v7[1], 0, 24);
  while (*__charset)
  {
    v2 = &v7[*(unsigned __int8 *)__charset / 64];
    *v2 |= 1 << (*(unsigned __int8 *)__charset++ % 64);
  }
  for (i = __s; (v7[*(unsigned __int8 *)i / 64] & (1 << (*(unsigned __int8 *)i % 64))) == 0; ++i)
    ;
  return i - __s;
}

char *__cdecl strdup(const char *__s1)
{
  char *v2;
  uint64_t v3;

  v3 = _platform_strlen(__s1) + 1;
  v2 = (char *)malloc_type_malloc(v3, 2298502748);
  if (!v2)
    return 0;
  j___platform_memmove(v2, __s1, v3);
  return v2;
}

uint64_t __errstr(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5;
  unsigned int v6;
  char *v7;
  char *v8;
  char v11;

  v7 = &v11;
  v11 = 0;
  if (a1 < 0)
    v5 = -a1;
  else
    v5 = a1;
  v6 = v5;
  do
  {
    *--v7 = a0123456789[v6 % 0xA];
    v6 /= 0xAu;
  }
  while (v6);
  if (a1 < 0)
    *--v7 = 45;
  v8 = v7 - 1;
  *v8-- = 32;
  *v8 = 58;
  _platform_strlcpy(a3, a2, a4);
  return _platform_strlcat(a3, v8, a4);
}

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
{
  int v4;

  v4 = 0;
  if (__errnum <= 0x6A)
  {
    if (_platform_strlcpy(__strerrbuf, sys_errlist[__errnum], __buflen) >= __buflen)
      return 34;
  }
  else
  {
    __errstr(__errnum, (uint64_t)"Unknown error", (uint64_t)__strerrbuf, __buflen);
    return 22;
  }
  return v4;
}

char *__cdecl strerror(int __errnum)
{
  if (__errnum <= 0x6A)
    return (char *)sys_errlist[__errnum];
  if (!__strerror_ebuf)
  {
    __strerror_ebuf = malloc_type_calloc(1, 2048, 1349494951);
    if (!__strerror_ebuf)
      return 0;
  }
  if (strerror_r(__errnum, (char *)__strerror_ebuf, 0x800uLL))
    *__error() = 22;
  return (char *)__strerror_ebuf;
}

void strmode(int __mode, char *__bp)
{
  char *v2;
  char *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  _BYTE *v14;
  _BYTE *v15;
  _BYTE *v16;
  _BYTE *v17;
  _BYTE *v18;
  _BYTE *v19;
  int v20;
  int v21;
  int v22;
  int v23;
  char *v24;
  char *v25;
  _BYTE *v26;
  _BYTE *v27;
  _BYTE *v28;
  _BYTE *v29;
  _BYTE *v30;

  v23 = __mode & 0xF000;
  switch(v23)
  {
    case 4096:
      v24 = __bp + 1;
      *__bp = 112;
      break;
    case 8192:
      v24 = __bp + 1;
      *__bp = 99;
      break;
    case 16384:
      v24 = __bp + 1;
      *__bp = 100;
      break;
    case 24576:
      v24 = __bp + 1;
      *__bp = 98;
      break;
    case 32768:
      v24 = __bp + 1;
      *__bp = 45;
      break;
    case 40960:
      v24 = __bp + 1;
      *__bp = 108;
      break;
    case 49152:
      v24 = __bp + 1;
      *__bp = 115;
      break;
    default:
      v24 = __bp + 1;
      if (v23 == 57344)
        *__bp = 119;
      else
        *__bp = 63;
      break;
  }
  v2 = v24;
  v25 = v24 + 1;
  if ((__mode & 0x100) != 0)
    *v2 = 114;
  else
    *v2 = 45;
  v3 = v25;
  v26 = v25 + 1;
  if ((__mode & 0x80u) == 0)
    *v3 = 45;
  else
    *v3 = 119;
  v22 = __mode & 0x840;
  if ((__mode & 0x840) != 0)
  {
    switch(v22)
    {
      case 64:
        v5 = v26++;
        *v5 = 120;
        break;
      case 2048:
        v6 = v26++;
        *v6 = 83;
        break;
      case 2112:
        v7 = v26++;
        *v7 = 115;
        break;
    }
  }
  else
  {
    v4 = v26++;
    *v4 = 45;
  }
  v8 = v26;
  v27 = v26 + 1;
  if ((__mode & 0x20) != 0)
    *v8 = 114;
  else
    *v8 = 45;
  v9 = v27;
  v28 = v27 + 1;
  if ((__mode & 0x10) != 0)
    *v9 = 119;
  else
    *v9 = 45;
  v21 = __mode & 0x408;
  if ((__mode & 0x408) != 0)
  {
    switch(v21)
    {
      case 8:
        v11 = v28++;
        *v11 = 120;
        break;
      case 1024:
        v12 = v28++;
        *v12 = 83;
        break;
      case 1032:
        v13 = v28++;
        *v13 = 115;
        break;
    }
  }
  else
  {
    v10 = v28++;
    *v10 = 45;
  }
  v14 = v28;
  v29 = v28 + 1;
  if ((__mode & 4) != 0)
    *v14 = 114;
  else
    *v14 = 45;
  v15 = v29;
  v30 = v29 + 1;
  if ((__mode & 2) != 0)
    *v15 = 119;
  else
    *v15 = 45;
  v20 = __mode & 0x201;
  if ((__mode & 0x201) != 0)
  {
    switch(v20)
    {
      case 1:
        v17 = v30++;
        *v17 = 120;
        break;
      case 512:
        v18 = v30++;
        *v18 = 84;
        break;
      case 513:
        v19 = v30++;
        *v19 = 116;
        break;
    }
  }
  else
  {
    v16 = v30++;
    *v16 = 45;
  }
  *v30 = 32;
  v30[1] = 0;
}

char *__cdecl strndup(const char *__s1, size_t __n)
{
  BOOL v3;
  char *v4;
  size_t i;

  for (i = 0; ; ++i)
  {
    v3 = 0;
    if (i < __n)
      v3 = __s1[i] != 0;
    if (!v3)
      break;
  }
  v4 = (char *)malloc_type_malloc(i + 1, 1725329557);
  if (!v4)
    return 0;
  j___platform_memmove(v4, __s1, i);
  v4[i] = 0;
  return v4;
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  const char *v4;
  int v5;
  size_t v7;
  char v8;
  const char *v10;

  v10 = __little + 1;
  v8 = *__little;
  if (*__little)
  {
    v7 = _platform_strlen(v10);
    do
    {
      do
      {
        if (__len--)
        {
          v4 = __big++;
          v5 = *v4;
          if (v5)
            continue;
        }
        return 0;
      }
      while ((char)v5 != v8);
      if (v7 > __len)
        return 0;
    }
    while (_platform_strncmp(__big, v10, v7));
    --__big;
  }
  return (char *)__big;
}

char *__cdecl strpbrk(const char *__s, const char *__charset)
{
  const char *v2;
  const char *v3;
  int v5;
  const char *v6;

  while (1)
  {
    v2 = __s++;
    v5 = *v2;
    if (!*v2)
      break;
    v6 = __charset;
    while (1)
    {
      v3 = v6++;
      if (!*v3)
        break;
      if (*v3 == v5)
        return (char *)(__s - 1);
    }
  }
  return 0;
}

char *__cdecl strrchr(const char *__s, int __c)
{
  char *v3;

  v3 = 0;
  while (1)
  {
    if (*__s == (char)__c)
      v3 = (char *)__s;
    if (!*__s)
      break;
    ++__s;
  }
  return v3;
}

char *__cdecl strsep(char **__stringp, const char *__delim)
{
  char *v2;
  const char *v3;
  char *v5;
  int v6;
  const char *v7;
  char *v8;

  v8 = *__stringp;
  if (!*__stringp)
    return 0;
  v5 = *__stringp;
LABEL_4:
  v2 = v8++;
  v6 = *v2;
  v7 = __delim;
  while (1)
  {
    v3 = v7++;
    if (*v3 == v6)
      break;
    if (!*v3)
      goto LABEL_4;
  }
  if (v6)
    *(v8 - 1) = 0;
  else
    v8 = 0;
  *__stringp = v8;
  return v5;
}

int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
{
  char *v3;
  char *v4;
  char *v5;
  int v7;
  char *v8;
  char *v9;
  int v10;
  size_t v11;
  int v12;
  uint64_t v16;
  _QWORD v17[2];

  v12 = 0;
  v16 = 0;
  v17[0] = 0;
  *(_QWORD *)((char *)v17 + 7) = 0;
  v10 = __sig;
  if (__sig < 0)
    v10 = -__sig;
  v9 = (char *)&v16;
  do
  {
    v3 = v9++;
    *v3 = a0123456789[v10 % 10];
    v10 /= 10;
  }
  while (v10);
  if (__sig < 0)
  {
    v4 = v9++;
    *v4 = 45;
  }
  v7 = _platform_strlen(&v16) + 2;
  if (__sig <= 0 || __sig >= 32)
  {
    v11 = _platform_strlcpy(__strsignalbuf, "Unknown signal", __buflen);
    v12 = 22;
  }
  else
  {
    v11 = _platform_strlcpy(__strsignalbuf, sys_siglist[__sig], __buflen);
    if (v11 >= __buflen - v7)
      v12 = 34;
  }
  if (v11 < __buflen - v7)
  {
    __strsignalbuf[v11] = 58;
    v8 = &__strsignalbuf[v11 + 2];
    __strsignalbuf[v11 + 1] = 32;
    do
    {
      --v9;
      v5 = v8++;
      *v5 = *v9;
    }
    while (v9 > (char *)&v16);
    *v8 = 0;
  }
  return v12;
}

char *__cdecl strsignal(int __sig)
{
  char *__strsignalbuf;

  __strsignalbuf = (char *)sig_tlsalloc();
  if (__strsignalbuf)
  {
    if (strsignal_r(__sig, __strsignalbuf, 0x800uLL))
      *__error() = 22;
    return __strsignalbuf;
  }
  else
  {
    *__error() = 12;
    return 0;
  }
}

void *sig_tlsalloc()
{
  void *v1;

  v1 = 0;
  if (!pthread_once(&sig_init_once, (void (*)(void))sig_keycreate))
  {
    if (sig_keycreated)
    {
      v1 = pthread_getspecific(sig_key);
      if (!v1)
      {
        v1 = (void *)malloc_type_malloc(2048, 0x100004077774924);
        if (v1)
        {
          if (pthread_setspecific(sig_key, v1))
          {
            free(v1);
            return 0;
          }
        }
      }
    }
  }
  return v1;
}

uint64_t sig_keycreate()
{
  uint64_t result;

  result = pthread_key_create((pthread_key_t *)&sig_key, (void (__cdecl *)(void *))&_free);
  sig_keycreated = result == 0;
  return result;
}

size_t strspn(const char *__s, const char *__charset)
{
  _QWORD *v2;
  const char *i;
  _QWORD v7[4];

  if (!*__s)
    return 0;
  memset(v7, 0, sizeof(v7));
  while (*__charset)
  {
    v2 = &v7[*(unsigned __int8 *)__charset / 64];
    *v2 |= 1 << (*(unsigned __int8 *)__charset++ % 64);
  }
  for (i = __s; (v7[*(unsigned __int8 *)i / 64] & (1 << (*(unsigned __int8 *)i % 64))) != 0; ++i)
    ;
  return i - __s;
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  char *v3;
  const char *v4;
  char *v5;
  const char *v6;
  int v8;
  int v9;
  char *v10;
  const char *v11;
  const char *v12;
  char *v13;

  v13 = __str;
  if (!__str)
  {
    v13 = *__lasts;
    if (!*__lasts)
      return 0;
  }
LABEL_4:
  v3 = v13++;
  v8 = *v3;
  v11 = __sep;
  while (1)
  {
    v4 = v11++;
    if (!*v4)
      break;
    if (v8 == *v4)
      goto LABEL_4;
  }
  if (v8)
  {
    v10 = v13 - 1;
LABEL_11:
    v5 = v13++;
    v9 = *v5;
    v12 = __sep;
    while (1)
    {
      v6 = v12++;
      if (*v6 == v9)
        break;
      if (!*v6)
        goto LABEL_11;
    }
    if (v9)
      *(v13 - 1) = 0;
    else
      v13 = 0;
    *__lasts = v13;
    return v10;
  }
  else
  {
    *__lasts = 0;
    return 0;
  }
}

char *__cdecl strtok(char *__str, const char *__sep)
{
  return strtok_r(__str, __sep, &strtok_last);
}

size_t strxfrm_l(char *a1, const char *a2, size_t a3, locale_t a4)
{
  int *v4;
  _BYTE *v5;
  char *v6;
  _BYTE *v7;
  char *v8;
  int *v9;
  _BYTE *v10;
  char *v11;
  int v13;
  _BYTE *v14;
  _BYTE *v15;
  _BYTE v16[4];
  int v17;
  __int32 *v18;
  int v19;
  void *v20;
  size_t v21;
  locale_t v22;
  size_t v23;
  char *v24;
  char *v25;
  __int32 *v27;
  __int32 *v28;

  v25 = a1;
  v24 = (char *)a2;
  v23 = a3;
  v22 = a4;
  v21 = 0;
  v20 = 0;
  _platform_memset(&v27, 0, 80);
  v19 = 0;
  if (*v24 || !v25)
  {
    if (v22)
    {
      if (v22 == (locale_t)-1)
        v22 = (locale_t)__global_locale;
    }
    else
    {
      v22 = (locale_t)&__c_locale;
    }
    if (!*(_BYTE *)(*((_QWORD *)v22 + 165) + 64) && (v20 = __collate_mbstowcs(v24, v22)) != 0)
    {
      __collate_xfrm((const __int32 *)v20, (uint64_t)&v27, (uint64_t)v22);
      v21 = 4 * wcslen(v27);
      if (v28)
        v21 += 4 * (wcslen(v28) + 1);
      if (v23)
      {
        v18 = v27;
        v17 = 0;
        v14 = 0;
        while (v23 > 1)
        {
          if (!v17)
          {
            if (!*v18)
              break;
            v14 = v16;
            v4 = v18++;
            xfrm(v16, *v4);
            v17 = 4;
          }
          v5 = v14++;
          LOBYTE(v5) = *v5;
          v6 = v25++;
          *v6 = (char)v5;
          --v17;
          --v23;
        }
        v18 = v28;
        if (v28)
        {
          v15 = v16;
          xfrm(v16, 0);
          v17 = 4;
          while (v23 > 1 && v17)
          {
            v7 = v15++;
            LOBYTE(v7) = *v7;
            v8 = v25++;
            *v8 = (char)v7;
            --v17;
            --v23;
          }
          v17 = 0;
          while (v23 > 1)
          {
            if (!v17)
            {
              if (!*v18)
                break;
              v15 = v16;
              v9 = v18++;
              xfrm(v16, *v9);
              v17 = 4;
            }
            v10 = v15++;
            LOBYTE(v10) = *v10;
            v11 = v25++;
            *v11 = (char)v10;
            --v17;
            --v23;
          }
        }
        *v25 = 0;
      }
      v19 = *__error();
      free(v20);
      free(v27);
      free(v28);
      v13 = v19;
      *__error() = v13;
      return v21;
    }
    else
    {
      return _platform_strlcpy(v25, v24, v23);
    }
  }
  else
  {
    if (v23)
      *v25 = 0;
    return 0;
  }
}

_BYTE *xfrm(_BYTE *result, int a2)
{
  result[3] = (a2 & 0x3F) + 48;
  result[2] = ((a2 >> 6) & 0x3F) + 48;
  result[1] = ((a2 >> 12) & 0x3F) + 48;
  *result = ((a2 >> 18) & 0x3F) + 48;
  return result;
}

size_t strxfrm(char *__s1, const char *__s2, size_t __n)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strxfrm_l(__s1, __s2, __n, v9);
  else
    return strxfrm_l(__s1, __s2, __n, (locale_t)__global_locale);
}

void swab(const void *a1, void *a2, ssize_t a3)
{
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  int i;
  int j;
  char v11;
  char v12;
  char v13;
  char v14;
  char v15;
  char v16;
  char v17;
  char v18;
  char v19;

  if (a3 > 0)
  {
    for (i = a3 >> 1; (i & 7) != 0; --i)
    {
      v11 = *(_BYTE *)a1;
      v3 = (char *)a1 + 1;
      a1 = (char *)a1 + 2;
      *(_BYTE *)a2 = *v3;
      v4 = (char *)a2 + 1;
      a2 = (char *)a2 + 2;
      *v4 = v11;
    }
    for (j = i >> 3; j > 0; --j)
    {
      v12 = *(_BYTE *)a1;
      *(_BYTE *)a2 = *((_BYTE *)a1 + 1);
      *((_BYTE *)a2 + 1) = v12;
      v13 = *((_BYTE *)a1 + 2);
      *((_BYTE *)a2 + 2) = *((_BYTE *)a1 + 3);
      *((_BYTE *)a2 + 3) = v13;
      v14 = *((_BYTE *)a1 + 4);
      *((_BYTE *)a2 + 4) = *((_BYTE *)a1 + 5);
      *((_BYTE *)a2 + 5) = v14;
      v15 = *((_BYTE *)a1 + 6);
      *((_BYTE *)a2 + 6) = *((_BYTE *)a1 + 7);
      *((_BYTE *)a2 + 7) = v15;
      v16 = *((_BYTE *)a1 + 8);
      *((_BYTE *)a2 + 8) = *((_BYTE *)a1 + 9);
      *((_BYTE *)a2 + 9) = v16;
      v17 = *((_BYTE *)a1 + 10);
      *((_BYTE *)a2 + 10) = *((_BYTE *)a1 + 11);
      *((_BYTE *)a2 + 11) = v17;
      v18 = *((_BYTE *)a1 + 12);
      *((_BYTE *)a2 + 12) = *((_BYTE *)a1 + 13);
      *((_BYTE *)a2 + 13) = v18;
      v19 = *((_BYTE *)a1 + 14);
      v5 = (char *)a1 + 15;
      a1 = (char *)a1 + 16;
      *((_BYTE *)a2 + 14) = *v5;
      v6 = (char *)a2 + 15;
      a2 = (char *)a2 + 16;
      *v6 = v19;
    }
  }
}

__int32 *__cdecl wcpcpy(__int32 *a1, const __int32 *a2)
{
  __int32 v2;

  while (1)
  {
    v2 = *a2;
    *a1 = *a2;
    if (!v2)
      break;
    ++a2;
    ++a1;
  }
  return a1;
}

__int32 *__cdecl wcpncpy(__int32 *a1, const __int32 *a2, size_t a3)
{
  __int32 v4;
  __int32 *v7;

  while (1)
  {
    if (!a3--)
      return a1;
    v4 = *a2;
    *a1 = *a2;
    if (!v4)
      break;
    ++a1;
    ++a2;
  }
  v7 = a1;
  while (a3--)
    *++a1 = 0;
  return v7;
}

int wcscasecmp_l(const __int32 *a1, const __int32 *a2, locale_t a3)
{
  wint_t v4;
  wint_t v5;

  while (*a1)
  {
    v5 = towlower_l(*a1, a3);
    v4 = towlower_l(*a2, a3);
    if (v5 != v4)
      return v5 - v4;
    ++a1;
    ++a2;
  }
  return -*a2;
}

int wcscasecmp(const __int32 *a1, const __int32 *a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return wcscasecmp_l(a1, a2, v7);
  else
    return wcscasecmp_l(a1, a2, (locale_t)__global_locale);
}

__int32 *__cdecl wcscat(__int32 *result, const __int32 *a2)
{
  const __int32 *v2;
  __int32 *v3;
  __int32 *i;

  for (i = result; *i; ++i)
    ;
  do
  {
    v2 = a2++;
    LODWORD(v2) = *v2;
    v3 = i++;
    *v3 = (int)v2;
  }
  while ((_DWORD)v2);
  return result;
}

__int32 *__cdecl wcschr(const __int32 *a1, __int32 a2)
{
  BOOL v3;

  while (1)
  {
    v3 = 0;
    if (*a1 != a2)
      v3 = *a1 != 0;
    if (!v3)
      break;
    ++a1;
  }
  if (*a1 == a2)
    return (__int32 *)a1;
  else
    return 0;
}

int wcscmp(const __int32 *a1, const __int32 *a2)
{
  const __int32 *v2;
  const __int32 *v3;

  while (1)
  {
    v2 = a2++;
    if (*a1 != *v2)
      break;
    v3 = a1++;
    if (!*v3)
      return 0;
  }
  return *a1 - *(a2 - 1);
}

int wcscoll_l(const __int32 *a1, const __int32 *a2, locale_t a3)
{
  __int32 *v3;
  __int32 *v4;
  __int32 *v5;
  __int32 *v6;
  __int32 *v7;
  __int32 *v8;
  int v10;
  BOOL v11;
  BOOL v12;
  BOOL v13;
  __int32 *v14;
  __int32 v15;
  __int32 v16;
  __int32 *j;
  __int32 *k;
  __int32 *v19;
  __int32 *v20;
  int i;
  unsigned __int8 v22;
  unsigned __int8 *v23;
  __int32 *v24;
  __int32 *v25;
  __int32 *v26;
  __int32 *v27;
  const __int32 *v28;
  const __int32 *v29;
  const __int32 *v30;
  const __int32 *v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  _QWORD *v41;
  const __int32 *v42;
  const __int32 *v43;

  v43 = a1;
  v42 = a2;
  v41 = a3;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v34 = 0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  if (a3)
  {
    if (v41 == (_QWORD *)-1)
      v41 = __global_locale;
  }
  else
  {
    v41 = &__c_locale;
  }
  if (*(_BYTE *)(v41[165] + 64))
    return wcscmp(v43, v42);
  v23 = *(unsigned __int8 **)(v41[165] + 88);
  v38 = 1;
  v39 = 1;
  v32 = 0;
  v33 = 0;
  if ((v23[1] & 6) != 0
    || (v23[2] & 6) != 0
    || !*((_DWORD *)v23 + 13) && (*((int *)v23 + 16) > 0 || *((int *)v23 + 17) > 0))
  {
    for (i = 0; i < *v23; ++i)
    {
      v22 = v23[i + 1];
      if (!i || (*((_DWORD *)v23 + 13) & 1) == 0)
      {
        free(v27);
        v27 = __collate_substitute(v43, i, (uint64_t)v41);
        free(v26);
        if (v27)
          v14 = __collate_substitute(v42, i, (uint64_t)v41);
        else
          v14 = 0;
        v26 = v14;
      }
      if ((v22 & 2) != 0)
      {
        if (v27)
          v3 = __collate_wcsdup(v27);
        else
          v3 = __collate_wcsdup(v43);
        v25 = v3;
        v19 = v3;
        for (j = &v3[wcslen(v3) - 1]; v19 < j; --j)
        {
          v15 = *v19;
          v4 = v19++;
          *v4 = *j;
          v5 = j;
          *v5 = v15;
        }
        if (v26)
          v6 = __collate_wcsdup(v26);
        else
          v6 = __collate_wcsdup(v42);
        v24 = v6;
        v20 = v6;
        for (k = &v6[wcslen(v6) - 1]; v20 < k; --k)
        {
          v16 = *v20;
          v7 = v20++;
          *v7 = *k;
          v8 = k;
          *v8 = v16;
        }
        v30 = v25;
        v28 = v24;
      }
      else if (v27)
      {
        v30 = v27;
        v28 = v26;
      }
      else
      {
        v30 = v43;
        v28 = v42;
      }
      if ((v22 & 4) != 0)
      {
        while (1)
        {
          v13 = 0;
          if (*v30)
            v13 = *v28 != 0;
          if (!v13)
            break;
          v36 = 0;
          v37 = 0;
          __collate_lookup_which(v30, &v39, &v37, i, (uint64_t)v41);
          if (v37 <= 0)
          {
            if (v37 < 0)
              goto LABEL_63;
            v37 = 0xFFFFFF;
          }
          __collate_lookup_which(v28, &v38, &v36, i, (uint64_t)v41);
          if (v36 <= 0)
          {
            if (v36 < 0)
              goto LABEL_63;
            v36 = 0xFFFFFF;
          }
          if (v37 != v36)
          {
            v33 = v37 - v36;
            goto LABEL_110;
          }
          v30 += v39;
          v28 += v38;
        }
      }
      else
      {
        while (1)
        {
          v12 = 0;
          if (*v30)
            v12 = *v28 != 0;
          if (!v12)
            break;
          v36 = 0;
          v37 = 0;
          while (*v30)
          {
            __collate_lookup_which(v30, &v39, &v37, i, (uint64_t)v41);
            if (v37 > 0)
              break;
            if (v37 < 0)
            {
LABEL_63:
              *__error() = 22;
              v33 = -1;
              goto LABEL_110;
            }
            v30 += v39;
          }
          while (*v28)
          {
            __collate_lookup_which(v28, &v38, &v36, i, (uint64_t)v41);
            if (v36 > 0)
              break;
            if (v36 < 0)
              goto LABEL_63;
            v28 += v38;
          }
          if (!v37 || !v36)
            break;
          if (v37 != v36)
          {
            v33 = v37 - v36;
            goto LABEL_110;
          }
          v30 += v39;
          v28 += v38;
        }
      }
      if (*v30)
      {
        v33 = *v30;
        goto LABEL_110;
      }
      if (*v28)
      {
        v33 = -*v28;
        goto LABEL_110;
      }
    }
    v33 = 0;
  }
  else
  {
    v27 = __collate_substitute(v43, 0, (uint64_t)v41);
    if (v27)
    {
      v26 = __collate_substitute(v42, 0, (uint64_t)v41);
      v31 = v27;
      v29 = v26;
    }
    else
    {
      v26 = 0;
      v31 = v43;
      v29 = v42;
    }
    while (1)
    {
      v11 = 0;
      if (*v31)
        v11 = *v29 != 0;
      if (!v11)
        break;
      v36 = 0;
      v37 = 0;
      while (*v31)
      {
        __collate_lookup_l(v31, &v39, &v37, &v35, v41);
        if (v37 > 0)
          break;
        if (v37 < 0)
        {
LABEL_87:
          *__error() = 22;
          v33 = -1;
          goto LABEL_110;
        }
        v31 += v39;
      }
      while (*v29)
      {
        __collate_lookup_l(v29, &v38, &v36, &v34, v41);
        if (v36 > 0)
          break;
        if (v36 < 0)
          goto LABEL_87;
        v29 += v38;
      }
      if (!v37 || !v36)
        break;
      if (v37 != v36)
      {
        v33 = v37 - v36;
        goto LABEL_110;
      }
      if (!v32)
        v32 = v35 - v34;
      v31 += v39;
      v29 += v38;
    }
    if (*v31 || !*v29)
    {
      if (!*v31 || *v29)
      {
        if (!*v31 && !*v29)
          v33 = v32;
      }
      else
      {
        v33 = *v31;
      }
    }
    else
    {
      v33 = -*v29;
    }
  }
LABEL_110:
  v40 = *__error();
  free(v27);
  free(v26);
  free(v25);
  free(v24);
  v10 = v40;
  *__error() = v10;
  return v33;
}

int wcscoll(const __int32 *a1, const __int32 *a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return wcscoll_l(a1, a2, v7);
  else
    return wcscoll_l(a1, a2, (locale_t)__global_locale);
}

__int32 *__cdecl wcscpy(__int32 *result, const __int32 *a2)
{
  const __int32 *v2;
  __int32 *v3;
  __int32 *v4;

  v4 = result;
  do
  {
    v2 = a2++;
    LODWORD(v2) = *v2;
    v3 = v4++;
    *v3 = (int)v2;
  }
  while ((_DWORD)v2);
  return result;
}

int wordexp(const char *a1, wordexp_t *a2, int a3)
{
  size_t we_offs;
  size_t we_wordc;
  char **v6;
  char **v7;
  size_t v8;
  size_t i;
  wordexp_t v10;
  int v11;
  int v12;
  wordexp_t *v13;
  char *v14;

  v14 = (char *)a1;
  v13 = a2;
  v12 = a3;
  memset(&v10, 0, sizeof(v10));
  v11 = we_check((char *)a1);
  if (v11)
    return v11;
  v10.we_offs = v13->we_offs;
  if ((v12 & 1) != 0)
  {
    we_wordc = v13->we_wordc;
    if ((v12 & 2) != 0)
      we_offs = v13->we_offs;
    else
      we_offs = 0;
    v8 = we_wordc + we_offs;
    v7 = v13->we_wordv - 2;
    v6 = (char **)malloc_type_malloc(8 * (we_wordc + we_offs + 1) + 16, 91663098);
    if (!v6)
      return 4;
    j___platform_memmove(v6, v7, 8 * (v8 + 1) + 16);
    *v6 = (char *)malloc_type_malloc(v6[1], 1241083701);
    if (!*v6)
    {
      free(v6);
      return 4;
    }
    j___platform_memmove(*v6, *v7, v6[1]);
    for (i = 0; i < v8; ++i)
    {
      if (v6[i + 2])
        v6[i + 2] += *v6 - *v7;
    }
    v10.we_wordc = v13->we_wordc;
    v10.we_wordv = v6 + 2;
  }
  else
  {
    v10.we_wordc = 0;
    v10.we_wordv = 0;
  }
  v11 = we_askshell(v14, &v10.we_wordc, v12);
  if (v11)
  {
    if (v11 == 4)
    {
      if ((v12 & 8) != 0)
        wordfree(v13);
      *v13 = v10;
    }
    else
    {
      wordfree(&v10);
    }
    return v11;
  }
  else
  {
    if ((v12 & 8) != 0)
      wordfree(v13);
    *v13 = v10;
    return 0;
  }
}

uint64_t we_check(char *a1)
{
  char *v1;
  int v2;
  unint64_t v4;

  while (1)
  {
    v1 = a1++;
    v2 = *v1;
    if (!v2)
      break;
    v4 = ((char)v2 - 10);
    if (v4 <= 0x73)
      __asm { BR              X8 }
  }
  return 0;
}

uint64_t we_askshell(char *a1, unint64_t *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char ***v7;
  int v8;
  uint64_t v9;
  uint64_t fully;
  unint64_t v13;
  uint64_t v14;
  unint64_t v16;
  uint64_t v17;
  int v19;
  BOOL v20;
  unint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t NOCANCEL;
  char *v26;
  int v27;
  char *__s1;
  int v29;
  int v30;
  int v31;
  int v32;
  sigset_t v33;
  sigset_t v34;
  sigset_t v35;
  posix_spawnattr_t v36;
  posix_spawn_file_actions_t v37;
  int v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t j;
  uint64_t v42;
  int v43;
  unsigned int v44;
  int v45;
  int v46;
  pid_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t i;
  uint64_t v51;
  uint64_t v52;
  int v53;
  unint64_t *v54;
  char *__s2;
  int v57;
  char v58[1024];
  _BYTE v59[64];
  char *v60[7];
  int v61[2];
  char __str[9];
  char v63[9];
  int v64[2];

  __s2 = a1;
  v54 = a2;
  v53 = a3;
  v52 = 0;
  v51 = 0;
  i = 0;
  v49 = 0;
  v48 = 0;
  v47 = 0;
  v46 = 0;
  v45 = 0;
  v44 = 0;
  v43 = 0;
  v42 = 0;
  j = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v34 = 0;
  v43 = *__error();
  if (pipe(v64) < 0)
    return 4;
  if (pipe(v61) < 0)
  {
    close_NOCANCEL(v64[0]);
    close_NOCANCEL(v64[1]);
    return 4;
  }
  v57 = 20;
  v35 = 0x80000;
  sigprocmask(1, &v35, &v34);
  v38 = posix_spawnattr_init(&v36);
  if (v38)
  {
LABEL_27:
    close_NOCANCEL(v64[0]);
    close_NOCANCEL(v64[1]);
    close_NOCANCEL(v61[0]);
    close_NOCANCEL(v61[1]);
    v23 = v38;
    *__error() = v23;
    return 4;
  }
  v33 = 0;
  v38 = posix_spawnattr_setflags(&v36, 0x4000);
  if (!v38)
  {
    v33 = -1;
    v38 = posix_spawnattr_setsigdefault(&v36, &v33);
    if (!v38)
    {
      v33 = 0;
      v38 = posix_spawnattr_setsigmask(&v36, &v33);
      if (!v38)
      {
        v38 = posix_spawn_file_actions_init(&v37);
        if (!v38)
        {
          j___platform_memmove(v60, &off_D90F8, 56);
          j___platform_memmove(v59, "[ $# -gt 0 ] && export IFS=\"$1\";/usr/lib/system/wordexp-helper ", 64);
          v29 = 1;
          if (v64[1] == 1)
          {
            v38 = posix_spawn_file_actions_addinherit_np(&v37, 1);
            if (v38)
              goto LABEL_25;
          }
          else
          {
            v38 = posix_spawn_file_actions_adddup2(&v37, v64[1], 1);
            if (v38)
              goto LABEL_25;
          }
          if (v61[1] == 2)
          {
            v38 = posix_spawn_file_actions_addinherit_np(&v37, 2);
            if (!v38)
              goto LABEL_18;
          }
          else
          {
            v38 = posix_spawn_file_actions_adddup2(&v37, v61[1], 2);
            if (!v38)
            {
LABEL_18:
              if ((v53 & 0x20) != 0)
              {
                v29 = 2;
                v60[1] = "-u";
              }
              v3 = v29;
              v30 = v29 + 1;
              v60[v3] = "-c";
              v27 = _platform_strlen(__s2) + 64;
              __s1 = (char *)malloc_type_malloc(v27, 1087532273);
              if (__s1)
              {
                _platform_strcpy(__s1, v59);
                strcat(__s1, __s2);
                v4 = v30;
                v31 = v30 + 1;
                v60[v4] = __s1;
                v26 = getenv("IFS");
                if (v26)
                {
                  v5 = v31;
                  v32 = v31 + 1;
                  v60[v5] = "--";
                  v6 = v32;
                  v31 = v32 + 1;
                  v60[v6] = v26;
                }
                v60[v31] = 0;
                v7 = _NSGetEnviron();
                v38 = posix_spawn(&v47, "/bin/sh", &v37, &v36, v60, *v7);
                free(__s1);
              }
              else
              {
                v38 = *__error();
              }
            }
          }
LABEL_25:
          posix_spawn_file_actions_destroy(&v37);
        }
      }
    }
  }
  posix_spawnattr_destroy(&v36);
  if (v38)
    goto LABEL_27;
  close_NOCANCEL(v64[1]);
  close_NOCANCEL(v61[1]);
  if (we_read_fully(v64[0], (uint64_t)__str, 8) == 8 && we_read_fully(v64[0], (uint64_t)v63, 8) == 8)
  {
    v63[8] = 0;
    __str[8] = 0;
    v52 = strtol(__str, 0, 16);
    v9 = strtol(v63, 0, 16);
    v51 = v9 + v52;
    v48 = *v54;
    if ((v53 & 3) == 3)
      v48 += v54[2];
    *v54 += v52;
    if (v54[1])
      v22 = v54[1] - 16;
    else
      v22 = 0;
    if ((v53 & 2) != 0)
      v21 = v54[2];
    else
      v21 = 0;
    v39 = (uint64_t *)malloc_type_realloc(v22, 8 * (*v54 + 1 + v21) + 16, 3716181451);
    if (!v39)
    {
      v44 = 4;
      goto LABEL_64;
    }
    if (!v54[1])
    {
      *v39 = 0;
      v39[1] = 0;
    }
    v49 = v39[1];
    v39[1] += v51;
    v54[1] = (unint64_t)(v39 + 2);
    v40 = malloc_type_realloc(*v39, v39[1], 195637404);
    if (!v40)
    {
      v44 = 4;
      goto LABEL_64;
    }
    for (i = 0; i < v48; ++i)
    {
      if (*(_QWORD *)(v54[1] + 8 * i))
        *(_QWORD *)(v54[1] + 8 * i) += v40 - *v39;
    }
    *v39 = v40;
    fully = we_read_fully(v64[0], *v39 + v49, v51);
    if (fully == v51)
    {
      NOCANCEL = read_NOCANCEL(v61[0], v58, 1023);
      if (NOCANCEL <= 0)
      {
        if (NOCANCEL < 0)
        {
          v43 = *__error();
          v44 = 4;
          goto LABEL_64;
        }
      }
      else
      {
        v58[NOCANCEL] = 0;
        if ((v53 & 0x10) != 0)
          fputs(v58, __stderrp);
      }
      v44 = 0;
      goto LABEL_64;
    }
    if ((v53 & 0x20) != 0)
      v8 = 2;
    else
      v8 = 6;
  }
  else if ((v53 & 0x20) != 0)
  {
    v8 = 2;
  }
  else
  {
    v8 = 6;
  }
  v44 = v8;
  v43 = *__error();
LABEL_64:
  close_NOCANCEL(v64[0]);
  close_NOCANCEL(v61[0]);
  do
  {
    v46 = waitpid_NOCANCEL(v47, (uint64_t)&v45, 0);
    v20 = 0;
    if (v46 < 0)
      v20 = *__error() == 4;
  }
  while (v20);
  sigprocmask(3, &v34, 0);
  if (v44)
  {
    v19 = v43;
    *__error() = v19;
    return v44;
  }
  else if (v46 < 0 || (v45 & 0x7F) != 0 || BYTE1(v45))
  {
    if ((v53 & 0x20) != 0)
      return 2;
    else
      return 6;
  }
  else
  {
    v24 = _platform_strstr(v58, "command substitution");
    if (v24 && _platform_strstr(v24 + 20, "syntax error"))
    {
      if (_platform_strstr(v58, " unbound variable"))
        return 2;
      else
        return 6;
    }
    else
    {
      if (!v48 && (v53 & 2) != 0)
      {
        while (v48 < v54[2])
        {
          v13 = v54[1];
          v14 = v48++;
          *(_QWORD *)(v13 + 8 * v14) = 0;
        }
      }
      for (j = *v39 + v49; v52--; j = v42 + 1)
      {
        v16 = v54[1];
        v17 = v48++;
        *(_QWORD *)(v16 + 8 * v17) = j;
        v42 = _platform_memchr(j, 0, v51);
        if (!v42)
          return 4;
        v51 -= v42 - j + 1;
      }
      *(_QWORD *)(v54[1] + 8 * v48) = 0;
      return 0;
    }
  }
}

void wordfree(wordexp_t *a1)
{
  if (a1)
  {
    if (a1->we_wordv)
    {
      free(*((void **)a1->we_wordv - 2));
      free(a1->we_wordv - 2);
    }
    a1->we_wordv = 0;
    a1->we_wordc = 0;
  }
}

uint64_t we_read_fully(unsigned int a1, uint64_t a2, uint64_t a3)
{
  uint64_t NOCANCEL;
  uint64_t v5;

  v5 = 0;
  do
  {
    NOCANCEL = read_NOCANCEL(a1, a2 + v5, a3 - v5);
    if (NOCANCEL != -1 || *__error() != 4)
    {
      if (NOCANCEL <= 0)
        return v5;
      v5 += NOCANCEL;
    }
  }
  while (v5 != a3);
  return v5;
}

size_t wcscspn(const __int32 *a1, const __int32 *a2)
{
  const __int32 *j;
  const __int32 *i;

  for (i = a1; *i; ++i)
  {
    for (j = a2; *j; ++j)
    {
      if (*i == *j)
        return i - a1;
    }
  }
  return i - a1;
}

__int32 *__cdecl wcsdup(const __int32 *a1)
{
  size_t v2;
  __int32 *v3;

  v2 = wcslen(a1) + 1;
  v3 = (__int32 *)malloc_type_malloc(4 * v2, 0x100004052888210);
  if (v3)
    return wmemcpy(v3, a1, v2);
  else
    return 0;
}

size_t wcslcat(__int32 *a1, const __int32 *a2, size_t a3)
{
  size_t v3;
  __int32 *v4;
  BOOL v6;
  uint64_t v7;
  size_t v8;
  size_t v9;
  __int32 *v10;
  __int32 *v11;

  v11 = a1;
  v10 = (__int32 *)a2;
  v8 = a3;
  while (1)
  {
    v6 = 0;
    if (*v11)
    {
      v3 = v8--;
      v6 = v3 != 0;
    }
    if (!v6)
      break;
    ++v11;
  }
  v7 = v11 - a1;
  v9 = a3 - v7;
  if (a3 == v7)
    return v7 + wcslen(a2);
  while (*v10)
  {
    if (v9 != 1)
    {
      v4 = v11++;
      *v4 = *v10;
      --v9;
    }
    ++v10;
  }
  *v11 = 0;
  return v7 + v10 - a2;
}

size_t wcslcpy(__int32 *a1, const __int32 *a2, size_t a3)
{
  const __int32 *v3;
  __int32 *v4;
  const __int32 *v5;
  size_t v7;
  const __int32 *v8;

  v8 = a2;
  v7 = a3;
  if (a3)
  {
    v7 = a3 - 1;
    if (a3 != 1)
    {
      do
      {
        v3 = v8++;
        LODWORD(v3) = *v3;
        v4 = a1++;
        *v4 = (int)v3;
        if (!(_DWORD)v3)
          break;
        --v7;
      }
      while (v7);
    }
  }
  if (!v7)
  {
    if (a3)
      *a1 = 0;
    do
      v5 = v8++;
    while (*v5);
  }
  return v8 - a2 - 1;
}

size_t wcslen(const __int32 *a1)
{
  const __int32 *i;

  for (i = a1; *i; ++i)
    ;
  return i - a1;
}

int wcsncasecmp_l(const __int32 *a1, const __int32 *a2, size_t n, locale_t a4)
{
  wint_t v5;
  wint_t v6;
  size_t v8;

  v8 = n;
  if (!n)
    return 0;
  while (*a1)
  {
    v6 = towlower_l(*a1, a4);
    v5 = towlower_l(*a2, a4);
    if (v6 != v5)
      return v6 - v5;
    if (!--v8)
      return 0;
    ++a1;
    ++a2;
  }
  return -*a2;
}

int wcsncasecmp(const __int32 *a1, const __int32 *a2, size_t n)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcsncasecmp_l(a1, a2, n, v9);
  else
    return wcsncasecmp_l(a1, a2, n, (locale_t)__global_locale);
}

__int32 *__cdecl wcsncat(__int32 *result, const __int32 *a2, size_t a3)
{
  const __int32 *v3;
  __int32 *v4;
  BOOL v5;
  __int32 *j;
  __int32 *i;

  for (i = result; *i; ++i)
    ;
  for (j = i; ; ++j)
  {
    v5 = 0;
    if (*a2)
      v5 = a3 != 0;
    if (!v5)
      break;
    v3 = a2++;
    v4 = j;
    *v4 = *v3;
    --a3;
  }
  *j = 0;
  return result;
}

int wcsncmp(const __int32 *a1, const __int32 *a2, size_t a3)
{
  const __int32 *v3;
  const __int32 *v4;
  size_t v6;

  v6 = a3;
  if (!a3)
    return 0;
  do
  {
    v3 = a2++;
    if (*a1 != *v3)
      return *a1 - *(a2 - 1);
    v4 = a1++;
    if (!*v4)
      break;
    --v6;
  }
  while (v6);
  return 0;
}

__int32 *__cdecl wcsncpy(__int32 *result, const __int32 *a2, size_t a3)
{
  const __int32 *v3;
  __int32 *v4;
  __int32 *v5;
  __int32 *v7;
  size_t v8;

  v8 = a3;
  if (a3)
  {
    v7 = result;
    while (1)
    {
      v3 = a2++;
      LODWORD(v3) = *v3;
      v4 = v7++;
      *v4 = (int)v3;
      if (!(_DWORD)v3)
        break;
      if (!--v8)
        return result;
    }
    while (--v8)
    {
      v5 = v7++;
      *v5 = 0;
    }
  }
  return result;
}

size_t wcsnlen(const __int32 *a1, size_t a2)
{
  size_t i;

  for (i = 0; i < a2 && *a1; ++i)
    ++a1;
  return i;
}

__int32 *__cdecl wcspbrk(const __int32 *a1, const __int32 *a2)
{
  const __int32 *i;

  while (*a1)
  {
    for (i = a2; *i; ++i)
    {
      if (*a1 == *i)
        return (__int32 *)a1;
    }
    ++a1;
  }
  return 0;
}

__int32 *__cdecl wcsrchr(const __int32 *a1, __int32 a2)
{
  __int32 *v3;

  v3 = 0;
  while (1)
  {
    if (*a1 == a2)
      v3 = (__int32 *)a1;
    if (!*a1)
      break;
    ++a1;
  }
  return v3;
}

size_t wcsspn(const __int32 *a1, const __int32 *a2)
{
  const __int32 *j;
  const __int32 *i;

  for (i = a1; *i; ++i)
  {
    for (j = a2; *j && *i != *j; ++j)
      ;
    if (!*j)
      break;
  }
  return i - a1;
}

FILE *__cdecl fmemopen(void *__buf, size_t __size, const char *__mode)
{
  void *v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  int (__cdecl *v7)(void *, char *, int);
  int v9;
  int v10;
  FILE *v11;
  void *v12;
  char *v13;
  size_t v14;
  void *v15;

  v15 = __buf;
  v14 = __size;
  v13 = (char *)__mode;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  if (!__size)
  {
    *__error() = 22;
    return 0;
  }
  if (!__sflags(v13, &v10) || (v10 & 2) == 0 && !v15)
  {
    *__error() = 22;
    return 0;
  }
  v12 = (void *)malloc_type_malloc(40, 0x10100402BFFC1BCLL);
  if (!v12)
    return 0;
  *((_QWORD *)v12 + 4) = 0;
  *((_QWORD *)v12 + 2) = v14;
  v3 = v15;
  *(_QWORD *)v12 = v15;
  *((_BYTE *)v12 + 8) = v3 == 0;
  if ((*((_BYTE *)v12 + 8) & 1) != 0)
  {
    v4 = malloc_type_malloc(v14, 278942673);
    *(_QWORD *)v12 = v4;
    if (!*(_QWORD *)v12)
    {
LABEL_11:
      free(v12);
      return 0;
    }
  }
  if ((*((_BYTE *)v12 + 8) & 1) != 0 || *v13 == 119)
    **(_BYTE **)v12 = 0;
  v5 = _platform_strchr(v13, 98) != 0;
  *((_BYTE *)v12 + 9) = v5;
  v9 = *v13;
  switch(v9)
  {
    case 'a':
      v6 = _platform_strnlen(*(_QWORD *)v12, *((_QWORD *)v12 + 2));
      *((_QWORD *)v12 + 3) = v6;
      *((_QWORD *)v12 + 4) = v6;
      break;
    case 'r':
      *((_QWORD *)v12 + 3) = v14;
      break;
    case 'w':
      *((_QWORD *)v12 + 3) = 0;
      break;
  }
  if ((v10 & 1) != 0)
    v7 = 0;
  else
    v7 = (int (__cdecl *)(void *, char *, int))fmemopen_read;
  v11 = funopen(v12, v7, (int (__cdecl *)(void *, const char *, int))fmemopen_write, (fpos_t (__cdecl *)(void *, fpos_t, int))fmemopen_seek, (int (__cdecl *)(void *))fmemopen_close);
  if (!v11)
  {
    if ((*((_BYTE *)v12 + 8) & 1) != 0)
      free(*(void **)v12);
    goto LABEL_11;
  }
  if (*v13 == 97)
    v11->_flags |= 0x100u;
  setvbuf(v11, 0, 2, 0);
  return v11;
}

uint64_t fmemopen_read(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  unsigned int v5;

  v5 = a3;
  if ((unint64_t)(int)a3 > a1[3] - a1[4])
    v5 = a1[3] - a1[4];
  if (v5)
  {
    j___platform_memmove(a2, *a1 + a1[4], (int)v5);
    a1[4] += (int)v5;
    return v5;
  }
  else
  {
    return 0;
  }
}

uint64_t fmemopen_write(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v5;

  v5 = a3;
  if ((unint64_t)(int)a3 > *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 32))
    v5 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 32);
  if (v5)
  {
    j___platform_memmove(*(_QWORD *)a1 + *(_QWORD *)(a1 + 32), a2, (int)v5);
    *(_QWORD *)(a1 + 32) += (int)v5;
    if (*(_QWORD *)(a1 + 32) > *(_QWORD *)(a1 + 24))
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 32);
    if (!*(_BYTE *)(a1 + 9)
      && *(_QWORD *)(a1 + 32) < *(_QWORD *)(a1 + 16)
      && *(_BYTE *)(*(_QWORD *)a1 + *(_QWORD *)(a1 + 32) - 1))
    {
      *(_BYTE *)(*(_QWORD *)a1 + *(_QWORD *)(a1 + 32)) = 0;
    }
    return v5;
  }
  else
  {
    return 0;
  }
}

uint64_t fmemopen_seek(_QWORD *a1, uint64_t a2, int a3)
{
  if (a3)
  {
    if (a3 != 1)
    {
      if (a3 != 2 || a2 > 0 || (unint64_t)-a2 > a1[3])
        goto LABEL_4;
      a1[4] = a1[3] + a2;
      return a1[4];
    }
    if ((unint64_t)(a1[4] + a2) <= a1[2])
    {
      a1[4] += a2;
      return a1[4];
    }
  }
  else if ((unint64_t)a2 <= a1[2])
  {
    a1[4] = a2;
    return a1[4];
  }
LABEL_4:
  *__error() = 22;
  return -1;
}

uint64_t fmemopen_close(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 8) & 1) != 0)
    free(*(void **)a1);
  free((void *)a1);
  return 0;
}

__int32 *__cdecl wcsstr(const __int32 *a1, const __int32 *a2)
{
  const __int32 *v2;
  size_t v4;
  __int32 v5;
  __int32 *v6;

  v6 = (__int32 *)(a2 + 1);
  v5 = *a2;
  if (*a2)
  {
    v4 = wcslen(v6);
    do
    {
      v2 = a1++;
      if (!*v2)
        return 0;
    }
    while (*v2 != v5 || wcsncmp(a1, v6, v4));
    --a1;
  }
  return (__int32 *)a1;
}

__int32 *__cdecl wcstok(__int32 *a1, const __int32 *a2, __int32 **a3)
{
  __int32 *v3;
  const __int32 *v4;
  __int32 *v5;
  const __int32 *v6;
  __int32 v8;
  __int32 v9;
  __int32 *v10;
  const __int32 *v11;
  const __int32 *v12;
  __int32 *v13;

  v13 = a1;
  if (!a1)
  {
    v13 = *a3;
    if (!*a3)
      return 0;
  }
LABEL_4:
  v3 = v13++;
  v8 = *v3;
  v11 = a2;
  while (1)
  {
    v4 = v11++;
    if (!*v4)
      break;
    if (v8 == *v4)
      goto LABEL_4;
  }
  if (v8)
  {
    v10 = v13 - 1;
LABEL_11:
    v5 = v13++;
    v9 = *v5;
    v12 = a2;
    while (1)
    {
      v6 = v12++;
      if (*v6 == v9)
        break;
      if (!*v6)
        goto LABEL_11;
    }
    if (v9)
      *(v13 - 1) = 0;
    else
      v13 = 0;
    *a3 = v13;
    return v10;
  }
  else
  {
    *a3 = 0;
    return 0;
  }
}

int wcswidth_l(const __int32 *a1, size_t a2, locale_t a3)
{
  size_t v3;
  __int32 *v4;
  BOOL v6;
  int v7;
  int i;
  __int32 v9;
  _xlocale *v10;

  v10 = a3;
  v9 = 0;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v10 = (_xlocale *)__global_locale;
  }
  else
  {
    v10 = (_xlocale *)__c_locale;
  }
  for (i = 0; ; i += v7)
  {
    v3 = a2--;
    v6 = 0;
    if (v3)
    {
      v4 = (__int32 *)a1++;
      v9 = *v4;
      v6 = *v4 != 0;
    }
    if (!v6)
      break;
    v7 = wcwidth_l(v9, v10);
    if (v7 < 0)
      return -1;
  }
  return i;
}

int wcswidth(const __int32 *a1, size_t a2)
{
  char v2;
  char v3;
  _xlocale *v7;
  uint64_t v8;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    v7 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v8 = __locale_key;
    v7 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v8);
  }
  if (v7)
    return wcswidth_l(a1, a2, v7);
  else
    return wcswidth_l(a1, a2, (locale_t)__global_locale);
}

size_t wcsxfrm_l(__int32 *a1, const __int32 *a2, size_t a3, locale_t a4)
{
  _DWORD *v4;
  __int32 *v5;
  __int32 *v6;
  _DWORD *v7;
  __int32 *v8;
  _DWORD *v10;
  _DWORD *v11;
  int v12;
  size_t v13;
  size_t v14;
  void *v20;
  void *v21;

  _platform_memset(&v20, 0, 80);
  if (*a2)
  {
    if (a4)
    {
      if (a4 == (locale_t)-1)
        a4 = (locale_t)__global_locale;
    }
    else
    {
      a4 = (locale_t)__c_locale;
    }
    if (*(_BYTE *)(*((_QWORD *)a4 + 165) + 64))
    {
      v13 = wcslen(a2);
      if (a3)
      {
        if (v13 >= a3)
        {
          wcsncpy(a1, a2, a3 - 1);
          a1[a3 - 1] = 0;
        }
        else
        {
          wcscpy(a1, a2);
        }
      }
      return v13;
    }
    else
    {
      __collate_xfrm(a2, (uint64_t)&v20, (uint64_t)a4);
      v14 = wcslen((const __int32 *)v20);
      if (v21)
        v14 += wcslen((const __int32 *)v21) + 1;
      if (a3)
      {
        v10 = v20;
        while (a3 > 1 && *v10)
        {
          v4 = v10++;
          v5 = a1++;
          *v5 = *v4 + 1;
          --a3;
        }
        v11 = v21;
        if (v21)
        {
          if (a3 > 1)
          {
            v6 = a1++;
            *v6 = 1;
          }
          while (a3 > 1 && *v11)
          {
            v7 = v11++;
            v8 = a1++;
            *v8 = *v7 + 1;
            --a3;
          }
        }
        *a1 = 0;
      }
      v12 = *__error();
      free(v20);
      free(v21);
      *__error() = v12;
      return v14;
    }
  }
  else
  {
    if (a3)
      *a1 = 0;
    return 0;
  }
}

size_t wcsxfrm(__int32 *a1, const __int32 *a2, size_t a3)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return wcsxfrm_l(a1, a2, a3, v9);
  else
    return wcsxfrm_l(a1, a2, a3, (locale_t)__global_locale);
}

__int32 *__cdecl wmemchr(const __int32 *a1, __int32 a2, size_t a3)
{
  size_t i;

  for (i = 0; i < a3; ++i)
  {
    if (*a1 == a2)
      return (__int32 *)a1;
    ++a1;
  }
  return 0;
}

int wmemcmp(const __int32 *a1, const __int32 *a2, size_t a3)
{
  size_t i;

  for (i = 0; ; ++i)
  {
    if (i >= a3)
      return 0;
    if (*a1 != *a2)
      break;
    ++a1;
    ++a2;
  }
  if (*a1 > *a2)
    return 1;
  else
    return -1;
}

__int32 *__cdecl wmemcpy(__int32 *a1, const __int32 *a2, size_t a3)
{
  j___platform_memmove(a1, a2, 4 * a3);
  return a1;
}

__int32 *__cdecl wmemmove(__int32 *a1, const __int32 *a2, size_t a3)
{
  _platform_memmove(a1, a2, 4 * a3);
  return a1;
}

__int32 *__cdecl wmemset(__int32 *result, __int32 a2, size_t a3)
{
  __int32 *v3;
  size_t i;

  v3 = result;
  for (i = 0; i < a3; ++i)
    *v3++ = a2;
  return result;
}

const char *regatoi(uint64_t a1, char *a2)
{
  _QWORD *i;

  for (i = &rerrs; *(_DWORD *)i && _platform_strcmp(i[1], *(_QWORD *)(a1 + 16)); i += 3)
    ;
  if (!*(_DWORD *)i)
    return "0";
  sprintf(a2, "%d", *(_DWORD *)i);
  return a2;
}

uint64_t _UTF2_init(uint64_t a1)
{
  *(_QWORD *)(a1 + 72) = _UTF2_mbrtowc;
  *(_QWORD *)(a1 + 96) = _UTF2_wcrtomb;
  *(_QWORD *)(a1 + 80) = _UTF2_mbsinit;
  *(_QWORD *)(a1 + 88) = _UTF2_mbsnrtowcs;
  *(_QWORD *)(a1 + 104) = _UTF2_wcsnrtombs;
  *(_DWORD *)(a1 + 64) = 3;
  *(_DWORD *)(a1 + 68) = 128;
  return 0;
}

uint64_t _UTF2_mbrtowc(int *a1, unsigned __int8 *a2, unint64_t a3, int *a4)
{
  unsigned __int8 *v4;
  unsigned __int8 *v5;
  unint64_t v8;
  int v9;
  int v10;
  int v11;
  char v12;
  int i;
  int v14;
  char v15;
  unsigned __int8 *v17;

  v17 = a2;
  v12 = 0;
  if (a4[1] > 6)
  {
    *__error() = 22;
    return -1;
  }
  if (!a2)
  {
    v17 = (unsigned __int8 *)&unk_D495D;
    a3 = 1;
    a1 = 0;
  }
  if (!a3)
    return -2;
  if (!a4[1])
  {
    v14 = *v17;
    if ((v14 & 0xFFFFFF80) == 0)
    {
      if (a1)
        *a1 = v14;
      return v14 != 0;
    }
  }
  if (a4[1])
  {
    v11 = a4[1];
    v10 = a4[2];
  }
  else
  {
    v15 = *v17;
    if ((*v17 & 0x80u) != 0)
    {
      if ((v15 & 0xE0) == 0xC0)
      {
        v12 = 31;
        v11 = 2;
        v10 = 128;
      }
      else
      {
        if ((v15 & 0xF0) != 0xE0)
          goto LABEL_34;
        v12 = 15;
        v11 = 3;
        v10 = 2048;
      }
    }
    else
    {
      v12 = 127;
      v11 = 1;
      v10 = 0;
    }
  }
  if (a4[1])
  {
    v9 = *a4;
  }
  else
  {
    v4 = v17++;
    v9 = (*v4 & v12);
  }
  for (i = a4[1] == 0; ; ++i)
  {
    v8 = v11 >= a3 ? a3 : v11;
    if (i >= v8)
      break;
    if ((*v17 & 0xC0) != 0x80)
      goto LABEL_34;
    v5 = v17++;
    v9 = (v9 << 6) | *v5 & 0x3F;
  }
  if (i < v11)
  {
    a4[1] = v11 - i;
    a4[2] = v10;
    *a4 = v9;
    return -2;
  }
  if (v9 < v10)
  {
LABEL_34:
    *__error() = 92;
    return -1;
  }
  if (a1)
    *a1 = v9;
  a4[1] = 0;
  if (v9)
    return v11;
  else
    return 0;
}

uint64_t _UTF2_wcrtomb(_BYTE *a1, int a2, uint64_t a3)
{
  int v4;
  int i;
  char v6;
  int v7;

  v7 = a2;
  if (*(_DWORD *)(a3 + 4))
  {
    *__error() = 22;
    return -1;
  }
  else if (a1)
  {
    if ((a2 & 0xFFFFFF80) != 0)
    {
      if ((a2 & 0xFFFFF800) != 0)
      {
        if ((a2 & 0xFFFF0000) != 0)
        {
          *__error() = 92;
          return -1;
        }
        v6 = -32;
        v4 = 3;
      }
      else
      {
        v6 = -64;
        v4 = 2;
      }
      for (i = v4 - 1; i > 0; --i)
      {
        a1[i] = v7 & 0x3F | 0x80;
        v7 >>= 6;
      }
      *a1 = v7 | v6;
      return v4;
    }
    else
    {
      *a1 = a2;
      return 1;
    }
  }
  else
  {
    return 1;
  }
}

BOOL _UTF2_mbsinit(uint64_t a1)
{
  BOOL v2;

  v2 = 1;
  if (a1)
    return *(_DWORD *)(a1 + 4) == 0;
  return v2;
}

uint64_t _UTF2_mbsnrtowcs(int *a1, unsigned __int8 **a2, unint64_t a3, uint64_t a4, int *a5, uint64_t a6)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unsigned __int8 *v12;
  int *v13;
  uint64_t v14;
  int *v15;
  uint64_t v16;
  unint64_t v17;
  unsigned __int8 **v18;
  int *v19;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = a6;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  v13 = a5;
  v12 = *a2;
  v11 = 0;
  if (a1)
  {
    if (!v17 || !v16 || v13[1] <= 0 || (char)*v12 <= 0)
    {
      while (1)
      {
        if (!v16--)
        {
          *v18 = v12;
          return v11;
        }
        if (v17 && (char)*v12 > 0)
        {
          *v19 = (char)*v12;
          v9 = 1;
        }
        else
        {
          v9 = _UTF2_mbrtowc(v19, v12, v17, v15);
          switch(v9)
          {
            case -1:
              *v18 = v12;
              return -1;
            case -2:
              *v18 = &v12[v17];
              return v11;
            case 0:
              *v18 = 0;
              return v11;
          }
        }
        v12 += v9;
        v17 -= v9;
        ++v11;
        ++v19;
      }
    }
  }
  else if (!v17 || v13[1] <= 0 || (char)*v12 <= 0)
  {
    while (1)
    {
      if (v17 && (char)*v12 > 0)
      {
        v8 = 1;
      }
      else
      {
        v8 = _UTF2_mbrtowc(&v10, v12, v17, v15);
        if (v8 == -1)
          return -1;
        if (!v8 || v8 == -2)
          return v11;
      }
      v12 += v8;
      v17 -= v8;
      ++v11;
    }
  }
  *__error() = 92;
  return -1;
}

uint64_t _UTF2_wcsnrtombs(_BYTE *a1, int **a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  BOOL v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  int *v13;
  _BYTE v14[6];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int **v20;
  _BYTE *v21;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = a5;
  v16 = a6;
  v15 = a5;
  if (*(_DWORD *)(a5 + 4))
  {
    *__error() = 22;
    return -1;
  }
  else
  {
    v13 = *v20;
    v12 = 0;
    if (v21)
    {
      while (1)
      {
        v9 = 0;
        if (v18)
        {
          v7 = v19--;
          v9 = v7 != 0;
        }
        if (!v9)
          break;
        if (*v13 >= 0x80)
        {
          if (v18 <= 3)
          {
            v11 = _UTF2_wcrtomb(v14, *v13, v17);
            if (v11 == -1)
            {
              *v20 = v13;
              return -1;
            }
            if (v11 > (int)v18)
              break;
            j___platform_memmove(v21, v14, v11);
          }
          else
          {
            v11 = _UTF2_wcrtomb(v21, *v13, v17);
            if (v11 == -1)
            {
              *v20 = v13;
              return -1;
            }
          }
        }
        else
        {
          v11 = 1;
          *v21 = *v13;
        }
        if (!*v13)
        {
          *v20 = 0;
          return v12 + v11 - 1;
        }
        ++v13;
        v21 += v11;
        v18 -= v11;
        v12 += v11;
      }
      *v20 = v13;
      return v12;
    }
    else
    {
      while (v19--)
      {
        if (*v13 >= 0x80)
        {
          v10 = _UTF2_wcrtomb(v14, *v13, v17);
          if (v10 == -1)
            return -1;
        }
        else
        {
          v10 = 1;
        }
        if (!*v13)
          return v12 + v10 - 1;
        ++v13;
        v12 += v10;
      }
      return v12;
    }
  }
}

uint64_t __guard_setup(uint64_t *a1)
{
  uint64_t v1;
  uint64_t result;
  uint64_t v3;
  BOOL v4;
  unsigned int v6;

  while (1)
  {
    v4 = 0;
    if (a1)
      v4 = *a1 != 0;
    if (!v4)
      break;
    if (_platform_strstr(*a1, "stack_guard") == *a1)
    {
      __guard_from_kernel(*a1);
      v3 = *a1;
      v1 = _platform_strlen(*a1);
      _platform_bzero(v3, v1);
    }
    ++a1;
  }
  result = open_NOCANCEL("/dev/urandom", 0);
  v6 = result;
  if ((_DWORD)result != -1)
  {
    read_NOCANCEL(result, __stack_chk_guard, 64);
    result = close_NOCANCEL(v6);
  }
  LODWORD(__stack_chk_guard[0]) = -16121856;
  return result;
}

uint64_t __guard_from_kernel(uint64_t a1)
{
  uint64_t result;
  BOOL v2;
  int v3;
  _BYTE *v4;
  char __str[20];
  unint64_t v6;
  uint64_t v7;

  v6 = 0;
  v3 = 0;
  result = _platform_strchr(a1, 61);
  v7 = result;
  if (result)
  {
    ++v7;
    while (1)
    {
      v2 = 0;
      if (v7)
        v2 = v3 < 8;
      if (!v2)
        break;
      _platform_strlcpy(__str, v7, 20);
      v4 = (_BYTE *)_platform_strchr(__str, 44);
      if (v4)
        *v4 = 0;
      v6 = strtoull(__str, 0, 0);
      __stack_chk_guard[v3++] = v6;
      result = _platform_strchr(v7, 44);
      v7 = result;
      if (result)
        ++v7;
    }
  }
  return result;
}

uint64_t a64l(const char *a1)
{
  BOOL v2;
  int i;
  int v4;
  int v5;
  int v6;
  const char *v7;

  v7 = a1;
  if (a1)
  {
    v6 = 0;
    v4 = 0;
    for (i = 0; ; ++i)
    {
      v2 = 0;
      if (*v7)
        v2 = i < 6;
      if (!v2)
        break;
      if (*v7 < 46 || *v7 > 47)
      {
        if (*v7 < 48 || *v7 > 57)
        {
          if (*v7 < 65 || *v7 > 90)
          {
            if (*v7 < 97 || *v7 > 122)
              goto LABEL_2;
            v5 = *v7 - 59;
          }
          else
          {
            v5 = *v7 - 53;
          }
        }
        else
        {
          v5 = *v7 - 46;
        }
      }
      else
      {
        v5 = *v7 - 46;
      }
      v6 |= v5 << v4;
      v4 += 6;
      ++v7;
    }
    return v6;
  }
  else
  {
LABEL_2:
    *__error() = 22;
    return -1;
  }
}

void _Exit(int a1)
{
  _exit(a1);
}

long double abs(long double __x)
{
  return __x;
}

void __atexit_init()
{
  uint64_t v0;

  if (*((_QWORD *)&_os_alloc_once_table + 4) == -1)
    v0 = *((_QWORD *)&_os_alloc_once_table + 5);
  else
    v0 = _os_alloc_once((char *)&_os_alloc_once_table + 32, 1040, 0);
  __atexit = v0;
}

int atexit(void (*a1)(void))
{
  _OWORD v2[2];
  void (*v3)(void);

  v3 = a1;
  *(_QWORD *)&v2[0] = 1;
  *((_QWORD *)&v2[0] + 1) = a1;
  v2[1] = 0uLL;
  return atexit_register(v2);
}

uint64_t atexit_register(_OWORD *a1)
{
  uint64_t v1;
  int *v2;
  uint64_t v4;
  int *v5;

  v5 = (int *)__atexit;
  if (!__atexit)
    __assert_rtn("atexit_register", "atexit.c", 115, "p");
  pthread_mutex_lock(&atexit_mutex);
  while (v5[2] >= 32)
  {
    v4 = __atexit;
    pthread_mutex_unlock(&atexit_mutex);
    v5 = (int *)malloc_type_malloc(1040, 0x10A00403E527AF6);
    if (!v5)
      return -1;
    pthread_mutex_lock(&atexit_mutex);
    if (v4 == __atexit)
    {
      v5[2] = 0;
      *(_QWORD *)v5 = __atexit;
      __atexit = (uint64_t)v5;
    }
    else
    {
      pthread_mutex_unlock(&atexit_mutex);
      free(v5);
      pthread_mutex_lock(&atexit_mutex);
      v5 = (int *)__atexit;
    }
  }
  v1 = v5[2]++;
  v2 = &v5[8 * v1 + 4];
  *(_OWORD *)v2 = *a1;
  *((_OWORD *)v2 + 1) = a1[1];
  __atexit_new_registration = 1;
  pthread_mutex_unlock(&atexit_mutex);
  return 0;
}

int atexit_b(void *a1)
{
  __int128 v2;
  __int128 v3;
  void *v4;

  v4 = a1;
  v2 = 0u;
  v3 = 0u;
  LODWORD(v2) = 3;
  *((_QWORD *)&v2 + 1) = _Block_copy(a1);
  v3 = 0uLL;
  return atexit_register(&v2);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  __int128 v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void (*v9)(void *);

  v9 = lpfunc;
  v8 = obj;
  v7 = lpdso_handle;
  *(_QWORD *)&v4 = 2;
  *((_QWORD *)&v4 + 1) = lpfunc;
  v5 = obj;
  v6 = lpdso_handle;
  return atexit_register(&v4);
}

uint64_t __cxa_finalize_ranges(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  int v4;
  unint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  pthread_mutex_lock(&atexit_mutex);
LABEL_2:
  v8 = __atexit;
LABEL_3:
  if (v8)
  {
    v6 = *(_DWORD *)(v8 + 8);
    while (1)
    {
      do
      {
        if (--v6 < 0)
        {
          v8 = *(_QWORD *)v8;
          goto LABEL_3;
        }
        v7 = v8 + 16 + 32 * v6;
      }
      while (!*(_DWORD *)v7);
      if (a2)
      {
        switch(*(_DWORD *)v7)
        {
          case 2:
            if ((__cxa_in_range(a1, a2, *(_QWORD *)(v7 + 24)) & 1) != 0)
              goto LABEL_16;
            break;
          case 1:
            if ((__cxa_in_range(a1, a2, *(_QWORD *)(v7 + 8)) & 1) != 0)
              goto LABEL_16;
            break;
          case 3:
            v5 = _Block_get_invoke_fn(*(_QWORD *)(v7 + 8));
            if ((__cxa_in_range(a1, a2, v5) & 1) != 0)
              goto LABEL_16;
            break;
          default:
            goto LABEL_16;
        }
      }
      else
      {
LABEL_16:
        v4 = *(_DWORD *)v7;
        *(_DWORD *)v7 = 0;
        __atexit_new_registration = 0;
        v2 = pthread_mutex_unlock(&atexit_mutex);
        switch(v4)
        {
          case 2:
            (*(void (**)(_QWORD))(v7 + 8))(*(_QWORD *)(v7 + 16));
            break;
          case 1:
            (*(void (**)(uint64_t))(v7 + 8))(v2);
            break;
          case 3:
            (*(void (**)(void))(*(_QWORD *)(v7 + 8) + 16))();
            break;
        }
        pthread_mutex_lock(&atexit_mutex);
        if (__atexit_new_registration)
          goto LABEL_2;
      }
    }
  }
  return pthread_mutex_unlock(&atexit_mutex);
}

uint64_t __cxa_in_range(uint64_t a1, unsigned int a2, unint64_t a3)
{
  unsigned int i;
  char v5;

  for (i = 0; i < a2; ++i)
  {
    if (a3 >= *(_QWORD *)(a1 + 16 * i) && a3 < *(_QWORD *)(a1 + 16 * i) + *(_QWORD *)(a1 + 16 * i + 8))
    {
      v5 = 1;
      return v5 & 1;
    }
  }
  v5 = 0;
  return v5 & 1;
}

uint64_t _Block_get_invoke_fn(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

int __cxa_finalize(void *a1)
{
  _QWORD v2[2];
  void *v3;

  v3 = a1;
  if (!a1)
    return __cxa_finalize_ranges(0, 0);
  v2[0] = v3;
  v2[1] = 1;
  return __cxa_finalize_ranges((uint64_t)v2, 1u);
}

double atof(const char *a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return strtod_l(a1, 0, v5);
  else
    return strtod_l(a1, 0, (locale_t)__global_locale);
}

double atof_l(const char *a1, locale_t a2)
{
  return strtod_l(a1, 0, a2);
}

int atoi(const char *a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return strtol_l(a1, 0, 10, v5);
  else
    return strtol_l(a1, 0, 10, (locale_t)__global_locale);
}

int atoi_l(const char *a1, locale_t a2)
{
  return strtol_l(a1, 0, 10, a2);
}

uint64_t atol(const char *a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return strtol_l(a1, 0, 10, v5);
  else
    return strtol_l(a1, 0, 10, (locale_t)__global_locale);
}

uint64_t atol_l(const char *a1, locale_t a2)
{
  return strtol_l(a1, 0, 10, a2);
}

uint64_t atoll(const char *a1)
{
  char v1;
  char v2;
  _xlocale *v5;
  uint64_t v6;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
  {
    v5 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v6 = __locale_key;
    v5 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v6);
  }
  if (v5)
    return strtoll_l(a1, 0, 10, v5);
  else
    return strtoll_l(a1, 0, 10, (locale_t)__global_locale);
}

uint64_t atoll_l(const char *a1, locale_t a2)
{
  return strtoll_l(a1, 0, 10, a2);
}

void *__cdecl bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  int v6;

  while (__nel)
  {
    v6 = ((uint64_t (*)(const void *, char *))__compar)(__key, (char *)__base + (__nel >> 1) * __width);
    if (!v6)
      return (char *)__base + (__nel >> 1) * __width;
    if (v6 > 0)
      __base = (char *)__base + (__nel-- >> 1) * __width + __width;
    __nel >>= 1;
  }
  return 0;
}

void *__cdecl bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, void *__compar)
{
  int v6;

  while (__nel)
  {
    v6 = (*((uint64_t (**)(void *, const void *, char *))__compar + 2))(__compar, __key, (char *)__base + (__nel >> 1) * __width);
    if (!v6)
      return (char *)__base + (__nel >> 1) * __width;
    if (v6 > 0)
      __base = (char *)__base + (__nel-- >> 1) * __width + __width;
    __nel >>= 1;
  }
  return 0;
}

div_t div(int a1, int a2)
{
  div_t v3;

  v3.quot = a1 / a2;
  v3.rem = a1 % a2;
  if (a1 >= 0 && v3.rem < 0)
  {
    ++v3.quot;
    v3.rem -= a2;
  }
  return v3;
}

void exit(int a1)
{
  __cxa_finalize(0);
  if (__cleanup)
    _cleanup();
  __exit(a1);
}

_BYTE *__findenv_locked(_BYTE *a1, _DWORD *a2, char **a3)
{
  char *v3;
  char *v4;
  char *v5;
  BOOL v7;
  BOOL v8;
  char *v9;
  _BYTE *v10;
  char **j;
  _BYTE *i;
  char *v13;
  int k;
  int v15;

  if (!a1 || !a3)
    return 0;
  for (i = a1; ; ++i)
  {
    v8 = 0;
    if (*i)
      v8 = *i != 61;
    if (!v8)
      break;
  }
  v15 = (_DWORD)i - (_DWORD)a1;
  for (j = a3; ; ++j)
  {
    v9 = *j;
    if (!*j)
      break;
    v13 = a1;
    for (k = v15; ; --k)
    {
      v7 = 0;
      if (k)
        v7 = *v9 != 0;
      if (!v7)
        break;
      v3 = v9++;
      v4 = v13++;
      if (*v3 != *v4)
        break;
    }
    if (!k)
    {
      v5 = v9;
      v10 = v9 + 1;
      if (*v5 == 61)
      {
        *a2 = j - a3;
        return v10;
      }
    }
  }
  return 0;
}

uint64_t environ_lock_np()
{
  return os_unfair_lock_lock_with_options(&__environ_lock_obj, 0x10000);
}

void environ_unlock_np()
{
  os_unfair_lock_unlock((os_unfair_lock_t)&__environ_lock_obj);
}

void __environ_lock_fork_child()
{
  __environ_lock_obj = 0;
}

_BYTE *_getenvp(_BYTE *a1, char ***a2, uint64_t a3)
{
  _BYTE *v4;
  int v5;
  uint64_t v6;
  char ***v7;
  _BYTE *v8;

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v5 = 0;
  environ_lock_np();
  v4 = __findenv_locked(v8, &v5, *v7);
  environ_unlock_np();
  return v4;
}

char *__cdecl getenv(const char *a1)
{
  char ***v1;
  char *v3;
  char *v4;
  int v5;
  const char *v6;

  v6 = a1;
  v5 = 0;
  environ_lock_np();
  v3 = (char *)v6;
  v1 = _NSGetEnviron();
  v4 = __findenv_locked(v3, &v5, *v1);
  environ_unlock_np();
  return v4;
}

int getopt(int a1, char *const a2[], const char *a3)
{
  char *v3;
  char *v4;
  char *v5;
  uint64_t v7;

  if (!optreset && *getopt_place)
  {
    v5 = getopt_place++;
    optopt = *v5;
  }
  else
  {
    optreset = 0;
    getopt_place = a2[optind];
    if (optind >= a1 || (v3 = getopt_place, ++getopt_place, *v3 != 45))
    {
      getopt_place = &EMSG;
      return -1;
    }
    v4 = getopt_place++;
    optopt = *v4;
    if (optopt == 45 && !*getopt_place)
    {
      ++optind;
      getopt_place = &EMSG;
      return -1;
    }
    if (!optopt)
    {
      getopt_place = &EMSG;
      if (!_platform_strchr(a3, 45))
        return -1;
      optopt = 45;
    }
  }
  if (optopt == 58 || (v7 = _platform_strchr(a3, optopt)) == 0)
  {
    if (!*getopt_place)
      ++optind;
    if (opterr && *a3 != 58)
      fprintf(__stderrp, "%s: illegal option -- %c\n", *(const char **)a2, optopt);
    return 63;
  }
  if (*(_BYTE *)(v7 + 1) != 58)
  {
    optarg = 0;
    if (!*getopt_place)
      ++optind;
    return optopt;
  }
  if (*getopt_place)
  {
    optarg = getopt_place;
LABEL_38:
    getopt_place = &EMSG;
    ++optind;
    return optopt;
  }
  if (*(_BYTE *)(v7 + 2) == 58)
  {
    optarg = 0;
    goto LABEL_38;
  }
  if (a1 > ++optind)
  {
    optarg = a2[optind];
    goto LABEL_38;
  }
  ++optind;
  optarg = 0;
  getopt_place = &EMSG;
  if (*a3 == 58)
    return 58;
  if (opterr)
    fprintf(__stderrp, "%s: option requires an argument -- %c\n", *(const char **)a2, optopt);
  return 63;
}

int getopt_long(int a1, char *const *a2, const char *a3, const option *a4, int *a5)
{
  return getopt_internal(a1, (uint64_t)a2, a3, (uint64_t)a4, a5, 1);
}

uint64_t getopt_internal(int a1, uint64_t a2, _BYTE *a3, uint64_t a4, int *a5, char a6)
{
  uint64_t v6;
  char *v7;
  char *v9;
  unsigned int v11;
  _BOOL4 v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  _BYTE *v18;
  _BYTE *v22;

  v22 = a3;
  if (!a3)
    return -1;
  if (!optind)
  {
    optreset = 1;
    optind = 1;
  }
  if (getopt_internal_posixly_correct == -1 || optreset)
  {
    LOBYTE(getopt_internal_posixly_correct) = getenv("POSIXLY_CORRECT") != 0;
    getopt_internal_posixly_correct = getopt_internal_posixly_correct;
  }
  if (*v22 == 45)
  {
    a6 |= 2u;
  }
  else if (getopt_internal_posixly_correct || *v22 == 43)
  {
    a6 &= ~1u;
  }
  if (*v22 == 43 || *v22 == 45)
    ++v22;
  optarg = 0;
  if (optreset)
  {
    nonopt_end = -1;
    nonopt_start = -1;
  }
  while (1)
  {
    if (!optreset && *place)
      goto LABEL_46;
    optreset = 0;
    if (optind >= a1)
    {
      place = &EMSG_0;
      if (nonopt_end == -1)
      {
        if (nonopt_start != -1)
          optind = nonopt_start;
      }
      else
      {
        permute_args(nonopt_start, nonopt_end, optind, a2);
        optind -= nonopt_end - nonopt_start;
      }
      nonopt_end = -1;
      nonopt_start = -1;
      return -1;
    }
    place = *(char **)(a2 + 8 * optind);
    if (*place == 45)
    {
      if (*((_BYTE *)&dword_0 + (_QWORD)place + 1))
        break;
    }
    place = &EMSG_0;
    if ((a6 & 2) != 0)
    {
      v6 = optind++;
      optarg = *(char **)(a2 + 8 * v6);
      return 1;
    }
    if ((a6 & 1) == 0)
      return -1;
    if (nonopt_start == -1)
    {
      nonopt_start = optind;
    }
    else if (nonopt_end != -1)
    {
      permute_args(nonopt_start, nonopt_end, optind, a2);
      nonopt_start = optind - (nonopt_end - nonopt_start);
      nonopt_end = -1;
    }
    ++optind;
  }
  if (nonopt_start != -1 && nonopt_end == -1)
    nonopt_end = optind;
  if (*((_BYTE *)&dword_0 + (_QWORD)place + 1))
  {
    v7 = place++;
    if (*((_BYTE *)&dword_0 + (_QWORD)v7 + 1) == 45 && !*((_BYTE *)&dword_0 + (_QWORD)place + 1))
    {
      ++optind;
      place = &EMSG_0;
      if (nonopt_end != -1)
      {
        permute_args(nonopt_start, nonopt_end, optind, a2);
        optind -= nonopt_end - nonopt_start;
      }
      nonopt_end = -1;
      nonopt_start = -1;
      return -1;
    }
  }
LABEL_46:
  if (a4 && place != *(char **)(a2 + 8 * optind) && (*place == 45 || (a6 & 4) != 0))
  {
    v14 = 0;
    dash_prefix = 0;
    if (*place == 45)
    {
      if (!*++place)
      {
        if (*v22 == 58)
          return 58;
        else
          return 63;
      }
      dash_prefix = 1;
    }
    else if (*place != 58)
    {
      v14 = _platform_strchr(v22, *place) != 0;
    }
    v15 = parse_long_options(a2, v22, a4, a5, v14, a6);
    if (v15 != -1)
    {
      place = &EMSG_0;
      return v15;
    }
  }
  v9 = place++;
  v16 = *v9;
  if (v16 == 58 || v16 == 45 && *place || (v17 = _platform_strchr(v22, v16)) == 0)
  {
    if (v16 != 45 || *place)
    {
      if (!*place)
        ++optind;
      if (opterr && *v22 != 58)
      {
        if (getopt_internal_posixly_correct)
          warnx("illegal option -- %c");
        else
          warnx("invalid option -- %c");
      }
      optopt = v16;
      return 63;
    }
    else
    {
      return -1;
    }
  }
  if (a4 && v16 == 87 && *(_BYTE *)(v17 + 1) == 59)
  {
    if (!*place)
    {
      if (++optind >= a1)
      {
        place = &EMSG_0;
        if (opterr && *v22 != 58)
          warnx("option requires an argument -- %c", 87);
        optopt = 87;
        if (*v22 == 58)
          return 58;
        else
          return 63;
      }
      place = *(char **)(a2 + 8 * optind);
    }
    dash_prefix = 2;
    v11 = parse_long_options(a2, v22, a4, a5, 0, a6);
    place = &EMSG_0;
    return v11;
  }
  v18 = (_BYTE *)(v17 + 1);
  if (*v18 != 58)
  {
    if (!*place)
      ++optind;
    return v16;
  }
  optarg = 0;
  if (*place)
  {
    optarg = place;
LABEL_106:
    place = &EMSG_0;
    ++optind;
    return v16;
  }
  if (v18[1] == 58)
    goto LABEL_106;
  if (++optind < a1)
  {
    optarg = *(char **)(a2 + 8 * optind);
    goto LABEL_106;
  }
  place = &EMSG_0;
  if (opterr && *v22 != 58)
    warnx("option requires an argument -- %c", v16);
  optopt = v16;
  if (*v22 == 58)
    return 58;
  else
    return 63;
}

int getopt_long_only(int a1, char *const *a2, const char *a3, const option *a4, int *a5)
{
  return getopt_internal(a1, (uint64_t)a2, a3, (uint64_t)a4, a5, 5);
}

uint64_t permute_args(int a1, int a2, int a3, uint64_t a4)
{
  uint64_t result;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  int j;
  int i;
  int v11;

  v8 = a2 - a1;
  v7 = a3 - a2;
  result = gcd(a2 - a1, a3 - a2);
  for (i = 0; i < (int)result; ++i)
  {
    v11 = a2 + i;
    v6 = a2 + i;
    for (j = 0; j < (a3 - a1) / (int)result; ++j)
    {
      if (v6 < a2)
        v6 += v7;
      else
        v6 -= v8;
      v5 = *(_QWORD *)(a4 + 8 * v6);
      *(_QWORD *)(a4 + 8 * v6) = *(_QWORD *)(a4 + 8 * v11);
      *(_QWORD *)(a4 + 8 * v11) = v5;
    }
  }
  return result;
}

uint64_t parse_long_options(uint64_t a1, _BYTE *a2, uint64_t a3, int *a4, int a5, char a6)
{
  uint64_t v6;
  int v9;
  int v10;
  int v11;
  int i;
  uint64_t v13;
  const char *v14;
  char *v15;
  const char *v16;

  v16 = place;
  if (dash_prefix)
  {
    if (dash_prefix == 1)
    {
      v14 = "--";
    }
    else if (dash_prefix == 2)
    {
      v14 = "-W ";
    }
    else
    {
      v14 = (const char *)&unk_D495D;
    }
  }
  else
  {
    v14 = "-";
  }
  v11 = -1;
  v10 = 0;
  v9 = 0;
  ++optind;
  v15 = (char *)_platform_strchr(place, 61);
  if (v15)
  {
    v13 = v15 - v16;
    ++v15;
  }
  else
  {
    v13 = _platform_strlen(v16);
  }
  for (i = 0; *(_QWORD *)(a3 + 32 * i); ++i)
  {
    if (!_platform_strncmp(v16, *(_QWORD *)(a3 + 32 * i), v13))
    {
      if (_platform_strlen(*(_QWORD *)(a3 + 32 * i)) == v13)
      {
        v11 = i;
        v10 = 1;
        break;
      }
      if (!a5 || v13 != 1)
      {
        if (v11 == -1)
        {
          v11 = i;
        }
        else if ((a6 & 4) != 0
               || *(_DWORD *)(a3 + 32 * i + 8) != *(_DWORD *)(a3 + 32 * v11 + 8)
               || *(_QWORD *)(a3 + 32 * i + 16) != *(_QWORD *)(a3 + 32 * v11 + 16)
               || *(_DWORD *)(a3 + 32 * i + 24) != *(_DWORD *)(a3 + 32 * v11 + 24))
        {
          v9 = 1;
        }
      }
    }
  }
  if (v10 || !v9)
  {
    if (v11 == -1)
    {
      if (a5)
      {
        --optind;
        return -1;
      }
      else
      {
        if (opterr && *a2 != 58)
        optopt = 0;
        return 63;
      }
    }
    else if (*(_DWORD *)(a3 + 32 * v11 + 8) || !v15)
    {
      if (*(_DWORD *)(a3 + 32 * v11 + 8) == 1 || *(_DWORD *)(a3 + 32 * v11 + 8) == 2)
      {
        if (v15)
        {
          optarg = v15;
        }
        else if (*(_DWORD *)(a3 + 32 * v11 + 8) == 1)
        {
          v6 = optind++;
          optarg = *(char **)(a1 + 8 * v6);
        }
      }
      if (*(_DWORD *)(a3 + 32 * v11 + 8) != 1 || optarg)
      {
        if (a4)
          *a4 = v11;
        if (*(_QWORD *)(a3 + 32 * v11 + 16))
        {
          **(_DWORD **)(a3 + 32 * v11 + 16) = *(_DWORD *)(a3 + 32 * v11 + 24);
          return 0;
        }
        else
        {
          return *(unsigned int *)(a3 + 32 * v11 + 24);
        }
      }
      else
      {
        if (opterr && *a2 != 58)
        if (*(_QWORD *)(a3 + 32 * v11 + 16))
          optopt = 0;
        else
          optopt = *(_DWORD *)(a3 + 32 * v11 + 24);
        --optind;
        if (*a2 == 58)
          return 58;
        else
          return 63;
      }
    }
    else
    {
      if (opterr && *a2 != 58)
      if (*(_QWORD *)(a3 + 32 * v11 + 16))
        optopt = 0;
      else
        optopt = *(_DWORD *)(a3 + 32 * v11 + 24);
      return 63;
    }
  }
  else
  {
    if (opterr && *a2 != 58)
    optopt = 0;
    return 63;
  }
}

uint64_t gcd(int a1, signed int a2)
{
  int i;
  unsigned int v4;
  signed int v5;

  v4 = a2;
  for (i = a1 % a2; i; i = v5 % i)
  {
    v5 = v4;
    v4 = i;
  }
  return v4;
}

int getsubopt(char **a1, char *const *a2, char **a3)
{
  char *v3;
  char *v4;
  BOOL v6;
  BOOL v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  BOOL v11;
  char *i;
  int v13;

  *a3 = 0;
  suboptarg = 0;
  if (!a1 || !*a1)
    return -1;
  for (i = *a1; ; ++i)
  {
    v11 = 0;
    if (*i)
    {
      v10 = 1;
      if (*i != 44)
      {
        v10 = 1;
        if (*i != 32)
          v10 = *i == 9;
      }
      v11 = v10;
    }
    if (!v11)
      break;
  }
  if (*i)
  {
    suboptarg = i;
    do
    {
      ++i;
      v9 = 0;
      if (*i)
      {
        v9 = 0;
        if (*i != 44)
        {
          v9 = 0;
          if (*i != 61)
          {
            v9 = 0;
            if (*i != 32)
              v9 = *i != 9;
          }
        }
      }
    }
    while (v9);
    if (*i)
    {
      if (*i == 61)
      {
        *i++ = 0;
        *a3 = i;
        while (1)
        {
          v8 = 0;
          if (*i)
          {
            v8 = 0;
            if (*i != 44)
            {
              v8 = 0;
              if (*i != 32)
                v8 = *i != 9;
            }
          }
          if (!v8)
            break;
          ++i;
        }
        if (*i)
        {
          v3 = i++;
          *v3 = 0;
        }
      }
      else
      {
        v4 = i++;
        *v4 = 0;
      }
      while (1)
      {
        v7 = 0;
        if (*i)
        {
          v6 = 1;
          if (*i != 44)
          {
            v6 = 1;
            if (*i != 32)
              v6 = *i == 9;
          }
          v7 = v6;
        }
        if (!v7)
          break;
        ++i;
      }
    }
    *a1 = i;
    v13 = 0;
    while (*a2)
    {
      if (!_platform_strcmp(suboptarg, *a2))
        return v13;
      ++a2;
      ++v13;
    }
    return -1;
  }
  else
  {
    *a1 = i;
    return -1;
  }
}

int hcreate(size_t a1)
{
  char v2;
  unint64_t i;
  size_t v4;

  v4 = a1;
  if (htable)
  {
    *__error() = 22;
    return 0;
  }
  else
  {
    if (a1 < 0x10)
      v4 = 16;
    if (v4 > 0x400000000000000)
      v4 = 0x400000000000000;
    if ((v4 & (v4 - 1)) != 0)
    {
      v2 = 0;
      while (v4)
      {
        v4 >>= 1;
        ++v2;
      }
      v4 = 1 << v2;
    }
    htablesize = v4;
    htable = malloc_type_malloc(8 * v4, 0x2004093837F09);
    if (htable)
    {
      for (i = 0; i < htablesize; ++i)
        *(_QWORD *)(htable + 8 * i) = 0;
      return 1;
    }
    else
    {
      *__error() = 12;
      return 0;
    }
  }
}

void hdestroy_0(void)
{
  unint64_t i;
  void **v1;

  if (htable)
  {
    for (i = 0; i < htablesize; ++i)
    {
      while (*(_QWORD *)(htable + 8 * i))
      {
        v1 = *(void ***)(htable + 8 * i);
        *(_QWORD *)(htable + 8 * i) = *v1;
        free(v1[1]);
        free(v1);
      }
    }
    free((void *)htable);
    htable = 0;
  }
}

ENTRY *__cdecl hsearch(ENTRY a1, ACTION a2)
{
  uint64_t v2;
  uint64_t i;
  uint64_t v5;
  uint64_t *v6;

  v2 = _platform_strlen(a1.key);
  v6 = (uint64_t *)(htable + 8 * (__default_hash((uint64_t)a1.key, v2) & (unint64_t)(htablesize - 1)));
  for (i = *v6; i && _platform_strcmp(*(_QWORD *)(i + 8), a1.key); i = *(_QWORD *)i)
    ;
  if (i)
    return (ENTRY *)(i + 8);
  if (a2 == FIND)
    return 0;
  v5 = malloc_type_malloc(24, 0xB00404D7CA56CLL);
  if (!v5)
    return 0;
  *(ENTRY *)(v5 + 8) = a1;
  *(_QWORD *)v5 = *v6;
  *v6 = v5;
  return (ENTRY *)(v5 + 8);
}

int heapsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  char v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t i;
  unint64_t j;
  size_t v39;
  size_t v40;
  size_t v41;
  size_t v42;
  size_t v43;
  size_t v44;
  size_t v47;

  v47 = __nel;
  if (__nel <= 1)
    return 0;
  if (__width)
  {
    v20 = (char *)malloc_type_malloc(__width, 930663621);
    if (v20)
    {
      v21 = (char *)__base - __width;
      v33 = v47 / 2 + 1;
      while (--v33)
      {
        for (i = v33; ; i = v34)
        {
          v34 = 2 * i;
          if (2 * i > v47)
            break;
          v18 = &v21[v34 * __width];
          if (v34 < v47 && ((int (*)(char *, char *))__compar)(v18, &v18[__width]) < 0)
          {
            v18 += __width;
            ++v34;
          }
          v17 = &v21[i * __width];
          if (((int (*)(char *, char *))__compar)(v18, v17) <= 0)
            break;
          v39 = __width;
          do
          {
            v32 = *v17;
            v4 = v17++;
            *v4 = *v18;
            v5 = v18++;
            *v5 = v32;
            --v39;
          }
          while (v39);
        }
      }
      while (v47 > 1)
      {
        v40 = __width;
        v27 = v20;
        v22 = &v21[v47 * __width];
        do
        {
          v6 = v22++;
          v7 = v27++;
          *v7 = *v6;
          --v40;
        }
        while (v40);
        v41 = __width;
        v28 = &v21[v47 * __width];
        v23 = (char *)__base;
        do
        {
          v8 = v23++;
          v9 = v28++;
          *v9 = *v8;
          --v41;
        }
        while (v41);
        --v47;
        for (j = 1; ; j = v35)
        {
          v35 = 2 * j;
          if (2 * j > v47)
            break;
          v19 = &v21[v35 * __width];
          if (v35 < v47 && ((int (*)(char *, char *))__compar)(v19, &v19[__width]) < 0)
          {
            v19 += __width;
            ++v35;
          }
          v42 = __width;
          v29 = &v21[j * __width];
          v24 = v19;
          do
          {
            v10 = v24++;
            v11 = v29++;
            *v11 = *v10;
            --v42;
          }
          while (v42);
        }
        while (1)
        {
          v36 = j;
          j /= 2uLL;
          if (v36 == 1 || ((int (*)(char *, char *))__compar)(v20, &v21[j * __width]) < 0)
            break;
          v44 = __width;
          v31 = &v21[v36 * __width];
          v26 = &v21[j * __width];
          do
          {
            v14 = v26++;
            v15 = v31++;
            *v15 = *v14;
            --v44;
          }
          while (v44);
        }
        v43 = __width;
        v30 = &v21[v36 * __width];
        v25 = v20;
        do
        {
          v12 = v25++;
          v13 = v30++;
          *v13 = *v12;
          --v43;
        }
        while (v43);
      }
      free(v20);
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

intmax_t imaxabs(intmax_t j)
{
  if (j >= 0)
    return j;
  else
    return -j;
}

imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
{
  intmax_t v2;
  intmax_t v3;
  intmax_t v4;
  intmax_t v5;
  imaxdiv_t result;

  v4 = __numer / __denom;
  v5 = __numer % __denom;
  if (__numer >= 0 && v5 < 0)
  {
    ++v4;
    v5 -= __denom;
  }
  v2 = v4;
  v3 = v5;
  result.rem = v3;
  result.quot = v2;
  return result;
}

void insque(void *a1, void *a2)
{
  const void **v3;

  if (a2)
  {
    v3 = *(const void ***)a2;
    if (*(_QWORD *)a2)
    {
      if (v3[1] != a2)
        fprintf(__stderrp, "insque: Inconsistency detected: next(%p)->prev(%p) != prev(%p)\n", v3, v3[1], a2);
      v3[1] = a1;
    }
    *(_QWORD *)a2 = a1;
    *((_QWORD *)a1 + 1) = a2;
    *(_QWORD *)a1 = v3;
  }
  else
  {
    *(_QWORD *)a1 = 0;
    *((_QWORD *)a1 + 1) = 0;
  }
}

uint64_t labs(uint64_t a1)
{
  if (a1 >= 0)
    return a1;
  else
    return -a1;
}

ldiv_t ldiv(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  ldiv_t result;

  v4 = a1 / a2;
  v5 = a1 % a2;
  if (a1 >= 0 && v5 < 0)
  {
    ++v4;
    v5 -= a2;
  }
  v2 = v4;
  v3 = v5;
  result.rem = v3;
  result.quot = v2;
  return result;
}

uint64_t llabs(uint64_t a1)
{
  if (a1 >= 0)
    return a1;
  else
    return -a1;
}

lldiv_t lldiv(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  lldiv_t result;

  v4 = a1 / a2;
  v5 = a1 % a2;
  if (a1 >= 0 && v5 < 0)
  {
    ++v4;
    v5 -= a2;
  }
  v2 = v4;
  v3 = v5;
  result.rem = v3;
  result.quot = v2;
  return result;
}

void *__cdecl lsearch(const void *a1, void *a2, size_t *a3, size_t a4, int (__cdecl *a5)(const void *, const void *))
{
  return (void *)lwork((uint64_t)a1, (unint64_t)a2, a3, a4, (unsigned int (*)(uint64_t, unint64_t))a5, 1);
}

unint64_t lwork(uint64_t a1, unint64_t a2, _QWORD *a3, uint64_t a4, unsigned int (*a5)(uint64_t, unint64_t), int a6)
{
  unint64_t v7;
  unint64_t v8;

  v8 = a2;
  v7 = a2 + a4 * *a3;
  while (v8 < v7)
  {
    if (!a5(a1, v8))
      return v8;
    v8 += a4;
  }
  if (!a6)
    return 0;
  j___platform_memmove(v7, a1, a4);
  ++*a3;
  return v7;
}

void *__cdecl lfind(const void *a1, const void *a2, size_t *a3, size_t a4, int (__cdecl *a5)(const void *, const void *))
{
  return (void *)lwork((uint64_t)a1, (unint64_t)a2, a3, a4, (unsigned int (*)(uint64_t, unint64_t))a5, 0);
}

int mergesort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  _BYTE *v14;
  _BYTE *v15;
  BOOL v17;
  BOOL v18;
  _QWORD *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  _DWORD *v26;
  _DWORD *v27;
  char *v28;
  char *v29;
  char *v30;
  _DWORD *v31;
  _DWORD *v32;
  _BOOL4 v33;
  int v34;
  int v35;
  size_t v36;
  size_t i;

  if (__width >= 4)
  {
    if (__nel)
    {
      v33 = 0;
      if (!(__width % 4))
        v33 = (unint64_t)__base % 4 == 0;
      v23 = (char *)malloc_type_malloc(__nel * __width + 8, 2398784519);
      if (v23)
      {
        v22 = (char *)__base;
        setup((uint64_t)__base, v23, __nel, __width, (uint64_t (*)(char *, char *))__compar);
        v20 = &v23[__nel * __width];
        v34 = 0;
        v36 = 0;
        while (*(char **)((unint64_t)(v23 + 7) & 0xFFFFFFFFFFFFFFF8) != v20)
        {
          v24 = v22;
          v19 = (_QWORD *)((unint64_t)(v22 + 7) & 0xFFFFFFFFFFFFFFF8);
          v21 = v23;
          v27 = v23;
          while (v21 != v20)
          {
            v21 = *(char **)((unint64_t)(v21 + 7) & 0xFFFFFFFFFFFFFFF8);
            v32 = v24;
            v25 = &v22[v21 - v23];
            v31 = v25;
            if (v21 != v20)
              v21 = *(char **)((unint64_t)(v21 + 7) & 0xFFFFFFFFFFFFFFF8);
            v24 = &v22[v21 - v23];
            while (1)
            {
              v18 = 0;
              if (v32 < (_DWORD *)v25)
                v18 = v31 < (_DWORD *)v24;
              if (!v18)
                break;
              if (((int (*)(_DWORD *, _DWORD *))__compar)(v32, v31) > 0)
              {
                v26 = v32;
                v29 = (char *)v31;
                v30 = &v22[v21 - v23];
                v35 = 0;
              }
              else
              {
                v26 = v31;
                v29 = (char *)v32;
                v30 = v25;
                v35 = -1;
              }
              if (v34)
              {
LABEL_30:
                for (i = __width; ; i *= 2)
                {
                  if (&v29[i] >= v30)
                  {
                    if (&v30[-__width] <= v29
                      || ((int (*)(_DWORD *, char *))__compar)(v26, &v30[-__width]) > v35)
                    {
                      v29 = &v30[-__width];
                    }
                    else
                    {
                      v30 -= __width;
                    }
                    while (v30 > &v29[__width])
                    {
                      if (((int (*)(_DWORD *))__compar)(v26) > v35)
                        v29 += (((v30 - v29) / __width) >> 1) * __width;
                      else
                        v30 = &v29[(((v30 - v29) / __width) >> 1) * __width];
                    }
                    goto LABEL_50;
                  }
                  if (((int (*)(_DWORD *, char *))__compar)(v26, &v29[i]) <= v35)
                    break;
                  v29 += i;
                }
                v30 = &v29[i];
                if (i == __width)
                  v34 = 0;
                while (i > __width)
                {
                  i >>= 1;
                  if (((int (*)(_DWORD *))__compar)(v26) > v35)
                    v29 += i;
                  else
                    v30 = &v29[i];
                }
LABEL_50:
                v29 = v30;
              }
              else
              {
                while (1)
                {
                  v29 += __width;
                  v17 = 0;
                  if (v29 < v30)
                    v17 = ((int (*)(_DWORD *, char *))__compar)(v26, v29) > v35;
                  if (!v17)
                    break;
                  if (++v36 == 6)
                  {
                    v34 = 1;
                    goto LABEL_30;
                  }
                }
              }
              v36 = __width;
              if (v26 == v32)
              {
                if (v33)
                {
                  do
                    *v27++ = *v31++;
                  while (v31 < (_DWORD *)v29);
                  do
                  {
                    *v27++ = *v32++;
                    v36 -= 4;
                  }
                  while (v36);
                }
                else
                {
                  do
                  {
                    v4 = v31;
                    v31 = (_DWORD *)((char *)v31 + 1);
                    v5 = v27;
                    v27 = (_DWORD *)((char *)v27 + 1);
                    *v5 = *v4;
                  }
                  while (v31 < (_DWORD *)v29);
                  do
                  {
                    v6 = v32;
                    v32 = (_DWORD *)((char *)v32 + 1);
                    v7 = v27;
                    v27 = (_DWORD *)((char *)v27 + 1);
                    *v7 = *v6;
                    --v36;
                  }
                  while (v36);
                }
              }
              else if (v33)
              {
                do
                  *v27++ = *v32++;
                while (v32 < (_DWORD *)v29);
                do
                {
                  *v27++ = *v31++;
                  v36 -= 4;
                }
                while (v36);
              }
              else
              {
                do
                {
                  v8 = v32;
                  v32 = (_DWORD *)((char *)v32 + 1);
                  v9 = v27;
                  v27 = (_DWORD *)((char *)v27 + 1);
                  *v9 = *v8;
                }
                while (v32 < (_DWORD *)v29);
                do
                {
                  v10 = v31;
                  v31 = (_DWORD *)((char *)v31 + 1);
                  v11 = v27;
                  v27 = (_DWORD *)((char *)v27 + 1);
                  *v11 = *v10;
                  --v36;
                }
                while (v36);
              }
            }
            if (v31 >= (_DWORD *)v24)
            {
              if (v32 < (_DWORD *)v25)
              {
                if (v33)
                {
                  do
                    *v27++ = *v32++;
                  while (v32 < (_DWORD *)v25);
                }
                else
                {
                  do
                  {
                    v14 = v32;
                    v32 = (_DWORD *)((char *)v32 + 1);
                    v15 = v27;
                    v27 = (_DWORD *)((char *)v27 + 1);
                    *v15 = *v14;
                  }
                  while (v32 < (_DWORD *)v25);
                }
              }
            }
            else if (v33)
            {
              do
                *v27++ = *v31++;
              while (v31 < (_DWORD *)v24);
            }
            else
            {
              do
              {
                v12 = v31;
                v31 = (_DWORD *)((char *)v31 + 1);
                v13 = v27;
                v27 = (_DWORD *)((char *)v27 + 1);
                *v13 = *v12;
              }
              while (v31 < (_DWORD *)v24);
            }
            *v19 = v24;
            v19 = (_QWORD *)((unint64_t)(v24 + 7) & 0xFFFFFFFFFFFFFFF8);
          }
          v28 = v22;
          v22 = v23;
          v23 = v28;
          v20 = &v28[__nel * __width];
        }
        if (__base == v23)
        {
          _platform_memmove(v23, v22, __nel * __width);
          v23 = v22;
        }
        free(v23);
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t setup(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t (*a5)(char *, char *))
{
  uint64_t result;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *i;
  char *j;
  char *v20;
  _BOOL4 v21;
  char v22;
  char v23;
  char v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v26 = 2 * a4;
  if (a3 > 5)
  {
    v27 = (a3 & 1) + 4;
    insertionsort(a1 + (a3 - v27) * a4, v27, a4, a5);
    v13 = a1 + a4 * (a3 - v27);
    *(_QWORD *)((unint64_t)&a2[a4 * (a3 - v27) + 7] & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
    v12 = a2;
    v20 = (char *)a1;
    result = a5((char *)a1, (char *)(a1 + a4));
    v21 = (int)result > 0;
    while ((unint64_t)v20 < v13)
    {
      v25 = 2;
      for (i = &v20[v26]; (unint64_t)i < v13; i += v26)
      {
        result = a5(i, &i[a4]);
        if ((int)result > 0 != v21)
          break;
        v25 += 2;
      }
      if (v25 >= 16)
      {
        v14 = i;
        for (j = &v20[v26]; j < v14; j += v26)
        {
          result = a5(&j[-a4], j);
          if ((int)result > 0 != v21)
          {
            *(_QWORD *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &j[(_QWORD)a2 - a1];
            v12 = &j[(_QWORD)a2 - a1];
            if (v21 > 0)
            {
              v16 = &j[-a4];
              do
              {
                v29 = a4;
                do
                {
                  v23 = *v20;
                  v8 = v20++;
                  *v8 = *v16;
                  v9 = v16++;
                  *v9 = v23;
                  --v29;
                }
                while (v29);
                v16 -= v26;
              }
              while (v20 < v16);
            }
            v20 = j;
          }
        }
        if (v21 > 0)
        {
          v17 = &j[-a4];
          do
          {
            v30 = a4;
            do
            {
              v24 = *v20;
              v10 = v20++;
              *v10 = *v17;
              v11 = v17++;
              *v11 = v24;
              --v30;
            }
            while (v30);
            v17 -= v26;
          }
          while (v20 < v17);
        }
        v20 = j;
        if ((unint64_t)j >= v13 && (result = a5(&j[-a4], j), (int)result <= 0))
        {
          *(_QWORD *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
          v12 = &a2[a3 * a4];
        }
        else
        {
          *(_QWORD *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &j[(_QWORD)a2 - a1];
          v12 = &j[(_QWORD)a2 - a1];
        }
      }
      else
      {
        do
        {
          *(_QWORD *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &v20[v26 - a1 + (_QWORD)a2];
          v12 = &v20[v26 - a1 + (_QWORD)a2];
          if (v21 > 0)
          {
            v15 = &v20[a4];
            v28 = a4;
            do
            {
              v22 = *v20;
              v6 = v20++;
              *v6 = *v15;
              v7 = v15++;
              *v7 = v22;
              --v28;
            }
            while (v28);
            v20 -= a4;
          }
          v20 += v26;
        }
        while (v20 < i);
      }
      v21 = !v21;
    }
  }
  else
  {
    result = insertionsort(a1, a3, a4, a5);
    *(_QWORD *)((unint64_t)(a2 + 7) & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
  }
  return result;
}

uint64_t insertionsort(uint64_t result, uint64_t a2, uint64_t a3, uint64_t (*a4)(char *, char *))
{
  char *v4;
  char *v5;
  int v6;
  char v7;
  char *v8;
  char *j;
  char *v10;
  char *i;
  unint64_t v15;

  v15 = result;
  for (i = (char *)(result + a3); --a2; i += a3)
  {
    for (j = i; (unint64_t)j > v15; j -= a3)
    {
      v8 = &j[-a3];
      result = a4(&j[-a3], j);
      if ((int)result <= 0)
        break;
      v10 = j;
      v6 = a3;
      do
      {
        v7 = *v8;
        v4 = v8++;
        *v4 = *v10;
        v5 = v10++;
        *v5 = v7;
        --v6;
      }
      while (v6);
    }
  }
  return result;
}

uint64_t _putenvp(char *a1, char ***a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v5;

  environ_lock_np();
  if (__init__env_owned_locked(1))
  {
    environ_unlock_np();
    return -1;
  }
  else
  {
    if (a3)
      v3 = __setenv_locked(a1, 0, 1, 0, a2, a3);
    else
      v3 = __setenv_locked(a1, 0, 1, 0, a2, __env_owned);
    v5 = v3;
    environ_unlock_np();
    return v5;
  }
}

int putenv(char *a1)
{
  char ***v1;
  int v3;

  if (a1 && *a1 && j___platform_strchr(a1, 61))
  {
    environ_lock_np();
    if (__init__env_owned_locked(1))
    {
      environ_unlock_np();
      return -1;
    }
    else
    {
      v1 = _NSGetEnviron();
      v3 = __setenv_locked(a1, 0, 1, 0, v1, __env_owned);
      environ_unlock_np();
      return v3;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  int v4;

  v4 = flsl(__nel);
  _qsort((unint64_t)__base, __nel, __width, __compar, 2 * (v4 - 1));
}

uint64_t _qsort(unint64_t a1, size_t a2, size_t a3, int (__cdecl *a4)(const void *, const void *), unsigned int a5)
{
  int v5;
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  BOOL v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  int v23;
  size_t v24;
  size_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  char *i;
  char *v32;
  char *v33;

  v23 = 0;
  while (1)
  {
    if (a1 % 8 || a3 % 8)
      v12 = 2;
    else
      v12 = a3 != 8;
    if (a1 % 4 || a3 % 4)
      v11 = 2;
    else
      v11 = a3 != 4;
    v22 = 0;
    v5 = a5--;
    if (v5 <= 0)
      return heapsort((void *)a1, a2, a3, a4);
    if (a2 <= 7)
      break;
    v29 = a1;
    v28 = a1 + a2 / 2 * a3;
    v26 = a1 + (a2 - 1) * a3;
    if (a2 > 0x28)
    {
      v21 = a2 / 8 * a3;
      v29 = med3(a1, a1 + v21, a1 + 2 * v21, (int (*)(uint64_t, uint64_t))a4);
      v28 = med3(v28 - v21, v28, v28 + v21, (int (*)(uint64_t, uint64_t))a4);
      v26 = med3(v26 - 2 * v21, v26 - v21, v26, (int (*)(uint64_t, uint64_t))a4);
    }
    result = med3(v29, v28, v26, (int (*)(uint64_t, uint64_t))a4);
    if (v12)
    {
      if (v11)
      {
        result = (uint64_t)swapfunc((char *)a1, (char *)result, a3, v12, v11);
      }
      else
      {
        v19 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)result;
        *(_DWORD *)result = v19;
      }
    }
    else
    {
      v20 = *(_QWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)result;
      *(_QWORD *)result = v20;
    }
    v32 = (char *)(a1 + a3);
    v33 = (char *)(a1 + a3);
    v30 = (char *)(a1 + (a2 - 1) * a3);
    for (i = v30; ; i -= a3)
    {
      while (1)
      {
        v10 = 0;
        if (v32 <= i)
        {
          result = ((uint64_t (*)(char *, unint64_t))a4)(v32, a1);
          v23 = result;
          v10 = (int)result <= 0;
        }
        if (!v10)
          break;
        if (!v23)
        {
          v22 = 1;
          if (v12)
          {
            if (v11)
            {
              result = (uint64_t)swapfunc(v33, v32, a3, v12, v11);
            }
            else
            {
              v17 = *(_DWORD *)v33;
              *(_DWORD *)v33 = *(_DWORD *)v32;
              *(_DWORD *)v32 = v17;
            }
          }
          else
          {
            v18 = *(_QWORD *)v33;
            *(_QWORD *)v33 = *(_QWORD *)v32;
            *(_QWORD *)v32 = v18;
          }
          v33 += a3;
        }
        v32 += a3;
      }
      while (1)
      {
        v9 = 0;
        if (v32 <= i)
        {
          result = ((uint64_t (*)(char *, unint64_t))a4)(i, a1);
          v23 = result;
          v9 = (int)result >= 0;
        }
        if (!v9)
          break;
        if (!v23)
        {
          v22 = 1;
          if (v12)
          {
            if (v11)
            {
              result = (uint64_t)swapfunc(i, v30, a3, v12, v11);
            }
            else
            {
              v15 = *(_DWORD *)i;
              *(_DWORD *)i = *(_DWORD *)v30;
              *(_DWORD *)v30 = v15;
            }
          }
          else
          {
            v16 = *(_QWORD *)i;
            *(_QWORD *)i = *(_QWORD *)v30;
            *(_QWORD *)v30 = v16;
          }
          v30 -= a3;
        }
        i -= a3;
      }
      if (v32 > i)
        break;
      if (v12)
      {
        if (v11)
        {
          result = (uint64_t)swapfunc(v32, i, a3, v12, v11);
        }
        else
        {
          v13 = *(_DWORD *)v32;
          *(_DWORD *)v32 = *(_DWORD *)i;
          *(_DWORD *)i = v13;
        }
      }
      else
      {
        v14 = *(_QWORD *)v32;
        *(_QWORD *)v32 = *(_QWORD *)i;
        *(_QWORD *)i = v14;
      }
      v22 = 1;
      v32 += a3;
    }
    v27 = a1 + a2 * a3;
    if ((uint64_t)&v33[-a1] >= v32 - v33)
      v8 = v32 - v33;
    else
      v8 = (unint64_t)&v33[-a1];
    if (v8)
      result = (uint64_t)swapfunc((char *)a1, &v32[-v8], v8, v12, v11);
    if (v30 - i >= v27 - (_QWORD)v30 - a3)
      v7 = v27 - (_QWORD)v30 - a3;
    else
      v7 = v30 - i;
    if (v7)
      result = (uint64_t)swapfunc(v32, (char *)(v27 - v7), v7, v12, v11);
    if (!v22)
    {
      result = _isort(a1, a2, a3, 0, (int (*)(char *, char *))a4, (a2 / 4) + 1, v12, v11);
      if ((result & 1) != 0)
        return result;
    }
    v25 = v32 - v33;
    v24 = v30 - i;
    if (v32 - v33 > (unint64_t)(v30 - i))
    {
      if (v24 > a3)
        result = _qsort(v27 - v24, v24 / a3, a3, a4, a5);
      if (v25 <= a3)
        return result;
      a2 = v25 / a3;
    }
    else
    {
      if (v25 > a3)
        result = _qsort(a1, v25 / a3, a3, a4, a5);
      if (v24 <= a3)
        return result;
      a1 = v27 - v24;
      a2 = v24 / a3;
    }
  }
  return _isort(a1, a2, a3, 0, (int (*)(char *, char *))a4, 0, v12, v11);
}

uint64_t _isort(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int (*a5)(char *, char *), int a6, int a7, int a8)
{
  BOOL v9;
  int v10;
  uint64_t v11;
  char *j;
  char *i;
  int v14;
  char v22;

  v14 = 0;
  for (i = (char *)(a1 + a3); (unint64_t)i < a1 + a2 * a3; i += a3)
  {
    for (j = i; ; j -= a3)
    {
      v9 = 0;
      if ((unint64_t)j > a1)
        v9 = a5(&j[-a3], j) > 0;
      if (!v9)
        break;
      if (a7)
      {
        if (a8)
        {
          swapfunc(j, &j[-a3], a3, a7, a8);
        }
        else
        {
          v10 = *(_DWORD *)j;
          *(_DWORD *)j = *(_DWORD *)&j[-a3];
          *(_DWORD *)&j[-a3] = v10;
        }
      }
      else
      {
        v11 = *(_QWORD *)j;
        *(_QWORD *)j = *(_QWORD *)&j[-a3];
        *(_QWORD *)&j[-a3] = v11;
      }
      if (a6)
      {
        if (++v14 > a6)
        {
          v22 = 0;
          return v22 & 1;
        }
      }
    }
  }
  v22 = 1;
  return v22 & 1;
}

uint64_t med3(uint64_t a1, uint64_t a2, uint64_t a3, int (*a4)(uint64_t, uint64_t))
{
  if (a4(a1, a2) >= 0)
  {
    if (a4(a2, a3) > 0)
      return a2;
    if (a4(a1, a3) >= 0)
      return a3;
    else
      return a1;
  }
  else
  {
    if (a4(a2, a3) < 0)
      return a2;
    if (a4(a1, a3) >= 0)
      return a1;
    else
      return a3;
  }
}

char *swapfunc(char *result, char *a2, unint64_t a3, int a4, int a5)
{
  uint64_t *v5;
  uint64_t *v6;
  int *v7;
  int *v8;
  char *v9;
  char *v10;
  char v11;
  char *v12;
  char *v13;
  unint64_t v14;
  int v15;
  int *v16;
  int *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  unint64_t v22;

  if (a4 > 1)
  {
    if (a5 > 1)
    {
      v14 = a3;
      v13 = result;
      v12 = a2;
      do
      {
        v11 = *v13;
        v9 = v13++;
        *v9 = *v12;
        v10 = v12++;
        *v10 = v11;
        --v14;
      }
      while (v14);
    }
    else
    {
      v18 = a3 / 4;
      v17 = (int *)result;
      v16 = (int *)a2;
      do
      {
        v15 = *v17;
        v7 = v17++;
        *v7 = *v16;
        v8 = v16++;
        *v8 = v15;
        --v18;
      }
      while (v18);
    }
  }
  else
  {
    v22 = a3 / 8;
    v21 = (uint64_t *)result;
    v20 = (uint64_t *)a2;
    do
    {
      v19 = *v21;
      v5 = v21++;
      *v5 = *v20;
      v6 = v20++;
      *v6 = v19;
      --v22;
    }
    while (v22);
  }
  return result;
}

void qsort_r(void *__base, size_t __nel, size_t __width, void *a4, int (__cdecl *__compar)(void *, const void *, const void *))
{
  int v5;

  v5 = flsl(__nel);
  _qsort_0((unint64_t)__base, __nel, __width, (uint64_t)a4, (int (*)(uint64_t, char *, char *))__compar, 2 * (v5 - 1));
}

uint64_t _qsort_0(unint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4, int (*a5)(uint64_t, char *, char *), unsigned int a6)
{
  int v6;
  uint64_t result;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  BOOL v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  int v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  char *i;
  char *v33;
  char *v34;

  v24 = 0;
  while (1)
  {
    if (a1 % 8 || a3 % 8)
      v13 = 2;
    else
      v13 = a3 != 8;
    if (a1 % 4 || a3 % 4)
      v12 = 2;
    else
      v12 = a3 != 4;
    v23 = 0;
    v6 = a6--;
    if (v6 <= 0)
      return __heapsort_r((_BYTE *)a1, a2, a3, a4, a5);
    if (a2 <= 7)
      break;
    v30 = a1;
    v29 = a1 + a2 / 2 * a3;
    v27 = a1 + (a2 - 1) * a3;
    if (a2 > 0x28)
    {
      v22 = a2 / 8 * a3;
      v30 = med3_0(a1, a1 + v22, a1 + 2 * v22, (int (*)(uint64_t, uint64_t, uint64_t))a5, a4);
      v29 = med3_0(v29 - v22, v29, v29 + v22, (int (*)(uint64_t, uint64_t, uint64_t))a5, a4);
      v27 = med3_0(v27 - 2 * v22, v27 - v22, v27, (int (*)(uint64_t, uint64_t, uint64_t))a5, a4);
    }
    result = med3_0(v30, v29, v27, (int (*)(uint64_t, uint64_t, uint64_t))a5, a4);
    if (v13)
    {
      if (v12)
      {
        result = (uint64_t)swapfunc((char *)a1, (char *)result, a3, v13, v12);
      }
      else
      {
        v20 = *(_DWORD *)a1;
        *(_DWORD *)a1 = *(_DWORD *)result;
        *(_DWORD *)result = v20;
      }
    }
    else
    {
      v21 = *(_QWORD *)a1;
      *(_QWORD *)a1 = *(_QWORD *)result;
      *(_QWORD *)result = v21;
    }
    v33 = (char *)(a1 + a3);
    v34 = (char *)(a1 + a3);
    v31 = (char *)(a1 + (a2 - 1) * a3);
    for (i = v31; ; i -= a3)
    {
      while (1)
      {
        v11 = 0;
        if (v33 <= i)
        {
          result = ((uint64_t (*)(uint64_t, char *, unint64_t))a5)(a4, v33, a1);
          v24 = result;
          v11 = (int)result <= 0;
        }
        if (!v11)
          break;
        if (!v24)
        {
          v23 = 1;
          if (v13)
          {
            if (v12)
            {
              result = (uint64_t)swapfunc(v34, v33, a3, v13, v12);
            }
            else
            {
              v18 = *(_DWORD *)v34;
              *(_DWORD *)v34 = *(_DWORD *)v33;
              *(_DWORD *)v33 = v18;
            }
          }
          else
          {
            v19 = *(_QWORD *)v34;
            *(_QWORD *)v34 = *(_QWORD *)v33;
            *(_QWORD *)v33 = v19;
          }
          v34 += a3;
        }
        v33 += a3;
      }
      while (1)
      {
        v10 = 0;
        if (v33 <= i)
        {
          result = ((uint64_t (*)(uint64_t, char *, unint64_t))a5)(a4, i, a1);
          v24 = result;
          v10 = (int)result >= 0;
        }
        if (!v10)
          break;
        if (!v24)
        {
          v23 = 1;
          if (v13)
          {
            if (v12)
            {
              result = (uint64_t)swapfunc(i, v31, a3, v13, v12);
            }
            else
            {
              v16 = *(_DWORD *)i;
              *(_DWORD *)i = *(_DWORD *)v31;
              *(_DWORD *)v31 = v16;
            }
          }
          else
          {
            v17 = *(_QWORD *)i;
            *(_QWORD *)i = *(_QWORD *)v31;
            *(_QWORD *)v31 = v17;
          }
          v31 -= a3;
        }
        i -= a3;
      }
      if (v33 > i)
        break;
      if (v13)
      {
        if (v12)
        {
          result = (uint64_t)swapfunc(v33, i, a3, v13, v12);
        }
        else
        {
          v14 = *(_DWORD *)v33;
          *(_DWORD *)v33 = *(_DWORD *)i;
          *(_DWORD *)i = v14;
        }
      }
      else
      {
        v15 = *(_QWORD *)v33;
        *(_QWORD *)v33 = *(_QWORD *)i;
        *(_QWORD *)i = v15;
      }
      v23 = 1;
      v33 += a3;
    }
    v28 = a1 + a2 * a3;
    if ((uint64_t)&v34[-a1] >= v33 - v34)
      v9 = v33 - v34;
    else
      v9 = (unint64_t)&v34[-a1];
    if (v9)
      result = (uint64_t)swapfunc((char *)a1, &v33[-v9], v9, v13, v12);
    if (v31 - i >= v28 - (_QWORD)v31 - a3)
      v8 = v28 - (_QWORD)v31 - a3;
    else
      v8 = v31 - i;
    if (v8)
      result = (uint64_t)swapfunc(v33, (char *)(v28 - v8), v8, v13, v12);
    if (!v23)
    {
      result = _isort_0(a1, a2, a3, a4, a5, (a2 / 4) + 1, v13, v12);
      if ((result & 1) != 0)
        return result;
    }
    v26 = v33 - v34;
    v25 = v31 - i;
    if (v33 - v34 > (unint64_t)(v31 - i))
    {
      if (v25 > a3)
        result = _qsort_0(v28 - v25, v25 / a3, a3, a4, a5, a6);
      if (v26 <= a3)
        return result;
      a2 = v26 / a3;
    }
    else
    {
      if (v26 > a3)
        result = _qsort_0(a1, v26 / a3, a3, a4, a5, a6);
      if (v25 <= a3)
        return result;
      a1 = v28 - v25;
      a2 = v25 / a3;
    }
  }
  return _isort_0(a1, a2, a3, a4, a5, 0, v13, v12);
}

uint64_t _isort_0(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, int (*a5)(uint64_t, char *, char *), int a6, int a7, int a8)
{
  BOOL v9;
  int v10;
  uint64_t v11;
  char *j;
  char *i;
  int v14;
  char v23;

  v14 = 0;
  for (i = (char *)(a1 + a3); (unint64_t)i < a1 + a2 * a3; i += a3)
  {
    for (j = i; ; j -= a3)
    {
      v9 = 0;
      if ((unint64_t)j > a1)
        v9 = a5(a4, &j[-a3], j) > 0;
      if (!v9)
        break;
      if (a7)
      {
        if (a8)
        {
          swapfunc(j, &j[-a3], a3, a7, a8);
        }
        else
        {
          v10 = *(_DWORD *)j;
          *(_DWORD *)j = *(_DWORD *)&j[-a3];
          *(_DWORD *)&j[-a3] = v10;
        }
      }
      else
      {
        v11 = *(_QWORD *)j;
        *(_QWORD *)j = *(_QWORD *)&j[-a3];
        *(_QWORD *)&j[-a3] = v11;
      }
      if (a6)
      {
        if (++v14 > a6)
        {
          v23 = 0;
          return v23 & 1;
        }
      }
    }
  }
  v23 = 1;
  return v23 & 1;
}

uint64_t med3_0(uint64_t a1, uint64_t a2, uint64_t a3, int (*a4)(uint64_t, uint64_t, uint64_t), uint64_t a5)
{
  if (a4(a5, a1, a2) >= 0)
  {
    if (a4(a5, a2, a3) > 0)
      return a2;
    if (a4(a5, a1, a3) >= 0)
      return a3;
    else
      return a1;
  }
  else
  {
    if (a4(a5, a2, a3) < 0)
      return a2;
    if (a4(a5, a1, a3) >= 0)
      return a1;
    else
      return a3;
  }
}

int radixsort(const unsigned __int8 **__base, int __nel, const unsigned __int8 *__table, unsigned int __endbyte)
{
  unsigned int i;
  int j;
  unsigned int v7;
  _BYTE v9[256];

  if (!__table)
  {
    for (i = 0; i < __endbyte; ++i)
      v9[i] = i + 1;
    v9[i] = 0;
    for (j = i + 1; j < 256; ++j)
      v9[j] = j;
    r_sort_a((uint64_t)__base, __nel, 0, (uint64_t)v9, 0);
    return 0;
  }
  v7 = __table[__endbyte];
  if (!__table[__endbyte] || v7 == 255)
  {
    r_sort_a((uint64_t)__base, __nel, 0, (uint64_t)__table, v7);
    return 0;
  }
  *__error() = 22;
  return -1;
}

uint64_t r_sort_a(uint64_t a1, int a2, int a3, uint64_t a4, unsigned int a5)
{
  uint64_t result;
  uint64_t *v6;
  int *v7;
  int v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t **v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  int *v17;
  __int128 v18;
  uint64_t *v19;
  __int128 *v20;
  uint64_t *v21;
  uint64_t i;
  uint64_t *v23;
  uint64_t *v24;
  int v25;
  int v26;
  unsigned int v30;
  int v32;
  uint64_t *v34;
  unsigned __int8 *m;
  unsigned __int8 *v36;
  uint64_t v37;
  uint64_t *k;
  uint64_t *j;
  unsigned __int8 v40;
  int v41;
  _QWORD v42[256];
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;

  _platform_bzero(v42, 512);
  result = pthread_once(&r_sort_count_control, (void (*)(void))r_sort_count_allocate);
  if (!(_DWORD)result)
  {
    r_sort_a_count = r_sort_a_count;
    v43 = a1;
    v44 = a2;
    v21 = &v46;
    v45 = a3;
    while (&v43 < v21)
    {
      v21 -= 2;
      v34 = (uint64_t *)*v21;
      v32 = *((_DWORD *)v21 + 2);
      v30 = *((_DWORD *)v21 + 3);
      if (v32 >= 20)
      {
        v15 = (unint64_t)&v34[v32];
        if (r_sort_a_nc)
          goto LABEL_29;
        r_sort_a_bmin = 255;
        v23 = v34;
        while ((unint64_t)v23 < v15)
        {
          v6 = v23++;
          v25 = *(unsigned __int8 *)(a4 + *(unsigned __int8 *)(*v6 + (int)v30));
          v7 = (int *)(r_sort_a_count + 4 * *(unsigned __int8 *)(a4 + *(unsigned __int8 *)(*v6 + (int)v30)));
          v8 = *v7 + 1;
          *v7 = v8;
          if (v8 == 1 && v25 != a5)
          {
            if (v25 < r_sort_a_bmin)
              r_sort_a_bmin = v25;
            ++r_sort_a_nc;
          }
        }
        if (&v21[2 * r_sort_a_nc] <= &v47)
        {
LABEL_29:
          if (r_sort_a_nc == 1 && *(_DWORD *)(r_sort_a_count + 4 * r_sort_a_bmin) == v32)
          {
            *v21 = (uint64_t)v34;
            *((_DWORD *)v21 + 2) = v32;
            v9 = v21;
            v21 += 2;
            *((_DWORD *)v9 + 3) = v30 + 1;
            *(_DWORD *)(r_sort_a_count + 4 * r_sort_a_bmin) = 0;
            r_sort_a_nc = 0;
          }
          else
          {
            v19 = v21;
            v20 = (__int128 *)v21;
            v16 = 2;
            if (a5)
            {
              v24 = v34;
              v42[255] = &v34[v32];
            }
            else
            {
              v24 = &v34[*(int *)r_sort_a_count];
              v42[0] = v24;
            }
            v17 = (int *)(r_sort_a_count + 4 * r_sort_a_bmin);
            while (r_sort_a_nc > 0)
            {
              while (!*v17)
                ++v17;
              if (*v17 > 1)
              {
                if (*v17 > v16)
                {
                  v16 = *v17;
                  v19 = v21;
                }
                *v21 = (uint64_t)v24;
                *((_DWORD *)v21 + 2) = *v17;
                v10 = v21;
                v21 += 2;
                *((_DWORD *)v10 + 3) = v30 + 1;
              }
              v24 += *v17;
              v42[((uint64_t)v17 - r_sort_a_count) / 4] = v24;
              --r_sort_a_nc;
              ++v17;
            }
            v18 = *v20;
            *v20 = *(_OWORD *)v19;
            *(_OWORD *)v19 = v18;
            v13 = v34;
            while ((unint64_t)v13 < v15)
            {
              for (i = *v13; ; i = v14)
              {
                v26 = *(unsigned __int8 *)(a4 + *(unsigned __int8 *)(i + (int)v30));
                v11 = (uint64_t **)&v42[*(unsigned __int8 *)(a4 + *(unsigned __int8 *)(i + (int)v30))];
                v12 = *v11 - 1;
                *v11 = v12;
                if (v13 >= v12)
                  break;
                v14 = *v12;
                *v12 = i;
              }
              *v13 = i;
              v13 += *(int *)(r_sort_a_count + 4 * v26);
              *(_DWORD *)(r_sort_a_count + 4 * v26) = 0;
            }
          }
        }
        else
        {
          result = r_sort_a(v34, v32, v30, a4, a5);
        }
      }
      else
      {
        v41 = *((_DWORD *)v21 + 2);
        for (j = v34 + 1; --v41 >= 1; ++j)
        {
          for (k = j; k > v34; --k)
          {
            v36 = (unsigned __int8 *)(*k + (int)v30);
            for (m = (unsigned __int8 *)(*(k - 1) + (int)v30); ; ++m)
            {
              v40 = *(_BYTE *)(a4 + *v36);
              if (v40 == a5 || v40 != *(unsigned __int8 *)(a4 + *m))
                break;
              ++v36;
            }
            if (v40 >= (int)*(unsigned __int8 *)(a4 + *m))
              break;
            v37 = *k;
            *k = *(k - 1);
            *(k - 1) = v37;
          }
        }
      }
    }
  }
  return result;
}

int sradixsort(const unsigned __int8 **__base, int __nel, const unsigned __int8 *__table, unsigned int __endbyte)
{
  unsigned int i;
  int j;
  void *v7;
  const unsigned __int8 *v8;
  unsigned int v9;
  unsigned __int8 *n;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  unsigned __int8 **m;
  const unsigned __int8 **k;
  unsigned __int8 v18;
  int v19;
  _BYTE v20[256];

  if (__table)
  {
    v9 = __table[__endbyte];
    v8 = __table;
    if (__table[__endbyte] && v9 != 255)
    {
      *__error() = 22;
      return -1;
    }
  }
  else
  {
    v8 = v20;
    for (i = 0; i < __endbyte; ++i)
      v20[i] = i + 1;
    v20[i] = 0;
    for (j = i + 1; j < 256; ++j)
      v20[j] = j;
    v9 = 0;
  }
  if (__nel < 20)
  {
    v19 = __nel;
    for (k = __base + 1; --v19 >= 1; ++k)
    {
      for (m = (unsigned __int8 **)k; m > (unsigned __int8 **)__base; --m)
      {
        v14 = *m;
        for (n = *(m - 1); ; ++n)
        {
          v18 = v8[*v14];
          if (v18 == v9 || v18 != v8[*n])
            break;
          ++v14;
        }
        if (v18 >= (int)v8[*n])
          break;
        v15 = *m;
        *m = *(m - 1);
        *(m - 1) = v15;
      }
    }
    return 0;
  }
  v7 = (void *)malloc_type_malloc(8 * __nel, 0x80040B8603338);
  if (v7)
  {
    r_sort_b((uint64_t)__base, (unint64_t)v7, __nel, 0, (uint64_t)v8, v9);
    free(v7);
    return 0;
  }
  return -1;
}

uint64_t r_sort_b(uint64_t a1, unint64_t a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  uint64_t result;
  int *v7;
  int v8;
  unint64_t *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  int v13;
  int *v14;
  __int128 v15;
  unint64_t *v16;
  unint64_t *v17;
  unint64_t *v18;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  _QWORD *v22;
  uint64_t *v23;
  int v24;
  int v25;
  unsigned int v29;
  int v31;
  unint64_t v34;
  unsigned __int8 *k;
  unsigned __int8 *v36;
  uint64_t v37;
  uint64_t *j;
  uint64_t *i;
  unsigned __int8 v40;
  int v41;
  _QWORD v42[256];
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;

  _platform_bzero(v42, 512);
  result = pthread_once(&r_sort_count_control, (void (*)(void))r_sort_count_allocate);
  if (!(_DWORD)result)
  {
    r_sort_b_count = r_sort_b_count;
    v43 = a1;
    v44 = a3;
    v18 = (unint64_t *)&v46;
    v45 = a4;
    while (&v43 < (uint64_t *)v18)
    {
      v18 -= 2;
      v34 = *v18;
      v31 = *((_DWORD *)v18 + 2);
      v29 = *((_DWORD *)v18 + 3);
      if (v31 >= 20)
      {
        if (r_sort_b_nc)
          goto LABEL_28;
        r_sort_b_bmin = 255;
        v20 = (_QWORD *)(v34 + 8 * v31);
        while ((unint64_t)--v20 >= v34)
        {
          v24 = *(unsigned __int8 *)(a5 + *(unsigned __int8 *)(*v20 + (int)v29));
          v7 = (int *)(r_sort_b_count + 4 * *(unsigned __int8 *)(a5 + *(unsigned __int8 *)(*v20 + (int)v29)));
          v8 = *v7 + 1;
          *v7 = v8;
          if (v8 == 1 && v24 != a6)
          {
            if (v24 < r_sort_b_bmin)
              r_sort_b_bmin = v24;
            ++r_sort_b_nc;
          }
        }
        if (&v18[2 * r_sort_b_nc] <= (unint64_t *)&v47)
        {
LABEL_28:
          v16 = v18;
          v17 = v18;
          v13 = 2;
          if (a6)
          {
            v21 = v34;
            v42[255] = v34 + 8 * v31;
            *(_DWORD *)(r_sort_b_count + 1020) = 0;
          }
          else
          {
            v21 = v34 + 8 * *(int *)r_sort_b_count;
            v42[0] = v21;
            *(_DWORD *)r_sort_b_count = 0;
          }
          v14 = (int *)(r_sort_b_count + 4 * r_sort_b_bmin);
          while (r_sort_b_nc > 0)
          {
            while (!*v14)
              ++v14;
            v25 = *v14;
            if (*v14 > 1)
            {
              if (v25 > v13)
              {
                v13 = *v14;
                v16 = v18;
              }
              *v18 = v21;
              *((_DWORD *)v18 + 2) = v25;
              v9 = v18;
              v18 += 2;
              *((_DWORD *)v9 + 3) = v29 + 1;
            }
            v21 += 8 * v25;
            v42[((uint64_t)v14 - r_sort_b_count) / 4] = v21;
            *v14 = 0;
            --r_sort_b_nc;
            ++v14;
          }
          v15 = *(_OWORD *)v17;
          *(_OWORD *)v17 = *(_OWORD *)v16;
          *(_OWORD *)v16 = v15;
          v22 = (_QWORD *)(a2 + 8 * v31);
          v19 = (_QWORD *)(v34 + 8 * v31);
          while ((unint64_t)v22 > a2)
            *--v22 = *--v19;
          v23 = (uint64_t *)(a2 + 8 * v31);
          while ((unint64_t)--v23 >= a2)
          {
            v10 = *v23;
            v11 = &v42[*(unsigned __int8 *)(a5 + *(unsigned __int8 *)(*v23 + (int)v29))];
            v12 = (_QWORD *)(*v11 - 8);
            *v11 = v12;
            *v12 = v10;
          }
        }
        else
        {
          result = r_sort_b(v34, a2, v31, v29, a5, a6);
        }
      }
      else
      {
        v41 = *((_DWORD *)v18 + 2);
        for (i = (uint64_t *)(v34 + 8); --v41 >= 1; ++i)
        {
          for (j = i; (unint64_t)j > v34; --j)
          {
            v36 = (unsigned __int8 *)(*j + (int)v29);
            for (k = (unsigned __int8 *)(*(j - 1) + (int)v29); ; ++k)
            {
              v40 = *(_BYTE *)(a5 + *v36);
              if (v40 == a6 || v40 != *(unsigned __int8 *)(a5 + *k))
                break;
              ++v36;
            }
            if (v40 >= (int)*(unsigned __int8 *)(a5 + *k))
              break;
            v37 = *j;
            *j = *(j - 1);
            *(j - 1) = v37;
          }
        }
      }
    }
  }
  return result;
}

uint64_t r_sort_count_allocate()
{
  uint64_t result;

  r_sort_a_count = malloc_type_calloc(256, 4, 0x100004052888210);
  result = malloc_type_calloc(256, 4, 0x100004052888210);
  r_sort_b_count = result;
  return result;
}

int rand_r(unsigned int *a1)
{
  int result;
  unint64_t v2;
  unsigned int *v3;

  v3 = a1;
  v2 = 0;
  v2 = *a1;
  result = do_rand(&v2);
  *v3 = v2;
  return result;
}

unint64_t do_rand(unint64_t *a1)
{
  int64_t v2;
  unint64_t v3;

  if (!*a1)
    *a1 = 123459876;
  v2 = 16807 * (*a1 % 0x1F31D) - 2836 * (*a1 / 0x1F31D);
  v3 = v2 + (v2 < 0 ? 0x7FFFFFFFuLL : 0);
  *a1 = v3;
  return v3 % 0x80000000;
}

int rand(void)
{
  return do_rand((unint64_t *)&next);
}

void srand(unsigned int a1)
{
  next = a1;
}

void sranddev(void)
{
  pid_t v0;
  timeval v1;
  _BOOL4 v2;
  int v3;

  v2 = 0;
  v3 = open_NOCANCEL("/dev/random", 0x1000000);
  if (v3 >= 0)
  {
    v2 = read_NOCANCEL(v3, &next, 8) == 8;
    close_NOCANCEL(v3);
  }
  if (!v2)
  {
    v1.tv_sec = 0;
    *(_QWORD *)&v1.tv_usec = 0;
    gettimeofday(&v1, 0);
    v0 = getpid();
    srand((v0 << 16) ^ LODWORD(v1.tv_sec) ^ v1.tv_usec);
  }
}

void srandom(unsigned int a1)
{
  int v1;
  int i;
  int j;

  *state = a1;
  if (rand_type)
  {
    for (i = 1; i < rand_deg; ++i)
      state[i] = good_rand(state[i - 1]);
    fptr = &state[rand_sep];
    rptr = state;
    v1 = 10 * rand_deg;
  }
  else
  {
    v1 = 50;
  }
  for (j = 0; j < v1; ++j)
    random();
}

uint64_t good_rand(int a1)
{
  int v2;
  int v3;

  v2 = a1;
  if (!a1)
    v2 = 123459876;
  v3 = 16807 * (v2 % 127773) - 2836 * (v2 / 127773);
  return v3 + (v3 < 0 ? 0x7FFFFFFF : 0);
}

uint64_t random(void)
{
  int *v1;
  int *v2;
  _DWORD *v3;
  int *v4;
  unsigned int v5;

  if (rand_type)
  {
    v3 = fptr;
    v1 = rptr;
    *(_DWORD *)fptr += *rptr;
    v5 = (*v3 >> 1) & 0x7FFFFFFF;
    v4 = v3 + 1;
    if (v4 < (int *)end_ptr)
    {
      v2 = v1 + 1;
      if (v2 >= (int *)end_ptr)
        v2 = state;
    }
    else
    {
      v4 = state;
      v2 = v1 + 1;
    }
    fptr = v4;
    rptr = v2;
  }
  else
  {
    v5 = good_rand(*state) & 0x7FFFFFFF;
    *state = v5;
  }
  return v5;
}

void srandomdev(void)
{
  pid_t v0;
  timeval v1;
  uint64_t v2;
  _BOOL4 v3;
  int v4;

  v4 = 0;
  v3 = 0;
  v2 = 0;
  if (rand_type)
    v2 = 4 * rand_deg;
  else
    v2 = 4;
  v3 = 0;
  v4 = open_NOCANCEL("/dev/random", 0x1000000);
  if (v4 >= 0)
  {
    v3 = read_NOCANCEL(v4, state, v2) == v2;
    close_NOCANCEL(v4);
  }
  if (v3)
  {
    if (rand_type)
    {
      fptr = &state[rand_sep];
      rptr = state;
    }
  }
  else
  {
    v1.tv_sec = 0;
    *(_QWORD *)&v1.tv_usec = 0;
    gettimeofday(&v1, 0);
    v0 = getpid();
    srandom((v0 << 16) ^ LODWORD(v1.tv_sec) ^ v1.tv_usec);
  }
}

char *__cdecl initstate(unsigned int a1, char *a2, size_t a3)
{
  char *v5;

  v5 = (char *)(state - 1);
  if (rand_type)
    *(state - 1) = 5 * (rptr - state) + rand_type;
  else
    *(state - 1) = 0;
  if (a3 >= 8)
  {
    if (a3 >= 0x20)
    {
      if (a3 >= 0x40)
      {
        if (a3 >= 0x80)
        {
          if (a3 >= 0x100)
          {
            rand_type = 4;
            rand_deg = 63;
            rand_sep = 1;
          }
          else
          {
            rand_type = 3;
            rand_deg = 31;
            rand_sep = 3;
          }
        }
        else
        {
          rand_type = 2;
          rand_deg = 15;
          rand_sep = 1;
        }
      }
      else
      {
        rand_type = 1;
        rand_deg = 7;
        rand_sep = 3;
      }
    }
    else
    {
      rand_type = 0;
      rand_deg = 0;
      rand_sep = 0;
    }
    state = (int *)(a2 + 4);
    end_ptr = (uint64_t (**)())&a2[4 * rand_deg + 4];
    srandom(a1);
    if (rand_type)
      *(_DWORD *)a2 = 5 * (rptr - state) + rand_type;
    else
      *(_DWORD *)a2 = 0;
    return v5;
  }
  else
  {
    fprintf(__stderrp, "random: not enough state (%ld bytes); ignored.\n", a3);
    return 0;
  }
}

char *__cdecl setstate(const char *a1)
{
  char *v2;
  unsigned int v3;
  unsigned int v4;

  v4 = *(_DWORD *)a1 % 5u;
  v3 = *(_DWORD *)a1 / 5u;
  v2 = (char *)(state - 1);
  if (rand_type)
    *(state - 1) = 5 * (rptr - state) + rand_type;
  else
    *(state - 1) = 0;
  if (v4 > 4)
  {
    fprintf(__stderrp, "random: state info corrupted; not changed.\n");
  }
  else
  {
    rand_type = v4;
    rand_deg = degrees[v4];
    rand_sep = seps[v4];
  }
  state = (int *)(a1 + 4);
  if (rand_type)
  {
    rptr = &state[v3];
    fptr = &state[(v3 + rand_sep) % rand_deg];
  }
  end_ptr = (uint64_t (**)())&state[rand_deg];
  return v2;
}

char *__cdecl realpath(const char *a1, char *a2)
{
  unint64_t v2;
  unsigned int v3;
  unint64_t v5;
  int v6;
  char *v7;
  int v8;
  char *__s;
  __darwin_ino64_t st_ino;
  dev_t st_dev;
  dev_t v12;
  ssize_t v13;
  _BOOL4 v14;
  int v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  stat v23;
  char *v24;
  const char *v25;
  char v27[1024];
  statfs v28;
  char v29[1024];
  _BYTE v30[1024];
  _BYTE v31[1024];
  _BYTE v32[4];
  _DWORD v33[262];

  v25 = a1;
  v24 = a2;
  _platform_bzero(v32, 512);
  _platform_memset(&v23, 0, 144);
  v14 = 0;
  v12 = 0;
  _platform_bzero(&v28, 512);
  st_ino = 0;
  if (!v25)
  {
    *__error() = 22;
    return 0;
  }
  if (!*v25)
  {
    *__error() = 2;
    return 0;
  }
  if (v24)
  {
    __s = v24;
  }
  else
  {
    __s = (char *)malloc_type_malloc(1024, 772935998);
    if (!__s)
      return 0;
  }
  if (!realpath_rootdev_inited)
  {
    realpath_rootdev_inited = 1;
    if (stat("/", &v23) < 0)
      goto LABEL_12;
    realpath_rootdev = v23.st_dev;
  }
  __error();
  v16 = 0;
  if (*v25 == 47)
  {
    *__s = 47;
    __s[1] = 0;
    if (!v25[1])
      return __s;
    v18 = 1;
    v19 = _platform_strlcpy(v31, v25 + 1, 1024);
  }
  else
  {
    if (!__private_getcwd(__s, 1024, 0))
    {
      _platform_strlcpy(__s, ".", 1024);
      goto LABEL_12;
    }
    v18 = _platform_strlen(__s);
    v19 = _platform_strlcpy(v31, v25, 1024);
  }
  if (v19 < 0x400 && v18 < 0x400)
  {
    if (v18 > 1)
    {
      if (stat(__s, &v23) >= 0)
      {
        st_dev = v23.st_dev;
        goto LABEL_30;
      }
      goto LABEL_12;
    }
    st_dev = realpath_rootdev;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            do
            {
LABEL_30:
              if (!v19)
              {
                if (v18 > 1 && __s[v18 - 1] == 47)
                  __s[v18 - 1] = 0;
                return __s;
              }
              v22 = _platform_strchr(v31, 47);
              if (v22)
                v5 = v22 - (_QWORD)v31;
              else
                v5 = v19;
              j___platform_memmove(v30, v31, v5);
              v30[v5] = 0;
              if (v22)
              {
                v19 -= v5 + 1;
                _platform_memmove(v31, v22 + 1, v19 + 1);
              }
              else
              {
                v31[0] = 0;
                v19 = 0;
              }
              if (__s[v18 - 1] != 47)
              {
                if (v18 + 1 >= 0x400)
                  goto LABEL_93;
                v2 = v18++;
                __s[v2] = 47;
                __s[v18] = 0;
              }
            }
            while (!v30[0] || !_platform_strcmp(v30, "."));
            if (_platform_strcmp(v30, ".."))
              break;
            if (v18 > 1)
            {
              __s[v18 - 1] = 0;
              v20 = strrchr(__s, 47) + 1;
              *v20 = 0;
              v18 = v20 - __s;
            }
          }
          v17 = v18;
          v18 = _platform_strlcat(__s, v30, 1024);
          if (v18 >= 0x400)
            goto LABEL_93;
          if (getattrlist(__s, &_rp_alist, v32, 0x41CuLL, 1u))
          {
            if (*__error() == 45 || *__error() == 22)
            {
              v15 = lstat(__s, &v23);
              if (!v15)
              {
                v14 = (v23.st_mode & 0xF000) == 40960;
                v12 = v23.st_dev;
                st_ino = v23.st_ino;
              }
            }
            else
            {
              v15 = -1;
            }
          }
          else
          {
            v15 = 1;
            v14 = v33[3] == 5;
            v12 = v33[2];
            st_ino = v33[4];
          }
          if (v15 < 0)
            goto LABEL_12;
          if (v12 == st_dev)
            break;
          st_dev = v12;
          if (statfs(__s, &v28) || lstat(v28.f_mntonname, &v23) || v12 != v23.st_dev || st_ino != v23.st_ino)
            break;
          v6 = 1;
          _platform_strcpy(v27, v28.f_mntonname);
          do
          {
            v7 = strrchr(v27, 47);
            if (!v7)
            {
              v6 = 0;
              goto LABEL_70;
            }
            if (v7 <= v27)
              goto LABEL_70;
            *v7 = 0;
          }
          while (lstat(v27, &v23) >= 0 && (v23.st_mode & 0xF000) == 0x4000);
          v6 = 0;
LABEL_70:
          if (!v6)
            break;
          v18 = _platform_strlcpy(__s, v28.f_mntonname, 1024);
        }
        if (v14)
          break;
        if (v15)
        {
          __s[v17] = 0;
          v18 = _platform_strlcat(__s, (char *)v33 + v33[0], 1024);
          if (v18 >= 0x400)
            goto LABEL_93;
        }
      }
      v3 = v16++;
      if (v3 > 0x20)
      {
        *__error() = 62;
        goto LABEL_12;
      }
      v13 = readlink(__s, v29, 0x400uLL);
      if (v13 <= 0 || (unint64_t)v13 >= 0x400)
        break;
      v29[v13] = 0;
      if (v29[0] == 47)
      {
        __s[1] = 0;
        v18 = 1;
        st_dev = realpath_rootdev;
      }
      else
      {
        v21 = strrchr(__s, 47) + 1;
        *v21 = 0;
        v18 = v21 - __s;
      }
      if (v22)
      {
        if (v29[v13 - 1] != 47)
        {
          if ((unint64_t)(v13 + 1) >= 0x400)
            goto LABEL_93;
          v29[v13] = 47;
          v29[v13 + 1] = 0;
        }
        if ((unint64_t)_platform_strlcat(v29, v31, 1024) >= 0x400)
          goto LABEL_93;
      }
      v19 = _platform_strlcpy(v31, v29, 1024);
    }
    if (v13 < 0)
      goto LABEL_12;
    if (!v13)
    {
      *__error() = 2;
      goto LABEL_12;
    }
  }
LABEL_93:
  *__error() = 63;
LABEL_12:
  if (!v24)
  {
    v8 = *__error();
    free(__s);
    *__error() = v8;
  }
  return 0;
}

void remque(void *a1)
{
  uint64_t v1;
  _QWORD *v2;

  v2 = (_QWORD *)*((_QWORD *)a1 + 1);
  v1 = *(_QWORD *)a1;
  if (v2)
    *v2 = v1;
  if (v1)
    *(_QWORD *)(v1 + 8) = v2;
}

uint64_t _do_nothing()
{
  return 0;
}

uint64_t _owned_ptr_add(uint64_t a1, unint64_t a2)
{
  uint64_t result;
  int v3;
  int v4;
  unint64_t v5;
  uint64_t v6;

  v6 = a1;
  v5 = a2;
  v4 = 0;
  result = _owned_ptr_search(a1, a2, &v4);
  if ((_DWORD)result)
  {
    if (*(_DWORD *)(v6 + 8) >= *(_DWORD *)(v6 + 12))
    {
      v3 = 2 * *(_DWORD *)(v6 + 12);
      result = malloc_type_realloc(*(_QWORD *)v6, 8 * v3, 0xC0040B8AA526DLL);
      if (!result)
        return result;
      *(_QWORD *)v6 = result;
      *(_DWORD *)(v6 + 12) = v3;
    }
    result = _platform_memmove(*(_QWORD *)v6 + 8 * v4 + 16, *(_QWORD *)v6 + 8 * v4 + 8, 8 * (*(_DWORD *)(v6 + 8) - v4 - 1));
    *(_QWORD *)(*(_QWORD *)v6 + 8 * (v4 + 1)) = v5;
    ++*(_DWORD *)(v6 + 8);
  }
  return result;
}

uint64_t _owned_ptr_search(uint64_t a1, unint64_t a2, int *a3)
{
  int v4;
  int v5;
  int v6;

  v6 = 0;
  v5 = *(_DWORD *)(a1 + 8) - 1;
  if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v5) >= a2)
  {
    if (*(_QWORD *)(*(_QWORD *)a1 + 8 * v5) == a2)
    {
      if (a3)
        *a3 = v5;
      return 0;
    }
    else
    {
      while (v5 - v6 > 1)
      {
        v4 = (v6 + v5) / 2;
        if (a2 <= *(_QWORD *)(*(_QWORD *)a1 + 8 * v4))
        {
          if (a2 >= *(_QWORD *)(*(_QWORD *)a1 + 8 * v4))
          {
            if (a3)
              *a3 = v4;
            return 0;
          }
          v5 = (v6 + v5) / 2;
        }
        else
        {
          v6 = (v6 + v5) / 2;
        }
      }
      if (a3)
        *a3 = v6;
      return -1;
    }
  }
  else
  {
    if (a3)
      *a3 = v5;
    return -1;
  }
}

_DWORD *_owned_ptr_alloc()
{
  int v1;
  _DWORD *v2;

  v2 = (_DWORD *)malloc_type_malloc(16, 0x1080040FC6463CFLL);
  if (!v2)
    return 0;
  *(_QWORD *)v2 = malloc_type_malloc(64, 0xC0040B8AA526DLL);
  if (*(_QWORD *)v2)
  {
    **(_QWORD **)v2 = 0;
    v2[2] = 1;
    v2[3] = 8;
    return v2;
  }
  else
  {
    v1 = *__error();
    free(v2);
    *__error() = v1;
    return 0;
  }
}

uint64_t _owned_ptr_delete(uint64_t result, int a2)
{
  uint64_t v2;

  v2 = result;
  if (a2)
  {
    if (a2 < *(_DWORD *)(result + 8))
    {
      result = _platform_memmove(*(_QWORD *)result + 8 * a2, *(_QWORD *)result + 8 * a2 + 8, 8 * (*(_DWORD *)(result + 8) - a2 - 1));
      --*(_DWORD *)(v2 + 8);
    }
  }
  return result;
}

void _owned_ptr_free(void **a1)
{
  free(*a1);
  free(a1);
}

uint64_t __init__env_owned_locked(int a1)
{
  int v2;

  v2 = 0;
  if (__env_owned)
  {
    return 0;
  }
  else
  {
    if (!a1)
      v2 = *__error();
    __env_owned = (uint64_t)_owned_ptr_alloc();
    if (__env_owned)
    {
      return 0;
    }
    else
    {
      if (!a1)
        *__error() = v2;
      return -1;
    }
  }
}

uint64_t __setenv_locked(char *a1, unsigned __int8 *a2, int a3, int a4, char ***a5, uint64_t a6)
{
  unsigned __int8 *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  unsigned __int8 *v12;
  char *v13;
  BOOL v15;
  int v16;
  BOOL v17;
  uint64_t v18;
  _QWORD *v19;
  void *v20;
  void *v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  void *v26;
  int v27;
  int v28;
  char *i;
  uint64_t v30;
  const void **v31;
  int v32;
  int v33;
  unsigned __int8 *v34;
  char *v35;

  v35 = a1;
  v34 = a2;
  v33 = a3;
  v32 = a4;
  v31 = (const void **)a5;
  v30 = a6;
  i = 0;
  v28 = 0;
  v27 = 0;
  i = __findenv_locked(a1, &v28, *a5);
  if (!i)
  {
    v19 = *v31;
    v22 = 0;
    while (*v19)
    {
      ++v19;
      ++v22;
    }
    if (_owned_ptr_search(v30, (unint64_t)*v31, &v27))
    {
      v21 = (void *)malloc_type_malloc(8 * (v22 + 2), 2308706146);
      if (!v21)
        return -1;
      _owned_ptr_add(v30, (unint64_t)v21);
      bcopy(*v31, v21, 8 * v22);
      *v31 = v21;
    }
    else
    {
      v20 = (void *)malloc_type_realloc(*v31, 8 * (v22 + 2), 586480216);
      if (!v20)
        return -1;
      if (*v31 != v20)
      {
        _owned_ptr_delete(v30, v27);
        _owned_ptr_add(v30, (unint64_t)v20);
        *v31 = v20;
      }
    }
    *((_QWORD *)*v31 + v22 + 1) = 0;
    v28 = v22;
    goto LABEL_28;
  }
  if (!v33)
    return 0;
  v26 = (void *)*((_QWORD *)*v31 + v28);
  if (_owned_ptr_search(v30, (unint64_t)v26, &v27))
  {
LABEL_28:
    if (v32 <= 0)
    {
      if (v32 < 0)
      {
        v18 = _platform_strlen(v35);
        i = (char *)malloc_type_malloc(v18 + 1, 3599397277);
        if (!i)
          return -1;
        _owned_ptr_add(v30, (unint64_t)i);
        j___platform_memmove(i, v35, v18 + 1);
        v35 = i;
      }
      *((_QWORD *)*v31 + v28) = v35;
    }
    else
    {
      for (i = v35; ; ++i)
      {
        v17 = 0;
        if (*i)
          v17 = *i != 61;
        if (!v17)
          break;
      }
      v16 = (_DWORD)i - (_DWORD)v35;
      v8 = _platform_strlen(v34);
      v9 = malloc_type_malloc(v8 + v16 + 2, 1461358959);
      *((_QWORD *)*v31 + v28) = v9;
      if (!v9)
        return -1;
      _owned_ptr_add(v30, *((_QWORD *)*v31 + v28));
      for (i = (char *)*((_QWORD *)*v31 + v28); ; ++i)
      {
        v10 = v35++;
        LODWORD(v10) = *v10;
        *i = (char)v10;
        v15 = 0;
        if ((_DWORD)v10)
          v15 = *i != 61;
        if (!v15)
          break;
      }
      v11 = i++;
      *v11 = 61;
      do
      {
        v12 = v34++;
        LODWORD(v12) = *v12;
        v13 = i++;
        *v13 = (char)v12;
      }
      while ((_DWORD)v12);
    }
    return 0;
  }
  if (v32 <= 0)
  {
    _owned_ptr_delete(v30, v27);
    free(v26);
    goto LABEL_28;
  }
  v25 = _platform_strlen(v34);
  if (_platform_strlen(i) < v25)
  {
    v23 = i - (_BYTE *)v26;
    v24 = malloc_type_realloc(v26, v25 + i - (_BYTE *)v26 + 1, 1726151774);
    if (!v24)
      return -1;
    if ((void *)v24 != v26)
    {
      *((_QWORD *)*v31 + v28) = v24;
      i = (char *)(v24 + v23);
      _owned_ptr_delete(v30, v27);
      _owned_ptr_add(v30, v24);
    }
  }
  do
  {
    v6 = v34++;
    LODWORD(v6) = *v6;
    v7 = i++;
    *v7 = (char)v6;
  }
  while ((_DWORD)v6);
  return 0;
}

_BYTE *__unsetenv_locked(_BYTE *a1, char **a2, uint64_t a3)
{
  _BYTE *result;
  char *v4;
  int v5;
  int v6;
  char **i;
  uint64_t v8;
  char **v9;
  _BYTE *v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  i = 0;
  v6 = 0;
  v5 = 0;
  while (1)
  {
    result = __findenv_locked(v10, &v6, v9);
    if (!result)
      break;
    if (!_owned_ptr_search(v8, (unint64_t)v9[v6], &v5))
    {
      _owned_ptr_delete(v8, v5);
      free(v9[v6]);
    }
    for (i = &v9[v6]; ; ++i)
    {
      v4 = i[1];
      *i = v4;
      if (!v4)
        break;
    }
  }
  return result;
}

_DWORD *_allocenvstate()
{
  return _owned_ptr_alloc();
}

_QWORD *_copyenv(_QWORD *a1)
{
  int v2;
  _QWORD *i;
  _QWORD *v4;

  v2 = 1;
  if (a1)
  {
    for (i = a1; *i; ++i)
      ++v2;
  }
  v4 = (_QWORD *)malloc_type_malloc(8 * v2, 1182616727);
  if (!v4)
    return 0;
  if (a1)
    bcopy(a1, v4, 8 * v2);
  else
    *v4 = 0;
  return v4;
}

uint64_t _deallocenvstate(void **a1)
{
  if (a1 && a1 != (void **)__env_owned)
  {
    _owned_ptr_free(a1);
    return 0;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t _setenvp(char *a1, unsigned __int8 *a2, int a3, char ***a4, uint64_t a5)
{
  unsigned int v5;
  unsigned int v7;

  environ_lock_np();
  if (__init__env_owned_locked(1))
  {
    environ_unlock_np();
    return -1;
  }
  else
  {
    if (a5)
      v5 = __setenv_locked(a1, a2, a3, 1, a4, a5);
    else
      v5 = __setenv_locked(a1, a2, a3, 1, a4, __env_owned);
    v7 = v5;
    environ_unlock_np();
    return v7;
  }
}

uint64_t _unsetenvp(_BYTE *a1, char ***a2, uint64_t a3)
{
  char **v4;

  environ_lock_np();
  if (__init__env_owned_locked(1))
  {
    environ_unlock_np();
    return -1;
  }
  else
  {
    v4 = *a2;
    if (a3)
      __unsetenv_locked(a1, v4, a3);
    else
      __unsetenv_locked(a1, v4, __env_owned);
    environ_unlock_np();
    return 0;
  }
}

int setenv(const char *__name, const char *__value, int __overwrite)
{
  char ***v3;
  int v5;

  if (__name && *__name && !_platform_strchr(__name, 61))
  {
    environ_lock_np();
    if (__init__env_owned_locked(1))
    {
      environ_unlock_np();
      return -1;
    }
    else
    {
      v3 = _NSGetEnviron();
      v5 = __setenv_locked((char *)__name, (unsigned __int8 *)__value, __overwrite, 1, v3, __env_owned);
      environ_unlock_np();
      return v5;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int unsetenv(const char *a1)
{
  char ***v1;

  if (a1 && *a1 && !_platform_strchr(a1, 61))
  {
    environ_lock_np();
    if (__init__env_owned_locked(1))
    {
      environ_unlock_np();
      return -1;
    }
    else
    {
      v1 = _NSGetEnviron();
      __unsetenv_locked(a1, *v1, __env_owned);
      environ_unlock_np();
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

hash_table *__cdecl hash_create(int size)
{
  uint64_t v1;
  hash_table *v3;
  int i;

  v3 = (hash_table *)malloc_type_malloc(16, 0x10800407411B482);
  if (!v3 || size < 0)
    return 0;
  if (!size)
    size = 97;
  v1 = malloc_type_malloc(8 * size, 0x2004093837F09);
  v3->buckets = (hash_node **)v1;
  if (!v1)
    return 0;
  for (i = 0; i < size; ++i)
    v3->buckets[i] = 0;
  v3->size = size;
  return v3;
}

void hash_destroy(hash_table *table, char *key, void (__cdecl *nukefunc)(char *, void *))
{
  hash_node *next;
  hash_node *v4;
  int v5;

  v5 = _hash(table->size, (unsigned __int8 *)key);
  v4 = table->buckets[v5];
  next = 0;
  if (!v4)
    return;
  if (!_platform_strcmp(v4->key, key))
  {
    table->buckets[v5] = v4->next;
    next = v4;
LABEL_9:
    if (nukefunc)
      ((void (*)(char *, void *))nukefunc)(next->key, next->data);
    free(next);
    return;
  }
  while (v4->next)
  {
    if (!_platform_strcmp(v4->next->key, key))
    {
      next = v4->next;
      v4->next = next->next;
      break;
    }
    v4 = v4->next;
  }
  if (next)
    goto LABEL_9;
}

uint64_t _hash(unsigned int a1, unsigned __int8 *a2)
{
  unsigned __int8 *v2;
  unsigned int v4;

  v4 = 0;
  while (*a2)
  {
    v2 = a2++;
    v4 ^= *v2 ^ (2 * v4);
  }
  return v4 % a1;
}

void *__cdecl hash_search(hash_table *table, char *key, void *datum, void (__cdecl *replace_func)(void *))
{
  hash_node *v5;
  _QWORD *v6;
  int v7;

  v7 = _hash(table->size, (unsigned __int8 *)key);
  v6 = list_find((uint64_t)key, &table->buckets[v7]->key);
  if (v6)
  {
    if (!replace_func)
      return (void *)v6[1];
    ((void (*)(_QWORD))replace_func)(v6[1]);
    v6[1] = datum;
    return 0;
  }
  if (!datum)
    return 0;
  v5 = (hash_node *)malloc_type_malloc(24, 0xB0040E10B54BDLL);
  if (!v5 || !assign_key(key, &v5->key))
    return 0;
  v5->data = datum;
  v5->next = table->buckets[v7];
  table->buckets[v7] = v5;
  return v5;
}

_QWORD *list_find(uint64_t a1, _QWORD *a2)
{
  while (a2)
  {
    if (!_platform_strcmp(*a2, a1))
      return a2;
    a2 = (_QWORD *)a2[2];
  }
  return 0;
}

uint64_t assign_key(const char *a1, char **a2)
{
  uint64_t v2;
  uint64_t v3;

  if (a2 && a1)
  {
    v2 = _platform_strlen(a1);
    v3 = malloc_type_malloc(v2 + 1, 3819558549);
    *a2 = (char *)v3;
    if (v3)
    {
      **a2 = 0;
      strcat(*a2, a1);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

void hash_traverse(hash_table *table, int (__cdecl *func)(char *, void *, void *), void *arg)
{
  hash_node *j;
  int size;
  int i;

  size = table->size;
  if (func)
  {
    for (i = 0; i < size; ++i)
    {
      for (j = table->buckets[i]; j; j = j->next)
      {
        if (!((unsigned int (*)(char *, void *, void *))func)(j->key, j->data, arg))
          return;
      }
    }
  }
}

void hash_purge(hash_table *table, void (__cdecl *purge_func)(char *, void *))
{
  hash_node *v2;
  hash_node *v3;
  int size;
  int i;

  size = table->size;
  for (i = 0; i < size; ++i)
  {
    v3 = table->buckets[i];
    if (v3)
    {
      do
      {
        v2 = v3;
        if (purge_func)
          ((void (*)(char *, void *))purge_func)(v3->key, v3->data);
        v3 = v3->next;
        free(v2);
      }
      while (v3);
      table->buckets[i] = 0;
    }
  }
}

uint64_t hash_stats(int *a1, int a2)
{
  const char *v2;
  uint64_t result;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int i;

  v12 = 0;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v7 = *a1;
  v8 = malloc_type_malloc(4 * *a1, 0x100004052888210);
  if (!v8)
  {
    fprintf(__stderrp, "malloc returns 0\n");
    exit(1);
  }
  for (i = 0; i < v7; ++i)
  {
    v6 = 0;
    v5 = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * i);
    *(_DWORD *)(v8 + 4 * i) = 0;
    while (v5)
    {
      if (!v6)
      {
        v6 = 1;
        ++v11;
        if (a2)
          printf("bucket %2d: ", i);
      }
      if (a2)
        printf(" %s", *(const char **)v5);
      ++*(_DWORD *)(v8 + 4 * i);
      v5 = *(_QWORD *)(v5 + 16);
    }
    v12 += *(_DWORD *)(v8 + 4 * i);
    if (*(_DWORD *)(v8 + 4 * i) <= v10)
    {
      if (*(_DWORD *)(v8 + 4 * i) == v10)
        ++v9;
    }
    else
    {
      v10 = *(_DWORD *)(v8 + 4 * i);
      v9 = 1;
    }
    if (*(_DWORD *)(v8 + 4 * i) && a2)
      printf(" (%d)\n", *(_DWORD *)(v8 + 4 * i));
  }
  printf("\n");
  v2 = (const char *)&unk_D495D;
  if (v12 != 1)
    v2 = "s";
  result = printf("%d element%s in storage.\n", v12, v2);
  if (v12)
  {
    printf("%d of %d (%.2f%%) buckets are in use\n", v11, v7, 100.0 * (double)v11 / (double)v7);
    printf("the maximum number of elements in a bucket is %d (%d times)\n", v10, v9);
    printf("average per bucket is %f\n", (double)v12 / (double)v11);
    if (v7 >= v12)
      v4 = v12;
    else
      v4 = v7;
    return printf("optimal would be %f\n", (double)v12 / (double)v4);
  }
  return result;
}

intmax_t strtoimax_l(const char *nptr, char **endptr, int base, locale_t a4)
{
  const char *v4;
  const char *v5;
  const char *v6;
  int v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  char *v12;
  int v13;
  int v14;
  int v15;
  unint64_t v16;
  char v17;
  char v18;
  unint64_t v19;
  const char *v20;
  _xlocale *v21;

  v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v21 = (_xlocale *)__global_locale;
  }
  else
  {
    v21 = (_xlocale *)&__c_locale;
  }
  v20 = nptr;
  do
  {
    v4 = v20++;
    v17 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v21));
  if (v17 == 45)
  {
    v15 = 1;
    v5 = v20++;
    v17 = *v5;
  }
  else
  {
    v15 = 0;
    if (v17 == 43)
    {
      v6 = v20++;
      v17 = *v6;
    }
  }
  if ((!base || base == 16)
    && v17 == 48
    && (*v20 == 120 || *v20 == 88)
    && (v20[1] >= 48 && v20[1] <= 57 || v20[1] >= 65 && v20[1] <= 70 || v20[1] >= 97 && v20[1] <= 102))
  {
    v17 = v20[1];
    v20 += 2;
    base = 16;
  }
  if (!base)
  {
    if (v17 == 48)
      v7 = 8;
    else
      v7 = 10;
    base = v7;
  }
  v14 = 0;
  v19 = 0;
  if (base < 2 || base > 36)
    goto LABEL_57;
  v8 = 0x8000000000000000;
  if (!v15)
    v8 = 0x7FFFFFFFFFFFFFFFLL;
  v13 = v8 % base;
  v16 = v8 / base;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      v18 = v17 - 48;
      goto LABEL_44;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      v18 = v17 - 55;
      goto LABEL_44;
    }
    if (v17 < 97 || v17 > 122)
      break;
    v18 = v17 - 87;
LABEL_44:
    if (v18 >= base)
      break;
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      v14 = -1;
    }
    else
    {
      v14 = 1;
      v19 = v19 * base + v18;
    }
    v9 = v20++;
    v17 = *v9;
  }
  if (v14 < 0)
  {
    v10 = 0x8000000000000000;
    if (!v15)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    v19 = v10;
    *__error() = 34;
    goto LABEL_60;
  }
  if (!v14)
  {
LABEL_57:
    *__error() = 22;
    goto LABEL_60;
  }
  if (v15)
    v19 = -(uint64_t)v19;
LABEL_60:
  if (endptr)
  {
    if (v14)
      v12 = (char *)(v20 - 1);
    else
      v12 = (char *)nptr;
    *endptr = v12;
  }
  return v19;
}

intmax_t strtoimax(const char *__nptr, char **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strtoimax_l(__nptr, __endptr, __base, v9);
  else
    return strtoimax_l(__nptr, __endptr, __base, (locale_t)__global_locale);
}

uint64_t strtol_l(const char *a1, char **a2, int a3, locale_t a4)
{
  const char *v4;
  const char *v5;
  const char *v6;
  int v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  char *v12;
  int v13;
  int v14;
  int v15;
  unint64_t v16;
  char v17;
  char v18;
  unint64_t v19;
  const char *v20;
  _xlocale *v21;

  v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v21 = (_xlocale *)__global_locale;
  }
  else
  {
    v21 = (_xlocale *)&__c_locale;
  }
  v20 = a1;
  do
  {
    v4 = v20++;
    v17 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v21));
  if (v17 == 45)
  {
    v15 = 1;
    v5 = v20++;
    v17 = *v5;
  }
  else
  {
    v15 = 0;
    if (v17 == 43)
    {
      v6 = v20++;
      v17 = *v6;
    }
  }
  if ((!a3 || a3 == 16)
    && v17 == 48
    && (*v20 == 120 || *v20 == 88)
    && (v20[1] >= 48 && v20[1] <= 57 || v20[1] >= 65 && v20[1] <= 70 || v20[1] >= 97 && v20[1] <= 102))
  {
    v17 = v20[1];
    v20 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v17 == 48)
      v7 = 8;
    else
      v7 = 10;
    a3 = v7;
  }
  v14 = 0;
  v19 = 0;
  if (a3 < 2 || a3 > 36)
    goto LABEL_57;
  v8 = 0x8000000000000000;
  if (!v15)
    v8 = 0x7FFFFFFFFFFFFFFFLL;
  v13 = v8 % a3;
  v16 = v8 / a3;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      v18 = v17 - 48;
      goto LABEL_44;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      v18 = v17 - 55;
      goto LABEL_44;
    }
    if (v17 < 97 || v17 > 122)
      break;
    v18 = v17 - 87;
LABEL_44:
    if (v18 >= a3)
      break;
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      v14 = -1;
    }
    else
    {
      v14 = 1;
      v19 = v19 * a3 + v18;
    }
    v9 = v20++;
    v17 = *v9;
  }
  if (v14 < 0)
  {
    v10 = 0x8000000000000000;
    if (!v15)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    v19 = v10;
    *__error() = 34;
    goto LABEL_60;
  }
  if (!v14)
  {
LABEL_57:
    *__error() = 22;
    goto LABEL_60;
  }
  if (v15)
    v19 = -(uint64_t)v19;
LABEL_60:
  if (a2)
  {
    if (v14)
      v12 = (char *)(v20 - 1);
    else
      v12 = (char *)a1;
    *a2 = v12;
  }
  return v19;
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strtol_l(__str, __endptr, __base, v9);
  else
    return strtol_l(__str, __endptr, __base, (locale_t)__global_locale);
}

uint64_t strtoll_l(const char *a1, char **a2, int a3, locale_t a4)
{
  const char *v4;
  const char *v5;
  const char *v6;
  int v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  char *v12;
  int v13;
  int v14;
  int v15;
  unint64_t v16;
  char v17;
  char v18;
  unint64_t v19;
  const char *v20;
  _xlocale *v21;

  v21 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v21 = (_xlocale *)__global_locale;
  }
  else
  {
    v21 = (_xlocale *)&__c_locale;
  }
  v20 = a1;
  do
  {
    v4 = v20++;
    v17 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v21));
  if (v17 == 45)
  {
    v15 = 1;
    v5 = v20++;
    v17 = *v5;
  }
  else
  {
    v15 = 0;
    if (v17 == 43)
    {
      v6 = v20++;
      v17 = *v6;
    }
  }
  if ((!a3 || a3 == 16)
    && v17 == 48
    && (*v20 == 120 || *v20 == 88)
    && (v20[1] >= 48 && v20[1] <= 57 || v20[1] >= 65 && v20[1] <= 70 || v20[1] >= 97 && v20[1] <= 102))
  {
    v17 = v20[1];
    v20 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v17 == 48)
      v7 = 8;
    else
      v7 = 10;
    a3 = v7;
  }
  v14 = 0;
  v19 = 0;
  if (a3 < 2 || a3 > 36)
    goto LABEL_57;
  v8 = 0x8000000000000000;
  if (!v15)
    v8 = 0x7FFFFFFFFFFFFFFFLL;
  v13 = v8 % a3;
  v16 = v8 / a3;
  while (1)
  {
    if (v17 >= 48 && v17 <= 57)
    {
      v18 = v17 - 48;
      goto LABEL_44;
    }
    if (v17 >= 65 && v17 <= 90)
    {
      v18 = v17 - 55;
      goto LABEL_44;
    }
    if (v17 < 97 || v17 > 122)
      break;
    v18 = v17 - 87;
LABEL_44:
    if (v18 >= a3)
      break;
    if (v14 < 0 || v19 > v16 || v19 == v16 && v18 > v13)
    {
      v14 = -1;
    }
    else
    {
      v14 = 1;
      v19 = v19 * a3 + v18;
    }
    v9 = v20++;
    v17 = *v9;
  }
  if (v14 < 0)
  {
    v10 = 0x8000000000000000;
    if (!v15)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    v19 = v10;
    *__error() = 34;
    goto LABEL_60;
  }
  if (!v14)
  {
LABEL_57:
    *__error() = 22;
    goto LABEL_60;
  }
  if (v15)
    v19 = -(uint64_t)v19;
LABEL_60:
  if (a2)
  {
    if (v14)
      v12 = (char *)(v20 - 1);
    else
      v12 = (char *)a1;
    *a2 = v12;
  }
  return v19;
}

uint64_t strtoll(const char *__str, char **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strtoll_l(__str, __endptr, __base, v9);
  else
    return strtoll_l(__str, __endptr, __base, (locale_t)__global_locale);
}

uint64_t strtoq(const char *__str, char **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strtoll_l(__str, __endptr, __base, v9);
  else
    return strtoll_l(__str, __endptr, __base, (locale_t)__global_locale);
}

uint64_t strtoq_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return strtoll_l(a1, a2, a3, a4);
}

unint64_t strtoul_l(const char *a1, char **a2, int a3, locale_t a4)
{
  const char *v4;
  const char *v5;
  const char *v6;
  int v7;
  const char *v8;
  char *v10;
  int v11;
  int v12;
  unint64_t v13;
  char v14;
  char v15;
  unint64_t v16;
  const char *v17;
  _xlocale *v18;

  v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v18 = (_xlocale *)__global_locale;
  }
  else
  {
    v18 = (_xlocale *)&__c_locale;
  }
  v17 = a1;
  do
  {
    v4 = v17++;
    v14 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v18));
  if (v14 == 45)
  {
    v12 = 1;
    v5 = v17++;
    v14 = *v5;
  }
  else
  {
    v12 = 0;
    if (v14 == 43)
    {
      v6 = v17++;
      v14 = *v6;
    }
  }
  if ((!a3 || a3 == 16)
    && v14 == 48
    && (*v17 == 120 || *v17 == 88)
    && (v17[1] >= 48 && v17[1] <= 57 || v17[1] >= 65 && v17[1] <= 70 || v17[1] >= 97 && v17[1] <= 102))
  {
    v14 = v17[1];
    v17 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v14 == 48)
      v7 = 8;
    else
      v7 = 10;
    a3 = v7;
  }
  v11 = 0;
  v16 = 0;
  if (a3 < 2 || a3 > 36)
    goto LABEL_53;
  v13 = 0xFFFFFFFFFFFFFFFFLL / a3;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      v15 = v14 - 48;
      goto LABEL_42;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      v15 = v14 - 55;
      goto LABEL_42;
    }
    if (v14 < 97 || v14 > 122)
      break;
    v15 = v14 - 87;
LABEL_42:
    if (v15 >= a3)
      break;
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % a3))
    {
      v11 = -1;
    }
    else
    {
      v11 = 1;
      v16 = v16 * a3 + v15;
    }
    v8 = v17++;
    v14 = *v8;
  }
  if (v11 < 0)
  {
    v16 = -1;
    *__error() = 34;
    goto LABEL_56;
  }
  if (v11)
  {
    if (v12)
      v16 = -(uint64_t)v16;
  }
  else
  {
LABEL_53:
    *__error() = 22;
  }
LABEL_56:
  if (a2)
  {
    if (v11)
      v10 = (char *)(v17 - 1);
    else
      v10 = (char *)a1;
    *a2 = v10;
  }
  return v16;
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strtoul_l(__str, __endptr, __base, v9);
  else
    return strtoul_l(__str, __endptr, __base, (locale_t)__global_locale);
}

unint64_t strtoull_l(const char *a1, char **a2, int a3, locale_t a4)
{
  const char *v4;
  const char *v5;
  const char *v6;
  int v7;
  const char *v8;
  char *v10;
  int v11;
  int v12;
  unint64_t v13;
  char v14;
  char v15;
  unint64_t v16;
  const char *v17;
  _xlocale *v18;

  v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v18 = (_xlocale *)__global_locale;
  }
  else
  {
    v18 = (_xlocale *)&__c_locale;
  }
  v17 = a1;
  do
  {
    v4 = v17++;
    v14 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v18));
  if (v14 == 45)
  {
    v12 = 1;
    v5 = v17++;
    v14 = *v5;
  }
  else
  {
    v12 = 0;
    if (v14 == 43)
    {
      v6 = v17++;
      v14 = *v6;
    }
  }
  if ((!a3 || a3 == 16)
    && v14 == 48
    && (*v17 == 120 || *v17 == 88)
    && (v17[1] >= 48 && v17[1] <= 57 || v17[1] >= 65 && v17[1] <= 70 || v17[1] >= 97 && v17[1] <= 102))
  {
    v14 = v17[1];
    v17 += 2;
    a3 = 16;
  }
  if (!a3)
  {
    if (v14 == 48)
      v7 = 8;
    else
      v7 = 10;
    a3 = v7;
  }
  v11 = 0;
  v16 = 0;
  if (a3 < 2 || a3 > 36)
    goto LABEL_53;
  v13 = 0xFFFFFFFFFFFFFFFFLL / a3;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      v15 = v14 - 48;
      goto LABEL_42;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      v15 = v14 - 55;
      goto LABEL_42;
    }
    if (v14 < 97 || v14 > 122)
      break;
    v15 = v14 - 87;
LABEL_42:
    if (v15 >= a3)
      break;
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % a3))
    {
      v11 = -1;
    }
    else
    {
      v11 = 1;
      v16 = v16 * a3 + v15;
    }
    v8 = v17++;
    v14 = *v8;
  }
  if (v11 < 0)
  {
    v16 = -1;
    *__error() = 34;
    goto LABEL_56;
  }
  if (v11)
  {
    if (v12)
      v16 = -(uint64_t)v16;
  }
  else
  {
LABEL_53:
    *__error() = 22;
  }
LABEL_56:
  if (a2)
  {
    if (v11)
      v10 = (char *)(v17 - 1);
    else
      v10 = (char *)a1;
    *a2 = v10;
  }
  return v16;
}

unint64_t strtoull(const char *__str, char **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strtoull_l(__str, __endptr, __base, v9);
  else
    return strtoull_l(__str, __endptr, __base, (locale_t)__global_locale);
}

uintmax_t strtoumax_l(const char *nptr, char **endptr, int base, locale_t a4)
{
  const char *v4;
  const char *v5;
  const char *v6;
  int v7;
  const char *v8;
  char *v10;
  int v11;
  int v12;
  unint64_t v13;
  char v14;
  char v15;
  uintmax_t v16;
  const char *v17;
  _xlocale *v18;

  v18 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v18 = (_xlocale *)__global_locale;
  }
  else
  {
    v18 = (_xlocale *)&__c_locale;
  }
  v17 = nptr;
  do
  {
    v4 = v17++;
    v14 = *v4;
  }
  while (isspace_l(*(unsigned __int8 *)v4, v18));
  if (v14 == 45)
  {
    v12 = 1;
    v5 = v17++;
    v14 = *v5;
  }
  else
  {
    v12 = 0;
    if (v14 == 43)
    {
      v6 = v17++;
      v14 = *v6;
    }
  }
  if ((!base || base == 16)
    && v14 == 48
    && (*v17 == 120 || *v17 == 88)
    && (v17[1] >= 48 && v17[1] <= 57 || v17[1] >= 65 && v17[1] <= 70 || v17[1] >= 97 && v17[1] <= 102))
  {
    v14 = v17[1];
    v17 += 2;
    base = 16;
  }
  if (!base)
  {
    if (v14 == 48)
      v7 = 8;
    else
      v7 = 10;
    base = v7;
  }
  v11 = 0;
  v16 = 0;
  if (base < 2 || base > 36)
    goto LABEL_53;
  v13 = 0xFFFFFFFFFFFFFFFFLL / base;
  while (1)
  {
    if (v14 >= 48 && v14 <= 57)
    {
      v15 = v14 - 48;
      goto LABEL_42;
    }
    if (v14 >= 65 && v14 <= 90)
    {
      v15 = v14 - 55;
      goto LABEL_42;
    }
    if (v14 < 97 || v14 > 122)
      break;
    v15 = v14 - 87;
LABEL_42:
    if (v15 >= base)
      break;
    if (v11 < 0 || v16 > v13 || v16 == v13 && v15 > (int)(0xFFFFFFFFFFFFFFFFLL % base))
    {
      v11 = -1;
    }
    else
    {
      v11 = 1;
      v16 = v16 * base + v15;
    }
    v8 = v17++;
    v14 = *v8;
  }
  if (v11 < 0)
  {
    v16 = -1;
    *__error() = 34;
    goto LABEL_56;
  }
  if (v11)
  {
    if (v12)
      v16 = -(uint64_t)v16;
  }
  else
  {
LABEL_53:
    *__error() = 22;
  }
LABEL_56:
  if (endptr)
  {
    if (v11)
      v10 = (char *)(v17 - 1);
    else
      v10 = (char *)nptr;
    *endptr = v10;
  }
  return v16;
}

uintmax_t strtoumax(const char *__nptr, char **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strtoumax_l(__nptr, __endptr, __base, v9);
  else
    return strtoumax_l(__nptr, __endptr, __base, (locale_t)__global_locale);
}

unint64_t strtouq(const char *__str, char **__endptr, int __base)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return strtoull_l(__str, __endptr, __base, v9);
  else
    return strtoull_l(__str, __endptr, __base, (locale_t)__global_locale);
}

unint64_t strtouq_l(const char *a1, char **a2, int a3, locale_t a4)
{
  return strtoull_l(a1, a2, a3, a4);
}

uint64_t system_NOCANCEL(uint64_t a1)
{
  char ***v1;
  BOOL v3;
  int v4;
  __int16 v5;
  posix_spawnattr_t v6;
  sigset_t v7;
  sigset_t v8;
  sigset_t v9;
  sigaction v10;
  sigaction v11;
  sigaction v12;
  int v13;
  int v14;
  pid_t v15;
  pid_t v16;
  uint64_t v17;
  int v19;
  int v20;
  int v21;
  char *__argv[2];
  uint64_t v23;
  uint64_t v24;

  v17 = a1;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v12.sa_mask = 0;
  v11.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v11.sa_mask = 0;
  v10.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v10.sa_mask = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 8;
  __argv[0] = "sh";
  __argv[1] = "-c";
  v23 = a1;
  v24 = 0;
  if (!__unix_conforming)
    __unix_conforming = 1;
  if (v17)
  {
    v13 = posix_spawnattr_init(&v6);
    if (v13)
    {
      v4 = v13;
      *__error() = v4;
      return -1;
    }
    else
    {
      v7 = 0;
      pthread_mutex_lock(&__systemfn_mutex);
      v12.__sigaction_u.__sa_handler = (void (__cdecl *)(int))(&dword_0 + 1);
      v12.sa_mask = 0;
      v12.sa_flags = 0;
      sigaction(2, &v12, &v11);
      if (v11.__sigaction_u.__sa_handler != (void (__cdecl *)(int))((char *)&dword_0 + 1))
      {
        v21 = 2;
        v7 |= 2u;
        v5 = 12;
      }
      sigaction(3, &v12, &v10);
      if (v10.__sigaction_u.__sa_handler != (void (__cdecl *)(int))((char *)&dword_0 + 1))
      {
        v20 = 3;
        v7 |= 4u;
        v5 |= 4u;
      }
      v19 = 20;
      v9 = 0x80000;
      sigprocmask(1, &v9, &v8);
      posix_spawnattr_setsigmask(&v6, &v8);
      if ((v5 & 4) != 0)
        posix_spawnattr_setsigdefault(&v6, &v7);
      posix_spawnattr_setflags(&v6, v5);
      v1 = _NSGetEnviron();
      v13 = posix_spawn(&v16, "/bin/sh", 0, &v6, __argv, *v1);
      posix_spawnattr_destroy(&v6);
      if (v13)
      {
        if (v13 == 12 || v13 == 35)
          v14 = -1;
        else
          v14 = 32512;
      }
      else
      {
        v15 = v16;
        do
        {
          v16 = wait4(v15, &v14, 0, 0);
          v3 = 0;
          if (v16 == -1)
            v3 = *__error() == 4;
        }
        while (v3);
        if (v16 == -1)
          v14 = -1;
      }
      sigaction(2, &v11, 0);
      sigaction(3, &v10, 0);
      sigprocmask(3, &v8, 0);
      pthread_mutex_unlock(&__systemfn_mutex);
      return v14;
    }
  }
  else
  {
    return access("/bin/sh", 0) != -1;
  }
}

void *__cdecl tdelete(const void *a1, void **a2, int (__cdecl *a3)(const void *, const void *))
{
  void **v4;
  int v5;
  _QWORD *v6;
  _QWORD *i;
  _QWORD *v8;
  void **v9;

  v9 = a2;
  if (!a2)
    return 0;
  v8 = *a2;
  if (!*a2)
    return 0;
  while (1)
  {
    v5 = ((uint64_t (*)(const void *, _QWORD))a3)(a1, *(_QWORD *)*v9);
    if (!v5)
      break;
    v8 = *v9;
    if (v5 >= 0)
      v4 = (void **)((char *)*v9 + 16);
    else
      v4 = (void **)((char *)*v9 + 8);
    v9 = v4;
    if (!*v4)
      return 0;
  }
  v6 = (_QWORD *)*((_QWORD *)*v9 + 2);
  i = (_QWORD *)*((_QWORD *)*v9 + 1);
  if (i)
  {
    if (v6)
    {
      if (v6[1])
      {
        for (i = (_QWORD *)v6[1]; i[1]; i = (_QWORD *)i[1])
          v6 = i;
        v6[1] = i[2];
        i[1] = *((_QWORD *)*v9 + 1);
        i[2] = *((_QWORD *)*v9 + 2);
      }
      else
      {
        v6[1] = i;
        i = v6;
      }
    }
  }
  else
  {
    i = (_QWORD *)*((_QWORD *)*v9 + 2);
  }
  free(*v9);
  *v9 = i;
  return v8;
}

void *__cdecl tfind(const void *a1, void *const *a2, int (__cdecl *a3)(const void *, const void *))
{
  uint64_t v4;
  int v5;
  void **v6;

  v6 = (void **)a2;
  if (!a2)
    return 0;
  while (*v6)
  {
    v5 = ((uint64_t (*)(const void *, _QWORD))a3)(a1, *(_QWORD *)*v6);
    if (!v5)
      return *v6;
    if (v5 >= 0)
      v4 = (uint64_t)*v6 + 16;
    else
      v4 = (uint64_t)*v6 + 8;
    v6 = (void **)v4;
  }
  return 0;
}

void *__cdecl tsearch(const void *a1, void **a2, int (__cdecl *a3)(const void *, const void *))
{
  uint64_t v4;
  int v5;
  void **v6;
  const void **v7;

  v6 = a2;
  if (!a2)
    return 0;
  while (*v6)
  {
    v5 = ((uint64_t (*)(const void *, _QWORD))a3)(a1, *(_QWORD *)*v6);
    if (!v5)
      return *v6;
    if (v5 >= 0)
      v4 = (uint64_t)*v6 + 16;
    else
      v4 = (uint64_t)*v6 + 8;
    v6 = (void **)v4;
  }
  v7 = (const void **)malloc_type_malloc(24, 0x30040D3A788E3);
  if (v7)
  {
    *v6 = v7;
    *v7 = a1;
    v7[2] = 0;
    v7[1] = 0;
  }
  return v7;
}

void twalk(const void *a1, void (__cdecl *a2)(const void *, VISIT, int))
{
  if (a1)
  {
    if (a2)
      trecurse((uint64_t)a1, (uint64_t (*)(uint64_t, uint64_t, _QWORD))a2, 0);
  }
}

uint64_t trecurse(uint64_t a1, uint64_t (*a2)(uint64_t, uint64_t, _QWORD), unsigned int a3)
{
  if (!*(_QWORD *)(a1 + 8) && !*(_QWORD *)(a1 + 16))
    return a2(a1, 3, a3);
  a2(a1, 0, a3);
  if (*(_QWORD *)(a1 + 8))
    trecurse(*(_QWORD *)(a1 + 8), a2, a3 + 1);
  a2(a1, 1, a3);
  if (*(_QWORD *)(a1 + 16))
    trecurse(*(_QWORD *)(a1 + 16), a2, a3 + 1);
  return a2(a1, 2, a3);
}

int posix_openpt(int a1)
{
  int v2;

  v2 = open_NOCANCEL("/dev/ptmx", a1);
  if (v2 < 0)
    return -1;
  else
    return v2;
}

int grantpt(int a1)
{
  return ioctl(a1, 0x20007454uLL);
}

char *__cdecl ptsname(int a1)
{
  char *v3;
  int v4;
  char *v5;
  void *v6;

  if (ptsname_once != -1)
    _os_once(&ptsname_once, 0, ptsname_once_init);
  v6 = pthread_getspecific(ptsname_buffer_specific_key);
  if (!v6)
  {
    v6 = (void *)malloc_type_malloc(128, 2589989431);
    if (!v6)
    {
      v5 = _os_assert_log(0);
      _os_crash((uint64_t)v5);
      __break(1u);
    }
    v4 = pthread_setspecific(ptsname_buffer_specific_key, v6);
    if (v4)
    {
      v3 = _os_assert_log(v4);
      _os_crash((uint64_t)v3);
      __break(1u);
    }
  }
  if (ptsname_r(a1, (char *)v6, 0x80uLL))
    return 0;
  else
    return (char *)v6;
}

uint64_t ptsname_once_init()
{
  uint64_t result;
  char *v1;

  result = pthread_key_create((pthread_key_t *)&ptsname_buffer_specific_key, (void (__cdecl *)(void *))&_free);
  if ((_DWORD)result)
  {
    v1 = _os_assert_log((int)result);
    result = _os_crash((uint64_t)v1);
    __break(1u);
  }
  return result;
}

int ptsname_r(int fildes, char *buffer, size_t buflen)
{
  unint64_t v4;
  stat v5;
  int v6;
  size_t v7;
  char *v8;
  int v9;
  char v11[128];

  v9 = fildes;
  v8 = buffer;
  v7 = buflen;
  v6 = 0;
  _platform_memset(&v5, 0, 144);
  if (v8)
  {
    v6 = ioctl(v9, 0x40807453uLL, v11);
    if (v6)
    {
      return -1;
    }
    else
    {
      v6 = stat(v11, &v5);
      if (v6)
      {
        return -1;
      }
      else
      {
        v4 = _platform_strlen(v11) + 1;
        if (v7 >= v4)
        {
          j___platform_memmove(v8, v11, v4);
          return 0;
        }
        else
        {
          *__error() = 34;
          return -1;
        }
      }
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int unlockpt(int a1)
{
  return ioctl(a1, 0x20007452uLL);
}

char *__cdecl l64a(uint64_t a1)
{
  BOOL v2;
  int i;
  char v4;
  _BYTE *v5;
  int v6;

  v6 = a1;
  v5 = &l64a_buf;
  for (i = 0; ; ++i)
  {
    v2 = 0;
    if (v6)
      v2 = i < 6;
    if (!v2)
      break;
    v4 = v6 & 0x3F;
    if ((v6 & 0x3Fu) >= 2)
    {
      if ((v6 & 0x3Fu) >= 0xC)
      {
        if ((v6 & 0x3Fu) >= 0x26)
          *v5 = v4 + 59;
        else
          *v5 = v4 + 53;
      }
      else
      {
        *v5 = v4 + 46;
      }
    }
    else
    {
      *v5 = v4 + 46;
    }
    v6 >>= 6;
    ++v5;
  }
  *v5 = 0;
  return (char *)&l64a_buf;
}

char *__cdecl ecvt(double a1, int a2, int *a3, int *a4)
{
  return (char *)__cvt(a2, a3, a4, 0, 1, a1);
}

const char *__cvt(int a1, _DWORD *a2, _DWORD *a3, int a4, int a5, double a6)
{
  _BYTE *v6;
  const char *v7;
  _BYTE *v8;
  uint64_t v10;
  uint64_t v11;
  char v12;
  _BYTE *v13;
  _DWORD *v14;
  int v15;
  int v16;
  _DWORD *v17;
  _DWORD *v18;
  int v19;
  double v20;

  v20 = a6;
  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = a5;
  v14 = 0;
  v13 = 0;
  if (!a1)
  {
    *v17 = v20 < 0.0;
    *v18 = 0;
    return (const char *)&unk_D495D;
  }
  if (__cvt_s)
  {
    free((void *)__cvt_s);
    __cvt_s = 0;
  }
  if (v19 >= 0)
    v10 = v19 + 1;
  else
    v10 = 1 - v19;
  if (v20 == 0.0)
  {
    *v18 = 1 - v16;
    *v17 = 0;
    __cvt_s = malloc_type_malloc(v10, 3691188370);
    v13 = (_BYTE *)__cvt_s;
    if (!__cvt_s)
      return 0;
    v6 = v13++;
    *v6 = 48;
    *v13 = 0;
    goto LABEL_24;
  }
  v14 = __dtoa(v16 + 2, v19, v18, v17, &v13, v20);
  if (!v14)
    return 0;
  if (*v18 != 9999)
  {
    if (v15 && v16)
      v10 += (int)*v18;
    __cvt_s = malloc_type_malloc(v10, 2540149391);
    if (!__cvt_s)
    {
      __freedtoa((uint64_t)v14);
      return 0;
    }
    _platform_strlcpy(__cvt_s, v14, v10);
    v13 = (_BYTE *)(__cvt_s + v13 - (_BYTE *)v14);
    __freedtoa((uint64_t)v14);
LABEL_24:
    if (v15)
    {
      v11 = v10 - (_QWORD)&v13[-__cvt_s];
      while (--v11)
      {
        v8 = v13++;
        *v8 = 48;
      }
      *v13 = 0;
    }
    return (const char *)__cvt_s;
  }
  *v18 = 0;
  v12 = *(_BYTE *)v14;
  __freedtoa((uint64_t)v14);
  v7 = "inf";
  if (v12 != 73)
    return "nan";
  return v7;
}

char *__cdecl fcvt(double a1, int a2, int *a3, int *a4)
{
  return (char *)__cvt(a2, a3, a4, 1, 1, a1);
}

char *__cdecl gcvt(double a1, int a2, char *a3)
{
  const char *v3;
  const char *v4;
  char *v5;
  char v6;
  char *v7;
  _BYTE *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  _BYTE *v15;
  char *v16;
  char *v17;
  char *v18;
  char v19;
  char *v20;
  lconv *v22;
  int v23;
  int v24;
  int i;
  _BYTE *v26;
  char *__dst;
  _DWORD *v28;
  char *v29;
  int v30;
  double v31;

  v31 = a1;
  v30 = a2;
  v29 = a3;
  v28 = 0;
  __dst = 0;
  v26 = 0;
  i = 0;
  v24 = 0;
  v23 = 0;
  v22 = localeconv();
  if (v30)
  {
    v28 = __dtoa(2, v30, &v24, &v23, 0, v31);
    if (v28)
    {
      if (v24 == 9999)
      {
        if (v23)
          v3 = "-";
        else
          v3 = (const char *)&unk_D495D;
        v4 = "inf";
        if (*(_BYTE *)v28 != 73)
          v4 = "nan";
        snprintf(v29, v30 + 1, "%s%s", v3, v4);
        __freedtoa((uint64_t)v28);
        return v29;
      }
      else
      {
        __dst = v29;
        if (v23)
        {
          v5 = __dst++;
          *v5 = 45;
        }
        if (v24 >= 0 && v24 <= v30)
        {
          i = 0;
          v26 = v28;
          while (i < v24)
          {
            if (*v26)
            {
              v15 = v26++;
              LOBYTE(v15) = *v15;
              v16 = __dst++;
              *v16 = (char)v15;
            }
            else
            {
              v17 = __dst++;
              *v17 = 48;
            }
            ++i;
          }
          if (*v26)
          {
            if (v26 == (_BYTE *)v28)
            {
              v18 = __dst++;
              *v18 = 48;
            }
            __dst = stpcpy(__dst, v22->decimal_point);
            for (i = v24; *((_BYTE *)v28 + i); ++i)
            {
              v19 = *((_BYTE *)v28 + i);
              v20 = __dst++;
              *v20 = v19;
            }
          }
          *__dst = 0;
        }
        else
        {
          if (--v24 >= 0)
          {
            v23 = 0;
          }
          else
          {
            v23 = 1;
            v24 = -v24;
          }
          v26 = (char *)v28 + 1;
          v6 = *(_BYTE *)v28;
          v7 = __dst++;
          *v7 = v6;
          __dst = stpcpy(__dst, v22->decimal_point);
          while (*v26)
          {
            v8 = v26++;
            LOBYTE(v8) = *v8;
            v9 = __dst++;
            *v9 = (char)v8;
          }
          v10 = __dst++;
          *v10 = 101;
          v11 = __dst++;
          if (v23)
            *v11 = 45;
          else
            *v11 = 43;
          if (v24 >= 10)
          {
            v23 = v24;
            for (i = 0; ; ++i)
            {
              v23 /= 10;
              if (!v23)
                break;
            }
            __dst[i + 1] = 0;
            while (v24)
            {
              v14 = i--;
              __dst[v14] = v24 % 10 + 48;
              v24 /= 10;
            }
          }
          else
          {
            v12 = __dst++;
            *v12 = 48;
            v13 = __dst++;
            *v13 = v24 + 48;
            *__dst = 0;
          }
        }
        __freedtoa((uint64_t)v28);
        return v29;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *v29 = 0;
    return v29;
  }
}

void qsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
  int (__cdecl *v4)(void *, const void *, const void *);

  v4 = (int (__cdecl *)(void *, const void *, const void *))_Block_get_invoke_fn((uint64_t)__compar);
  qsort_r(__base, __nel, __width, __compar, v4);
}

int heapsort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  char *v31;
  char v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t i;
  unint64_t j;
  size_t v39;
  size_t v40;
  size_t v41;
  size_t v42;
  size_t v43;
  size_t v44;
  size_t v47;

  v47 = __nel;
  if (__nel <= 1)
    return 0;
  if (__width)
  {
    v20 = (char *)malloc_type_malloc(__width, 1644793451);
    if (v20)
    {
      v21 = (char *)__base - __width;
      v33 = v47 / 2 + 1;
      while (--v33)
      {
        for (i = v33; ; i = v34)
        {
          v34 = 2 * i;
          if (2 * i > v47)
            break;
          v18 = &v21[v34 * __width];
          if (v34 < v47
            && (*((int (**)(void *, char *, char *))__compar + 2))(__compar, v18, &v18[__width]) < 0)
          {
            v18 += __width;
            ++v34;
          }
          v17 = &v21[i * __width];
          if ((*((int (**)(void *, char *, char *))__compar + 2))(__compar, v18, v17) <= 0)
            break;
          v39 = __width;
          do
          {
            v32 = *v17;
            v4 = v17++;
            *v4 = *v18;
            v5 = v18++;
            *v5 = v32;
            --v39;
          }
          while (v39);
        }
      }
      while (v47 > 1)
      {
        v40 = __width;
        v27 = v20;
        v22 = &v21[v47 * __width];
        do
        {
          v6 = v22++;
          v7 = v27++;
          *v7 = *v6;
          --v40;
        }
        while (v40);
        v41 = __width;
        v28 = &v21[v47 * __width];
        v23 = (char *)__base;
        do
        {
          v8 = v23++;
          v9 = v28++;
          *v9 = *v8;
          --v41;
        }
        while (v41);
        --v47;
        for (j = 1; ; j = v35)
        {
          v35 = 2 * j;
          if (2 * j > v47)
            break;
          v19 = &v21[v35 * __width];
          if (v35 < v47
            && (*((int (**)(void *, char *, char *))__compar + 2))(__compar, v19, &v19[__width]) < 0)
          {
            v19 += __width;
            ++v35;
          }
          v42 = __width;
          v29 = &v21[j * __width];
          v24 = v19;
          do
          {
            v10 = v24++;
            v11 = v29++;
            *v11 = *v10;
            --v42;
          }
          while (v42);
        }
        while (1)
        {
          v36 = j;
          j /= 2uLL;
          if (v36 == 1
            || (*((int (**)(void *, char *, char *))__compar + 2))(__compar, v20, &v21[j * __width]) < 0)
          {
            break;
          }
          v44 = __width;
          v31 = &v21[v36 * __width];
          v26 = &v21[j * __width];
          do
          {
            v14 = v26++;
            v15 = v31++;
            *v15 = *v14;
            --v44;
          }
          while (v44);
        }
        v43 = __width;
        v30 = &v21[v36 * __width];
        v25 = v20;
        do
        {
          v12 = v25++;
          v13 = v30++;
          *v13 = *v12;
          --v43;
        }
        while (v43);
      }
      free(v20);
      return 0;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t __heapsort_r(_BYTE *a1, unint64_t a2, uint64_t a3, uint64_t a4, int (*a5)(uint64_t, char *, char *))
{
  char *v5;
  char *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  _BYTE *v14;
  _BYTE *v15;
  _BYTE *v16;
  char *v18;
  char *v19;
  char *v20;
  _BYTE *v21;
  _BYTE *v22;
  _BYTE *v23;
  _BYTE *v24;
  _BYTE *v25;
  _BYTE *v26;
  _BYTE *v27;
  _BYTE *v28;
  _BYTE *v29;
  _BYTE *v30;
  _BYTE *v31;
  _BYTE *v32;
  char v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t i;
  unint64_t j;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v49;

  v49 = a2;
  if (a2 > 1)
  {
    if (a3)
    {
      v21 = (_BYTE *)malloc_type_malloc(a3, 3367899874);
      if (v21)
      {
        v22 = &a1[-a3];
        v34 = v49 / 2 + 1;
        while (--v34)
        {
          for (i = v34; ; i = v35)
          {
            v35 = 2 * i;
            if (2 * i > v49)
              break;
            v19 = &v22[v35 * a3];
            if (v35 < v49 && a5(a4, v19, &v19[a3]) < 0)
            {
              v19 += a3;
              ++v35;
            }
            v18 = &v22[i * a3];
            if (a5(a4, v19, v18) <= 0)
              break;
            v40 = a3;
            do
            {
              v33 = *v18;
              v5 = v18++;
              *v5 = *v19;
              v6 = v19++;
              *v6 = v33;
              --v40;
            }
            while (v40);
          }
        }
        while (v49 > 1)
        {
          v41 = a3;
          v28 = v21;
          v23 = &v22[v49 * a3];
          do
          {
            v7 = v23++;
            v8 = v28++;
            *v8 = *v7;
            --v41;
          }
          while (v41);
          v42 = a3;
          v29 = &v22[v49 * a3];
          v24 = a1;
          do
          {
            v9 = v24++;
            v10 = v29++;
            *v10 = *v9;
            --v42;
          }
          while (v42);
          --v49;
          for (j = 1; ; j = v36)
          {
            v36 = 2 * j;
            if (2 * j > v49)
              break;
            v20 = &v22[v36 * a3];
            if (v36 < v49 && a5(a4, v20, &v20[a3]) < 0)
            {
              v20 += a3;
              ++v36;
            }
            v43 = a3;
            v30 = &v22[j * a3];
            v25 = v20;
            do
            {
              v11 = v25++;
              v12 = v30++;
              *v12 = *v11;
              --v43;
            }
            while (v43);
          }
          while (1)
          {
            v37 = j;
            j /= 2uLL;
            if (v37 == 1 || a5(a4, v21, &v22[j * a3]) < 0)
              break;
            v45 = a3;
            v32 = &v22[v37 * a3];
            v27 = &v22[j * a3];
            do
            {
              v15 = v27++;
              v16 = v32++;
              *v16 = *v15;
              --v45;
            }
            while (v45);
          }
          v44 = a3;
          v31 = &v22[v37 * a3];
          v26 = v21;
          do
          {
            v13 = v26++;
            v14 = v31++;
            *v14 = *v13;
            --v44;
          }
          while (v44);
        }
        free(v21);
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      *__error() = 22;
      return -1;
    }
  }
  else
  {
    return 0;
  }
}

_DWORD *__ldtoa(double *a1, int a2, int a3, _DWORD *a4, _DWORD *a5, _QWORD *a6)
{
  _DWORD *v7;

  v7 = __dtoa(a2, a3, a4, a5, a6, *a1);
  if (*a4 == 9999)
    *a4 = 0x7FFFFFFF;
  return v7;
}

BOOL timespec_get(timespec *a1, int a2)
{
  return a2 == 1 && clock_gettime(_CLOCK_REALTIME, a1) != -1;
}

_DWORD *_Read_RuneMagi(FILE *a1)
{
  int v1;
  int v2;
  char *v3;
  char *v4;
  char *v5;
  int v6;
  _QWORD *v7;
  _QWORD *v8;
  off_t st_size;
  int v11;
  unint64_t v12;
  int v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  int v23;
  int v24;
  int i;
  int j;
  int k;
  int m;
  int n;
  int ii;
  stat v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  char *v37;
  _DWORD *RuneMagi_A;
  char *v39;
  uint64_t v40;
  FILE *v41;

  v41 = a1;
  v40 = 0;
  v39 = 0;
  RuneMagi_A = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  v34 = 0;
  v33 = 0;
  v32 = 0;
  _platform_memset(&v31, 0, 144);
  v14 = 0;
  RuneMagi_A = 0;
  v35 = 0;
  v1 = fileno(v41);
  if (fstat(v1, &v31) < 0)
    return 0;
  if (v31.st_size < 0xC3CuLL)
  {
LABEL_4:
    *__error() = 79;
    return 0;
  }
  st_size = v31.st_size;
  v2 = fileno(v41);
  v39 = (char *)mmap(0, st_size, 3, 2, v2, 0);
  if (v39 == (char *)-1)
  {
    *__error() = 22;
    return 0;
  }
  v36 = v39;
  v37 = &v39[v31.st_size];
  if (_platform_memcmp(v39, "RuneMagA", 8))
  {
    v18 = v36 + 3132;
    if (_platform_memcmp(v36, "RuneMagB", 8))
    {
      *__error() = 79;
LABEL_61:
      v24 = *__error();
      munmap(v39, v31.st_size);
      free(v35);
      free(RuneMagi_A);
      *__error() = v24;
      return 0;
    }
    v17 = v18;
    v19 = (unint64_t)&v18[12 * *((int *)v36 + 778)];
    if (v19 <= (unint64_t)v37)
    {
      v16 = v19;
      v20 = v19 + 12 * *((int *)v36 + 779);
      if (v20 <= (unint64_t)v37)
      {
        v15 = v20;
        v21 = v20 + 12 * *((int *)v36 + 780);
        if (v21 <= (unint64_t)v37)
        {
          v34 = (unint64_t)v17;
          for (i = 0; i < *((_DWORD *)v36 + 778); ++i)
          {
            if (!*(_DWORD *)(v34 + 12 * i + 8))
            {
              v13 = *(_DWORD *)(v34 + 12 * i + 4) - *(_DWORD *)(v34 + 12 * i) + 1;
              v21 += 4 * v13;
              v14 += v13;
              if (v21 > (unint64_t)v37)
                goto LABEL_48;
            }
          }
          v32 = v21;
          if (v21 + 20 * *((int *)v36 + 782) + *((int *)v36 + 781) <= (unint64_t)v37)
          {
            v40 = 24 * (*((_DWORD *)v36 + 778) + *((_DWORD *)v36 + 779) + *((_DWORD *)v36 + 780))
                + 128
                + 4 * v14
                + 20 * *((int *)v36 + 782)
                + *((int *)v36 + 781);
            RuneMagi_A = (_DWORD *)malloc_type_calloc(1, v40, 3938915710);
            if (!RuneMagi_A)
              goto LABEL_61;
            *RuneMagi_A = 1;
            *((_QWORD *)RuneMagi_A + 1) = destruct_ctype;
            v3 = (char *)malloc_type_calloc(1, 3208, 0x10A0040C89F755ALL);
            *((_QWORD *)RuneMagi_A + 15) = v3;
            v35 = v3;
            if (!v3)
            {
              free(RuneMagi_A);
              goto LABEL_61;
            }
            *((_QWORD *)v35 + 398) = RuneMagi_A + 32;
            *(_QWORD *)v35 = *(_QWORD *)"RuneMagA";
            v4 = v35;
            v5 = v36;
            *(_OWORD *)(v35 + 8) = *(_OWORD *)(v36 + 8);
            *(_OWORD *)(v4 + 24) = *(_OWORD *)(v5 + 24);
            *((_DWORD *)v35 + 14) = 0;
            *((_DWORD *)v35 + 798) = *((_DWORD *)v36 + 781);
            *((_DWORD *)v35 + 784) = *((_DWORD *)v36 + 778);
            *((_DWORD *)v35 + 788) = *((_DWORD *)v36 + 779);
            *((_DWORD *)v35 + 792) = *((_DWORD *)v36 + 780);
            *((_DWORD *)v35 + 799) = *((_DWORD *)v36 + 782);
            for (j = 0; j < 256; ++j)
            {
              *(_DWORD *)&v35[4 * j + 60] = *(_DWORD *)&v36[4 * j + 40];
              *(_DWORD *)&v35[4 * j + 1084] = *(_DWORD *)&v36[4 * j + 1064];
              *(_DWORD *)&v35[4 * j + 2108] = *(_DWORD *)&v36[4 * j + 2088];
            }
            *((_QWORD *)v35 + 393) = *((_QWORD *)v35 + 398);
            *((_QWORD *)v35 + 398) = *((_QWORD *)v35 + 393) + 24 * *((int *)v35 + 784);
            *((_QWORD *)v35 + 395) = *((_QWORD *)v35 + 398);
            *((_QWORD *)v35 + 398) = *((_QWORD *)v35 + 395) + 24 * *((int *)v35 + 788);
            *((_QWORD *)v35 + 397) = *((_QWORD *)v35 + 398);
            *((_QWORD *)v35 + 398) = *((_QWORD *)v35 + 397) + 24 * *((int *)v35 + 792);
            *((_QWORD *)v35 + 400) = *((_QWORD *)v35 + 398);
            *((_QWORD *)v35 + 398) = *((_QWORD *)v35 + 400) + 20 * *((int *)v35 + 799);
            v22 = v15 + 12 * *((int *)v36 + 780);
            v34 = (unint64_t)v17;
            v33 = *((_QWORD *)v35 + 393);
            for (k = 0; k < *((_DWORD *)v35 + 784); ++k)
            {
              *(_DWORD *)(v33 + 24 * k) = *(_DWORD *)(v34 + 12 * k);
              *(_DWORD *)(v33 + 24 * k + 4) = *(_DWORD *)(v34 + 12 * k + 4);
              *(_DWORD *)(v33 + 24 * k + 8) = *(_DWORD *)(v34 + 12 * k + 8);
              if (*(_DWORD *)(v33 + 24 * k + 8))
              {
                *(_QWORD *)(v33 + 24 * k + 16) = 0;
              }
              else
              {
                v11 = *(_DWORD *)(v33 + 24 * k + 4) - *(_DWORD *)(v33 + 24 * k) + 1;
                v12 = v22;
                v22 += 4 * v11;
                *(_QWORD *)(v33 + 24 * k + 16) = *((_QWORD *)v35 + 398);
                *((_QWORD *)v35 + 398) = *(_QWORD *)(v33 + 24 * k + 16) + 4 * v11;
                while (1)
                {
                  v6 = v11--;
                  if (v6 <= 0)
                    break;
                  *(_DWORD *)(*(_QWORD *)(v33 + 24 * k + 16) + 4 * v11) = *(_DWORD *)(v12 + 4 * v11);
                }
              }
            }
            v34 = v16;
            v33 = *((_QWORD *)v35 + 395);
            for (m = 0; m < *((_DWORD *)v35 + 788); ++m)
            {
              *(_DWORD *)(v33 + 24 * m) = *(_DWORD *)(v34 + 12 * m);
              *(_DWORD *)(v33 + 24 * m + 4) = *(_DWORD *)(v34 + 12 * m + 4);
              *(_DWORD *)(v33 + 24 * m + 8) = *(_DWORD *)(v34 + 12 * m + 8);
            }
            v34 = v15;
            v33 = *((_QWORD *)v35 + 397);
            for (n = 0; n < *((_DWORD *)v36 + 780); ++n)
            {
              *(_DWORD *)(v33 + 24 * n) = *(_DWORD *)(v34 + 12 * n);
              *(_DWORD *)(v33 + 24 * n + 4) = *(_DWORD *)(v34 + 12 * n + 4);
              *(_DWORD *)(v33 + 24 * n + 8) = *(_DWORD *)(v34 + 12 * n + 8);
            }
            if (*((int *)v36 + 782) > 0)
            {
              v32 = v22;
              v22 += 20 * *((int *)v36 + 782);
              if (v22 > (unint64_t)v37)
                goto LABEL_48;
              *((_QWORD *)v35 + 400) = *((_QWORD *)v35 + 398);
              *((_QWORD *)v35 + 398) = *((_QWORD *)v35 + 400) + 20 * *((int *)v35 + 799);
              for (ii = 0; ii < *((_DWORD *)v36 + 782); ++ii)
              {
                v7 = (_QWORD *)(*((_QWORD *)v35 + 400) + 20 * ii);
                v8 = (_QWORD *)(v32 + 20 * ii);
                *v7 = *v8;
                *(_QWORD *)((char *)v7 + 6) = *(_QWORD *)((char *)v8 + 6);
                *(_DWORD *)(*((_QWORD *)v35 + 400) + 20 * ii + 16) = *(_DWORD *)(v32 + 20 * ii + 16);
              }
            }
            j___platform_memmove(*((_QWORD *)v35 + 398), v22, *((int *)v35 + 798));
            munmap(v39, v31.st_size);
            if (!*((_DWORD *)v35 + 798))
              *((_QWORD *)v35 + 398) = 0;
            if (!*((_DWORD *)v35 + 784))
              *((_QWORD *)v35 + 393) = 0;
            if (!*((_DWORD *)v35 + 788))
              *((_QWORD *)v35 + 395) = 0;
            if (!*((_DWORD *)v35 + 792))
              *((_QWORD *)v35 + 397) = 0;
            RuneMagi_A[28] = v40;
            return RuneMagi_A;
          }
        }
      }
    }
LABEL_48:
    *__error() = 22;
    goto LABEL_61;
  }
  if (v31.st_size < 0xC5CuLL)
    goto LABEL_4;
  RuneMagi_A = _Read_RuneMagi_A((uint64_t)v41, (uint64_t)v36, (unint64_t)v37);
  v23 = *__error();
  munmap(v39, v31.st_size);
  if (!RuneMagi_A)
    *__error() = v23;
  return RuneMagi_A;
}

_DWORD *_Read_RuneMagi_A(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  int v4;
  _QWORD *v5;
  unint64_t v6;
  int v8;
  unint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  int v20;
  int i;
  int j;
  int k;
  int m;
  int n;
  int ii;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  int v33;

  v11 = 0;
  v32 = 0;
  v31 = 0;
  v15 = a2 + 3164;
  *(_DWORD *)(a2 + 48) = _OSSwapInt32(*(_DWORD *)(a2 + 48));
  *(_DWORD *)(a2 + 3152) = _OSSwapInt32(*(_DWORD *)(a2 + 3152));
  *(_DWORD *)(a2 + 3156) = _OSSwapInt32(*(_DWORD *)(a2 + 3156));
  *(_DWORD *)(a2 + 3124) = _OSSwapInt32(*(_DWORD *)(a2 + 3124));
  *(_DWORD *)(a2 + 3132) = _OSSwapInt32(*(_DWORD *)(a2 + 3132));
  *(_DWORD *)(a2 + 3140) = _OSSwapInt32(*(_DWORD *)(a2 + 3140));
  v14 = v15;
  v16 = v15 + 16 * *(int *)(a2 + 3124);
  if (v16 > a3)
    goto LABEL_35;
  v13 = v16;
  v17 = v16 + 16 * *(int *)(a2 + 3132);
  if (v17 > a3)
    goto LABEL_35;
  v12 = v17;
  v18 = v17 + 16 * *(int *)(a2 + 3140);
  if (v18 > a3)
    goto LABEL_35;
  for (i = 0; i < *(_DWORD *)(a2 + 3124); ++i)
  {
    *(_DWORD *)(v14 + 16 * i) = _OSSwapInt32(*(_DWORD *)(v14 + 16 * i));
    *(_DWORD *)(v14 + 16 * i + 4) = _OSSwapInt32(*(_DWORD *)(v14 + 16 * i + 4));
    *(_DWORD *)(v14 + 16 * i + 8) = _OSSwapInt32(*(_DWORD *)(v14 + 16 * i + 8));
    if (!*(_DWORD *)(v14 + 16 * i + 8))
    {
      v10 = *(_DWORD *)(v14 + 16 * i + 4) - *(_DWORD *)(v14 + 16 * i) + 1;
      v18 += 4 * v10;
      v11 += v10;
      if (v18 > a3)
        goto LABEL_35;
    }
  }
  if (v18 + 20 * *(int *)(a2 + 3156) + *(int *)(a2 + 3152) > a3)
    goto LABEL_35;
  v33 = 24 * (*(_DWORD *)(a2 + 3124) + *(_DWORD *)(a2 + 3132) + *(_DWORD *)(a2 + 3140))
      + 128
      + 4 * v11
      + 20 * *(_DWORD *)(a2 + 3156)
      + *(_DWORD *)(a2 + 3152);
  v32 = (_DWORD *)malloc_type_calloc(1, 24 * (*(_DWORD *)(a2 + 3124) + *(_DWORD *)(a2 + 3132) + *(_DWORD *)(a2 + 3140))+ 128+ 4 * v11+ 20 * *(int *)(a2 + 3156)+ *(int *)(a2 + 3152), 1030992387);
  if (!v32)
  {
LABEL_48:
    v20 = *__error();
    free((void *)v31);
    free(v32);
    *__error() = v20;
    return 0;
  }
  *v32 = 1;
  *((_QWORD *)v32 + 1) = destruct_ctype;
  v3 = malloc_type_calloc(1, 3208, 0x10A0040C89F755ALL);
  *((_QWORD *)v32 + 15) = v3;
  v31 = v3;
  if (!v3)
  {
    free(v32);
    goto LABEL_48;
  }
  *(_QWORD *)(v3 + 3184) = v32 + 32;
  *(_QWORD *)v3 = *(_QWORD *)"RuneMagA";
  *(_OWORD *)(v3 + 8) = *(_OWORD *)(a2 + 8);
  *(_OWORD *)(v3 + 24) = *(_OWORD *)(a2 + 24);
  *(_DWORD *)(v3 + 56) = *(_DWORD *)(a2 + 48);
  *(_DWORD *)(v3 + 3192) = *(_DWORD *)(a2 + 3152);
  *(_DWORD *)(v3 + 3136) = *(_DWORD *)(a2 + 3124);
  *(_DWORD *)(v3 + 3152) = *(_DWORD *)(a2 + 3132);
  *(_DWORD *)(v3 + 3168) = *(_DWORD *)(a2 + 3140);
  *(_DWORD *)(v3 + 3196) = *(_DWORD *)(a2 + 3156);
  for (j = 0; j < 256; ++j)
  {
    *(_DWORD *)(v31 + 60 + 4 * j) = _OSSwapInt32(*(_DWORD *)(a2 + 52 + 4 * j));
    *(_DWORD *)(v31 + 1084 + 4 * j) = _OSSwapInt32(*(_DWORD *)(a2 + 1076 + 4 * j));
    *(_DWORD *)(v31 + 2108 + 4 * j) = _OSSwapInt32(*(_DWORD *)(a2 + 2100 + 4 * j));
  }
  *(_QWORD *)(v31 + 3144) = *(_QWORD *)(v31 + 3184);
  *(_QWORD *)(v31 + 3184) = *(_QWORD *)(v31 + 3144) + 24 * *(int *)(v31 + 3136);
  *(_QWORD *)(v31 + 3160) = *(_QWORD *)(v31 + 3184);
  *(_QWORD *)(v31 + 3184) = *(_QWORD *)(v31 + 3160) + 24 * *(int *)(v31 + 3152);
  *(_QWORD *)(v31 + 3176) = *(_QWORD *)(v31 + 3184);
  *(_QWORD *)(v31 + 3184) = *(_QWORD *)(v31 + 3176) + 24 * *(int *)(v31 + 3168);
  *(_QWORD *)(v31 + 3200) = *(_QWORD *)(v31 + 3184);
  *(_QWORD *)(v31 + 3184) = *(_QWORD *)(v31 + 3200) + 20 * *(int *)(v31 + 3196);
  v19 = v12 + 16 * *(int *)(a2 + 3140);
  v28 = *(_QWORD *)(v31 + 3144);
  for (k = 0; k < *(_DWORD *)(v31 + 3136); ++k)
  {
    *(_DWORD *)(v28 + 24 * k) = *(_DWORD *)(v14 + 16 * k);
    *(_DWORD *)(v28 + 24 * k + 4) = *(_DWORD *)(v14 + 16 * k + 4);
    *(_DWORD *)(v28 + 24 * k + 8) = *(_DWORD *)(v14 + 16 * k + 8);
    if (*(_DWORD *)(v28 + 24 * k + 8))
    {
      *(_QWORD *)(v28 + 24 * k + 16) = 0;
    }
    else
    {
      v8 = *(_DWORD *)(v28 + 24 * k + 4) - *(_DWORD *)(v28 + 24 * k) + 1;
      v9 = v19;
      v19 += 4 * v8;
      *(_QWORD *)(v28 + 24 * k + 16) = *(_QWORD *)(v31 + 3184);
      *(_QWORD *)(v31 + 3184) = *(_QWORD *)(v28 + 24 * k + 16) + 4 * v8;
      while (1)
      {
        v4 = v8--;
        if (v4 <= 0)
          break;
        *(_DWORD *)(*(_QWORD *)(v28 + 24 * k + 16) + 4 * v8) = _OSSwapInt32(*(_DWORD *)(v9 + 4 * v8));
      }
    }
  }
  v29 = *(_QWORD *)(v31 + 3160);
  for (m = 0; m < *(_DWORD *)(v31 + 3152); ++m)
  {
    *(_DWORD *)(v29 + 24 * m) = _OSSwapInt32(*(_DWORD *)(v13 + 16 * m));
    *(_DWORD *)(v29 + 24 * m + 4) = _OSSwapInt32(*(_DWORD *)(v13 + 16 * m + 4));
    *(_DWORD *)(v29 + 24 * m + 8) = _OSSwapInt32(*(_DWORD *)(v13 + 16 * m + 8));
  }
  v30 = *(_QWORD *)(v31 + 3176);
  for (n = 0; n < *(_DWORD *)(a2 + 3140); ++n)
  {
    *(_DWORD *)(v30 + 24 * n) = _OSSwapInt32(*(_DWORD *)(v12 + 16 * n));
    *(_DWORD *)(v30 + 24 * n + 4) = _OSSwapInt32(*(_DWORD *)(v12 + 16 * n + 4));
    *(_DWORD *)(v30 + 24 * n + 8) = _OSSwapInt32(*(_DWORD *)(v12 + 16 * n + 8));
  }
  if (*(int *)(a2 + 3156) > 0)
  {
    v27 = v19;
    v19 += 20 * *(int *)(a2 + 3156);
    if (v19 > a3)
    {
LABEL_35:
      *__error() = 22;
      goto LABEL_48;
    }
    *(_QWORD *)(v31 + 3200) = *(_QWORD *)(v31 + 3184);
    *(_QWORD *)(v31 + 3184) = *(_QWORD *)(v31 + 3200) + 20 * *(int *)(v31 + 3196);
    for (ii = 0; ii < *(_DWORD *)(a2 + 3156); ++ii)
    {
      v5 = (_QWORD *)(*(_QWORD *)(v31 + 3200) + 20 * ii);
      v6 = v27 + 20 * ii;
      *v5 = *(_QWORD *)v6;
      *(_QWORD *)((char *)v5 + 6) = *(_QWORD *)(v6 + 6);
      *(_DWORD *)(*(_QWORD *)(v31 + 3200) + 20 * ii + 16) = _OSSwapInt32(*(_DWORD *)(v6 + 16));
    }
  }
  j___platform_memmove(*(_QWORD *)(v31 + 3184), v19, *(int *)(v31 + 3192));
  if (!*(_DWORD *)(v31 + 3192))
    *(_QWORD *)(v31 + 3184) = 0;
  if (!*(_DWORD *)(v31 + 3136))
    *(_QWORD *)(v31 + 3144) = 0;
  if (!*(_DWORD *)(v31 + 3152))
    *(_QWORD *)(v31 + 3160) = 0;
  if (!*(_DWORD *)(v31 + 3168))
    *(_QWORD *)(v31 + 3176) = 0;
  v32[28] = v33;
  return v32;
}

void destruct_ctype(void **a1)
{
  if (&_DefaultRuneLocale != a1[15])
    free(a1[15]);
  free(a1);
}

int mergesort_b(void *__base, size_t __nel, size_t __width, void *__compar)
{
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  _BYTE *v14;
  _BYTE *v15;
  BOOL v17;
  BOOL v18;
  _QWORD *v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  char *v25;
  _DWORD *v26;
  _DWORD *v27;
  char *v28;
  char *v29;
  char *v30;
  _DWORD *v31;
  _DWORD *v32;
  _BOOL4 v33;
  int v34;
  int v35;
  size_t v36;
  size_t i;

  if (__width >= 4)
  {
    if (__nel)
    {
      v33 = 0;
      if (!(__width % 4))
        v33 = (unint64_t)__base % 4 == 0;
      v23 = (char *)malloc_type_malloc(__nel * __width + 8, 4018481808);
      if (v23)
      {
        v22 = (char *)__base;
        setup_0((uint64_t)__base, v23, __nel, __width, (uint64_t)__compar);
        v20 = &v23[__nel * __width];
        v34 = 0;
        v36 = 0;
        while (*(char **)((unint64_t)(v23 + 7) & 0xFFFFFFFFFFFFFFF8) != v20)
        {
          v24 = v22;
          v19 = (_QWORD *)((unint64_t)(v22 + 7) & 0xFFFFFFFFFFFFFFF8);
          v21 = v23;
          v27 = v23;
          while (v21 != v20)
          {
            v21 = *(char **)((unint64_t)(v21 + 7) & 0xFFFFFFFFFFFFFFF8);
            v32 = v24;
            v25 = &v22[v21 - v23];
            v31 = v25;
            if (v21 != v20)
              v21 = *(char **)((unint64_t)(v21 + 7) & 0xFFFFFFFFFFFFFFF8);
            v24 = &v22[v21 - v23];
            while (1)
            {
              v18 = 0;
              if (v32 < (_DWORD *)v25)
                v18 = v31 < (_DWORD *)v24;
              if (!v18)
                break;
              if ((*((int (**)(void *, _DWORD *, _DWORD *))__compar + 2))(__compar, v32, v31) > 0)
              {
                v26 = v32;
                v29 = (char *)v31;
                v30 = &v22[v21 - v23];
                v35 = 0;
              }
              else
              {
                v26 = v31;
                v29 = (char *)v32;
                v30 = v25;
                v35 = -1;
              }
              if (v34)
              {
LABEL_30:
                for (i = __width; ; i *= 2)
                {
                  if (&v29[i] >= v30)
                  {
                    if (&v30[-__width] <= v29
                      || (*((int (**)(void *, _DWORD *, char *))__compar + 2))(__compar, v26, &v30[-__width]) > v35)
                    {
                      v29 = &v30[-__width];
                    }
                    else
                    {
                      v30 -= __width;
                    }
                    while (v30 > &v29[__width])
                    {
                      if ((*((int (**)(void *, _DWORD *))__compar + 2))(__compar, v26) > v35)
                        v29 += (((v30 - v29) / __width) >> 1) * __width;
                      else
                        v30 = &v29[(((v30 - v29) / __width) >> 1) * __width];
                    }
                    goto LABEL_50;
                  }
                  if ((*((int (**)(void *, _DWORD *, char *))__compar + 2))(__compar, v26, &v29[i]) <= v35)
                    break;
                  v29 += i;
                }
                v30 = &v29[i];
                if (i == __width)
                  v34 = 0;
                while (i > __width)
                {
                  i >>= 1;
                  if ((*((int (**)(void *, _DWORD *))__compar + 2))(__compar, v26) > v35)
                    v29 += i;
                  else
                    v30 = &v29[i];
                }
LABEL_50:
                v29 = v30;
              }
              else
              {
                while (1)
                {
                  v29 += __width;
                  v17 = 0;
                  if (v29 < v30)
                    v17 = (*((int (**)(void *, _DWORD *, char *))__compar + 2))(__compar, v26, v29) > v35;
                  if (!v17)
                    break;
                  if (++v36 == 6)
                  {
                    v34 = 1;
                    goto LABEL_30;
                  }
                }
              }
              v36 = __width;
              if (v26 == v32)
              {
                if (v33)
                {
                  do
                    *v27++ = *v31++;
                  while (v31 < (_DWORD *)v29);
                  do
                  {
                    *v27++ = *v32++;
                    v36 -= 4;
                  }
                  while (v36);
                }
                else
                {
                  do
                  {
                    v4 = v31;
                    v31 = (_DWORD *)((char *)v31 + 1);
                    v5 = v27;
                    v27 = (_DWORD *)((char *)v27 + 1);
                    *v5 = *v4;
                  }
                  while (v31 < (_DWORD *)v29);
                  do
                  {
                    v6 = v32;
                    v32 = (_DWORD *)((char *)v32 + 1);
                    v7 = v27;
                    v27 = (_DWORD *)((char *)v27 + 1);
                    *v7 = *v6;
                    --v36;
                  }
                  while (v36);
                }
              }
              else if (v33)
              {
                do
                  *v27++ = *v32++;
                while (v32 < (_DWORD *)v29);
                do
                {
                  *v27++ = *v31++;
                  v36 -= 4;
                }
                while (v36);
              }
              else
              {
                do
                {
                  v8 = v32;
                  v32 = (_DWORD *)((char *)v32 + 1);
                  v9 = v27;
                  v27 = (_DWORD *)((char *)v27 + 1);
                  *v9 = *v8;
                }
                while (v32 < (_DWORD *)v29);
                do
                {
                  v10 = v31;
                  v31 = (_DWORD *)((char *)v31 + 1);
                  v11 = v27;
                  v27 = (_DWORD *)((char *)v27 + 1);
                  *v11 = *v10;
                  --v36;
                }
                while (v36);
              }
            }
            if (v31 >= (_DWORD *)v24)
            {
              if (v32 < (_DWORD *)v25)
              {
                if (v33)
                {
                  do
                    *v27++ = *v32++;
                  while (v32 < (_DWORD *)v25);
                }
                else
                {
                  do
                  {
                    v14 = v32;
                    v32 = (_DWORD *)((char *)v32 + 1);
                    v15 = v27;
                    v27 = (_DWORD *)((char *)v27 + 1);
                    *v15 = *v14;
                  }
                  while (v32 < (_DWORD *)v25);
                }
              }
            }
            else if (v33)
            {
              do
                *v27++ = *v31++;
              while (v31 < (_DWORD *)v24);
            }
            else
            {
              do
              {
                v12 = v31;
                v31 = (_DWORD *)((char *)v31 + 1);
                v13 = v27;
                v27 = (_DWORD *)((char *)v27 + 1);
                *v13 = *v12;
              }
              while (v31 < (_DWORD *)v24);
            }
            *v19 = v24;
            v19 = (_QWORD *)((unint64_t)(v24 + 7) & 0xFFFFFFFFFFFFFFF8);
          }
          v28 = v22;
          v22 = v23;
          v23 = v28;
          v20 = &v28[__nel * __width];
        }
        if (__base == v23)
        {
          _platform_memmove(v23, v22, __nel * __width);
          v23 = v22;
        }
        free(v23);
        return 0;
      }
      else
      {
        return -1;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

uint64_t setup_0(uint64_t a1, char *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *i;
  char *j;
  char *v20;
  _BOOL4 v21;
  char v22;
  char v23;
  char v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v26 = 2 * a4;
  if (a3 > 5)
  {
    v27 = (a3 & 1) + 4;
    insertionsort_0(a1 + (a3 - v27) * a4, v27, a4, a5);
    v13 = a1 + a4 * (a3 - v27);
    *(_QWORD *)((unint64_t)&a2[a4 * (a3 - v27) + 7] & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
    v12 = a2;
    v20 = (char *)a1;
    result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a5 + 16))(a5, a1, a1 + a4);
    v21 = (int)result > 0;
    while ((unint64_t)v20 < v13)
    {
      v25 = 2;
      for (i = &v20[v26]; (unint64_t)i < v13; i += v26)
      {
        result = (*(uint64_t (**)(uint64_t, char *, char *))(a5 + 16))(a5, i, &i[a4]);
        if ((int)result > 0 != v21)
          break;
        v25 += 2;
      }
      if (v25 >= 16)
      {
        v14 = i;
        for (j = &v20[v26]; j < v14; j += v26)
        {
          result = (*(uint64_t (**)(uint64_t, char *, char *))(a5 + 16))(a5, &j[-a4], j);
          if ((int)result > 0 != v21)
          {
            *(_QWORD *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &j[(_QWORD)a2 - a1];
            v12 = &j[(_QWORD)a2 - a1];
            if (v21 > 0)
            {
              v16 = &j[-a4];
              do
              {
                v29 = a4;
                do
                {
                  v23 = *v20;
                  v8 = v20++;
                  *v8 = *v16;
                  v9 = v16++;
                  *v9 = v23;
                  --v29;
                }
                while (v29);
                v16 -= v26;
              }
              while (v20 < v16);
            }
            v20 = j;
          }
        }
        if (v21 > 0)
        {
          v17 = &j[-a4];
          do
          {
            v30 = a4;
            do
            {
              v24 = *v20;
              v10 = v20++;
              *v10 = *v17;
              v11 = v17++;
              *v11 = v24;
              --v30;
            }
            while (v30);
            v17 -= v26;
          }
          while (v20 < v17);
        }
        v20 = j;
        if ((unint64_t)j >= v13
          && (result = (*(uint64_t (**)(uint64_t, char *, char *))(a5 + 16))(a5, &j[-a4], j), (int)result <= 0))
        {
          *(_QWORD *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
          v12 = &a2[a3 * a4];
        }
        else
        {
          *(_QWORD *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &j[(_QWORD)a2 - a1];
          v12 = &j[(_QWORD)a2 - a1];
        }
      }
      else
      {
        do
        {
          *(_QWORD *)((unint64_t)(v12 + 7) & 0xFFFFFFFFFFFFFFF8) = &v20[v26 - a1 + (_QWORD)a2];
          v12 = &v20[v26 - a1 + (_QWORD)a2];
          if (v21 > 0)
          {
            v15 = &v20[a4];
            v28 = a4;
            do
            {
              v22 = *v20;
              v6 = v20++;
              *v6 = *v15;
              v7 = v15++;
              *v7 = v22;
              --v28;
            }
            while (v28);
            v20 -= a4;
          }
          v20 += v26;
        }
        while (v20 < i);
      }
      v21 = !v21;
    }
  }
  else
  {
    result = insertionsort_0(a1, a3, a4, a5);
    *(_QWORD *)((unint64_t)(a2 + 7) & 0xFFFFFFFFFFFFFFF8) = &a2[a3 * a4];
  }
  return result;
}

uint64_t insertionsort_0(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  char *v4;
  char *v5;
  int v6;
  char v7;
  char *v8;
  char *j;
  char *v10;
  char *i;
  unint64_t v15;

  v15 = result;
  for (i = (char *)(result + a3); --a2; i += a3)
  {
    for (j = i; (unint64_t)j > v15; j -= a3)
    {
      v8 = &j[-a3];
      result = (*(uint64_t (**)(uint64_t, char *, char *))(a4 + 16))(a4, &j[-a3], j);
      if ((int)result <= 0)
        break;
      v10 = j;
      v6 = a3;
      do
      {
        v7 = *v8;
        v4 = v8++;
        *v4 = *v10;
        v5 = v10++;
        *v5 = v7;
        --v6;
      }
      while (v6);
    }
  }
  return result;
}

int scandir_b(const char *a1, dirent ***a2, void *a3, void *a4)
{
  size_t v4;
  uint64_t v6;
  DIR *v8;
  unint64_t v9;
  size_t __nel;
  _QWORD *__base;
  char *v12;
  dirent *v13;

  __nel = 0;
  v8 = opendir(a1);
  if (!v8)
    return -1;
  v9 = 32;
  __base = (_QWORD *)malloc_type_malloc(256, 0x2004093837F09);
  if (__base)
  {
    while (1)
    {
      v13 = readdir(v8);
      if (!v13)
        break;
      if (!a3 || (*((unsigned int (**)(void *, dirent *))a3 + 2))(a3, v13))
      {
        v12 = (char *)malloc_type_malloc((int)((v13->d_namlen + 4) & 0xFFFFFFFC) + 24, 3587914482);
        if (!v12)
          goto LABEL_17;
        *(_QWORD *)v12 = v13->d_ino;
        v12[20] = v13->d_type;
        *((_WORD *)v12 + 8) = v13->d_reclen;
        *((_WORD *)v12 + 9) = v13->d_namlen;
        bcopy(v13->d_name, v12 + 21, *((unsigned __int16 *)v12 + 9) + 1);
        if (__nel >= v9)
        {
          v6 = malloc_type_realloc(__base, 16 * v9, 0x2004093837F09);
          if (!v6)
          {
            free(v12);
            goto LABEL_17;
          }
          __base = (_QWORD *)v6;
          v9 *= 2;
        }
        v4 = __nel++;
        __base[v4] = v12;
      }
    }
    closedir(v8);
    if (__nel && a4)
      qsort_b(__base, __nel, 8uLL, a4);
    *a2 = (dirent **)__base;
    return __nel;
  }
  else
  {
LABEL_17:
    while (__nel)
      free((void *)__base[--__nel]);
    free(__base);
    closedir(v8);
    return -1;
  }
}

uint64_t __printf_arginfo_errno(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;

  if (!a2)
    __assert_rtn("__printf_arginfo_errno", "xprintf_errno.c", 44, "n >= 1");
  result = 1;
  *a3 = 1;
  return result;
}

uint64_t __printf_render_errno(_QWORD **a1, uint64_t a2, unsigned int **a3)
{
  signed int v3;
  signed int v4;
  char *v6;
  unsigned int __errnum;
  unsigned int v8;
  char v12[64];

  __errnum = **a3;
  if (__errnum > 0x6A)
  {
    sprintf(v12, "errno=%d/0x%x", __errnum, __errnum);
    v4 = _platform_strlen(v12);
    v8 = __printf_out((uint64_t)a1, a2, (uint64_t)v12, v4);
    __printf_flush(a1);
    return v8;
  }
  else
  {
    v6 = strerror(__errnum);
    v3 = _platform_strlen(v6);
    return __printf_out((uint64_t)a1, a2, (uint64_t)v6, v3);
  }
}

uint64_t __printf_arginfo_float(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
    __assert_rtn("__printf_arginfo_float", "xprintf_float.c", 130, "n > 0");
  if (*(__int16 *)(a1 + 40) >= 0)
  {
    *a3 = 128;
    if ((*(_WORD *)(a1 + 40) & 1) != 0)
      *a3 |= 0x10000u;
  }
  else
  {
    *a3 = 256;
  }
  return 1;
}

uint64_t __printf_render_float(_QWORD **a1, uint64_t a2, unsigned __int16 **a3)
{
  lconv *v3;
  const char *v4;
  const char *v5;
  char *v6;
  signed int v8;
  signed int v9;
  BOOL v10;
  signed int v11;
  signed int v12;
  unint64_t v13;
  int v14;
  unsigned int v15;
  char *thousands_sep;
  signed int v17;
  signed int v18;
  signed int v19;
  signed int v20;
  char *decimal_point;
  int v22;
  int v23;
  unsigned int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  char v31;
  signed int v32;
  signed int v33;
  double v34;
  double v35;
  int v36;
  _BYTE *fixed;
  int v38;
  int v39;
  unsigned int v40;
  int v41;
  signed int v42;
  char v43;
  _DWORD *v44;
  int v45;
  int v46;
  _DWORD *v47;
  char v48;
  _DWORD *v49;
  int v50;
  double **v51;
  uint64_t v52;
  _QWORD **v53;
  char v55;
  _BYTE v56[3];
  _BYTE v57[8];

  v53 = a1;
  v52 = a2;
  v51 = (double **)a3;
  v50 = 0;
  v49 = 0;
  v48 = 0;
  v47 = 0;
  v46 = 0;
  v45 = 0;
  v44 = 0;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  fixed = 0;
  v36 = 0;
  v35 = 0.0;
  v34 = 0.0;
  v33 = 0;
  v32 = 0;
  if (*(__int16 *)(a2 + 40) >= 0)
  {
    v50 = *(_DWORD *)(v52 + 20);
    v31 = 0;
    v43 = *(_DWORD *)(v52 + 36);
    v14 = 0;
    v22 = 0;
    thousands_sep = localeconv_l(*(locale_t *)(v52 + 8))->thousands_sep;
    v15 = _platform_strlen(thousands_sep);
    fixed = 0;
    if ((*(_WORD *)(v52 + 40) & 0x100) != 0)
    {
      v3 = localeconv_l(*(locale_t *)(v52 + 8));
      fixed = __fix_nogrouping(v3->grouping);
    }
    decimal_point = localeconv_l(*(locale_t *)(v52 + 8))->decimal_point;
    v20 = _platform_strlen(decimal_point);
    v32 = -1;
    v13 = (*(_DWORD *)(v52 + 28) - 65);
    if (v13 <= 0x26)
      __asm { BR              X8 }
    if (*(_DWORD *)(v52 + 28) != 102)
      __assert_rtn("__printf_render_float", "xprintf_float.c", 263, "pi->spec == 'f'");
    if (v50 < 0)
      v50 = 6;
    if ((*(_WORD *)(v52 + 40) & 1) != 0)
    {
      v35 = **v51;
      v47 = __ldtoa(&v35, 3, v50, &v46, &v45, &v44);
      v49 = v47;
    }
    else
    {
      v34 = **v51;
      v47 = __dtoa(3, v50, &v46, &v45, &v44, v34);
      v49 = v47;
      if (v46 == 9999)
        v46 = 0x7FFFFFFF;
    }
    if (v45)
      v43 = 45;
    if (v46 == 0x7FFFFFFF)
    {
      if (*(_BYTE *)v47 == 78)
      {
        v4 = "nan";
        if (*(int *)(v52 + 28) < 97)
          v4 = "NAN";
        v47 = v4;
        v43 = 0;
      }
      else
      {
        v5 = "inf";
        if (*(int *)(v52 + 28) < 97)
          v5 = "INF";
        v47 = v5;
      }
      v42 = 3;
      v14 = 1;
    }
    else
    {
      v41 = (_DWORD)v44 - (_DWORD)v47;
      if (*(_DWORD *)(v52 + 28) == 103 || *(_DWORD *)(v52 + 28) == 71)
      {
        if (v46 <= -4 || v46 > v50)
        {
          if (((*(_WORD *)(v52 + 40) >> 4) & 1) == 0)
            v50 = v41;
        }
        else
        {
          v48 = 0;
          if (((*(_WORD *)(v52 + 40) >> 4) & 1) != 0)
            v50 -= v46;
          else
            v50 = v41 - v46;
          if (v50 < 0)
            v50 = 0;
        }
      }
      if (v48)
      {
        v40 = exponent_1(v57, v46 - 1, v48);
        v42 = v40 + v50;
        if (v50 > 1 || ((*(_WORD *)(v52 + 40) >> 4) & 1) != 0)
          ++v42;
      }
      else
      {
        if (v46 <= 0)
          v42 = 1;
        else
          v42 = v46;
        if (v50 || ((*(_WORD *)(v52 + 40) >> 4) & 1) != 0)
          v42 += v50 + 1;
        if (fixed && v46 > 0)
        {
          v38 = 0;
          v39 = 0;
          v36 = v46;
          while (*fixed != 127 && v36 > (char)*fixed)
          {
            v36 -= (char)*fixed;
            if (fixed[1])
            {
              ++v39;
              ++fixed;
            }
            else
            {
              ++v38;
            }
          }
          v42 += v39 + v38;
        }
        else
        {
          v36 = v46;
        }
      }
    }
    if (v32 <= v42)
      v12 = v42;
    else
      v12 = v32;
    v33 = v12;
    if (v43)
      ++v33;
    if (*(_DWORD *)(v52 + 32) != 48 && ((*(_WORD *)(v52 + 40) >> 6) & 1) == 0)
      v22 = __printf_pad((uint64_t)v53, *(_DWORD *)(v52 + 24) - v33, 0);
    if (v43)
      v22 += __printf_puts((uint64_t)v53, (uint64_t)&v43, 1u);
    if (*(_DWORD *)(v52 + 32) == 48 && ((*(_WORD *)(v52 + 40) >> 6) & 1) == 0)
      v22 += __printf_pad((uint64_t)v53, *(_DWORD *)(v52 + 24) - v33, 1);
    v23 = v22 + __printf_pad((uint64_t)v53, v32 - v42, 1);
    if (v14)
    {
      v24 = v23 + __printf_puts((uint64_t)v53, (uint64_t)v47, v42);
    }
    else if (v48)
    {
      if (v50 > 1 || ((*(_WORD *)(v52 + 40) >> 4) & 1) != 0)
      {
        v6 = (char *)v47;
        v47 = (_DWORD *)((char *)v47 + 1);
        v55 = *v6;
        j___platform_memmove(v56, decimal_point, v20);
        v28 = v23 + __printf_puts((uint64_t)v53, (uint64_t)&v55, v20 + 1);
        v29 = v28 + __printf_puts((uint64_t)v53, (uint64_t)v47, v41 - 1);
        v30 = v29 + __printf_pad((uint64_t)v53, v50 - v41, 1);
      }
      else
      {
        v30 = v23 + __printf_puts((uint64_t)v53, (uint64_t)v47, 1u);
      }
      v24 = v30 + __printf_puts((uint64_t)v53, (uint64_t)v57, v40);
    }
    else
    {
      if (v46 > 0)
      {
        v17 = (_DWORD)v44 - (_DWORD)v47;
        if ((int)v44 - (int)v47 > v36)
          v17 = v36;
        if (v17 <= 0)
        {
          v11 = 0;
        }
        else
        {
          v23 += __printf_puts((uint64_t)v53, (uint64_t)v47, v17);
          v11 = v17;
        }
        v26 = v23 + __printf_pad((uint64_t)v53, v36 - v11, 1);
        v47 = (_DWORD *)((char *)v47 + v36);
        if (fixed)
        {
          while (1)
          {
            v10 = 1;
            if (v39 <= 0)
              v10 = v38 > 0;
            if (!v10)
              break;
            if (v38 <= 0)
            {
              --fixed;
              --v39;
            }
            else
            {
              --v38;
            }
            v27 = v26 + __printf_puts((uint64_t)v53, (uint64_t)thousands_sep, v15);
            v18 = (_DWORD)v44 - (_DWORD)v47;
            if ((int)v44 - (int)v47 > (char)*fixed)
              v18 = (char)*fixed;
            if (v18 <= 0)
            {
              v9 = 0;
            }
            else
            {
              v27 += __printf_puts((uint64_t)v53, (uint64_t)v47, v18);
              v9 = v18;
            }
            v26 = v27 + __printf_pad((uint64_t)v53, (char)*fixed - v9, 1);
            v47 = (_DWORD *)((char *)v47 + (char)*fixed);
          }
          if (v47 > v44)
            v47 = v44;
        }
        if (v50 || ((*(_WORD *)(v52 + 40) >> 4) & 1) != 0)
          v26 += __printf_puts((uint64_t)v53, (uint64_t)decimal_point, v20);
      }
      else
      {
        v25 = v23 + __printf_puts((uint64_t)v53, (uint64_t)"0", 1u);
        if (v50 || ((*(_WORD *)(v52 + 40) >> 4) & 1) != 0)
          v25 += __printf_puts((uint64_t)v53, (uint64_t)decimal_point, v20);
        v26 = v25 + __printf_pad((uint64_t)v53, -v46, 1);
        v50 += v46;
      }
      v19 = (_DWORD)v44 - (_DWORD)v47;
      if ((int)v44 - (int)v47 > v50)
        v19 = v50;
      if (v19 <= 0)
      {
        v8 = 0;
      }
      else
      {
        v26 += __printf_puts((uint64_t)v53, (uint64_t)v47, v19);
        v8 = v19;
      }
      v24 = v26 + __printf_pad((uint64_t)v53, v50 - v8, 1);
    }
    if (((*(_WORD *)(v52 + 40) >> 6) & 1) != 0)
      v24 += __printf_pad((uint64_t)v53, *(_DWORD *)(v52 + 24) - v33, 0);
    __printf_flush(v53);
    if (v49)
      __freedtoa((uint64_t)v49);
    return v24;
  }
  else
  {
    return __xprintf_vector((uint64_t)v53, v52, (unsigned __int16 **)v51);
  }
}

uint64_t exponent_1(_BYTE *a1, int a2, int a3)
{
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v10;
  _BYTE *v11;
  int v12;
  int v13;
  _BYTE *v14;

  v14 = a1;
  v13 = a2;
  v12 = a3;
  v10 = 0;
  v11 = a1 + 1;
  *a1 = a3;
  if (v13 >= 0)
  {
    v4 = v11++;
    *v4 = 43;
  }
  else
  {
    v13 = -v13;
    v3 = v11++;
    *v3 = 45;
  }
  v10 = &v10;
  if (v13 <= 9)
  {
    if (v12 == 101 || v12 == 69)
    {
      v7 = v11++;
      *v7 = 48;
    }
    v8 = v11++;
    *v8 = v13 + 48;
  }
  else
  {
    do
    {
      *--v10 = v13 % 10 + 48;
      v13 /= 10;
    }
    while (v13 > 9);
    *--v10 = v13 + 48;
    while (v10 < (_BYTE *)&v10)
    {
      v5 = v10++;
      LOBYTE(v5) = *v5;
      v6 = v11++;
      *v6 = (_BYTE)v5;
    }
  }
  return v11 - v14;
}

uint64_t __printf_arginfo_hexdump(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  if (a2 < 2)
    __assert_rtn("__printf_arginfo_hexdump", "xprintf_hexdump.c", 42, "n >= 2");
  *a3 = 32;
  a3[1] = 1;
  return 2;
}

uint64_t __printf_render_hexdump(_QWORD **a1, uint64_t a2, uint64_t **a3)
{
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  BOOL v9;
  BOOL v10;
  unsigned int v11;
  char *v12;
  char *v13;
  int v14;
  unsigned int i;
  unsigned int j;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  char v23;
  _BYTE v24[99];

  if (*(int *)(a2 + 24) <= 0 || *(int *)(a2 + 24) >= 16)
    v18 = 16;
  else
    v18 = *(_DWORD *)(a2 + 24);
  v20 = **a3;
  v19 = *(_DWORD *)a3[1];
  v11 = 0;
  v14 = 0;
  while (v19)
  {
    v12 = &v23;
    if (((*(_WORD *)(a2 + 40) >> 7) & 1) != 0)
      v12 = &v24[sprintf(&v23, " %04x", v14) - 1];
    for (i = 0; ; ++i)
    {
      v10 = 0;
      if (i < v18)
        v10 = i < v19;
      if (!v10)
        break;
      v12 += sprintf(v12, " %02x", *(unsigned __int8 *)(v20 + i));
    }
    if (((*(_WORD *)(a2 + 40) >> 4) & 1) != 0)
    {
      while (i < v18)
      {
        v12 += sprintf(v12, "   ");
        ++i;
      }
      v13 = &v12[sprintf(v12, "  |")];
      for (j = 0; ; ++j)
      {
        v9 = 0;
        if (j < v18)
          v9 = j < v19;
        if (!v9)
          break;
        if (*(unsigned __int8 *)(v20 + j) >= 0x20u && *(unsigned __int8 *)(v20 + j) <= 0x7Eu)
        {
          v4 = v13++;
          *v4 = *(_BYTE *)(v20 + j);
        }
        else
        {
          v3 = v13++;
          *v3 = 46;
        }
      }
      while (j < v18)
      {
        v5 = v13++;
        *v5 = 32;
        ++j;
      }
      v6 = v13;
      v12 = v13 + 1;
      *v6 = 124;
    }
    if (v18 >= v19)
      v17 = v19;
    else
      v17 = v18;
    v20 += v17;
    v19 -= v17;
    v14 += v17;
    if (v19)
    {
      v7 = v12++;
      *v7 = 10;
    }
    v11 += __printf_puts((uint64_t)a1, (uint64_t)v24, v12 - v24);
    __printf_flush(a1);
  }
  return v11;
}

uint64_t __printf_arginfo_int(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
    __assert_rtn("__printf_arginfo_int", "xprintf_int.c", 240, "n > 0");
  *a3 = 1;
  if (*(__int16 *)(a1 + 40) >= 0)
  {
    if (((*(_WORD *)(a1 + 40) >> 13) & 1) != 0)
    {
      *a3 |= 0x800000u;
    }
    else if (((*(_WORD *)(a1 + 40) >> 14) & 1) != 0)
    {
      *a3 |= 0x400000u;
    }
    else if (((*(_WORD *)(a1 + 40) >> 3) & 1) != 0)
    {
      *a3 |= 0x20000u;
    }
    else if (((*(_WORD *)(a1 + 40) >> 12) & 1) != 0)
    {
      *a3 |= 0x200000u;
    }
    else if (((*(_WORD *)(a1 + 40) >> 11) & 1) != 0)
    {
      *a3 |= 0x100000u;
    }
    else if ((*(_WORD *)(a1 + 40) & 1) != 0)
    {
      *a3 |= 0x10000u;
    }
    else if (((*(_WORD *)(a1 + 40) >> 2) & 1) != 0)
    {
      *a3 |= 0x40000u;
    }
    else if (((*(_WORD *)(a1 + 40) >> 1) & 1) != 0)
    {
      *a3 = 2;
    }
  }
  else
  {
    *a3 = 256;
  }
  return 1;
}

uint64_t __printf_render_int(uint64_t a1, uint64_t a2, uint64_t a3)
{
  lconv *v3;
  unint64_t v5;
  char *thousands_sep;

  if (*(__int16 *)(a2 + 40) >= 0)
  {
    if ((*(_WORD *)(a2 + 40) & 0x100) != 0)
    {
      thousands_sep = localeconv_l(*(locale_t *)(a2 + 8))->thousands_sep;
      _platform_strlen(thousands_sep);
      v3 = localeconv_l(*(locale_t *)(a2 + 8));
      __fix_nogrouping(v3->grouping);
    }
    v5 = (*(_DWORD *)(a2 + 28) - 79);
    if (v5 <= 0x29)
      __asm { BR              X8 }
    fprintf(__stderrp, "pi->spec = '%c'\n", *(unsigned int *)(a2 + 28));
    __assert_rtn("__printf_render_int", "xprintf_int.c", 328, "1 == 0");
  }
  return __xprintf_vector(a1, a2, a3);
}

uint64_t __ultoa_1(unint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, char *a8)
{
  int v9;
  int64_t v10;
  uint64_t v11;
  unint64_t v16;

  v16 = a1;
  v11 = a2;
  if (a3 == 8)
  {
    do
    {
      *(_BYTE *)--v11 = (v16 & 7) + 48;
      v16 >>= 3;
    }
    while (v16);
    return v11;
  }
  if (a3 != 10)
  {
    if (a3 != 16)
      __assert_rtn("__ultoa", "xprintf_int.c", 162, "base == 16");
    do
    {
      *(_BYTE *)--v11 = *(_BYTE *)(a4 + (v16 & 0xF));
      v16 >>= 4;
    }
    while (v16);
    return v11;
  }
  if (a1 >= 0xA)
  {
    v9 = 0;
    if (a1 <= 0x7FFFFFFFFFFFFFFFLL)
    {
      v10 = a1;
    }
    else
    {
      v11 = a2 - 1;
      *(_BYTE *)(a2 - 1) = a1 % 0xA + 48;
      v9 = 1;
      v10 = a1 / 0xA;
    }
    do
    {
      *(_BYTE *)--v11 = v10 % 10 + 48;
      ++v9;
      if (a5)
      {
        if (v9 == *a8 && *a8 != 127 && v10 > 9)
        {
          v11 -= a7;
          j___platform_memmove(v11, a6, a7);
          v9 = 0;
          if (a8[1])
            ++a8;
        }
      }
      v10 /= 10;
    }
    while (v10);
    return v11;
  }
  *(_BYTE *)(a2 - 1) = a1 + 48;
  return a2 - 1;
}

uint64_t __ujtoa_1(unint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, int a7, char *a8)
{
  int v9;
  int64_t v10;
  uint64_t v11;
  unint64_t v16;

  v16 = a1;
  v11 = a2;
  if (a3 == 8)
  {
    do
    {
      *(_BYTE *)--v11 = (v16 & 7) + 48;
      v16 >>= 3;
    }
    while (v16);
    return v11;
  }
  if (a3 != 10)
  {
    if (a3 != 16)
      abort();
    do
    {
      *(_BYTE *)--v11 = *(_BYTE *)(a4 + (v16 & 0xF));
      v16 >>= 4;
    }
    while (v16);
    return v11;
  }
  if (a1 >= 0xA)
  {
    v9 = 0;
    if (a1 <= 0x7FFFFFFFFFFFFFFFLL)
    {
      v10 = a1;
    }
    else
    {
      v11 = a2 - 1;
      *(_BYTE *)(a2 - 1) = a1 % 0xA + 48;
      v9 = 1;
      v10 = a1 / 0xA;
    }
    do
    {
      *(_BYTE *)--v11 = v10 % 10 + 48;
      ++v9;
      if (a5)
      {
        if (*a8 != 127 && v9 == *a8 && v10 > 9)
        {
          v11 -= a7;
          j___platform_memmove(v11, a6, a7);
          v9 = 0;
          if (a8[1])
            ++a8;
        }
      }
      v10 /= 10;
    }
    while (v10);
    return v11;
  }
  *(_BYTE *)(a2 - 1) = a1 % 0xA + 48;
  return a2 - 1;
}

uint64_t __printf_arginfo_ptr(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
    __assert_rtn("__printf_arginfo_ptr", "xprintf_int.c", 462, "n > 0");
  if (*(__int16 *)(a1 + 40) >= 0)
    *a3 = 32;
  else
    *a3 = 256;
  return 1;
}

uint64_t __printf_render_ptr(uint64_t a1, uint64_t a2, uint64_t **a3)
{
  uint64_t *v4;
  uint64_t v5;
  _BYTE v6[28];
  int v7;
  __int16 v8;
  uint64_t **v9;
  uint64_t v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  _platform_memset(v6, 0, 88);
  v5 = 0;
  v4 = 0;
  if (*(__int16 *)(v10 + 40) >= 0)
  {
    v5 = **v9;
    j___platform_memmove(v6, v10, 88);
    v7 = 120;
    v8 = v8 & 0xFFEF | 0x10;
    v8 = v8 & 0xFFFE | 1;
    v4 = &v5;
    return __printf_render_int(v11, (uint64_t)v6, (uint64_t)&v4);
  }
  else
  {
    return __xprintf_vector(v11, v10, v9);
  }
}

uint64_t __printf_arginfo_quote(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
    __assert_rtn("__printf_arginfo_quote", "xprintf_quote.c", 45, "n >= 1");
  *a3 = 32;
  return 1;
}

uint64_t __printf_render_quote(_QWORD **a1, uint64_t a2, char ***a3)
{
  signed int v3;
  signed int v4;
  uint64_t v6;
  uint64_t v7;
  _QWORD **v8;
  int v9;
  unsigned int v10;
  int v11;
  char v12[5];
  char *v13;
  char *v14;
  char *i;
  char *v16;
  char ***v17;
  uint64_t v18;
  _QWORD **v19;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = 0;
  i = 0;
  v14 = 0;
  v13 = 0;
  v16 = **a3;
  if (!v16)
    return __printf_out((uint64_t)v19, v18, (uint64_t)"\"(null)\"", 8);
  if (!*v16)
    return __printf_out((uint64_t)v19, v18, (uint64_t)"\"\"", 2);
  v11 = 0;
  for (i = v16; *i; ++i)
  {
    if (isspace(*i) || *i == 92 || *i == 34)
      ++v11;
  }
  if (!v11)
  {
    v3 = _platform_strlen(v16);
    return __printf_out((uint64_t)v19, v18, (uint64_t)v16, v3);
  }
  v9 = __printf_out((uint64_t)v19, v18, (uint64_t)"\"", 1);
  i = v16;
  v14 = v16;
  while (*i)
  {
    v13 = 0;
    switch(*i)
    {
      case 92:
        v13 = "\\\\";
        break;
      case 10:
        v13 = "\\n";
        break;
      case 13:
        v13 = "\\r";
        break;
      case 9:
        v13 = "\\t";
        break;
      case 32:
        v13 = " ";
        break;
      case 34:
        v13 = "\\\"";
        break;
      default:
        if (!isspace(*i))
          goto LABEL_34;
        sprintf(v12, "\\%03o", *i);
        v13 = v12;
        break;
    }
    if (i != v14)
      v9 += __printf_out((uint64_t)v19, v18, (uint64_t)v14, (int)i - (int)v14);
    v8 = v19;
    v6 = v18;
    v7 = (uint64_t)v13;
    v4 = _platform_strlen(v13);
    v9 += __printf_out((uint64_t)v8, v6, v7, v4);
    v14 = i + 1;
LABEL_34:
    ++i;
  }
  if (i != v14)
    v9 += __printf_out((uint64_t)v19, v18, (uint64_t)v14, (int)i - (int)v14);
  v10 = v9 + __printf_out((uint64_t)v19, v18, (uint64_t)"\"", 1);
  __printf_flush(v19);
  return v10;
}

uint64_t __printf_arginfo_str(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
    __assert_rtn("__printf_arginfo_str", "xprintf_str.c", 113, "n > 0");
  if (((*(_WORD *)(a1 + 40) >> 3) & 1) != 0 || *(_DWORD *)(a1 + 28) == 67)
    *a3 = 16;
  else
    *a3 = 8;
  return 1;
}

uint64_t __printf_render_str(_QWORD **a1, uint64_t a2, uint64_t **a3)
{
  signed int v3;
  unsigned int v5;
  signed int v6;
  char *v7;
  const __int32 *v8;
  uint64_t v9;

  if (((*(_WORD *)(a2 + 40) >> 3) & 1) != 0 || *(_DWORD *)(a2 + 28) == 83)
  {
    v8 = (const __int32 *)**a3;
    if (!v8)
      return __printf_out((uint64_t)a1, a2, (uint64_t)"(null)", 6);
    v7 = __wcsconv_0(v8, *(_DWORD *)(a2 + 20), *(_xlocale **)(a2 + 8));
    if (v7)
    {
      v3 = _platform_strlen(v7);
      v5 = __printf_out((uint64_t)a1, a2, (uint64_t)v7, v3);
      __printf_flush(a1);
      free(v7);
      return v5;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    v9 = **a3;
    if (!v9)
      return __printf_out((uint64_t)a1, a2, (uint64_t)"(null)", 6);
    v6 = _platform_strlen(v9);
    if (*(int *)(a2 + 20) >= 0 && *(_DWORD *)(a2 + 20) < v6)
      v6 = *(_DWORD *)(a2 + 20);
    return __printf_out((uint64_t)a1, a2, v9, v6);
  }
}

char *__wcsconv_0(const __int32 *a1, int a2, _xlocale *a3)
{
  __int32 *v3;
  size_t v5;
  size_t v6;
  size_t v7;
  char *v8;
  __int32 *v9;
  char v10[6];
  locale_t v11;
  int v12;
  const __int32 *v13;
  mbstate_t v15;

  v13 = a1;
  v12 = a2;
  v11 = a3;
  _platform_memset(&v15, 0, 128);
  v9 = 0;
  if (v12 >= 0)
  {
    if (v12 >= 128)
    {
      v5 = 0;
      v9 = (__int32 *)v13;
      j___platform_memmove(&v15, &__wcsconv_initial_0, 128);
      while (1)
      {
        v3 = v9++;
        v7 = wcrtomb_l(v10, *v3, &v15, v11);
        if (!v7 || v7 == -1 || (int)v5 + (int)v7 > v12)
          break;
        v5 += v7;
      }
    }
    else
    {
      v5 = v12;
    }
  }
  else
  {
    v9 = (__int32 *)v13;
    j___platform_memmove(&v15, &__wcsconv_initial_0, 128);
    v5 = wcsrtombs_l(0, (const __int32 **)&v9, 0, &v15, v11);
    if (v5 == -1)
      return 0;
  }
  v8 = (char *)malloc_type_malloc(v5 + 1, 3521613877);
  if (!v8)
    return 0;
  v9 = (__int32 *)v13;
  j___platform_memmove(&v15, &__wcsconv_initial_0, 128);
  v6 = wcsrtombs_l(v8, (const __int32 **)&v9, v5, &v15, v11);
  if (v6 == -1)
  {
    free(v8);
    return 0;
  }
  else
  {
    v8[v6] = 0;
    return v8;
  }
}

uint64_t __printf_arginfo_chr(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
    __assert_rtn("__printf_arginfo_chr", "xprintf_str.c", 156, "n > 0");
  if (*(__int16 *)(a1 + 40) >= 0)
  {
    if (((*(_WORD *)(a1 + 40) >> 3) & 1) != 0 || *(_DWORD *)(a1 + 28) == 67)
      *a3 = 4;
    else
      *a3 = 1;
  }
  else
  {
    *a3 = 256;
  }
  return 1;
}

uint64_t __printf_render_chr(_QWORD **a1, uint64_t a2, __int32 **a3)
{
  uint64_t v3;
  int v5;
  int v6;
  mbstate_t *v7;
  char *v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int *v12;
  size_t v13;
  char v14;
  __int32 v15;
  unsigned int v16;
  __int32 **v17;
  uint64_t v18;
  _QWORD **v19;
  unsigned int v20;
  _BYTE v21[128];

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  _platform_memset(v21, 0, 128);
  v13 = 0;
  v3 = *(unsigned int *)(*(_QWORD *)(*(_QWORD *)(v18 + 8) + 1328) + 64);
  v12 = &v5;
  v8 = (char *)&v5 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  v11 = v3;
  if (*(__int16 *)(v18 + 40) >= 0)
  {
    if (((*(_WORD *)(v18 + 40) >> 3) & 1) != 0 || *(_DWORD *)(v18 + 28) == 67)
    {
      v9 = 0;
      v15 = **v17;
      v7 = (mbstate_t *)v21;
      j___platform_memmove(v21, &__printf_render_chr_initial, 128);
      v13 = wcrtomb_l(v8, v15, v7, *(locale_t *)(v18 + 8));
      if (v13 == -1)
      {
        v20 = -1;
      }
      else
      {
        v9 = __printf_out((uint64_t)v19, v18, (uint64_t)v8, v13);
        __printf_flush(v19);
        v20 = v9;
      }
      v10 = 1;
    }
    else
    {
      v16 = **v17;
      v14 = v16;
      v6 = 1;
      v16 = __printf_out((uint64_t)v19, v18, (uint64_t)&v14, 1);
      __printf_flush(v19);
      v20 = v16;
      v10 = v6;
    }
  }
  else
  {
    v20 = __xprintf_vector(v19, v18, v17);
    v10 = 1;
  }
  return v20;
}

uint64_t __printf_arginfo_time(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
    __assert_rtn("__printf_arginfo_time", "xprintf_time.c", 48, "n >= 1");
  *a3 = 32;
  return 1;
}

uint64_t __printf_render_time(_QWORD **a1, uint64_t a2, uint64_t ***a3)
{
  unsigned int v4;
  int v5;
  int v6;
  int i;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  char *v12;
  char v15[100];

  if (((*(_WORD *)(a2 + 40) >> 3) & 1) != 0)
  {
    v11 = **a3;
    v9 = *v11;
    v5 = 1000 * *((_DWORD *)v11 + 2);
    v6 = 6;
  }
  else if ((*(_WORD *)(a2 + 40) & 1) != 0)
  {
    v10 = **a3;
    v9 = *v10;
    v5 = v10[1];
    v6 = 9;
  }
  else
  {
    v9 = ***a3;
    v5 = 0;
    v6 = 0;
  }
  if (((*(_WORD *)(a2 + 40) >> 3) & 1) != 0 || (*(_WORD *)(a2 + 40) & 1) != 0)
  {
    if (*(int *)(a2 + 20) >= 0)
      v6 = *(_DWORD *)(a2 + 20);
    if (!v6)
      v5 = 0;
  }
  v12 = v15;
  if (((*(_WORD *)(a2 + 40) >> 4) & 1) != 0)
  {
    v8 = v9;
    if (v9 >= 31536000)
    {
      v12 = &v15[sprintf(v15, "%jdy", v9 / 31536000)];
      v9 %= 31536000;
    }
    if (v8 >= 86400 && (v9 || v6))
    {
      v12 += sprintf(v12, "%jdd", v9 / 86400);
      v9 %= 86400;
    }
    if (v8 >= 3600 && (v9 || v6))
    {
      v12 += sprintf(v12, "%jdh", v9 / 3600);
      v9 %= 3600;
    }
    if (v8 >= 60 && (v9 || v6))
    {
      v12 += sprintf(v12, "%jdm", v9 / 60);
      v9 %= 60;
    }
    if (v9 || !v8 || v6)
      v12 += sprintf(v12, "%jds", v9);
  }
  else
  {
    v12 = &v15[sprintf(v15, "%jd", v9)];
  }
  if (v6)
  {
    for (i = v6; i < 9; ++i)
      v5 /= 10;
    v12 += sprintf(v12, ".%.*d", v6, v5);
  }
  v4 = __printf_out((uint64_t)a1, a2, (uint64_t)v15, v12 - v15);
  __printf_flush(a1);
  return v4;
}

uint64_t __printf_arginfo_vis(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
    __assert_rtn("__printf_arginfo_vis", "xprintf_vis.c", 44, "n >= 1");
  *a3 = 32;
  return 1;
}

uint64_t __printf_render_vis(_QWORD **a1, uint64_t a2, char ***a3)
{
  int v3;
  signed int v5;
  unsigned int v6;
  unsigned int v7;
  char *v8;
  char *v9;

  v9 = **a3;
  if (v9)
  {
    if (*(int *)(a2 + 20) < 0)
      v7 = _platform_strlen(v9);
    else
      v7 = *(_DWORD *)(a2 + 20);
    v8 = (char *)malloc_type_malloc(4 * v7 + 1, 1738750566);
    if (v8)
    {
      if (((*(_WORD *)(a2 + 40) >> 7) & 1) != 0)
      {
        v5 = strvisx(v8, v9, v7, 156);
        v3 = __printf_out((uint64_t)a1, a2, (uint64_t)v8, v5);
      }
      else if (*(_DWORD *)(a2 + 32) == 48)
      {
        v5 = strvisx(v8, v9, v7, 29);
        v3 = __printf_out((uint64_t)a1, a2, (uint64_t)v8, v5);
      }
      else
      {
        if (((*(_WORD *)(a2 + 40) >> 4) & 1) != 0)
          v5 = strvisx(v8, v9, v7, 28);
        else
          v5 = strvisx(v8, v9, v7, 31);
        v3 = __printf_out((uint64_t)a1, a2, (uint64_t)v8, v5);
      }
      v6 = v5 + v3;
      __printf_flush(a1);
      free(v8);
      return v6;
    }
    else
    {
      return -1;
    }
  }
  else
  {
    return __printf_out((uint64_t)a1, a2, (uint64_t)"(null)", 6);
  }
}

uint64_t __printf_flush(_QWORD **a1)
{
  __sfvwrite(*a1, (uint64_t)(a1 + 1));
  return __printf_init((uint64_t)a1);
}

uint64_t __printf_init(uint64_t result)
{
  *(_QWORD *)(result + 152) = result + 24;
  *(_QWORD *)(result + 8) = result + 24;
  *(_DWORD *)(result + 20) = 0;
  *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t __printf_puts(uint64_t a1, uint64_t a2, unsigned int a3)
{
  if (a3)
  {
    **(_QWORD **)(a1 + 152) = a2;
    *(_QWORD *)(*(_QWORD *)(a1 + 152) + 8) = (int)a3;
    *(_DWORD *)(a1 + 20) += a3;
    *(_QWORD *)(a1 + 152) += 16;
    if ((int)++*(_DWORD *)(a1 + 16) >= 8)
      __printf_flush((_QWORD **)a1);
    return a3;
  }
  else
  {
    return 0;
  }
}

uint64_t __printf_pad(uint64_t a1, int a2, int a3)
{
  unsigned int v4;
  void *v5;
  signed int v6;

  v4 = 0;
  if (a3)
    v5 = &zeroes_1;
  else
    v5 = &blanks_1;
  v6 = a2;
  if (a2 > 0)
  {
    while (v6 > 16)
    {
      v4 += __printf_puts(a1, (uint64_t)v5, 0x10u);
      v6 -= 16;
    }
    v4 += __printf_puts(a1, (uint64_t)v5, v6);
  }
  return v4;
}

uint64_t __printf_out(uint64_t a1, uint64_t a2, uint64_t a3, signed int a4)
{
  int v5;
  unsigned int v6;

  v5 = 0;
  if (((*(_WORD *)(a2 + 40) >> 6) & 1) == 0 && *(_DWORD *)(a2 + 24) > a4)
    v5 = __printf_pad(a1, *(_DWORD *)(a2 + 24) - a4, *(_DWORD *)(a2 + 32) == 48);
  v6 = v5 + __printf_puts(a1, a3, a4);
  if (((*(_WORD *)(a2 + 40) >> 6) & 1) != 0 && *(_DWORD *)(a2 + 24) > a4)
    v6 += __printf_pad(a1, *(_DWORD *)(a2 + 24) - a4, *(_DWORD *)(a2 + 32) == 48);
  return v6;
}

uint64_t __printf_arginfo_pct()
{
  return 0;
}

uint64_t __printf_render_pct(uint64_t a1)
{
  return __printf_puts(a1, (uint64_t)"%", 1u);
}

uint64_t __printf_arginfo_n(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  if (!a2)
    __assert_rtn("__printf_arginfo_n", "xprintf.c", 233, "n >= 1");
  *a3 = 32;
  return 1;
}

uint64_t __printf_render_n(uint64_t a1, uint64_t a2, _BYTE **a3)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int16 v11;
  char v12;
  _BYTE *v13;

  v13 = *a3;
  if (((*(_WORD *)(a2 + 40) >> 1) & 1) != 0)
  {
    v12 = *(_DWORD *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 1);
    *v13 = v12;
  }
  else if (((*(_WORD *)(a2 + 40) >> 2) & 1) != 0)
  {
    v11 = *(_DWORD *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 2);
    *(_WORD *)v13 = v11;
  }
  else if (((*(_WORD *)(a2 + 40) >> 3) & 1) != 0)
  {
    v10 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(_QWORD *)v13 = v10;
  }
  else if ((*(_WORD *)(a2 + 40) & 1) != 0)
  {
    v9 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(_QWORD *)v13 = v9;
  }
  else if (((*(_WORD *)(a2 + 40) >> 12) & 1) != 0)
  {
    v8 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(_QWORD *)v13 = v8;
  }
  else if (((*(_WORD *)(a2 + 40) >> 13) & 1) != 0)
  {
    v7 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(_QWORD *)v13 = v7;
  }
  else if (((*(_WORD *)(a2 + 40) >> 11) & 1) != 0)
  {
    v6 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(_QWORD *)v13 = v6;
  }
  else if (((*(_WORD *)(a2 + 40) >> 14) & 1) != 0)
  {
    v5 = *(int *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 8);
    *(_QWORD *)v13 = v5;
  }
  else
  {
    v4 = *(_DWORD *)(a2 + 44);
    libc_hooks_will_write((uint64_t)v13, 4);
    *(_DWORD *)v13 = v4;
  }
  return 0;
}

uint64_t __printf_comp(uint64_t a1, uint64_t a2)
{
  _BYTE *v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v7)(unint64_t, uint64_t, uint64_t);
  unint64_t v8;
  int v9;
  unint64_t v10;
  BOOL v11;
  void **v12;
  void **v13;
  _QWORD v14[2];
  _QWORD v15[2];
  int v16;
  unsigned int v17;
  int v18;
  int v19;
  uint64_t v20;
  int i;
  int v22;
  _BYTE *v23;
  unint64_t v24;
  unint64_t j;
  uint64_t v26;
  uint64_t v27;

  v27 = a1;
  v26 = a2;
  j = 0;
  v24 = 0;
  v23 = 0;
  v22 = 0;
  i = 0;
  v20 = 0;
  v19 = 0;
  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15[0] = 0;
  v15[1] = 0;
  v14[0] = 0;
  v14[1] = 0;
  v23 = *(_BYTE **)(a1 + 64);
  v18 = 0;
  v19 = 1;
  v13 = (void **)arrayinit((uint64_t)v15, 88);
  if (!v13)
    return -1;
  v12 = (void **)arrayinit((uint64_t)v14, 4);
  if (!v12)
  {
    arrayfree(v13);
    return -1;
  }
  for (i = 0; ; ++i)
  {
    j = arrayget((uint64_t)v13, i);
    if (!j)
    {
      v17 = -1;
LABEL_47:
      arrayfree(v13);
      arrayfree(v12);
      return v17;
    }
    v24 = j;
    if (!*v23)
      break;
    v24 = j + 88;
    *(_DWORD *)(j + 20) = -1;
    *(_DWORD *)(j + 32) = 32;
    *(_DWORD *)(j + 16) = 88;
    v2 = v23;
    *(_QWORD *)(j + 64) = v23;
    *(_QWORD *)(j + 56) = v2;
    while (1)
    {
      v11 = 0;
      if (*v23)
        v11 = *v23 != 37;
      if (!v11)
        break;
      *(_QWORD *)(j + 64) = ++v23;
    }
    if (!*v23)
      break;
    *(_DWORD *)(j + 28) = (char)*++v23;
    v10 = (*(_DWORD *)(j + 28) - 32);
    if (v10 <= 0x5A)
      __asm { BR              X8 }
    ++v23;
    if (*(int *)(j + 28) >= 33 && *(int *)(j + 28) <= 126)
    {
      v9 = *(char *)(v26 + 200 + *(_DWORD *)(j + 28) - 33);
      if (v9 == 2 || v9 == 1)
      {
        if (!arrayget((uint64_t)v12, v19 + 1))
        {
          v17 = -1;
          goto LABEL_47;
        }
        *(_QWORD *)j = *(_QWORD *)(v26 + 296 + 24 * (*(_DWORD *)(j + 28) - 33) + 16);
        *(_QWORD *)(j + 8) = *(_QWORD *)(v27 + 80);
        v7 = *(uint64_t (**)(unint64_t, uint64_t, uint64_t))(v26 + 296 + 24
                                                                                      * (*(_DWORD *)(j + 28) - 33));
        v8 = j;
        v4 = arrayget((uint64_t)v12, v19);
        v22 = v7(v8, 2, v4);
        if (v22 > 0)
          *(_QWORD *)(j + 72) = v19;
        if (v22 > 1)
          *(_QWORD *)(j + 80) = v19 + 1;
        v19 += v22;
      }
      else if (v9 == 3)
      {
        errx(1, "Unexpected flag: %c", *(unsigned int *)(j + 28));
      }
    }
  }
  if (v19 > v18)
    v18 = v19;
  *(_QWORD *)(v27 + 104) = *v12;
  *(_QWORD *)(v27 + 88) = *v13;
  *(_QWORD *)(v27 + 96) = v24;
  v22 = v18;
  *(_DWORD *)(v27 + 120) = v18;
  if (v22 < 1)
    v22 = 1;
  v5 = malloc_type_malloc(16 * v22, 0x1092040C99D0F4CLL);
  *(_QWORD *)(v27 + 112) = v5;
  if (!*(_QWORD *)(v27 + 112))
  {
    v17 = -1;
    goto LABEL_47;
  }
  for (j = *(_QWORD *)(v27 + 88); j < v24; j += 88)
  {
    if (*(_QWORD *)(j + 72))
      *(_QWORD *)(j + 72) = *(_QWORD *)(v27 + 112) + 16 * *(_QWORD *)(j + 72);
    if (*(_QWORD *)(j + 80))
      *(_QWORD *)(j + 80) = *(_QWORD *)(v27 + 112) + 16 * *(_QWORD *)(j + 80);
  }
  *(_QWORD *)(v27 + 72) = v26;
  return v17;
}

uint64_t arrayinit(uint64_t a1, int a2)
{
  *(_QWORD *)a1 = malloc_type_calloc(8, a2, 881937338);
  if (!*(_QWORD *)a1)
    return 0;
  *(_DWORD *)(a1 + 8) = a2;
  *(_DWORD *)(a1 + 12) = 8;
  return a1;
}

void arrayfree(void **a1)
{
  if (a1)
    free(*a1);
}

uint64_t arrayget(uint64_t a1, int a2)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;

  if (a2 < *(_DWORD *)(a1 + 12))
    return *(_QWORD *)a1 + a2 * *(_DWORD *)(a1 + 8);
  v6 = *(_DWORD *)(a1 + 12) * *(_DWORD *)(a1 + 8);
  v5 = a2 + 8;
  v4 = (a2 + 8) * *(_DWORD *)(a1 + 8);
  v3 = malloc_type_realloc(*(_QWORD *)a1, v4, 1491423812);
  if (v3)
  {
    _platform_bzero(v3 + v6, v4 - v6);
    *(_QWORD *)a1 = v3;
    *(_DWORD *)(a1 + 12) = v5;
    return *(_QWORD *)a1 + a2 * *(_DWORD *)(a1 + 8);
  }
  return 0;
}

uint64_t __printf_exec(uint64_t a1, _QWORD *a2, int *a3)
{
  int *v3;
  int *v4;
  int *v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t *v11;
  int *v12;
  uint64_t *v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t *v17;
  _OWORD *v18;
  int v19;
  int v20;
  int v21;
  int v23;
  int v24;
  char v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  _QWORD *v44[20];
  int v45;
  unsigned int v46;
  int i;
  unint64_t j;
  int *v49;
  _QWORD *v50;
  uint64_t v51;

  v51 = a1;
  v50 = a2;
  v49 = a3;
  j = 0;
  i = 0;
  v46 = 0;
  v45 = 0;
  memset(v44, 0, sizeof(v44));
  __printf_init((uint64_t)v44);
  v44[0] = v50;
  for (i = 1; i < *(_DWORD *)(v51 + 120); ++i)
  {
    v24 = *(_DWORD *)(*(_QWORD *)(v51 + 104) + 4 * i);
    switch(v24)
    {
      case 1:
        v4 = v49;
        v49 += 2;
        v42 = *v4;
        *(_DWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v42;
        break;
      case 2:
        v3 = v49;
        v49 += 2;
        v43 = *v3;
        *(_DWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = (char)v43;
        break;
      case 4:
        v12 = v49;
        v49 += 2;
        v34 = *v12;
        *(_DWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v34;
        break;
      case 8:
        v32 = 0;
        v14 = (uint64_t *)v49;
        v49 += 2;
        v31 = *v14;
        v32 = v31;
        libc_hooks_will_read_cstring(v31);
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v31;
        break;
      case 16:
        v30 = 0;
        v15 = (uint64_t *)v49;
        v49 += 2;
        v29 = *v15;
        v30 = v29;
        libc_hooks_will_read_wcstring(v29);
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v29;
        break;
      case 32:
        v13 = (uint64_t *)v49;
        v49 += 2;
        v33 = *v13;
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v33;
        break;
      case 128:
        v16 = (uint64_t *)v49;
        v49 += 2;
        v28 = *v16;
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v28;
        break;
      case 256:
        v18 = (_OWORD *)(((unint64_t)v49 + 15) & 0xFFFFFFFFFFFFFFF0);
        v49 = (int *)(v18 + 1);
        v26 = *v18;
        *(_OWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v26;
        break;
      case 65537:
        v9 = (uint64_t *)v49;
        v49 += 2;
        v37 = *v9;
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v37;
        break;
      case 65664:
        v17 = (uint64_t *)v49;
        v49 += 2;
        v27 = *v17;
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v27;
        break;
      case 131073:
        v6 = (uint64_t *)v49;
        v49 += 2;
        v40 = *v6;
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v40;
        break;
      case 262145:
        v5 = v49;
        v49 += 2;
        v41 = *v5;
        *(_DWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = (__int16)v41;
        break;
      case 1048577:
        v8 = (uint64_t *)v49;
        v49 += 2;
        v38 = *v8;
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v38;
        break;
      case 2097153:
        v7 = (uint64_t *)v49;
        v49 += 2;
        v39 = *v7;
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v39;
        break;
      case 4194305:
        v10 = (uint64_t *)v49;
        v49 += 2;
        v36 = *v10;
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v36;
        break;
      case 8388609:
        v11 = (uint64_t *)v49;
        v49 += 2;
        v35 = *v11;
        *(_QWORD *)(*(_QWORD *)(v51 + 112) + 16 * i) = v35;
        break;
      default:
        errx(1, "argtype = %x (fmt = \"%s\")\n", *(_DWORD *)(*(_QWORD *)(v51 + 104) + 4 * i), *(const char **)(v51 + 64));
    }
  }
  for (j = *(_QWORD *)(v51 + 88); j < *(_QWORD *)(v51 + 96); j += 88)
  {
    if (*(_DWORD *)(j + 48))
    {
      *(_DWORD *)(j + 24) = *(_DWORD *)(*(_QWORD *)(v51 + 112) + 16 * *(unsigned int *)(j + 48));
      if ((*(_DWORD *)(j + 24) & 0x80000000) != 0)
      {
        *(_WORD *)(j + 40) |= 0x40u;
        *(_DWORD *)(j + 24) = -*(_DWORD *)(j + 24);
      }
    }
    if (*(_DWORD *)(j + 52))
      *(_DWORD *)(j + 20) = *(_DWORD *)(*(_QWORD *)(v51 + 112) + 16 * *(unsigned int *)(j + 52));
    v46 += __printf_puts((uint64_t)v44, *(_QWORD *)(j + 56), *(_DWORD *)(j + 64) - *(_QWORD *)(j + 56));
    if (*(_DWORD *)(j + 28))
    {
      if (*(int *)(j + 28) >= 33
        && *(int *)(j + 28) < 127
        && (v19 = *(_DWORD *)(j + 28) - 33,
            v23 = *(char *)(*(_QWORD *)(v51 + 72) + v19 + 200),
            *(_BYTE *)(*(_QWORD *)(v51 + 72) + v19 + 200)))
      {
        if (v23 == 1)
        {
          __printf_flush(v44);
          *(_DWORD *)(j + 44) = v46;
          v21 = (*(uint64_t (**)(_QWORD *, unint64_t, unint64_t))(*(_QWORD *)(v51 + 72)
                                                                                        + 24
                                                                                        * (*(_DWORD *)(j + 28) - 33)
                                                                                        + 304))(v50, j, j + 72);
          v46 += v21;
        }
        else if (v23 == 2)
        {
          *(_DWORD *)(j + 44) = v46;
          v45 = (*(uint64_t (**)(_QWORD **, unint64_t, unint64_t))(*(_QWORD *)(v51 + 72)
                                                                                         + 24
                                                                                         * (*(_DWORD *)(j + 28) - 33)
                                                                                         + 304))(v44, j, j + 72);
          if (v45 < 0)
            *((_WORD *)v44[0] + 8) |= 0x40u;
          else
            v46 += v45;
        }
      }
      else
      {
        v25 = 0;
        v25 = *(_DWORD *)(j + 28);
        v20 = __printf_out((uint64_t)v44, j, (uint64_t)&v25, 1);
        v46 += v20;
      }
    }
  }
  __printf_flush(v44);
  return v46;
}

uint64_t libc_hooks_will_read_wcstring(uint64_t result)
{
  if (off_E9738)
    return off_E9738(result);
  return result;
}

uint64_t __v2printf(uint64_t a1, pthread_rwlock_t *a2, uint64_t a3, _xlocale *a4, char *a5, int *a6)
{
  unsigned int *v8;
  BOOL v9;
  int v10;
  int v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int *v22;
  _BYTE v23[64];
  char *v24;
  _xlocale *v25;
  void *v26;
  void *v27;
  void *v28;

  _platform_memset(v23, 0, 128);
  libc_hooks_will_read((uint64_t)a4, 1472);
  libc_hooks_will_read_cstring((uint64_t)a5);
  if ((*(_WORD *)(a3 + 16) & 8) == 0 || (v9 = 0, !*(_QWORD *)(a3 + 24)) && (v9 = 0, (*(_WORD *)(a3 + 16) & 0x200) == 0))
    v9 = __swsetup(a3) != 0;
  if (v9)
  {
    *__error() = 9;
    return -1;
  }
  else
  {
    if (!((char)(32 * *(_BYTE *)(*(_QWORD *)(a3 + 104) + 72)) >> 5))
      *(_BYTE *)(*(_QWORD *)(a3 + 104) + 72) = *(_BYTE *)(*(_QWORD *)(a3 + 104) + 72) & 0xF8 | 7;
    if (a1 == -1)
    {
      if (a4)
      {
        if (a4 == (_xlocale *)-1)
          a4 = (_xlocale *)&__global_locale;
        return __vfprintf(a3, a4, a5, a6);
      }
      else
      {
        return __vfprintf(a3, (_xlocale *)&__c_locale, a5, a6);
      }
    }
    else if (a1)
    {
      pthread_mutex_lock((pthread_mutex_t *)a1);
      pthread_rwlock_rdlock(*(pthread_rwlock_t **)(a1 + 72));
      v13 = __printf_exec(a1, (_QWORD *)a3, a6);
      v10 = *__error();
      pthread_rwlock_unlock(*(pthread_rwlock_t **)(a1 + 72));
      pthread_mutex_unlock((pthread_mutex_t *)a1);
      *__error() = v10;
      return v13;
    }
    else if (a2)
    {
      pthread_once(&__xprintf_domain_once, (void (*)(void))__xprintf_domain_init);
      _platform_memset(v23, 0, 128);
      v24 = a5;
      if (a4)
      {
        if (a4 == (_xlocale *)-1)
          a4 = (_xlocale *)&__global_locale;
        xlocale_retain((unsigned int *)a4);
      }
      else
      {
        v22 = (unsigned int *)pthread_getspecific(__locale_key);
        if (v22)
          v8 = v22;
        else
          v8 = (unsigned int *)&__global_locale;
        a4 = (_xlocale *)v8;
        xlocale_retain(v8);
      }
      v25 = a4;
      pthread_rwlock_rdlock(a2);
      if ((int)__printf_comp((uint64_t)v23, (uint64_t)a2) >= 0)
      {
        v14 = __printf_exec((uint64_t)v23, (_QWORD *)a3, a6);
        v12 = *__error();
        pthread_rwlock_unlock(a2);
        xlocale_release((uint64_t)a4);
        free(v26);
        free(v27);
        free(v28);
        *__error() = v12;
        return v14;
      }
      else
      {
        v11 = *__error();
        pthread_rwlock_unlock(a2);
        xlocale_release((uint64_t)a4);
        *__error() = v11;
        return -1;
      }
    }
    else
    {
      *__error() = 22;
      return -1;
    }
  }
}

uint64_t __xvprintf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  if ((*(_WORD *)(a3 + 16) & 0x1A) == 0xA && *(__int16 *)(a3 + 18) >= 0)
    return __v3printf(a1, a2, a3, a4, a5, a6);
  else
    return __v2printf(a1, a2, a3, a4, a5, a6);
}

uint64_t __v3printf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _BYTE *v7;
  int v8;
  __int16 v9;
  __int16 v10;
  _BYTE *v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD v24[8];
  _BYTE v25[1024];
  uint64_t v26;
  uint64_t v27;

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v19 = a5;
  v18 = a6;
  v17 = 0;
  _platform_memset(&v7, 0, 152);
  _platform_memset(&v26, 0, 208);
  v16 = &v26;
  v26 = 0;
  _platform_memset(v24, 0, 64);
  v24[0] = 850045858;
  j___platform_memmove(&v27, v24, 64);
  *((_BYTE *)v16 + 72) &= 0xF8u;
  _platform_memset(v16 + 10, 0, 128);
  *((_BYTE *)v16 + 72) &= ~8u;
  v9 = *(_WORD *)(v21 + 16) & 0xFFFD;
  v10 = *(_WORD *)(v21 + 18);
  v14 = *(_QWORD *)(v21 + 48);
  v15 = *(_QWORD *)(v21 + 80);
  *((_BYTE *)v16 + 72) = v16[9] & 0xF8 | ((char)(32 * *(_BYTE *)(*(_QWORD *)(v21 + 104) + 72)) >> 5) & 7;
  j___platform_memmove(v16 + 10, *(_QWORD *)(v21 + 104) + 80, 128);
  v7 = v25;
  v11 = v25;
  v8 = 1024;
  v12 = 1024;
  v13 = 0;
  v17 = __v2printf(v23, v22, &v7, v20, v19, v18);
  if (v17 >= 0 && __fflush((uint64_t)&v7))
    v17 = -1;
  if ((v9 & 0x40) != 0)
    *(_WORD *)(v21 + 16) |= 0x40u;
  return v17;
}

uint64_t __xprintf_vector(uint64_t a1, uint64_t a2, unsigned __int16 **a3)
{
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  unint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  int n;
  int *v23;
  int v24;
  int m;
  uint64_t *v26;
  uint64_t v27;
  int k;
  int *v29;
  int v30;
  int j;
  uint64_t *v32;
  uint64_t v33;
  int i;
  _BYTE v35[40];
  __int16 v36;
  char *v37;
  char *v38;
  unsigned int v39;
  unsigned __int16 *v40;
  char v41;
  unsigned __int16 **v42;
  uint64_t v43;
  uint64_t v44;

  v44 = a1;
  v43 = a2;
  v42 = a3;
  v41 = 0;
  v40 = 0;
  v39 = 0;
  _platform_memset(v35, 0, 88);
  j___platform_memmove(v35, v43, 88);
  v40 = *v42;
  v41 = *(_DWORD *)(v43 + 16);
  if (v41 == 88)
  {
    if (*(_DWORD *)(v43 + 28) == 99)
      v41 = 0;
    else
      v41 = 32;
  }
  v38 = &v41;
  v37 = &v41;
  if (v41)
    ++v38;
  v36 &= ~0x8000u;
  if (((*(_WORD *)(v43 + 40) >> 2) & 1) != 0)
  {
    if (*(_DWORD *)(v43 + 28) == 112)
    {
      i = 0;
      v33 = 0;
      v32 = 0;
      v33 = *v40;
      v32 = &v33;
      v3 = __printf_render_ptr(v44, (uint64_t)v35, &v32);
      v39 += v3;
      for (i = 1; i < 8; ++i)
      {
        v4 = __printf_puts(v44, (uint64_t)v37, (int)v38 - (int)v37);
        v39 += v4;
        v33 = v40[i];
        v5 = __printf_render_ptr(v44, (uint64_t)v35, &v32);
        v39 += v5;
      }
    }
    else
    {
      j = 0;
      v30 = 0;
      v29 = 0;
      v30 = *v40;
      v29 = &v30;
      v6 = __printf_render_int(v44, (uint64_t)v35, (uint64_t)&v29);
      v39 += v6;
      for (j = 1; j < 8; ++j)
      {
        v7 = __printf_puts(v44, (uint64_t)v37, (int)v38 - (int)v37);
        v39 += v7;
        v30 = v40[j];
        v8 = __printf_render_int(v44, (uint64_t)v35, (uint64_t)&v29);
        v39 += v8;
      }
    }
  }
  else if (((*(_WORD *)(v43 + 40) >> 3) & 1) != 0)
  {
    v36 &= ~8u;
    if (*(_DWORD *)(v43 + 28) == 112)
    {
      k = 0;
      v27 = 0;
      v26 = 0;
      v27 = *(unsigned int *)v40;
      v26 = &v27;
      v9 = __printf_render_ptr(v44, (uint64_t)v35, &v26);
      v39 += v9;
      for (k = 1; k < 4; ++k)
      {
        v10 = __printf_puts(v44, (uint64_t)v37, (int)v38 - (int)v37);
        v39 += v10;
        v27 = *(unsigned int *)&v40[2 * k];
        v11 = __printf_render_ptr(v44, (uint64_t)v35, &v26);
        v39 += v11;
      }
    }
    else
    {
      m = 0;
      v24 = 0;
      v23 = 0;
      v24 = *(_DWORD *)v40;
      v23 = &v24;
      v12 = __printf_render_int(v44, (uint64_t)v35, (uint64_t)&v23);
      v39 += v12;
      for (m = 1; m < 4; ++m)
      {
        v13 = __printf_puts(v44, (uint64_t)v37, (int)v38 - (int)v37);
        v39 += v13;
        v24 = *(_DWORD *)&v40[2 * m];
        v14 = __printf_render_int(v44, (uint64_t)v35, (uint64_t)&v23);
        v39 += v14;
      }
    }
  }
  else
  {
    v19 = (*(_DWORD *)(v43 + 28) - 65);
    if (v19 <= 0x37)
      __asm { BR              X8 }
    n = 0;
    v21 = 0;
    v20 = 0;
    v21 = *(unsigned __int8 *)v40;
    v20 = &v21;
    v15 = __printf_render_ptr(v44, (uint64_t)v35, &v20);
    v39 += v15;
    for (n = 1; n < 16; ++n)
    {
      v16 = __printf_puts(v44, (uint64_t)v37, (int)v38 - (int)v37);
      v39 += v16;
      v21 = *((unsigned __int8 *)v40 + n);
      v17 = __printf_render_ptr(v44, (uint64_t)v35, &v20);
      v39 += v17;
    }
  }
  return v39;
}

uint64_t at_quick_exit(unint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t *v4;

  v4 = (unint64_t *)malloc_type_calloc(1, 16, 0xA0040AFF93C70);
  if (v4)
  {
    v4[1] = a1;
    while (1)
    {
      v1 = *v4;
      do
        v2 = __ldaxr(&handlers);
      while (v2 == v1 && __stlxr((unint64_t)v4, &handlers));
      if (v2 == v1)
        break;
      *v4 = v2;
    }
    return 0;
  }
  else
  {
    return -1;
  }
}

void quick_exit(int a1)
{
  unint64_t v1;
  unint64_t i;

  v1 = atomic_load(&handlers);
  for (i = v1; i; i = *(_QWORD *)i)
    (*(void (**)(void))(i + 8))();
  _Exit(a1);
}

ssize_t strfmon(char *a1, size_t a2, const char *a3, ...)
{
  char v3;
  char v4;
  _xlocale *v9;
  uint64_t v10;
  va_list va;

  va_start(va, a3);
  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v9 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v10 = __locale_key;
    v9 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v10);
  }
  if (v9)
    return _strfmon(a1, a2, v9, (char *)a3, (double *)va);
  else
    return _strfmon(a1, a2, (_xlocale *)__global_locale, (char *)a3, (double *)va);
}

uint64_t _strfmon(char *a1, unint64_t a2, _xlocale *a3, char *a4, double *a5)
{
  unsigned __int8 *v5;
  char *v6;
  unsigned __int8 *v8;
  double v9;
  int v10;
  char *v11;
  char *v12;
  const char *v13;
  char *v14;
  char *v15;
  _BYTE *v16;
  char *v17;
  char *v18;
  const char *v19;
  char *v20;
  char *v21;
  char *v22;
  const char *v23;
  char *v24;
  char *v25;
  _BYTE *v26;
  char *v27;
  char *v28;
  const char *v29;
  char *v30;
  char *v31;
  _BYTE *v32;
  char *v33;
  char *v34;
  const char *v35;
  char *v36;
  char *v37;
  const char *v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  int v45;
  int v46;
  int v47;
  const char *v48;
  const char *v49;
  _BYTE *v50;
  const char *v51;
  _BYTE *v52;
  const char *v53;
  const char *v54;
  _BYTE *v55;
  const char *v56;
  char *v57;
  int v58;
  char *v59;
  const char *v60;
  void *v61;
  char v62;
  char v63;
  char v64;
  char v65;
  double v66;
  int v67;
  int v68;
  int v69;
  int v70;
  unsigned int v71;
  unsigned int v72;
  _BYTE *v73;
  lconv *v74;
  char *v75;
  char *v76;
  double *v77;
  char *v78;
  _xlocale *v79;
  unint64_t v80;
  char *v81;

  v81 = a1;
  v80 = a2;
  v79 = a3;
  v78 = a4;
  v77 = a5;
  v72 = 0;
  v71 = 0;
  v69 = 0;
  v68 = 0;
  v67 = 0;
  v66 = 0.0;
  v65 = 32;
  v64 = 0;
  v63 = 0;
  v62 = 0;
  v60 = 0;
  v74 = localeconv_l(a3);
  v76 = v81;
  v75 = v78;
  v73 = 0;
  v61 = 0;
  v70 = 0;
  while (*v75)
  {
    if (*v75 != 37)
      goto LABEL_6;
    if (v75[1] == 37)
    {
      ++v75;
LABEL_6:
      if (v76 >= &v81[v80])
        goto LABEL_169;
      v5 = (unsigned __int8 *)v75++;
      LOBYTE(v5) = *v5;
      v6 = v76++;
      *v6 = (char)v5;
    }
    else
    {
      v72 = 5;
      v71 = 32;
      v68 = -1;
      v67 = -1;
      v69 = -1;
      v66 = 0.0;
      while (1)
      {
        while (1)
        {
          while (1)
          {
            while (1)
            {
              while (1)
              {
                while (1)
                {
                  v47 = *++v75;
                  if (v47 != 33)
                    break;
                  v72 |= 0x10u;
                }
                if (v47 != 40)
                  break;
                if ((v72 & 2) != 0)
                  goto LABEL_170;
                v72 |= 0xAu;
              }
              if (v47 != 43)
                break;
              if ((v72 & 2) != 0)
                goto LABEL_170;
              v72 |= 6u;
            }
            if (v47 != 45)
              break;
            v72 |= 0x20u;
          }
          if (v47 != 61)
            break;
          v71 = *++v75;
          if (!v71)
            goto LABEL_170;
        }
        if (v47 != 94)
          break;
        v72 &= ~1u;
      }
      if (isdigit_l(*v75, v79) != 0)
      {
        v57 = (char *)(v76 - v81);
        v69 = 0;
        while (isdigit_l(*v75, v79))
        {
          v69 *= 10;
          v69 += *v75 - 48;
          if (v69 > 0xFFFFFF)
            goto LABEL_169;
          ++v75;
        }
        if ((unint64_t)&v57[v69] >= v80)
          goto LABEL_169;
      }
      if (*v75 == 35)
      {
        if (!isdigit_l(*++v75, v79))
          goto LABEL_170;
        v68 = 0;
        while (isdigit_l(*v75, v79))
        {
          v68 *= 10;
          v68 += *v75 - 48;
          if (v68 > 0xFFFFFF)
            goto LABEL_169;
          ++v75;
        }
      }
      if (*v75 == 46)
      {
        if (!isdigit_l(*++v75, v79))
          goto LABEL_170;
        v67 = 0;
        while (isdigit_l(*v75, v79))
        {
          v67 *= 10;
          v67 += *v75 - 48;
          if (v67 > 0xFFFFFF)
            goto LABEL_169;
          ++v75;
        }
      }
      v8 = (unsigned __int8 *)v75++;
      v46 = (char)*v8;
      if (v46 == 105)
      {
        v72 |= 0x40u;
      }
      else
      {
        if (v46 != 110)
        {
LABEL_170:
          *__error() = 22;
          goto LABEL_171;
        }
        v72 &= ~0x40u;
      }
      if (v61)
        free(v61);
      if ((v72 & 0x40) != 0)
      {
        v61 = strdup(v74->int_curr_symbol);
        if (v61)
        {
          v65 = *((_BYTE *)v61 + 3);
          *((_BYTE *)v61 + 3) = 0;
        }
      }
      else
      {
        v61 = strdup(v74->currency_symbol);
      }
      if (!v61)
        goto LABEL_171;
      v9 = *v77++;
      v66 = v9;
      if (v9 < 0.0)
      {
        v72 |= 0x80u;
        v66 = -v66;
      }
      if (v68 >= 0)
      {
        v45 = __calc_left_pad(v72 ^ 0x80, (uint64_t)v61, (uint64_t)v74);
        v70 = v45 - __calc_left_pad(v72, (uint64_t)v61, (uint64_t)v74);
        if (v70 < 0)
          v70 = 0;
      }
      v73 = (_BYTE *)__format_grouped_double(&v72, v68, v67, v71, &v74->decimal_point, v79, v66);
      if (!v73)
        goto LABEL_171;
      __setup_vars(v72, &v64, &v63, &v62, &v60, (uint64_t)v74);
      v59 = v76;
      while (1)
      {
        v10 = v70--;
        if (v10 <= 0)
          break;
        if (v76 >= &v81[v80])
          goto LABEL_169;
        v11 = v76++;
        *v11 = 32;
      }
      if (!v62 && (v72 & 0x80) != 0)
      {
        if (v76 >= &v81[v80])
          goto LABEL_169;
        v12 = v76++;
        *v12 = 40;
      }
      if (v64 == 1)
      {
        if (v62 == 1 || v62 == 3)
        {
          v56 = v60;
          while (*v56)
          {
            if (v76 >= &v81[v80])
              goto LABEL_169;
            v13 = v56++;
            LOBYTE(v13) = *v13;
            v14 = v76++;
            *v14 = (char)v13;
          }
          if (v63 == 2)
          {
            if (v76 >= &v81[v80])
              goto LABEL_169;
            v15 = v76++;
            *v15 = 32;
          }
        }
        if ((v72 & 0x10) == 0)
        {
          v55 = v61;
          while (*v55)
          {
            if (v76 >= &v81[v80])
              goto LABEL_169;
            v16 = v55++;
            LOBYTE(v16) = *v16;
            v17 = v76++;
            *v17 = (char)v16;
          }
          if (v62 == 4)
          {
            if (v63 == 2)
            {
              if (v76 >= &v81[v80])
                goto LABEL_169;
              v18 = v76++;
              *v18 = v65;
            }
            v54 = v60;
            while (*v54)
            {
              if (v76 >= &v81[v80])
                goto LABEL_169;
              v19 = v54++;
              LOBYTE(v19) = *v19;
              v20 = v76++;
              *v20 = (char)v19;
            }
            if (v63 == 1)
            {
              if (v76 >= &v81[v80])
                goto LABEL_169;
              v21 = v76++;
              *v21 = 32;
            }
          }
          else if (v63 == 1)
          {
            if (v76 >= &v81[v80])
              goto LABEL_169;
            v22 = v76++;
            *v22 = v65;
          }
        }
      }
      else if (v62 == 1)
      {
        v53 = v60;
        while (*v53)
        {
          if (v76 >= &v81[v80])
            goto LABEL_169;
          v23 = v53++;
          LOBYTE(v23) = *v23;
          v24 = v76++;
          *v24 = (char)v23;
        }
        if (v63 == 2)
        {
          if (v76 >= &v81[v80])
            goto LABEL_169;
          v25 = v76++;
          *v25 = 32;
        }
      }
      v52 = v73;
      while (*v52)
      {
        if (v76 >= &v81[v80])
          goto LABEL_169;
        v26 = v52++;
        LOBYTE(v26) = *v26;
        v27 = v76++;
        *v27 = (char)v26;
      }
      if (!v64)
      {
        if (v62 == 3)
        {
          if (v63 == 1)
          {
            if (v76 >= &v81[v80])
              goto LABEL_169;
            v28 = v76++;
            *v28 = 32;
          }
          v51 = v60;
          while (*v51)
          {
            if (v76 >= &v81[v80])
              goto LABEL_169;
            v29 = v51++;
            LOBYTE(v29) = *v29;
            v30 = v76++;
            *v30 = (char)v29;
          }
        }
        if ((v72 & 0x10) == 0)
        {
          if (v62 == 3 && v63 == 2 || v63 == 1 && (!v62 || v62 == 1 || v62 == 2 || v62 == 4))
          {
            if (v76 >= &v81[v80])
              goto LABEL_169;
            v31 = v76++;
            *v31 = v65;
          }
          v50 = v61;
          while (*v50)
          {
            if (v76 >= &v81[v80])
              goto LABEL_169;
            v32 = v50++;
            LOBYTE(v32) = *v32;
            v33 = v76++;
            *v33 = (char)v32;
          }
          if (v62 == 4)
          {
            if (v63 == 2)
            {
              if (v76 >= &v81[v80])
                goto LABEL_169;
              v34 = v76++;
              *v34 = 32;
            }
            v49 = v60;
            while (*v49)
            {
              if (v76 >= &v81[v80])
                goto LABEL_169;
              v35 = v49++;
              LOBYTE(v35) = *v35;
              v36 = v76++;
              *v36 = (char)v35;
            }
          }
        }
      }
      if (v62 == 2)
      {
        if (v63 == 2)
        {
          if (v76 >= &v81[v80])
            goto LABEL_169;
          v37 = v76++;
          *v37 = 32;
        }
        v48 = v60;
        while (*v48)
        {
          if (v76 >= &v81[v80])
            goto LABEL_169;
          v38 = v48++;
          LOBYTE(v38) = *v38;
          v39 = v76++;
          *v39 = (char)v38;
        }
      }
      if (!v62)
      {
        if ((v72 & 0x80) != 0)
        {
          if (v76 >= &v81[v80])
            goto LABEL_169;
          v40 = v76++;
          *v40 = 41;
        }
        else if (v68 >= 0)
        {
          if (v76 >= &v81[v80])
            goto LABEL_169;
          v41 = v76++;
          *v41 = 32;
        }
      }
      if (v76 - v59 < v69)
      {
        if ((v72 & 0x20) != 0)
        {
          while (v76 - v59 < v69)
          {
            if (v76 >= &v81[v80])
              goto LABEL_169;
            v42 = v76++;
            *v42 = 32;
          }
        }
        else
        {
          v70 = (_DWORD)v76 - (_DWORD)v59;
          _platform_memmove(&v59[v69 - ((int)v76 - (int)v59)], v59, (int)v76 - (int)v59);
          _platform_memset(v59, 32, v69 - (uint64_t)v70);
          v76 += v69 - v70;
        }
      }
    }
  }
  if (v76 < &v81[v80])
  {
    v43 = v76++;
    *v43 = 0;
    free(v73);
    free(v61);
    return v76 - v81 - 1;
  }
LABEL_169:
  *__error() = 7;
LABEL_171:
  v58 = *__error();
  if (v73)
    free(v73);
  if (v61)
    free(v61);
  *__error() = v58;
  return -1;
}

ssize_t strfmon_l(char *a1, size_t a2, locale_t a3, const char *a4, ...)
{
  _xlocale *v5;
  va_list va;

  va_start(va, a4);
  v5 = a3;
  if (a3)
  {
    if (a3 == (locale_t)-1)
      v5 = (_xlocale *)__global_locale;
  }
  else
  {
    v5 = (_xlocale *)__c_locale;
  }
  return _strfmon(a1, a2, v5, (char *)a4, (double *)va);
}

uint64_t __calc_left_pad(unsigned int a1, uint64_t a2, uint64_t a3)
{
  char v3;
  unsigned int v5;
  const char *v6;
  char v7;
  char v8;
  char v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  __setup_vars(a1, &v9, &v8, &v7, &v6, a3);
  if (v9)
  {
    v5 = _platform_strlen(v11);
    if (v8)
      ++v5;
  }
  if (v7)
  {
    if (v7 == 1 || (v7 != 4 && v7 != 3 ? (v3 = 0) : (v3 = 1), (v3 & 1) != 0 && v9))
      v5 += _platform_strlen(v6);
  }
  else if ((v12 & 0x80) != 0)
  {
    ++v5;
  }
  return v5;
}

uint64_t __format_grouped_double(_DWORD *a1, int a2, int a3, unsigned int a4, char **a5, _xlocale *a6, double a7)
{
  int v7;
  int v8;
  int v9;
  int v11;
  int v12;
  int v13;
  int v14;
  char v15;
  char v16;
  char *fixed;
  int i;
  _BYTE *v19;
  _BYTE *v20;
  uint64_t v21;
  int v22;
  char *v23;
  uint64_t v24;
  locale_t v25;
  char **v26;
  unsigned int v27;
  int v28;
  int v29;
  _DWORD *v30;
  double v31;
  char v33[32];

  v31 = a7;
  v30 = a1;
  v29 = a2;
  v28 = a3;
  v27 = a4;
  v26 = a5;
  v25 = a6;
  v24 = 0;
  v23 = 0;
  v14 = 0;
  fixed = __fix_nogrouping(a5[7]);
  v16 = *v26[5];
  if (!v16)
    v16 = **v26;
  v15 = *v26[6];
  if (!v15)
    v15 = *v26[1];
  if (v29 == -1)
    v29 = 0;
  if (v28 == -1)
  {
    v28 = (*v30 & 0x40) != 0 ? *((char *)v26 + 80) : *((char *)v26 + 81);
    if (v28 == 127)
      v28 = 2;
  }
  if ((*v30 & 1) != 0)
    v29 += get_groups(v29, fixed);
  snprintf_l(v33, 0x20uLL, v25, "%%%d.%df", v29 + v28 + 1, v28);
  v22 = asprintf_l(&v23, v25, v33, *(_QWORD *)&v31);
  if (v22 < 0)
    return 0;
  v21 = 2 * _platform_strlen(v23) + 1;
  v24 = malloc_type_malloc(v21, 299188151);
  if (v24)
  {
    _platform_bzero(v24, v21);
    v19 = (_BYTE *)(v24 + v21 - 1);
    for (i = 0; v23[i] == 32; ++i)
      --v22;
    if (v28 > 0)
    {
      v20 = &v19[-v28];
      j___platform_memmove(v20, &v23[v22 + i - v28], v28);
      v19 = v20 - 1;
      *v19 = v16;
      v22 -= v28 + 1;
    }
    if ((*v30 & 1) != 0 && v15 && *fixed != 127 && *fixed > 0)
    {
      while (v22 > *fixed)
      {
        v13 = *fixed;
        while (1)
        {
          v7 = v13--;
          if (v7 <= 0)
            break;
          *--v19 = v23[--v22 + i];
        }
        *--v19 = v15;
        ++v14;
        if (*++fixed == 127)
          break;
        if (!*fixed)
        {
          --fixed;
          while (v22 > *fixed)
          {
            v12 = *fixed;
            while (1)
            {
              v8 = v12--;
              if (v8 <= 0)
                break;
              *--v19 = v23[--v22 + i];
            }
            *--v19 = v15;
            ++v14;
          }
        }
      }
      if (v22)
      {
        v11 = v22;
        while (1)
        {
          v9 = v11--;
          if (v9 <= 0)
            break;
          *--v19 = v23[--v22 + i];
        }
      }
      i -= v14;
    }
    else
    {
      v19 -= v22;
      j___platform_memmove(v19, &v23[i], v22);
      if (!v28)
        --i;
    }
    if (i > 0)
    {
      v19 -= i;
      _platform_memset(v19, v27, i);
    }
    _platform_memmove(v24, v19, v21 - (_QWORD)&v19[-v24] + 1);
    free(v23);
    return v24;
  }
  else
  {
    free(v23);
    return 0;
  }
}

uint64_t __setup_vars(uint64_t result, _BYTE *a2, _BYTE *a3, _BYTE *a4, const char **a5, uint64_t a6)
{
  char v6;
  const char *v7;
  char v8;
  char v9;
  const char *v10;
  char v11;

  if ((result & 0x80u) != 0 && (result & 0x40) != 0)
  {
    *a2 = *(_BYTE *)(a6 + 89);
    *a3 = *(_BYTE *)(a6 + 91);
    if ((result & 8) != 0)
      v11 = 0;
    else
      v11 = *(_BYTE *)(a6 + 93);
    *a4 = v11;
    if (**(_BYTE **)(a6 + 72))
      v10 = *(const char **)(a6 + 72);
    else
      v10 = "-";
    *a5 = v10;
  }
  else if ((result & 0x40) != 0)
  {
    *a2 = *(_BYTE *)(a6 + 88);
    *a3 = *(_BYTE *)(a6 + 90);
    if ((result & 8) != 0)
      v9 = 0;
    else
      v9 = *(_BYTE *)(a6 + 92);
    *a4 = v9;
    *a5 = *(const char **)(a6 + 64);
  }
  else if ((result & 0x80u) == 0)
  {
    *a2 = *(_BYTE *)(a6 + 82);
    *a3 = *(_BYTE *)(a6 + 83);
    if ((result & 8) != 0)
      v6 = 0;
    else
      v6 = *(_BYTE *)(a6 + 86);
    *a4 = v6;
    *a5 = *(const char **)(a6 + 64);
  }
  else
  {
    *a2 = *(_BYTE *)(a6 + 84);
    *a3 = *(_BYTE *)(a6 + 85);
    if ((result & 8) != 0)
      v8 = 0;
    else
      v8 = *(_BYTE *)(a6 + 87);
    *a4 = v8;
    if (**(_BYTE **)(a6 + 72))
      v7 = *(const char **)(a6 + 72);
    else
      v7 = "-";
    *a5 = v7;
  }
  if (*a2)
    *a2 = 1;
  if (*a3 == 127)
    *a3 = 0;
  if (*a4 == 127)
    *a4 = 0;
  return result;
}

uint64_t get_groups(int a1, char *a2)
{
  char *v2;
  unsigned int v4;
  char *v5;

  v5 = a2;
  v4 = 0;
  if (*a2 == 127 || *a2 <= 0)
  {
    return 0;
  }
  else
  {
    while (a1 > *v5)
    {
      ++v4;
      v2 = v5++;
      a1 -= *v2;
      if (*v5 == 127)
        break;
      if (!*v5)
      {
        v4 += (a1 - 1) / *(v5 - 1);
        break;
      }
    }
    return v4;
  }
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  errno_t v5;
  rsize_t v6;

  v6 = __n;
  v5 = 0;
  if (!__s)
    return 22;
  if (__smax > 0x7FFFFFFFFFFFFFFFLL)
    return 7;
  if (__n > 0x7FFFFFFFFFFFFFFFLL)
  {
    v5 = 7;
    v6 = __smax;
  }
  if (v6 > __smax)
  {
    v5 = 84;
    v6 = __smax;
  }
  _platform_memset(__s, __c, v6);
  return v5;
}

void rb_tree_init(rb_tree_t *a1, const rb_tree_ops_t *a2)
{
  a1->opaque[1] = (void *)a2;
  a1->opaque[0] = 0;
  a1->opaque[2] = a1->opaque[0];
  a1->opaque[3] = a1->opaque[0];
  a1->opaque[4] = 0;
}

void *__cdecl rb_tree_find_node(rb_tree_t *a1, const void *a2)
{
  int v3;
  char *v4;
  _QWORD *i;
  uint64_t (*v6)(_QWORD, char *, const void *);
  _QWORD *v7;

  v7 = a1->opaque[1];
  v6 = (uint64_t (*)(_QWORD, char *, const void *))v7[1];
  for (i = a1->opaque[0]; i; i = (_QWORD *)i[v3 < 0])
  {
    v4 = (char *)i - v7[2];
    v3 = v6(v7[3], v4, a2);
    if (!v3)
      return v4;
  }
  return 0;
}

void *__cdecl rb_tree_find_node_geq(rb_tree_t *a1, const void *a2)
{
  int v4;
  char *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t (*v8)(_QWORD, char *, const void *);
  _QWORD *v9;

  v9 = a1->opaque[1];
  v8 = (uint64_t (*)(_QWORD, char *, const void *))v9[1];
  v7 = a1->opaque[0];
  v6 = 0;
  while (v7)
  {
    v5 = (char *)v7 - v9[2];
    v4 = v8(v9[3], v5, a2);
    if (!v4)
      return v5;
    if (v4 > 0)
      v6 = v7;
    v7 = (_QWORD *)v7[v4 < 0];
  }
  if (v6)
    return (char *)v6 - v9[2];
  else
    return 0;
}

void *__cdecl rb_tree_find_node_leq(rb_tree_t *a1, const void *a2)
{
  int v4;
  char *v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t (*v8)(_QWORD, char *, const void *);
  _QWORD *v9;

  v9 = a1->opaque[1];
  v8 = (uint64_t (*)(_QWORD, char *, const void *))v9[1];
  v7 = a1->opaque[0];
  v6 = 0;
  while (v7)
  {
    v5 = (char *)v7 - v9[2];
    v4 = v8(v9[3], v5, a2);
    if (!v4)
      return v5;
    if (v4 < 0)
      v6 = v7;
    v7 = (_QWORD *)v7[v4 < 0];
  }
  if (v6)
    return (char *)v6 - v9[2];
  else
    return 0;
}

void *__cdecl rb_tree_insert_node(rb_tree_t *a1, void *a2)
{
  BOOL v3;
  int v4;
  char *v5;
  BOOL v6;
  _BOOL4 v7;
  _QWORD *v8;
  rb_tree_t *v9;
  rb_tree_t *v10;
  uint64_t (*v11)(_QWORD, char *, void *);
  _QWORD *v12;

  v12 = a1->opaque[1];
  v11 = (uint64_t (*)(_QWORD, char *, void *))*v12;
  v8 = (char *)a2 + v12[2];
  v9 = (rb_tree_t *)a1->opaque[0];
  v10 = a1;
  v7 = 0;
  while (v9)
  {
    v5 = (char *)v9 - v12[2];
    v4 = v11(v12[3], v5, a2);
    if (!v4)
      return v5;
    v10 = v9;
    v7 = v4 < 0;
    v9 = (rb_tree_t *)v9->opaque[v4 < 0];
  }
  v8[2] = (unint64_t)v10 | v8[2] & 3;
  if (v7)
    v8[2] |= 2uLL;
  else
    v8[2] &= ~2uLL;
  if (v10 == a1)
  {
    v8[2] &= ~1uLL;
    a1->opaque[2] = v8;
    a1->opaque[3] = v8;
    v6 = 0;
  }
  else
  {
    if (v10 == a1->opaque[v7 + 2])
      a1->opaque[v7 + 2] = v8;
    v8[2] |= 1uLL;
    v3 = 0;
    if (v10)
      v3 = ((uint64_t)v10->opaque[2] & 1) != 0;
    v6 = v3;
  }
  *v8 = v10->opaque[v7];
  v8[1] = v10->opaque[v7];
  v10->opaque[v7] = v8;
  ++a1->opaque[4];
  if (v6)
    rb_tree_insert_rebalance((uint64_t)a1, (unint64_t)v8);
  return a2;
}

void rb_tree_insert_rebalance(uint64_t a1, unint64_t a2)
{
  unsigned int v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v6 = a2;
  v5 = *(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  while (1)
  {
    v4 = *(_QWORD *)(v5 + 16) & 0xFFFFFFFFFFFFFFFCLL;
    v2 = v5 == *(_QWORD *)(v4 + 8);
    v3 = *(_QWORD *)(v4 + 8 * (v5 != *(_QWORD *)(v4 + 8)));
    if (!v3 || (*(_QWORD *)(v3 + 16) & 1) == 0)
      break;
    *(_QWORD *)(v3 + 16) &= ~1uLL;
    *(_QWORD *)(v5 + 16) &= ~1uLL;
    if (*(_QWORD *)a1 != v4)
    {
      *(_QWORD *)(v4 + 16) |= 1uLL;
      v6 = v4;
      v5 = *(_QWORD *)(v4 + 16) & 0xFFFFFFFFFFFFFFFCLL;
      if (v5)
      {
        if ((*(_QWORD *)(v5 + 16) & 1) != 0)
          continue;
      }
    }
    return;
  }
  if (v6 == *(_QWORD *)(v5 + 8 * (v5 != *(_QWORD *)(v4 + 8))))
    rb_tree_reparent_nodes(a1, v5, v5 != *(_QWORD *)(v4 + 8));
  rb_tree_reparent_nodes(a1, v4, v2);
  *(_QWORD *)(*(_QWORD *)a1 + 16) &= ~1uLL;
}

void rb_tree_remove_node(rb_tree_t *a1, void *a2)
{
  void *v2;
  BOOL v3;
  _QWORD *v4;
  _QWORD *v5;

  v5 = a1->opaque[1];
  v4 = (char *)a2 + v5[2];
  if (v4 && (*v4 || v4[1]))
  {
    if (*v4 && v4[1])
    {
      v2 = rb_tree_iterate(a1, a2, (v4[2] & 2) == 0);
      rb_tree_swap_prune_and_rebalance(a1, (uint64_t)v4, (unint64_t)v2 + v5[2]);
    }
    else
    {
      rb_tree_prune_blackred_branch(a1, (uint64_t)v4, *v4 == 0);
    }
  }
  else
  {
    if (!v4 || (v3 = 0, (v4[2] & 1) == 0))
      v3 = a1->opaque[0] != v4;
    rb_tree_prune_node(a1, v4, v3);
  }
}

void rb_tree_prune_node(_QWORD *a1, _QWORD *a2, char a3)
{
  BOOL v3;
  unint64_t v4;
  unsigned int v5;

  v5 = (a2[2] & 2) != 0;
  v4 = a2[2] & 0xFFFFFFFFFFFFFFFCLL;
  v3 = *a1 == (_QWORD)a2;
  *(_QWORD *)(v4 + 8 * ((a2[2] & 2) != 0)) = *a2;
  --a1[4];
  if ((_QWORD *)a1[((a2[2] & 2) != 0) + 2] == a2)
  {
    a1[((a2[2] & 2) != 0) + 2] = v4;
    if (v3)
      a1[3] = v4;
  }
  a2[2] &= 3uLL;
  if ((a3 & 1) != 0)
    rb_tree_removal_rebalance(a1, v4, v5);
}

_QWORD *rb_tree_prune_blackred_branch(_QWORD *result, uint64_t a2, unsigned int a3)
{
  BOOL v3;
  uint64_t v4;
  unint64_t v5;

  v5 = *(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  v4 = *(_QWORD *)(a2 + 8 * a3);
  v3 = *result == a2;
  *(_QWORD *)(v4 + 16) ^= (*(_QWORD *)(v4 + 16) ^ *(_QWORD *)(a2 + 16)) & 3;
  *(_QWORD *)(v5 + 8 * ((*(_QWORD *)(v4 + 16) & 2) != 0)) = v4;
  *(_QWORD *)(v4 + 16) = v5 | *(_QWORD *)(v4 + 16) & 3;
  --result[4];
  if (v3)
  {
    result[(a3 ^ 1) + 2] = v4;
  }
  else if (result[((*(_QWORD *)(a2 + 16) & 2) != 0) + 2] == a2)
  {
    result[((*(_QWORD *)(a2 + 16) & 2) != 0) + 2] = v4;
  }
  *(_QWORD *)(a2 + 16) &= 3uLL;
  return result;
}

void *__cdecl rb_tree_iterate(rb_tree_t *a1, void *a2, const unsigned int a3)
{
  _QWORD *v4;
  uint64_t i;
  unsigned int v6;
  _QWORD *v7;

  v7 = a1->opaque[1];
  v6 = a3 ^ 1;
  if (a2)
  {
    v4 = (char *)a2 + v7[2];
    if (v4[a3])
    {
      for (i = v4[a3]; *(_QWORD *)(i + 8 * v6); i = *(_QWORD *)(i + 8 * v6))
        ;
      return (void *)(i - v7[2]);
    }
    else
    {
      while (a1->opaque[0] != v4)
      {
        if (v6 == ((v4[2] & 2) != 0))
          return (void *)((v4[2] & 0xFFFFFFFFFFFFFFFCLL) - v7[2]);
        v4 = (_QWORD *)(v4[2] & 0xFFFFFFFFFFFFFFFCLL);
      }
      return 0;
    }
  }
  else if (a1->opaque[0])
  {
    return (char *)a1->opaque[(a3 == 0) + 2] - v7[2];
  }
  else
  {
    return 0;
  }
}

void rb_tree_swap_prune_and_rebalance(_QWORD *a1, uint64_t a2, unint64_t a3)
{
  unsigned int v3;
  BOOL v4;
  BOOL v5;
  BOOL v6;
  unint64_t v7;
  uint64_t v8;
  _BOOL4 v9;

  v3 = (*(_QWORD *)(a3 + 16) & 2) != 0;
  v9 = (*(_QWORD *)(a3 + 16) & 2) == 0;
  v7 = *(_QWORD *)(a3 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  v5 = 1;
  if (a3)
    v5 = (*(_QWORD *)(a3 + 16) & 1) == 0;
  v6 = v5;
  if (v7 == a2)
    v8 = *(_QWORD *)(a3 + 8 * ((*(_QWORD *)(a3 + 16) & 2) != 0));
  else
    v8 = *(_QWORD *)(a3 + 8 * ((*(_QWORD *)(a3 + 16) & 2) == 0));
  v4 = 0;
  if (v8)
    v4 = (*(_QWORD *)(v8 + 16) & 1) != 0;
  if (v4)
  {
    *(_QWORD *)(v8 + 16) &= ~1uLL;
    v6 = 0;
    if (v7 != a2)
    {
      *(_QWORD *)(v8 + 16) = v7 | *(_QWORD *)(v8 + 16) & 3;
      if (v3)
        *(_QWORD *)(v8 + 16) |= 2uLL;
      else
        *(_QWORD *)(v8 + 16) &= ~2uLL;
    }
  }
  if (v7 == a2)
  {
    v7 = a3;
  }
  else
  {
    *(_QWORD *)(v7 + 8 * v3) = v8;
    *(_QWORD *)(a3 + 8 * v9) = *(_QWORD *)(a2 + 8 * v9);
    *(_QWORD *)(*(_QWORD *)(a3 + 8 * v9) + 16) = a3 | *(_QWORD *)(*(_QWORD *)(a3 + 8 * v9) + 16) & 3;
    v9 = v3;
  }
  *(_QWORD *)(a3 + 8 * v9) = *(_QWORD *)(a2 + 8 * v9);
  *(_QWORD *)(*(_QWORD *)(a3 + 8 * v9) + 16) = a3 | *(_QWORD *)(*(_QWORD *)(a3 + 8 * v9) + 16) & 3;
  *(_QWORD *)(a3 + 16) ^= (*(_QWORD *)(a3 + 16) ^ *(_QWORD *)(a2 + 16)) & 3;
  *(_QWORD *)(a3 + 16) = *(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL | *(_QWORD *)(a3 + 16) & 3;
  *(_QWORD *)((*(_QWORD *)(a3 + 16) & 0xFFFFFFFFFFFFFFFCLL) + 8 * ((*(_QWORD *)(a3 + 16) & 2) != 0)) = a3;
  --a1[4];
  if (a1[((*(_QWORD *)(a2 + 16) & 2) != 0) + 2] == a2)
    a1[((*(_QWORD *)(a2 + 16) & 2) != 0) + 2] = *(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  *(_QWORD *)(a2 + 16) &= 3uLL;
  if (v6)
    rb_tree_removal_rebalance(a1, v7, v3);
}

size_t rb_tree_count(rb_tree_t *a1)
{
  if (a1)
    return (size_t)a1->opaque[4];
  else
    return 0;
}

void rb_tree_reparent_nodes(uint64_t a1, unint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v5 = *(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  v4 = *(_QWORD *)(a2 + 8 * a3);
  *(_QWORD *)(v5 + 8 * ((*(_QWORD *)(a2 + 16) & 2) != 0)) = v4;
  *(_QWORD *)(a2 + 8 * a3) = *(_QWORD *)(v4 + 8 * (a3 ^ 1));
  *(_QWORD *)(v4 + 8 * (a3 ^ 1)) = a2;
  *(_QWORD *)(v4 + 16) = v5 | *(_QWORD *)(v4 + 16) & 3;
  *(_QWORD *)(a2 + 16) = v4 | *(_QWORD *)(a2 + 16) & 3;
  v3 = (*(_QWORD *)(v4 + 16) ^ *(_QWORD *)(a2 + 16)) & 3;
  *(_QWORD *)(v4 + 16) ^= v3;
  *(_QWORD *)(a2 + 16) ^= v3;
  if (a3 != 1)
    *(_QWORD *)(a2 + 16) |= 2uLL;
  else
    *(_QWORD *)(a2 + 16) &= ~2uLL;
  if (*(_QWORD *)(a2 + 8 * a3))
  {
    *(_QWORD *)(*(_QWORD *)(a2 + 8 * a3) + 16) = a2 | *(_QWORD *)(*(_QWORD *)(a2 + 8 * a3) + 16) & 3;
    if (a3)
      *(_QWORD *)(*(_QWORD *)(a2 + 8 * a3) + 16) |= 2uLL;
    else
      *(_QWORD *)(*(_QWORD *)a2 + 16) &= ~2uLL;
  }
}

void rb_tree_removal_rebalance(_QWORD *a1, unint64_t a2, unsigned int a3)
{
  BOOL v3;
  _QWORD *v4;
  unsigned int v5;

  while (1)
  {
    v3 = 1;
    if (*(_QWORD *)(a2 + 8 * a3))
      v3 = (*(_QWORD *)(*(_QWORD *)(a2 + 8 * a3) + 16) & 1) == 0;
    if (!v3)
      break;
    v5 = a3 ^ 1;
    v4 = *(_QWORD **)(a2 + 8 * (a3 ^ 1));
    if (a2 && (*(_QWORD *)(a2 + 16) & 1) != 0
      || *v4 && (*(_QWORD *)(*v4 + 16) & 1) != 0
      || v4[1] && (*(_QWORD *)(v4[1] + 16) & 1) != 0)
    {
      goto LABEL_15;
    }
    if (v4 && (v4[2] & 1) != 0)
    {
      rb_tree_reparent_nodes((uint64_t)a1, a2, v5);
      v4 = *(_QWORD **)(a2 + 8 * v5);
LABEL_15:
      if (!a2
        || (*(_QWORD *)(a2 + 16) & 1) == 0
        || v4 && (v4[2] & 1) != 0
        || *v4 && (*(_QWORD *)(*v4 + 16) & 1) != 0
        || v4[1] && (*(_QWORD *)(v4[1] + 16) & 1) != 0)
      {
        if (!v4[v5] || (*(_QWORD *)(v4[v5] + 16) & 1) == 0)
        {
          rb_tree_reparent_nodes((uint64_t)a1, (unint64_t)v4, a3);
          v4 = *(_QWORD **)(a2 + 8 * v5);
        }
        *(_QWORD *)(v4[v5] + 16) &= ~1uLL;
        rb_tree_reparent_nodes((uint64_t)a1, a2, v5);
      }
      else
      {
        *(_QWORD *)(a2 + 16) &= ~1uLL;
        v4[2] |= 1uLL;
      }
      return;
    }
    v4[2] |= 1uLL;
    if (*a1 == a2)
      return;
    a3 = (*(_QWORD *)(a2 + 16) & 2) != 0;
    a2 = *(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  }
}

int regncomp_l(regex_t *a1, const char *a2, size_t a3, int a4, locale_t a5)
{
  const char *v5;
  __int32 *v6;
  __int32 *v8;
  size_t v9;
  __int32 *v10;
  const char *v11;
  unsigned int i;
  uint64_t v13;
  __int32 *v14;
  int v15;
  unint64_t v18;
  mbstate_t v22;

  v18 = a3;
  v14 = (__int32 *)malloc_type_malloc(4 * (a3 + 1), 0x100004052888210);
  if (!v14)
    return 12;
  if (a5)
  {
    if (a5 == (locale_t)-1)
      a5 = (locale_t)__global_locale;
  }
  else
  {
    a5 = (locale_t)&__c_locale;
  }
  if (*(_DWORD *)(*((_QWORD *)a5 + 166) + 64) == 1)
  {
    v11 = a2;
    v10 = v14;
    for (i = 0; i < v18; ++i)
    {
      v5 = v11++;
      v6 = v10++;
      *v6 = *(unsigned __int8 *)v5;
    }
    v13 = v18;
  }
  else
  {
    v8 = v14;
    _platform_memset(&v22, 0, 128);
    _platform_memset(&v22, 0, 128);
    while (v18)
    {
      v9 = mbrtowc_l(v8, a2, v18, &v22, a5);
      if (v9 + 2 <= 1)
      {
        free(v14);
        return 17;
      }
      if (!v9)
      {
        if (*a2)
        {
          free(v14);
          return 2;
        }
        v9 = 1;
      }
      a2 += v9;
      v18 -= v9;
      ++v8;
    }
    v13 = v8 - v14;
  }
  v14[v13] = 0;
  v15 = tre_compile((uint64_t)a1, (uint64_t)v14, v13, a4, (uint64_t)a5);
  free(v14);
  return v15;
}

int regncomp(regex_t *a1, const char *a2, size_t a3, int a4)
{
  char v4;
  char v5;
  _xlocale *v7;
  _xlocale *v12;
  uint64_t v13;

  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    v12 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v13 = __locale_key;
    v12 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v13);
  }
  if (v12)
    v7 = v12;
  else
    v7 = (_xlocale *)__global_locale;
  return regncomp_l(a1, a2, a3, a4, v7);
}

int regcomp_l(regex_t *a1, const char *a2, int a3, locale_t a4)
{
  uint64_t v5;

  if ((a3 & 0x20) != 0)
  {
    if (a1->re_endp >= a2)
      return regncomp_l(a1, a2, a1->re_endp - a2, a3, a4);
    else
      return 16;
  }
  else
  {
    v5 = _platform_strlen(a2);
    return regncomp_l(a1, a2, v5, a3, a4);
  }
}

int regcomp(regex_t *a1, const char *a2, int a3)
{
  char v3;
  char v4;
  _xlocale *v6;
  _xlocale *v10;
  uint64_t v11;

  if (v3)
    v4 = 1;
  else
    v4 = 0;
  if ((v4 & 1) != 0)
  {
    v10 = (_xlocale *)pthread_getspecific(__locale_key);
  }
  else
  {
    v11 = __locale_key;
    v10 = *(_xlocale **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v11);
  }
  if (v10)
    v6 = v10;
  else
    v6 = (_xlocale *)__global_locale;
  return regcomp_l(a1, a2, a3, v6);
}

uint64_t regwncomp_l(uint64_t a1, uint64_t a2, uint64_t a3, int a4, _QWORD *a5)
{
  _QWORD *v6;

  v6 = a5;
  if (!a5)
    return tre_compile(a1, a2, a3, a4, (uint64_t)__c_locale);
  if (a5 == (_QWORD *)-1)
    v6 = __global_locale;
  return tre_compile(a1, a2, a3, a4, (uint64_t)v6);
}

int regwncomp(regex_t *a1, const __int32 *a2, size_t a3, int a4)
{
  char v4;
  char v5;
  _QWORD *v7;
  _QWORD *v12;
  uint64_t v13;

  if (v4)
    v5 = 1;
  else
    v5 = 0;
  if ((v5 & 1) != 0)
  {
    v12 = pthread_getspecific(__locale_key);
  }
  else
  {
    v13 = __locale_key;
    v12 = *(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * v13);
  }
  if (v12)
    v7 = v12;
  else
    v7 = __global_locale;
  return tre_compile((uint64_t)a1, (uint64_t)a2, a3, a4, (uint64_t)v7);
}

int regwcomp_l(regex_t *a1, const __int32 *a2, int a3, locale_t a4)
{
  size_t v4;
  locale_t v6;

  v6 = a4;
  if (a4)
  {
    if (a4 == (locale_t)-1)
      v6 = (locale_t)__global_locale;
  }
  else
  {
    v6 = (locale_t)__c_locale;
  }
  v4 = wcslen(a2);
  return tre_compile((uint64_t)a1, (uint64_t)a2, v4, a3, (uint64_t)v6);
}

int regwcomp(regex_t *a1, const __int32 *a2, int a3)
{
  size_t v3;

  v3 = wcslen(a2);
  return regwncomp(a1, a2, v3, a3);
}

void regfree(regex_t *a1)
{
  tre_free((uint64_t)a1);
}

uint64_t tre_fill_pmatch(unint64_t a1, uint64_t a2, char a3, uint64_t a4, void *a5, int a6)
{
  BOOL v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  unsigned int v11;

  if ((a3 & 4) != 0)
  {
    return 0;
  }
  else
  {
    v11 = 0;
    if (a6 >= 0 && a5)
    {
      v10 = a5;
      if (*(_QWORD *)(a4 + 48) && *(int *)(*(_QWORD *)(a4 + 48) + 16) > 0)
      {
        v8 = malloc_type_malloc(16 * *(int *)(a4 + 80), 0x1000040451B5BE8);
        if (!v8)
          return 12;
        j___platform_memmove(v8, a5, 16 * *(int *)(a4 + 80));
        tre_reset_last_matched_branches(v8, *(uint64_t **)(*(_QWORD *)(a4 + 48) + 8), *(_DWORD *)(*(_QWORD *)(a4 + 48) + 16), 0, 0);
        v10 = (void *)v8;
      }
      v9 = *(_QWORD *)(a4 + 24);
      while (1)
      {
        v7 = 0;
        if (v11 < *(_DWORD *)(a4 + 72))
          v7 = v11 < a1;
        if (!v7)
          break;
        if (*(_DWORD *)(v9 + 8 * v11) == *(_DWORD *)(a4 + 88))
          *(_QWORD *)(a2 + 16 * v11) = a6;
        else
          *(_QWORD *)(a2 + 16 * v11) = (int)tre_tag_get((uint64_t)v10, *(_DWORD *)(v9 + 8 * v11));
        if (*(_DWORD *)(v9 + 8 * v11 + 4) == *(_DWORD *)(a4 + 88))
          *(_QWORD *)(a2 + 16 * v11 + 8) = a6;
        else
          *(_QWORD *)(a2 + 16 * v11 + 8) = (int)tre_tag_get((uint64_t)v10, *(_DWORD *)(v9 + 8 * v11 + 4));
        if (*(_QWORD *)(a2 + 16 * v11) == -1 || *(_QWORD *)(a2 + 16 * v11 + 8) == -1)
        {
          *(_QWORD *)(a2 + 16 * v11 + 8) = -1;
          *(_QWORD *)(a2 + 16 * v11) = -1;
        }
        ++v11;
      }
      if (v10 != a5)
        free(v10);
    }
    while (v11 < a1)
    {
      *(_QWORD *)(a2 + 16 * v11) = -1;
      *(_QWORD *)(a2 + 16 * v11++ + 8) = -1;
    }
    return 0;
  }
}

uint64_t tre_reset_last_matched_branches(uint64_t result, uint64_t *a2, int a3, int a4, int a5)
{
  int v5;
  int v6;
  BOOL v7;
  unsigned int v8;
  BOOL v9;
  int *v10;
  int v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v25;

  v25 = result;
  v20 = 0;
  while (1)
  {
    v5 = a3--;
    if (v5 <= 0)
      break;
    if (*((_DWORD *)a2 + 2) == 1)
    {
      v13 = *a2;
      if (a4 <= 0)
      {
        v16 = 0;
      }
      else
      {
        v9 = 1;
        if (!a5)
        {
          v8 = tre_tag_touch_get(v25, *(_DWORD *)(v13 + 20));
          v6 = tre_tag_touch_get(v25, a4);
          result = v8;
          v9 = (int)v8 < v6;
        }
        v16 = v9;
      }
      if (v16)
      {
        v17 = *(_DWORD *)(v13 + 24);
        v12 = *(int **)v13;
        while (v17 > 0)
        {
          result = tre_tag_reset(v25, *v12);
          --v17;
          ++v12;
        }
      }
      if (*(int *)(v13 + 16) > 0)
        result = tre_reset_last_matched_branches(v25, *(_QWORD *)(v13 + 8), *(unsigned int *)(v13 + 16), *((unsigned int *)a2 + 3), v16);
    }
    else
    {
      if (!a5)
      {
        v20 = 0;
        v18 = *((_DWORD *)a2 + 2);
        v14 = *a2;
        while (v18 > 0)
        {
          result = tre_tag_touch_get(v25, *(_DWORD *)(v14 + 20));
          if ((int)result > v20)
            v20 = result;
          --v18;
          v14 += 32;
        }
      }
      v19 = *((_DWORD *)a2 + 2);
      v15 = *a2;
      while (v19 > 0)
      {
        v7 = 1;
        if (!a5)
        {
          result = tre_tag_touch_get(v25, *(_DWORD *)(v15 + 20));
          v7 = (int)result < v20;
        }
        if (v7)
        {
          v11 = *(_DWORD *)(v15 + 24);
          v10 = *(int **)v15;
          while (v11 > 0)
          {
            result = tre_tag_reset(v25, *v10);
            --v11;
            ++v10;
          }
        }
        if (*(int *)(v15 + 16) > 0)
          result = tre_reset_last_matched_branches(v25, *(_QWORD *)(v15 + 8), *(unsigned int *)(v15 + 16), *((unsigned int *)a2 + 3), v7);
        --v19;
        v15 += 32;
      }
    }
    a2 += 2;
  }
  return result;
}

uint64_t tre_tag_get(uint64_t a1, int a2)
{
  if (*(int *)(a1 + 16 * a2) <= 0)
    return -1;
  else
    return *(unsigned int *)(a1 + 16 * a2 + 8);
}

int regnexec(const regex_t *a1, const char *a2, size_t a3, size_t a4, regmatch_t __pmatch[], int a6)
{
  int v6;
  re_guts *re_g;

  re_g = a1->re_g;
  if (*(_DWORD *)(*(_QWORD *)(*((_QWORD *)re_g + 7) + 1328) + 64) == 1)
    v6 = 1;
  else
    v6 = 2;
  if (a1->re_magic == 62053)
    return tre_match((int *)re_g, (uint64_t)a2, a3, v6, a4, &__pmatch->rm_so, a6);
  else
    return 2;
}

uint64_t tre_match(int *a1, uint64_t a2, uint64_t a3, int a4, unint64_t a5, uint64_t *a6, int a7)
{
  uint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void *v13;
  unsigned int v14;
  int v15;
  uint64_t *v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = a5;
  v16 = a6;
  v15 = a7;
  v14 = 0;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  if ((a7 & 4) != 0 && v16)
  {
    if (*v16 < 0)
      return 16;
    if (v19 == -1)
    {
      if (v16[1] < 0 || *v16 > v16[1])
        return 16;
      v19 = v16[1] - *v16;
    }
    v11 = *v16;
    v10 = *v16;
    if (!v18)
      v11 *= 4;
  }
  if (v21[20] <= 0 || !v17 || (v13 = (void *)malloc_type_malloc(16 * v21[20], 0x1000040451B5BE8)) != 0)
  {
    if (v21[25] || (v15 & 0x400) != 0)
      v14 = tre_tnfa_run_backtrack((uint64_t)v21, (char *)(v20 + v11), v19, v18, (uint64_t)v13, v15, &v12);
    else
      v14 = tre_tnfa_run_parallel((uint64_t)v21, (const char *)(v20 + v11), v19, v18, (uint64_t)v13, v15, &v12);
    if (!v14)
    {
      v14 = tre_fill_pmatch(v17, (uint64_t)v16, v21[24], (uint64_t)v21, v13, v12);
      if (!v14 && (v21[24] & 4) == 0 && (v15 & 4) != 0 && v16 && v17)
      {
        v9 = v17;
        v8 = v16;
        while (v9)
        {
          if (*v8 >= 0)
            *v8 += v10;
          if (v8[1] >= 0)
            v8[1] += v10;
          v8 += 2;
          --v9;
        }
      }
    }
    if (v13)
      free(v13);
    return v14;
  }
  else
  {
    return 12;
  }
}

int regexec(const regex_t *a1, const char *a2, size_t a3, regmatch_t __pmatch[], int a5)
{
  return regnexec(a1, a2, 0xFFFFFFFFFFFFFFFFLL, a3, __pmatch, a5);
}

int regwnexec(const regex_t *a1, const __int32 *a2, size_t a3, size_t a4, regmatch_t __pmatch[], int a6)
{
  if (a1->re_magic == 62053)
    return tre_match((int *)a1->re_g, (uint64_t)a2, a3, 0, a4, &__pmatch->rm_so, a6);
  else
    return 2;
}

int regwexec(const regex_t *a1, const __int32 *a2, size_t a3, regmatch_t __pmatch[], int a5)
{
  return regwnexec(a1, a2, 0xFFFFFFFFFFFFFFFFLL, a3, __pmatch, a5);
}

uint64_t tre_tag_touch_get(uint64_t a1, int a2)
{
  return *(unsigned int *)(a1 + 16 * a2 + 12);
}

uint64_t tre_tag_reset(uint64_t result, int a2)
{
  *(_DWORD *)(result + 16 * a2) = 0;
  return result;
}

uint64_t tre_ast_new_node(uint64_t a1, int a2, unint64_t a3)
{
  uint64_t v4;

  v4 = tre_mem_alloc_impl(a1, 0, 0, 1, 0x48uLL);
  if (!v4)
    return 0;
  *(_QWORD *)v4 = tre_mem_alloc_impl(a1, 0, 0, 1, a3);
  if (!*(_QWORD *)v4)
    return 0;
  *(_DWORD *)(v4 + 48) = a2;
  *(_WORD *)(v4 + 64) = -1;
  *(_DWORD *)(v4 + 52) = -1;
  return v4;
}

_DWORD **tre_ast_new_literal(uint64_t a1, int a2, int a3, int a4)
{
  _DWORD *v5;
  _DWORD **v6;

  v6 = (_DWORD **)tre_ast_new_node(a1, 0, 0x18uLL);
  if (!v6)
    return 0;
  v5 = *v6;
  *v5 = a2;
  v5[1] = a3;
  v5[2] = a4;
  return v6;
}

uint64_t tre_ast_new_iter(uint64_t a1, uint64_t a2, int a3, int a4, char a5)
{
  uint64_t v6;
  uint64_t v7;

  v7 = tre_ast_new_node(a1, 2, 0x20uLL);
  if (!v7)
    return 0;
  v6 = *(_QWORD *)v7;
  *(_QWORD *)v6 = a2;
  *(_DWORD *)(v6 + 8) = a3;
  *(_DWORD *)(v6 + 12) = a4;
  *(_BYTE *)(v6 + 16) = *(_BYTE *)(v6 + 16) & 0xFE | a5 & 1;
  *(_DWORD *)(v7 + 56) = *(_DWORD *)(a2 + 56);
  return v7;
}

_DWORD *tre_ast_new_union(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v4;

  v4 = (_DWORD *)tre_ast_new_node(a1, 3, 0x18uLL);
  if (!v4)
    return 0;
  **(_QWORD **)v4 = a2;
  *(_QWORD *)(*(_QWORD *)v4 + 8) = a3;
  v4[14] = *(_DWORD *)(a2 + 56) + *(_DWORD *)(a3 + 56);
  return v4;
}

_DWORD *tre_ast_new_catenation(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v4;

  v4 = (_DWORD *)tre_ast_new_node(a1, 1, 0x10uLL);
  if (!v4)
    return 0;
  **(_QWORD **)v4 = a2;
  *(_QWORD *)(*(_QWORD *)v4 + 8) = a3;
  v4[14] = *(_DWORD *)(a2 + 56) + *(_DWORD *)(a3 + 56);
  return v4;
}

uint64_t tre_compile(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v9;
  int m;
  uint64_t k;
  int v12;
  _QWORD v13[6];
  uint64_t v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  void **v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int i;
  int *v32;
  void *v33;
  int *j;
  _DWORD **v35;
  _DWORD *v36;
  _DWORD *v37;
  void **v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v43 = a1;
  v42 = a2;
  v41 = a3;
  v40 = a4;
  v39 = a5;
  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  j = 0;
  v33 = 0;
  v32 = 0;
  i = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  _platform_memset(v13, 0, 128);
  v38 = (void **)tre_stack_new(512, 10240, 128);
  if (!v38)
    return 12;
  v23 = (void **)tre_mem_new_impl(0, 0);
  if (!v23)
  {
    tre_stack_destroy(v38);
    return 12;
  }
  _platform_memset(v13, 0, 128);
  v13[0] = v23;
  v13[1] = v38;
  v13[3] = v42;
  v15 = v41;
  if ((v40 & 0x101) != 0x101)
    v40 &= ~0x40u;
  v22 = v40;
  v19 = -1;
  v14 = v39;
  v17 = 0x40000000;
  v24 = tre_parse((uint64_t)v13);
  if (v24)
    goto LABEL_84;
  *(_QWORD *)(v43 + 8) = v16 - 1;
  v37 = (_DWORD *)v13[2];
  if (v19 >= 0 && v21)
  {
    v24 = 2;
LABEL_84:
    tre_mem_destroy(v23);
    if (v38)
      tre_stack_destroy(v38);
    if (v33)
      free(v33);
    if (v32)
      free(v32);
    *(_QWORD *)(v43 + 24) = v27;
    if (v27)
      *(_QWORD *)(v27 + 56) = 0;
    tre_free(v43);
    return v24;
  }
  if (v19 > (int)*(_QWORD *)(v43 + 8))
  {
    v24 = 6;
    goto LABEL_84;
  }
  v27 = malloc_type_calloc(1, 120, 0x1030040C46BC5F1);
  if (!v27)
  {
    v24 = 12;
    goto LABEL_84;
  }
  *(_DWORD *)(v27 + 100) = v19 >= 0;
  *(_DWORD *)(v27 + 108) = v21;
  *(_DWORD *)(v27 + 72) = v16;
  *(_DWORD *)(v27 + 76) = v17 - 0x40000000;
  *(_DWORD *)(v27 + 104) = v20;
  *(_QWORD *)(v27 + 56) = v14;
  if (*(int *)(v27 + 104) > 0 || (v40 & 4) == 0)
  {
    v24 = tre_add_tags(0, (uint64_t)v38, (uint64_t)v37, v27);
    if (v24)
      goto LABEL_84;
    if (*(int *)(v27 + 80) > 0)
    {
      v25 = malloc_type_malloc(4 * (*(_DWORD *)(v27 + 80) + 1), 0x100004052888210);
      if (!v25)
      {
        v24 = 12;
        goto LABEL_84;
      }
      *(_QWORD *)(v27 + 32) = v25;
      _platform_memset(v25, 0xFFFFFFFFLL, 4 * (*(_DWORD *)(v27 + 80) + 1));
    }
    *(_QWORD *)(v27 + 40) = malloc_type_calloc((2 * *(_DWORD *)(v27 + 80) + 3), 4, 0x100004052888210);
    if (!*(_QWORD *)(v27 + 40))
    {
      v24 = 12;
      goto LABEL_84;
    }
    v26 = malloc_type_calloc(v16, 8, 0x100004000313F17);
    if (!v26)
    {
      v24 = 12;
      goto LABEL_84;
    }
    for (i = 0; i < v16; ++i)
      *(_DWORD *)(v26 + 8 * i + 4) = -1;
    *(_QWORD *)(v27 + 24) = v26;
    v24 = tre_add_tags((uint64_t)v23, (uint64_t)v38, (uint64_t)v37, v27);
    if (v24)
      goto LABEL_84;
  }
  v24 = tre_expand_ast((uint64_t)v23, (uint64_t)v38, (uint64_t)v37, &v18, v25, v27 + 112);
  if (v24)
    goto LABEL_84;
  v36 = v37;
  v5 = v18++;
  v35 = tre_ast_new_literal((uint64_t)v23, 0, 0, v5);
  if (!v35)
  {
    v24 = 12;
    goto LABEL_84;
  }
  v37 = tre_ast_new_catenation((uint64_t)v23, (uint64_t)v36, (uint64_t)v35);
  if (!v37)
  {
    v24 = 12;
    goto LABEL_84;
  }
  v24 = tre_compute_nfl((uint64_t)v23, (uint64_t)v38, (uint64_t)v37);
  if (v24)
    goto LABEL_84;
  v33 = (void *)malloc_type_malloc(4 * v18, 0x100004052888210);
  if (!v33)
  {
    v24 = 12;
    goto LABEL_84;
  }
  v32 = (int *)malloc_type_malloc(4 * v18, 0x100004052888210);
  if (!v32)
  {
    v24 = 12;
    goto LABEL_84;
  }
  for (i = 0; i < v18; ++i)
    *((_DWORD *)v33 + i) = 0;
  tre_ast_to_tnfa((uint64_t)v37);
  v30 = 0;
  for (i = 0; i < v18; ++i)
  {
    v32[i] = v30;
    v30 += *((_DWORD *)v33 + i) + 1;
    *((_DWORD *)v33 + i) = 0;
  }
  v29 = malloc_type_calloc((v30 + 1), 56, 0x1032040B21D0138);
  if (!v29)
  {
    v24 = 12;
    goto LABEL_84;
  }
  *(_QWORD *)v27 = v29;
  *(_DWORD *)(v27 + 64) = v30;
  v24 = tre_ast_to_tnfa((uint64_t)v37);
  if (v24)
    goto LABEL_84;
  *(_DWORD *)(v27 + 68) = -1;
  if (!*((_WORD *)v36 + 32))
  {
    v12 = 1;
    for (j = (int *)*((_QWORD *)v37 + 3); ; j += 16)
    {
      v9 = 0;
      if (v12)
        v9 = *j >= 0;
      if (!v9)
        break;
      for (k = v29 + 56 * v32[*j]; *(_QWORD *)(k + 8); k += 56)
      {
        if (*(_DWORD *)k <= *(_DWORD *)(k + 4))
        {
          if (*(_DWORD *)(k + 4) != *(_DWORD *)k || *(_DWORD *)k == -1 || *(_DWORD *)(v27 + 68) != -1)
          {
            *(_DWORD *)(v27 + 68) = -1;
            v12 = 0;
            break;
          }
          *(_DWORD *)(v27 + 68) = *(_DWORD *)k;
        }
      }
    }
  }
  j = (int *)*((_QWORD *)v37 + 3);
  i = 0;
  while (*j >= 0)
  {
    ++i;
    j += 16;
  }
  v28 = malloc_type_calloc((i + 1), 56, 0x1032040B21D0138);
  if (!v28)
  {
    v24 = 12;
    goto LABEL_84;
  }
  *(_QWORD *)(v27 + 8) = v28;
  i = 0;
  for (j = (int *)*((_QWORD *)v37 + 3); *j >= 0; j += 16)
  {
    *(_QWORD *)(v28 + 56 * i + 8) = v29 + 56 * v32[*j];
    *(_DWORD *)(v28 + 56 * i + 16) = *j;
    *(_QWORD *)(v28 + 56 * i + 24) = 0;
    if (*((_QWORD *)j + 2))
    {
      for (m = 0; *(int *)(*((_QWORD *)j + 2) + 4 * m) >= 0; ++m)
        ;
      v6 = malloc_type_malloc(4 * (m + 1), 0x100004052888210);
      *(_QWORD *)(v28 + 56 * i + 24) = v6;
      if (!*(_QWORD *)(v28 + 56 * i + 24))
      {
        v24 = 12;
        goto LABEL_84;
      }
      j___platform_memmove(*(_QWORD *)(v28 + 56 * i + 24), *((_QWORD *)j + 2), 4 * (m + 1));
    }
    *(_QWORD *)(v28 + 56 * i + 32) = 0;
    if (*((_QWORD *)j + 6))
    {
      v7 = malloc_type_malloc(36, 0x100004052888210);
      *(_QWORD *)(v28 + 56 * i + 32) = v7;
      if (!*(_QWORD *)(v28 + 56 * i + 32))
      {
        v24 = 12;
        goto LABEL_84;
      }
      j___platform_memmove(*(_QWORD *)(v28 + 56 * i + 32), *((_QWORD *)j + 6), 36);
    }
    *(_DWORD *)(v28 + 56 * i++ + 40) = j[6];
  }
  *(_QWORD *)(v28 + 56 * i + 8) = 0;
  *(_DWORD *)(v27 + 64) = v30;
  *(_QWORD *)(v27 + 16) = v29 + 56 * v32[**((int **)v37 + 4)];
  *(_DWORD *)(v27 + 92) = v18;
  *(_DWORD *)(v27 + 96) = v40;
  tre_mem_destroy(v23);
  tre_stack_destroy(v38);
  free(v33);
  free(v32);
  *(_DWORD *)v43 = 62053;
  *(_QWORD *)(v43 + 24) = v27;
  xlocale_retain(*(unsigned int **)(v27 + 56));
  return 0;
}

uint64_t tre_add_tags(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int *v4;
  int *v5;
  unint64_t v7;
  BOOL v8;
  unint64_t v9;
  BOOL v10;
  int v11;
  unint64_t v12;
  BOOL v13;
  uint64_t v14;
  void *v15;
  int i;
  int j;
  int v18;
  int v19;
  int v20;
  char *v21;
  _DWORD *v22;
  int *v23;
  int *v24;
  _DWORD *v25;
  _DWORD *v26;
  int v27;
  unsigned int v29;

  v27 = tre_stack_num_objects(a2);
  v13 = 1;
  if (a1)
    v13 = a4 == 0;
  v25 = 0;
  v22 = 0;
  v21 = 0;
  if (!v13)
  {
    *(_DWORD *)(a4 + 88) = 0;
    **(_DWORD **)(a4 + 40) = -1;
  }
  v26 = (_DWORD *)malloc_type_malloc(4 * (2 * (*(_DWORD *)(a4 + 72) + *(_DWORD *)(a4 + 76) + 1)), 0x100004052888210);
  if (v26)
  {
    *v26 = -1;
    if (!v13)
    {
      v25 = (_DWORD *)malloc_type_malloc(4 * (2 * *(_DWORD *)(a4 + 104) + 1 + *(_DWORD *)(a4 + 80)), 0x100004052888210);
      v22 = v25;
      if (!v25)
      {
        v29 = 12;
LABEL_65:
        free(v26);
        return v29;
      }
      v21 = (char *)&v25[2 * *(_DWORD *)(a4 + 104) + 1];
    }
    tre_stack_push_voidptr(a2, a3);
    v29 = tre_stack_push_int(a2, 0);
    while ((int)tre_stack_num_objects(a2) > v27 && !v29)
    {
      v12 = tre_stack_pop_int(a2);
      if (v12 <= 0xA)
        __asm { BR              X8 }
    }
    if (!v29)
    {
      if (!v13)
      {
        if (*(_DWORD *)(a4 + 80))
        {
          v29 = 2;
          goto LABEL_64;
        }
        tre_purge_regset(v26, a4, 0);
        **(_DWORD **)(a4 + 32) = 2;
        if (v22 > &v25[2 * *(_DWORD *)(a4 + 104)])
        {
          v29 = 2;
          goto LABEL_64;
        }
        *v22 = -1;
        v23 = v25;
        while (*v23 >= 0)
        {
          v4 = v23;
          v24 = v23 + 1;
          v18 = *v4;
          if (*v4 < 0)
          {
            v20 = *(_DWORD *)&v21[4 * v18];
            v5 = v24;
            v23 = v24 + 1;
            v19 = *(_DWORD *)&v21[4 * *v5];
            if (v19 <= v20)
              *(_DWORD *)&v21[4 * v18] = v19 + 1;
          }
          else
          {
            v23 = v24 + 1;
          }
        }
        free(v25);
        v25 = 0;
      }
      if (v25)
      {
        for (i = 0; i < *(_DWORD *)(a4 + 72); ++i)
        {
          *(_DWORD *)(*(_QWORD *)(a4 + 24) + 8 * i) = *(_DWORD *)&v21[4 * *(int *)(*(_QWORD *)(a4 + 24) + 8 * i)];
          if (*(int *)(*(_QWORD *)(a4 + 24) + 8 * i + 4) >= 0)
            v11 = *(_DWORD *)(*(_QWORD *)(a4 + 24) + 8 * i + 4);
          else
            v11 = *(_DWORD *)&v21[4 * *(int *)(*(_QWORD *)(a4 + 24) + 8 * i + 4)];
          *(_DWORD *)(*(_QWORD *)(a4 + 24) + 8 * i + 4) = v11;
        }
        v15 = (void *)malloc_type_malloc(0, 0x100004052888210);
        if (!v15)
        {
          v29 = 12;
          goto LABEL_64;
        }
        j___platform_memmove(*(_QWORD *)(a4 + 32), v15, 0);
        free(v15);
        for (j = 0; *(int *)(*(_QWORD *)(a4 + 40) + 4 * j) >= 0; ++j)
          *(_DWORD *)(*(_QWORD *)(a4 + 40) + 4 * j) = *(_DWORD *)(*(_QWORD *)(a4 + 40) + 4 * j);
        v29 = tre_stack_push_voidptr(a2, a3);
        while (1)
        {
          v10 = 0;
          if (!v29)
            v10 = (int)tre_stack_num_objects(a2) > v27;
          if (!v10)
            break;
          v9 = *(unsigned int *)(tre_stack_pop_voidptr(a2) + 48);
          if (v9 <= 3)
            __asm { BR              X8 }
        }
        if (v29)
          goto LABEL_64;
      }
      if (!v13 && *(_QWORD *)(a3 + 8))
      {
        v14 = malloc_type_calloc(1, 16 * *(int *)(*(_QWORD *)(a3 + 8) + 32)+ 32 * *(int *)(*(_QWORD *)(a3 + 8) + 28)+ 4 * *(int *)(*(_QWORD *)(a3 + 8) + 36), 1045921248);
        if (!v14)
        {
          v29 = 12;
          goto LABEL_64;
        }
        tre_stack_push_voidptr(a2, *(_QWORD *)(a3 + 8));
        tre_stack_push_int(a2, 1u);
        v29 = tre_stack_push_int(a2, 0);
        while (1)
        {
          v8 = 0;
          if (!v29)
            v8 = (int)tre_stack_num_objects(a2) > v27;
          if (!v8)
            break;
          v7 = tre_stack_pop_int(a2);
          if (v7 <= 3)
            __asm { BR              X8 }
        }
        if (v29)
          goto LABEL_64;
        *(_QWORD *)(a4 + 48) = v14;
      }
      *(_DWORD *)(a4 + 88) = 0;
      *(_DWORD *)(a4 + 80) = 0;
      *(_DWORD *)(a4 + 84) = 0;
    }
LABEL_64:
    free(v25);
    goto LABEL_65;
  }
  return 12;
}

uint64_t tre_expand_ast(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, uint64_t a5, uint64_t a6)
{
  int v6;
  unsigned int v7;
  unint64_t v9;
  BOOL v10;
  int v11;
  uint64_t v12;
  _DWORD **v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v30 = a1;
  v29 = a2;
  v28 = a3;
  v27 = a4;
  v26 = a5;
  v25 = a6;
  v24 = 0;
  v23 = tre_stack_num_objects(a2);
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v19 = tre_stack_push_voidptr(v29, v28);
  if (v19)
  {
    return v19;
  }
  else
  {
    v18 = tre_stack_push_int(v29, 0);
    if (v18)
    {
      return v18;
    }
    else
    {
      while (1)
      {
        v10 = 0;
        if (!v24)
        {
          v6 = tre_stack_num_objects(v29);
          v10 = v6 > v23;
        }
        if (!v10 || v24)
          break;
        v16 = tre_stack_pop_int(v29);
        v17 = tre_stack_pop_voidptr(v29);
        if (v16)
        {
          if (v16 == 1)
          {
            v15 = *(_QWORD *)v17;
            v22 = tre_stack_pop_int(v29);
            v14 = v22;
            if (*(_DWORD *)(v15 + 8) || *(_DWORD *)(v15 + 12))
            {
              if (*(int *)(v15 + 8) > 1 || *(int *)(v15 + 12) > 1)
              {
                v12 = 0;
                v11 = v22;
                if (*(int *)(v15 + 8) > 0)
                {
                  if (*(int *)(v15 + 8) > 1)
                    v7 = 1;
                  else
                    v7 = 2;
                  v24 = tre_copy_ast(v30, v29, *(_QWORD *)v15, v7, &v22);
                  if (v24)
                    return v24;
                  else
                    return 12;
                }
                if (*(_DWORD *)(v15 + 12) == -1)
                {
                  v11 = v22;
                  v24 = tre_copy_ast(v30, v29, *(_QWORD *)v15, 0, &v22);
                  if (v24)
                    return v24;
                  v12 = tre_ast_new_iter(v30, 0, 0, -1, 0);
                  if (!v12)
                    return 12;
                }
                else if (*(_DWORD *)(v15 + 8) < *(_DWORD *)(v15 + 12))
                {
                  v24 = tre_copy_ast(v30, v29, *(_QWORD *)v15, 0, &v22);
                  if (v24)
                    return v24;
                  else
                    return 12;
                }
                v22 = v11;
                if (!v12)
                  return 12;
                *(_QWORD *)v17 = *(_QWORD *)v12;
                *(_DWORD *)(v17 + 48) = *(_DWORD *)(v12 + 48);
              }
            }
            else
            {
              v13 = tre_ast_new_literal(v30, -1, -1, -1);
              if (!v13)
                return 12;
              *(_QWORD *)v17 = *v13;
              *(_DWORD *)(v17 + 48) = *((_DWORD *)v13 + 12);
            }
            --v20;
            v21 += v22 - v14;
            if (!v20)
              v22 = v21;
          }
        }
        else
        {
          v9 = *(unsigned int *)(v17 + 48);
          if (v9 <= 3)
            __asm { BR              X8 }
        }
      }
      *v27 += v21;
      if (*v27 < 0)
        *v27 = 0;
      return v24;
    }
  }
}

uint64_t tre_compute_nfl(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;

  v7 = tre_stack_num_objects(a2);
  v6 = tre_stack_push_voidptr(a2, a3);
  if (v6)
  {
    return v6;
  }
  else
  {
    v5 = tre_stack_push_int(a2, 0);
    if (v5)
    {
      return v5;
    }
    else
    {
      while ((int)tre_stack_num_objects(a2) > v7)
      {
        v4 = tre_stack_pop_int(a2);
        tre_stack_pop_voidptr(a2);
        if (v4 <= 3uLL)
          __asm { BR              X8 }
      }
      return 0;
    }
  }
}

uint64_t tre_ast_to_tnfa(uint64_t a1)
{
  unint64_t v2;

  v2 = *(unsigned int *)(a1 + 48);
  if (v2 <= 3)
    __asm { BR              X8 }
  return 0;
}

void tre_free(uint64_t a1)
{
  uint64_t j;
  unsigned int i;
  void *v3;

  *(_DWORD *)a1 = 0;
  v3 = *(void **)(a1 + 24);
  if (v3)
  {
    *(_QWORD *)(a1 + 24) = 0;
    for (i = 0; i < *((_DWORD *)v3 + 16); ++i)
    {
      if (*(_QWORD *)(*(_QWORD *)v3 + 56 * i + 8))
      {
        if (*(_QWORD *)(*(_QWORD *)v3 + 56 * i + 24))
          free(*(void **)(*(_QWORD *)v3 + 56 * i + 24));
        if ((*(_DWORD *)(*(_QWORD *)v3 + 56 * i + 40) & 4) != 0)
          free(*(void **)(*(_QWORD *)v3 + 56 * i + 48));
        if (*(_QWORD *)(*(_QWORD *)v3 + 56 * i + 32))
          free(*(void **)(*(_QWORD *)v3 + 56 * i + 32));
      }
    }
    if (*(_QWORD *)v3)
      free(*(void **)v3);
    if (*((_QWORD *)v3 + 1))
    {
      for (j = *((_QWORD *)v3 + 1); *(_QWORD *)(j + 8); j += 56)
      {
        if (*(_QWORD *)(j + 24))
          free(*(void **)(j + 24));
        if (*(_QWORD *)(j + 32))
          free(*(void **)(j + 32));
      }
      free(*((void **)v3 + 1));
    }
    if (*((_QWORD *)v3 + 3))
      free(*((void **)v3 + 3));
    if (*((_QWORD *)v3 + 4))
      free(*((void **)v3 + 4));
    if (*((_QWORD *)v3 + 5))
      free(*((void **)v3 + 5));
    if (*((_QWORD *)v3 + 7))
      xlocale_release(*((_QWORD *)v3 + 7));
    if (*((_QWORD *)v3 + 6))
      free(*((void **)v3 + 6));
    free(v3);
  }
}

uint64_t tre_merge_branches(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  int v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v9;
  _QWORD *i;
  int v11;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;

  v14 = *(_QWORD *)(a2 + 8);
  if (a3)
    v9 = *(_QWORD *)(a3 + 8);
  else
    v9 = 0;
  if (v14)
  {
    if (v9)
    {
      v13 = (_BYTE *)(v14 + 40);
      v12 = (_BYTE *)(v9 + 40);
      v11 = (a5 + 7) >> 3;
      while (1)
      {
        v5 = v11--;
        if (v5 <= 0)
          break;
        v6 = v12++;
        v7 = v13++;
        *v7 |= *v6;
      }
      *(_DWORD *)(v14 + 24) += *(_DWORD *)(v9 + 24);
      *(_DWORD *)(v14 + 36) += *(_DWORD *)(v9 + 36);
      if (*(_QWORD *)(v14 + 8))
      {
        if (*(_QWORD *)(v9 + 8))
        {
          for (i = *(_QWORD **)(v14 + 8); *i; i = (_QWORD *)*i)
            ;
          *i = *(_QWORD *)(v9 + 8);
          *(_DWORD *)(v14 + 16) += *(_DWORD *)(v9 + 16);
          *(_DWORD *)(v14 + 28) += *(_DWORD *)(v9 + 28);
          *(_DWORD *)(v14 + 32) += *(_DWORD *)(v9 + 32);
        }
      }
      else if (*(_QWORD *)(v9 + 8))
      {
        *(_QWORD *)(v14 + 8) = *(_QWORD *)(v9 + 8);
        *(_DWORD *)(v14 + 16) = *(_DWORD *)(v9 + 16);
        *(_DWORD *)(v14 + 28) = *(_DWORD *)(v9 + 28);
        *(_DWORD *)(v14 + 32) = *(_DWORD *)(v9 + 32);
      }
    }
  }
  else
  {
    v14 = v9;
  }
  if (!a4)
    goto LABEL_27;
  if (v14)
  {
LABEL_25:
    if (a4 > 0)
    {
      *(_BYTE *)(v14 + 40 + (a4 >> 3)) |= 1 << (a4 & 7);
      ++*(_DWORD *)(v14 + 24);
      ++*(_DWORD *)(v14 + 36);
    }
LABEL_27:
    *(_QWORD *)(a2 + 8) = v14;
    return 0;
  }
  v14 = tre_mem_alloc_impl(a1, 0, 0, 1, ((a5 + 7) >> 3) + 40);
  if (v14)
  {
    *(_DWORD *)(v14 + 28) = 1;
    goto LABEL_25;
  }
  return 12;
}

uint64_t tre_add_tag_right(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v4;

  v4 = (_QWORD *)tre_mem_alloc_impl(a1, 0, 0, 0, 0x10uLL);
  if (v4)
  {
    v4[1] = tre_ast_new_literal(a1, -3, a3, -1);
    if (v4[1])
    {
      *v4 = tre_mem_alloc_impl(a1, 0, 0, 1, 0x48uLL);
      if (*v4)
      {
        *(_QWORD *)*v4 = *(_QWORD *)a2;
        *(_DWORD *)(*v4 + 48) = *(_DWORD *)(a2 + 48);
        *(_QWORD *)(*v4 + 8) = *(_QWORD *)(a2 + 8);
        *(_WORD *)(*v4 + 64) = -1;
        *(_DWORD *)(*v4 + 52) = -1;
        *(_QWORD *)a2 = v4;
        *(_DWORD *)(a2 + 48) = 1;
        *(_QWORD *)(a2 + 40) = *v4;
        return 0;
      }
      else
      {
        return 12;
      }
    }
    else
    {
      return 12;
    }
  }
  else
  {
    return 12;
  }
}

_DWORD *tre_purge_regset(_DWORD *result, uint64_t a2, int a3)
{
  signed int v3;
  int i;

  for (i = 0; result[i] != -1; ++i)
  {
    v3 = result[i] / 2u;
    if (v3 < 0x40000000)
    {
      if (result[i] % 2u)
        *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8 * v3 + 4) = a3;
      else
        *(_DWORD *)(*(_QWORD *)(a2 + 24) + 8 * v3) = a3;
    }
  }
  *result = -1;
  return result;
}

uint64_t tre_add_tag_left(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v4;

  v4 = (_QWORD *)tre_mem_alloc_impl(a1, 0, 0, 0, 0x10uLL);
  if (v4)
  {
    *v4 = tre_ast_new_literal(a1, -3, a3, -1);
    if (*v4)
    {
      v4[1] = tre_mem_alloc_impl(a1, 0, 0, 1, 0x48uLL);
      if (v4[1])
      {
        *(_QWORD *)v4[1] = *(_QWORD *)a2;
        *(_DWORD *)(v4[1] + 48) = *(_DWORD *)(a2 + 48);
        *(_QWORD *)(v4[1] + 8) = *(_QWORD *)(a2 + 8);
        *(_WORD *)(v4[1] + 64) = -1;
        *(_DWORD *)(v4[1] + 52) = -1;
        *(_QWORD *)a2 = v4;
        *(_DWORD *)(a2 + 48) = 1;
        *(_QWORD *)(a2 + 40) = v4[1];
        return 0;
      }
      else
      {
        return 12;
      }
    }
    else
    {
      return 12;
    }
  }
  else
  {
    return 12;
  }
}

uint64_t tre_copy_ast(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  unint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  unsigned int v10;

  v9 = tre_stack_num_objects(a2);
  tre_stack_push_voidptr(a2, a3);
  v10 = tre_stack_push_int(a2, 0);
  while (1)
  {
    v8 = 0;
    if (!v10)
      v8 = (int)tre_stack_num_objects(a2) > v9;
    if (!v8 || v10)
      break;
    v7 = tre_stack_pop_int(a2);
    if (v7)
    {
      if (v7 == 1)
        tre_stack_pop_voidptr(a2);
    }
    else
    {
      v6 = *(unsigned int *)(tre_stack_pop_voidptr(a2) + 48);
      if (v6 <= 3)
        __asm { BR              X8 }
    }
  }
  *a5 = *a5;
  return v10;
}

uint64_t tre_set_one(uint64_t a1, int a2, int a3, int a4, uint64_t a5, int a6)
{
  uint64_t v7;

  v7 = tre_mem_alloc_impl(a1, 0, 0, 1, 0x80uLL);
  if (!v7)
    return 0;
  *(_DWORD *)v7 = a2;
  *(_DWORD *)(v7 + 4) = a3;
  *(_DWORD *)(v7 + 8) = a4;
  *(_QWORD *)(v7 + 32) = a5;
  *(_DWORD *)(v7 + 40) = a6;
  *(_DWORD *)(v7 + 64) = -1;
  *(_DWORD *)(v7 + 68) = -1;
  *(_DWORD *)(v7 + 72) = -1;
  return v7;
}

_DWORD *tre_set_empty(uint64_t a1)
{
  _DWORD *v2;

  v2 = (_DWORD *)tre_mem_alloc_impl(a1, 0, 0, 1, 0x40uLL);
  if (!v2)
    return 0;
  *v2 = -1;
  v2[1] = -1;
  v2[2] = -1;
  return v2;
}

uint64_t tre_set_union(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  BOOL v7;
  BOOL v8;
  int i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int ii;
  int i1;
  int n;
  int jj;
  int kk;
  int nn;
  int i2;
  int k;
  int mm;
  int j;
  int m;

  for (i = 0; ; ++i)
  {
    v8 = 0;
    if (a4)
      v8 = *(_DWORD *)(a4 + 4 * i) >= 0;
    if (!v8)
      break;
  }
  for (j = 0; *(int *)(a2 + ((uint64_t)j << 6)) >= 0; ++j)
    ;
  for (k = 0; *(int *)(a3 + ((uint64_t)k << 6)) >= 0; ++k)
    ;
  v12 = tre_mem_alloc_impl(a1, 0, 0, 1, (uint64_t)(j + k + 1) << 6);
  if (!v12)
    return 0;
  for (m = 0; *(int *)(a2 + ((uint64_t)m << 6)) >= 0; ++m)
  {
    *(_DWORD *)(v12 + ((uint64_t)m << 6)) = *(_DWORD *)(a2 + ((uint64_t)m << 6));
    *(_DWORD *)(v12 + ((uint64_t)m << 6) + 4) = *(_DWORD *)(a2 + ((uint64_t)m << 6) + 4);
    *(_DWORD *)(v12 + ((uint64_t)m << 6) + 8) = *(_DWORD *)(a2 + ((uint64_t)m << 6) + 8);
    *(_DWORD *)(v12 + ((uint64_t)m << 6) + 24) = *(_DWORD *)(a2 + ((uint64_t)m << 6) + 24) | a5;
    *(_QWORD *)(v12 + ((uint64_t)m << 6) + 32) = *(_QWORD *)(a2 + ((uint64_t)m << 6) + 32);
    *(_DWORD *)(v12 + ((uint64_t)m << 6) + 40) = *(_DWORD *)(a2 + ((uint64_t)m << 6) + 40);
    if (*(_QWORD *)(a2 + ((uint64_t)m << 6) + 16) || a4)
    {
      for (n = 0; ; ++n)
      {
        v7 = 0;
        if (*(_QWORD *)(a2 + ((uint64_t)m << 6) + 16))
          v7 = *(_DWORD *)(*(_QWORD *)(a2 + ((uint64_t)m << 6) + 16) + 4 * n) >= 0;
        if (!v7)
          break;
      }
      v10 = tre_mem_alloc_impl(a1, 0, 0, 0, 4 * (n + i + 1));
      if (!v10)
        return 0;
      for (ii = 0; ii < n; ++ii)
        *(_DWORD *)(v10 + 4 * ii) = *(_DWORD *)(*(_QWORD *)(a2 + ((uint64_t)m << 6) + 16) + 4 * ii);
      for (jj = 0; jj < i; ++jj)
        *(_DWORD *)(v10 + 4 * (ii + jj)) = *(_DWORD *)(a4 + 4 * jj);
      *(_DWORD *)(v10 + 4 * (ii + jj)) = -1;
      *(_QWORD *)(v12 + ((uint64_t)m << 6) + 16) = v10;
    }
    else
    {
      *(_QWORD *)(v12 + ((uint64_t)m << 6) + 16) = 0;
    }
    if (*(_QWORD *)(a2 + ((uint64_t)m << 6) + 48))
      *(_QWORD *)(v12 + ((uint64_t)m << 6) + 48) = *(_QWORD *)(a2 + ((uint64_t)m << 6) + 48);
    if (a6)
    {
      if (*(_QWORD *)(v12 + ((uint64_t)m << 6) + 48))
      {
        *(_QWORD *)(v12 + ((uint64_t)m << 6) + 48) = tre_mem_alloc_impl(a1, 0, 0, 0, 0x24uLL);
        if (!*(_QWORD *)(v12 + ((uint64_t)m << 6) + 48))
          return 0;
        for (kk = 0; kk < 9; ++kk)
        {
          if (*(_DWORD *)(a6 + 4 * kk) != -1)
            *(_DWORD *)(*(_QWORD *)(v12 + ((uint64_t)m << 6) + 48) + 4 * kk) = *(_DWORD *)(a6 + 4 * kk);
        }
      }
      else
      {
        *(_QWORD *)(v12 + ((uint64_t)m << 6) + 48) = a6;
      }
    }
  }
  for (mm = 0; *(int *)(a3 + ((uint64_t)mm << 6)) >= 0; ++mm)
  {
    *(_DWORD *)(v12 + ((uint64_t)(m + mm) << 6)) = *(_DWORD *)(a3 + ((uint64_t)mm << 6));
    *(_DWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 4) = *(_DWORD *)(a3 + ((uint64_t)mm << 6) + 4);
    *(_DWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 8) = *(_DWORD *)(a3 + ((uint64_t)mm << 6) + 8);
    *(_DWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 24) = *(_DWORD *)(a3 + ((uint64_t)mm << 6) + 24);
    *(_QWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 32) = *(_QWORD *)(a3 + ((uint64_t)mm << 6) + 32);
    *(_DWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 40) = *(_DWORD *)(a3 + ((uint64_t)mm << 6) + 40);
    if (*(_QWORD *)(a3 + ((uint64_t)mm << 6) + 16))
    {
      for (nn = 0; *(int *)(*(_QWORD *)(a3 + ((uint64_t)mm << 6) + 16) + 4 * nn) >= 0; ++nn)
        ;
      v11 = tre_mem_alloc_impl(a1, 0, 0, 0, 4 * (nn + 1));
      if (!v11)
        return 0;
      for (i1 = 0; i1 < nn; ++i1)
        *(_DWORD *)(v11 + 4 * i1) = *(_DWORD *)(*(_QWORD *)(a3 + ((uint64_t)mm << 6) + 16) + 4 * i1);
      *(_DWORD *)(v11 + 4 * i1) = -1;
      *(_QWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 16) = v11;
    }
    else
    {
      *(_QWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 16) = 0;
    }
    if (*(_QWORD *)(a3 + ((uint64_t)mm << 6) + 48))
      *(_QWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 48) = *(_QWORD *)(a3 + ((uint64_t)mm << 6) + 48);
    if (a6)
    {
      if (*(_QWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 48))
      {
        *(_QWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 48) = tre_mem_alloc_impl(a1, 0, 0, 0, 0x24uLL);
        if (!*(_QWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 48))
          return 0;
        for (i2 = 0; i2 < 9; ++i2)
        {
          if (*(_DWORD *)(a6 + 4 * i2) != -1)
            *(_DWORD *)(*(_QWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 48) + 4 * i2) = *(_DWORD *)(a6 + 4 * i2);
        }
      }
      else
      {
        *(_QWORD *)(v12 + ((uint64_t)(m + mm) << 6) + 48) = a6;
      }
    }
  }
  *(_DWORD *)(v12 + ((uint64_t)(m + mm) << 6)) = -1;
  return v12;
}

uint64_t tre_match_empty(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _DWORD *a6, _DWORD *a7)
{
  unint64_t v8;
  BOOL v9;
  unsigned int v10;
  int v11;

  v11 = tre_stack_num_objects(a1);
  if (a6)
    *a6 = 0;
  if (a7)
    *a7 = 0;
  v10 = tre_stack_push_voidptr(a1, a2);
  while (1)
  {
    v9 = 0;
    if (!v10)
      v9 = (int)tre_stack_num_objects(a1) > v11;
    if (!v9)
      break;
    v8 = *(unsigned int *)(tre_stack_pop_voidptr(a1) + 48);
    if (v8 <= 3)
      __asm { BR              X8 }
  }
  return v10;
}

uint64_t tre_make_trans(int *a1, int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  uint64_t v6;
  int v8;
  int v9;
  int v10;
  int j;
  int v12;
  int v13;
  int v14;
  int v15;
  int k;
  uint64_t i;
  int *v21;
  int *m;

  if (a3)
  {
    while (*a1 >= 0)
    {
      v21 = a2;
      v8 = -1;
      while (*v21 >= 0)
      {
        if (*v21 == v8)
        {
          v21 += 16;
        }
        else
        {
          v8 = *v21;
          for (i = a3 + 56 * *(int *)(a5 + 4 * *a1); *(_QWORD *)(i + 8); i += 56)
            ;
          *(_QWORD *)(i + 64) = 0;
          *(_DWORD *)i = a1[1];
          *(_DWORD *)(i + 4) = a1[2];
          *(_QWORD *)(i + 8) = a3 + 56 * *(int *)(a5 + 4 * *v21);
          *(_DWORD *)(i + 16) = *v21;
          if (*((_QWORD *)a1 + 4))
            v5 = 4;
          else
            v5 = 0;
          *(_DWORD *)(i + 40) = a1[6] | v21[6] | v5;
          if (a1[10] >= 0)
          {
            *(_DWORD *)(i + 48) = a1[10];
            *(_DWORD *)(i + 40) |= 0x80u;
          }
          if (*((_QWORD *)a1 + 4))
          {
            *(_QWORD *)(i + 48) = malloc_type_malloc(8 * **((int **)a1 + 4) + 8, 2235706890);
            if (!*(_QWORD *)(i + 48))
              return 12;
            j___platform_memmove(*(_QWORD *)(i + 48), *((_QWORD *)a1 + 4), 8 * **((int **)a1 + 4) + 8);
          }
          v14 = 0;
          if (*((_QWORD *)a1 + 2))
          {
            while (*(int *)(*((_QWORD *)a1 + 2) + 4 * v14) >= 0)
              ++v14;
          }
          v12 = 0;
          if (*((_QWORD *)v21 + 2))
          {
            while (*(int *)(*((_QWORD *)v21 + 2) + 4 * v12) >= 0)
              ++v12;
          }
          if (*(_QWORD *)(i + 24))
            free(*(void **)(i + 24));
          *(_QWORD *)(i + 24) = 0;
          if (v14 + v12 > 0)
          {
            *(_QWORD *)(i + 24) = malloc_type_malloc(4 * (v14 + v12 + 1), 0x100004052888210);
            if (!*(_QWORD *)(i + 24))
              return 12;
            v15 = 0;
            if (*((_QWORD *)a1 + 2))
            {
              while (*(int *)(*((_QWORD *)a1 + 2) + 4 * v15) >= 0)
              {
                *(_DWORD *)(*(_QWORD *)(i + 24) + 4 * v15) = *(_DWORD *)(*((_QWORD *)a1 + 2) + 4 * v15);
                ++v15;
              }
            }
            v10 = v15;
            v13 = 0;
            if (*((_QWORD *)v21 + 2))
            {
              while (*(int *)(*((_QWORD *)v21 + 2) + 4 * v13) >= 0)
              {
                v9 = 0;
                for (j = 0; j < v15; ++j)
                {
                  if (*(_DWORD *)(*(_QWORD *)(i + 24) + 4 * j) == *(_DWORD *)(*((_QWORD *)v21 + 2) + 4 * v13))
                  {
                    v9 = 1;
                    break;
                  }
                }
                if (!v9)
                {
                  v6 = v10++;
                  *(_DWORD *)(*(_QWORD *)(i + 24) + 4 * v6) = *(_DWORD *)(*((_QWORD *)v21 + 2) + 4 * v13);
                }
                ++v13;
              }
            }
            *(_DWORD *)(*(_QWORD *)(i + 24) + 4 * v10) = -1;
          }
          if (*((_QWORD *)a1 + 6) || *((_QWORD *)v21 + 6))
          {
            if (!*(_QWORD *)(i + 32))
              *(_QWORD *)(i + 32) = malloc_type_malloc(36, 0x100004052888210);
            if (!*(_QWORD *)(i + 32))
              return 12;
            for (k = 0; k < 9; ++k)
            {
              *(_DWORD *)(*(_QWORD *)(i + 32) + 4 * k) = -1;
              if (*((_QWORD *)a1 + 6) && *(_DWORD *)(*((_QWORD *)a1 + 6) + 4 * k) != -1)
                *(_DWORD *)(*(_QWORD *)(i + 32) + 4 * k) = *(_DWORD *)(*((_QWORD *)a1 + 6) + 4 * k);
              if (*((_QWORD *)v21 + 6) && *(_DWORD *)(*((_QWORD *)v21 + 6) + 4 * k) != -1)
                *(_DWORD *)(*(_QWORD *)(i + 32) + 4 * k) = *(_DWORD *)(*((_QWORD *)v21 + 6) + 4 * k);
            }
          }
          else
          {
            if (*(_QWORD *)(i + 32))
              free(*(void **)(i + 32));
            *(_QWORD *)(i + 32) = 0;
          }
          v21 += 16;
        }
      }
      a1 += 16;
    }
  }
  else
  {
    while (*a1 >= 0)
    {
      for (m = a2; *m >= 0; m += 16)
        ++*(_DWORD *)(a4 + 4 * *a1);
      a1 += 16;
    }
  }
  return 0;
}

uint64_t tre_tnfa_run_backtrack(uint64_t a1, char *a2, int a3, int a4, uint64_t a5, int a6, int *a7)
{
  char *v7;
  wint_t *v8;
  char *v9;
  int *v10;
  char *v11;
  wint_t *v12;
  char *v13;
  char *v14;
  wint_t *v15;
  char *v16;
  int *v17;
  BOOL v19;
  BOOL v20;
  BOOL v21;
  BOOL v22;
  BOOL v23;
  BOOL v24;
  BOOL v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  BOOL v29;
  BOOL v30;
  unint64_t v31;
  unint64_t v32;
  int *n;
  _QWORD *v34;
  int v35;
  size_t v36;
  int v37;
  size_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  int *v47;
  _QWORD *v48;
  int v49;
  size_t v50;
  unint64_t v51;
  unint64_t v52;
  int v53;
  char *v54;
  int v55;
  int v56;
  unsigned int v57;
  char *v58;
  uint64_t j;
  uint64_t m;
  uint64_t v61;
  void **v62;
  _DWORD *v63;
  uint64_t v64;
  int *v65;
  int v66;
  wint_t *v67;
  int v68;
  char *v69;
  wint_t v70;
  int i;
  int k;
  int ii;
  int v74;
  int v75;
  int v76;
  wint_t *v77;
  int v78;
  int v79;
  char *v80;
  wint_t v81;
  wint_t v82;
  int *v83;
  int v84;
  uint64_t v85;
  int v86;
  int v87;
  char *v88;
  uint64_t v89;
  _BYTE v91[128];
  mbstate_t v92;

  v89 = a1;
  v88 = a2;
  v87 = a3;
  v86 = a4;
  v85 = a5;
  v84 = a6;
  v83 = a7;
  v82 = 0;
  v81 = 0;
  v80 = a2;
  v78 = 1;
  v77 = (wint_t *)a2;
  _platform_memset(&v92, 0, 128);
  v76 = v84 & 1;
  v75 = v84 & 2;
  v74 = *(_DWORD *)(v89 + 96) & 8;
  v68 = -1;
  _platform_memset(v91, 0, 128);
  v66 = -1;
  v62 = (void **)tre_mem_new_impl(0, 0);
  v56 = *(_DWORD *)(v89 + 80);
  v55 = 1;
  v54 = 0;
  _platform_memset(&v92, 0, 128);
  if (!v62)
    return 12;
  v61 = tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 0xC0uLL);
  if (!v61)
  {
    v57 = 12;
    goto LABEL_302;
  }
  *(_QWORD *)(v61 + 176) = 0;
  *(_QWORD *)(v61 + 184) = 0;
  v53 = 16 * *(_DWORD *)(v89 + 72);
  v54 = (char *)malloc_type_malloc((16 * v56 + 14 + v53 + 4 * *(_DWORD *)(v89 + 92)), 3125671067);
  if (!v54)
    return 12;
  v51 = (unint64_t)&v54[16 * v56];
  if (v51 % 8)
    v32 = 8 - v51 % 8;
  else
    v32 = 0;
  v58 = (char *)(v51 + v32);
  v52 = v51 + v32 + v53;
  if (v52 % 8)
    v31 = 8 - v52 % 8;
  else
    v31 = 0;
  v63 = (_DWORD *)(v52 + v31);
  while (1)
  {
    _platform_bzero(v54, 16 * v56);
    if (v85)
      _platform_bzero(v85, 16 * v56);
    for (i = 0; i < *(_DWORD *)(v89 + 92); ++i)
      v63[i] = 0;
    v64 = 0;
    v79 = v68;
    v82 = v81;
    if (v86)
    {
      if (v86 == 1)
      {
        v79 = v68 + 1;
        if (v87 < 0 || v79 < v87)
        {
          v7 = v80++;
          v81 = *v7;
        }
        else
        {
          v81 = 0;
        }
      }
      else if (v86 == 2)
      {
        v79 = v68 + v78;
        v30 = 0;
        if (v87 >= 0)
          v30 = v79 >= v87;
        if (v30)
        {
          v81 = 0;
          v78 = 1;
        }
        else if (*v80 < 0)
        {
          if (v87 < 0)
            v49 = 32;
          else
            v49 = v87 - v79;
          v50 = mbrtowc_l(&v81, v80, v49, &v92, *(locale_t *)(v89 + 56));
          if (v50 >= 0xFFFFFFFFFFFFFFFELL)
            return 17;
          if (v50 || v87 < 0)
          {
            v78 = v50;
            v80 += v50;
          }
          else
          {
            v78 = 1;
            v81 = 0;
            ++v80;
          }
        }
        else
        {
          v9 = v80++;
          v81 = *v9;
          v78 = 1;
        }
      }
    }
    else
    {
      v79 = v68 + 1;
      if (v87 < 0 || v79 < v87)
      {
        v8 = v77++;
        v81 = *v8;
      }
      else
      {
        v81 = 0;
      }
    }
    v68 = v79;
    v70 = v81;
    v69 = v80;
    v67 = v77;
    j___platform_memmove(v91, &v92, 128);
    v65 = 0;
    for (j = *(_QWORD *)(v89 + 8); *(_QWORD *)(j + 8); j += 56)
    {
      if (!*(_DWORD *)(j + 40))
        goto LABEL_86;
      if (((*(_DWORD *)(j + 40) & 1) == 0 || v79 <= 0 && !v76 || v82 == 10 && v74)
        && ((*(_DWORD *)(j + 40) & 2) == 0 || !v81 && !v75 || v81 == 10 && v74)
        && ((*(_DWORD *)(j + 40) & 8) == 0
         || v82 != 95
         && !iswalnum_l(v82, *(locale_t *)(v89 + 56))
         && (v81 == 95 || iswalnum_l(v81, *(locale_t *)(v89 + 56))))
        && ((*(_DWORD *)(j + 40) & 0x10) == 0
         || (v82 == 95 || iswalnum_l(v82, *(locale_t *)(v89 + 56)))
         && v81 != 95
         && !iswalnum_l(v81, *(locale_t *)(v89 + 56))))
      {
        if ((*(_DWORD *)(j + 40) & 0x20) == 0 || !v79 || !v81)
          goto LABEL_77;
        v29 = 1;
        if (v82 != 95)
          v29 = iswalnum_l(v82, *(locale_t *)(v89 + 56)) != 0;
        v28 = 1;
        if (v81 != 95)
          v28 = iswalnum_l(v81, *(locale_t *)(v89 + 56)) != 0;
        if (v29 != v28)
        {
LABEL_77:
          if ((*(_DWORD *)(j + 40) & 0x40) == 0)
            goto LABEL_86;
          if (v79 && v81)
          {
            v27 = 1;
            if (v82 != 95)
              v27 = iswalnum_l(v82, *(locale_t *)(v89 + 56)) != 0;
            v26 = 1;
            if (v81 != 95)
              v26 = iswalnum_l(v81, *(locale_t *)(v89 + 56)) != 0;
            if (v27 == v26)
            {
LABEL_86:
              if (v64)
              {
                if (*(_QWORD *)(v61 + 184))
                {
                  v61 = *(_QWORD *)(v61 + 184);
                }
                else
                {
                  v48 = (_QWORD *)tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 0xC0uLL);
                  if (!v48)
                  {
                    tre_mem_destroy(v62);
                    free(v54);
                    if (v58)
                      free(v58);
                    if (v63)
                      free(v63);
                    return 12;
                  }
                  v48[22] = v61;
                  v48[23] = 0;
                  v48[5] = tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 16 * v56);
                  if (!v48[5])
                  {
                    tre_mem_destroy(v62);
                    free(v54);
                    if (v58)
                      free(v58);
                    if (v63)
                      free(v63);
                    return 12;
                  }
                  *(_QWORD *)(v61 + 184) = v48;
                  v61 = (uint64_t)v48;
                }
                *(_DWORD *)v61 = v79;
                *(_DWORD *)(v61 + 4) = v78;
                *(_QWORD *)(v61 + 8) = v80;
                *(_QWORD *)(v61 + 16) = v77;
                *(_QWORD *)(v61 + 24) = *(_QWORD *)(j + 8);
                *(_DWORD *)(v61 + 32) = *(_DWORD *)(j + 16);
                *(_DWORD *)(v61 + 36) = v81;
                j___platform_memmove(*(_QWORD *)(v61 + 40), v54, 16 * v56);
                j___platform_memmove(v61 + 48, &v92, 128);
                v47 = *(int **)(j + 24);
                if (v47)
                {
                  while (*v47 >= 0)
                  {
                    v10 = v47++;
                    tre_tag_set(*(_QWORD *)(v61 + 40), *v10, v79, v55);
                  }
                  ++v55;
                }
              }
              else
              {
                v64 = *(_QWORD *)(j + 8);
                v65 = *(int **)(j + 24);
              }
            }
          }
        }
      }
    }
    if (v65)
    {
      while (*v65 >= 0)
        tre_tag_set((uint64_t)v54, *v65++, v79, v55);
      ++v55;
    }
    if (!v64)
      goto LABEL_290;
    while (1)
    {
      while (1)
      {
        if (v66 >= 0 && *(_DWORD *)(v89 + 84))
        {
          v44 = 0;
          for (k = 0; *(int *)(*(_QWORD *)(v89 + 40) + 4 * k) >= 0; k += 2)
          {
            if ((int)tre_minimal_tag_order(*(_DWORD *)(*(_QWORD *)(v89 + 40) + 4 * (k + 1)), *(_DWORD *)(*(_QWORD *)(v89 + 40) + 4 * k), v85, (uint64_t)v54) > 0)
            {
              v44 = 1;
              break;
            }
          }
          if (v44)
            goto LABEL_290;
        }
        if (v64 == *(_QWORD *)(v89 + 16))
          break;
        v45 = 0;
        if (*(_QWORD *)(v64 + 8) && (*(_DWORD *)(v64 + 40) & 0x80) != 0)
        {
          v41 = *(_DWORD *)(v64 + 48);
          v57 = tre_fill_pmatch(v41 + 1, (uint64_t)v58, *(_DWORD *)(v89 + 96) & 0xFB, v89, v54, v79);
          if (v57)
            goto LABEL_302;
          v42 = *(_QWORD *)&v58[16 * v41];
          v40 = *(_QWORD *)&v58[16 * v41 + 8] - v42;
          if (v42 >= 0)
          {
            if (v87 >= 0)
            {
              if (v87 - v79 >= v40)
              {
                if (v86)
                  v39 = _platform_memcmp(&v88[v42], v80 - 1, v40);
                else
                  v39 = wmemcmp((const __int32 *)&v88[4 * v42], v77 - 1, v40);
              }
              else
              {
                v39 = 1;
              }
            }
            else if (v86)
            {
              v39 = _platform_strncmp(&v88[v42], v80 - 1, v40);
            }
            else
            {
              v39 = wcsncmp((const __int32 *)&v88[4 * v42], v77 - 1, v40);
            }
          }
          else
          {
            v39 = 1;
          }
          if (v39)
            goto LABEL_290;
          if (!v40)
            v45 = 1;
          if (v45 && v63[*(int *)(v64 + 16)])
            goto LABEL_290;
          v63[*(int *)(v64 + 16)] = v45;
          v80 += v40 - 1;
          v77 += v40 - 1;
          v79 += v40 - 1;
          v82 = v81;
          if (v86)
          {
            if (v86 == 1)
            {
              ++v79;
              if (v87 < 0 || v79 < v87)
              {
                v11 = v80++;
                v81 = *v11;
              }
              else
              {
                v81 = 0;
              }
            }
            else if (v86 == 2)
            {
              v79 += v78;
              v25 = 0;
              if (v87 >= 0)
                v25 = v79 >= v87;
              if (v25)
              {
                v81 = 0;
                v78 = 1;
              }
              else if (*v80 < 0)
              {
                if (v87 < 0)
                  v37 = 32;
                else
                  v37 = v87 - v79;
                v38 = mbrtowc_l(&v81, v80, v37, &v92, *(locale_t *)(v89 + 56));
                if (v38 >= 0xFFFFFFFFFFFFFFFELL)
                  return 17;
                if (v38 || v87 < 0)
                {
                  v78 = v38;
                  v80 += v38;
                }
                else
                {
                  v78 = 1;
                  v81 = 0;
                  ++v80;
                }
              }
              else
              {
                v13 = v80++;
                v81 = *v13;
                v78 = 1;
              }
            }
          }
          else
          {
            ++v79;
            if (v87 < 0 || v79 < v87)
            {
              v12 = v77++;
              v81 = *v12;
            }
            else
            {
              v81 = 0;
            }
          }
        }
        else
        {
          if (v87 >= 0)
          {
            if (v79 >= v87)
              goto LABEL_290;
          }
          else if (!v81)
          {
            goto LABEL_290;
          }
          v82 = v81;
          if (v86)
          {
            if (v86 == 1)
            {
              ++v79;
              if (v87 < 0 || v79 < v87)
              {
                v14 = v80++;
                v81 = *v14;
              }
              else
              {
                v81 = 0;
              }
            }
            else if (v86 == 2)
            {
              v79 += v78;
              v24 = 0;
              if (v87 >= 0)
                v24 = v79 >= v87;
              if (v24)
              {
                v81 = 0;
                v78 = 1;
              }
              else if (*v80 < 0)
              {
                if (v87 < 0)
                  v35 = 32;
                else
                  v35 = v87 - v79;
                v36 = mbrtowc_l(&v81, v80, v35, &v92, *(locale_t *)(v89 + 56));
                if (v36 >= 0xFFFFFFFFFFFFFFFELL)
                  return 17;
                if (v36 || v87 < 0)
                {
                  v78 = v36;
                  v80 += v36;
                }
                else
                {
                  v78 = 1;
                  v81 = 0;
                  ++v80;
                }
              }
              else
              {
                v16 = v80++;
                v81 = *v16;
                v78 = 1;
              }
            }
          }
          else
          {
            ++v79;
            if (v87 < 0 || v79 < v87)
            {
              v15 = v77++;
              v81 = *v15;
            }
            else
            {
              v81 = 0;
            }
          }
        }
        v46 = 0;
        for (m = v64; *(_QWORD *)(m + 8); m += 56)
        {
          if (*(_DWORD *)m <= v82 && *(_DWORD *)(m + 4) >= v82)
          {
            if (!*(_DWORD *)(m + 40))
              goto LABEL_260;
            if (((*(_DWORD *)(m + 40) & 1) == 0 || v79 <= 0 && !v76 || v82 == 10 && v74)
              && ((*(_DWORD *)(m + 40) & 2) == 0 || !v81 && !v75 || v81 == 10 && v74)
              && ((*(_DWORD *)(m + 40) & 8) == 0
               || v82 != 95
               && !iswalnum_l(v82, *(locale_t *)(v89 + 56))
               && (v81 == 95 || iswalnum_l(v81, *(locale_t *)(v89 + 56))))
              && ((*(_DWORD *)(m + 40) & 0x10) == 0
               || (v82 == 95 || iswalnum_l(v82, *(locale_t *)(v89 + 56)))
               && v81 != 95
               && !iswalnum_l(v81, *(locale_t *)(v89 + 56))))
            {
              if ((*(_DWORD *)(m + 40) & 0x20) == 0 || !v79 || !v81)
                goto LABEL_249;
              v23 = 1;
              if (v82 != 95)
                v23 = iswalnum_l(v82, *(locale_t *)(v89 + 56)) != 0;
              v22 = 1;
              if (v81 != 95)
                v22 = iswalnum_l(v81, *(locale_t *)(v89 + 56)) != 0;
              if (v23 != v22)
              {
LABEL_249:
                if ((*(_DWORD *)(m + 40) & 0x40) == 0)
                  goto LABEL_308;
                if (v79 && v81)
                {
                  v21 = 1;
                  if (v82 != 95)
                    v21 = iswalnum_l(v82, *(locale_t *)(v89 + 56)) != 0;
                  v20 = 1;
                  if (v81 != 95)
                    v20 = iswalnum_l(v81, *(locale_t *)(v89 + 56)) != 0;
                  if (v21 == v20)
                  {
LABEL_308:
                    if ((*(_DWORD *)(m + 40) & 4) == 0
                      || tre_bracket_match(*(_DWORD **)(m + 48), v82, v89))
                    {
LABEL_260:
                      if (v46)
                      {
                        if (*(_QWORD *)(v61 + 184))
                        {
                          v61 = *(_QWORD *)(v61 + 184);
                        }
                        else
                        {
                          v34 = (_QWORD *)tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 0xC0uLL);
                          if (!v34)
                          {
                            tre_mem_destroy(v62);
                            free(v54);
                            if (v58)
                              free(v58);
                            if (v63)
                              free(v63);
                            return 12;
                          }
                          v34[22] = v61;
                          v34[23] = 0;
                          v34[5] = tre_mem_alloc_impl((uint64_t)v62, 0, 0, 0, 16 * v56);
                          if (!v34[5])
                          {
                            tre_mem_destroy(v62);
                            free(v54);
                            if (v58)
                              free(v58);
                            if (v63)
                              free(v63);
                            return 12;
                          }
                          *(_QWORD *)(v61 + 184) = v34;
                          v61 = (uint64_t)v34;
                        }
                        *(_DWORD *)v61 = v79;
                        *(_DWORD *)(v61 + 4) = v78;
                        *(_QWORD *)(v61 + 8) = v80;
                        *(_QWORD *)(v61 + 16) = v77;
                        *(_QWORD *)(v61 + 24) = *(_QWORD *)(m + 8);
                        *(_DWORD *)(v61 + 32) = *(_DWORD *)(m + 16);
                        *(_DWORD *)(v61 + 36) = v81;
                        j___platform_memmove(*(_QWORD *)(v61 + 40), v54, 16 * v56);
                        j___platform_memmove(v61 + 48, &v92, 128);
                        for (n = *(int **)(m + 24); ; ++n)
                        {
                          v19 = 0;
                          if (n)
                            v19 = *n >= 0;
                          if (!v19)
                            break;
                          tre_tag_set(*(_QWORD *)(v61 + 40), *n, v79, v55);
                        }
                        ++v55;
                      }
                      else
                      {
                        v46 = *(_QWORD *)(m + 8);
                        v65 = *(int **)(m + 24);
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (!v46)
          goto LABEL_290;
        v64 = v46;
        if (v65)
        {
          while (*v65 >= 0)
          {
            v17 = v65++;
            tre_tag_set((uint64_t)v54, *v17, v79, v55);
          }
          ++v55;
        }
      }
      if (v66 >= 0 && *(_DWORD *)(v89 + 84))
      {
        v43 = 0;
        for (ii = 0; *(int *)(*(_QWORD *)(v89 + 40) + 4 * ii) >= 0; ii += 2)
        {
          v43 = tre_minimal_tag_order(*(_DWORD *)(*(_QWORD *)(v89 + 40) + 4 * (ii + 1)), *(_DWORD *)(*(_QWORD *)(v89 + 40) + 4 * ii), v85, (uint64_t)v54);
          if (v43)
            break;
        }
        if (v43 > 0)
          goto LABEL_290;
        if (v43 < 0)
          v66 = -1;
      }
      if (v66 < v79
        || v66 == v79 && v85 && tre_tag_order(*(_DWORD *)(v89 + 80), *(_QWORD *)(v89 + 32), (uint64_t)v54, v85))
      {
        v66 = v79;
        if (v85)
          j___platform_memmove(v85, v54, 16 * v56);
      }
LABEL_290:
      if (!*(_QWORD *)(v61 + 176))
        break;
      if ((*(_DWORD *)(*(_QWORD *)(v61 + 24) + 40) & 0x80) != 0)
        v63[*(int *)(v61 + 32)] = 0;
      v79 = *(_DWORD *)v61;
      v78 = *(_DWORD *)(v61 + 4);
      v80 = *(char **)(v61 + 8);
      v77 = *(wint_t **)(v61 + 16);
      v64 = *(_QWORD *)(v61 + 24);
      v81 = *(_DWORD *)(v61 + 36);
      j___platform_memmove(v54, *(_QWORD *)(v61 + 40), 16 * v56);
      j___platform_memmove(&v92, v61 + 48, 128);
      v61 = *(_QWORD *)(v61 + 176);
    }
    if (v66 >= 0)
      goto LABEL_301;
    if (v79 != v68)
      goto LABEL_300;
    if (v87 >= 0)
      break;
    if (!v81)
      goto LABEL_301;
LABEL_300:
    v81 = v70;
    j___platform_memmove(&v92, v91, 128);
    v80 = v69;
    v77 = v67;
  }
  if (v79 < v87)
    goto LABEL_300;
LABEL_301:
  v57 = v66 < 0;
  *v83 = v66;
LABEL_302:
  tre_mem_destroy(v62);
  if (v54)
    free(v54);
  return v57;
}

uint64_t tre_tag_set(uint64_t result, int a2, int a3, int a4)
{
  _DWORD *v5;

  v5 = (_DWORD *)(result + 16 * a2);
  if (!(*v5)++)
    v5[1] = a3;
  v5[2] = a3;
  v5[3] = a4;
  return result;
}

uint64_t tre_minimal_tag_order(int a1, int a2, uint64_t a3, uint64_t a4)
{
  _DWORD *v5;
  _DWORD *v6;

  v5 = (_DWORD *)(a4 + 16 * a1);
  if (*(_DWORD *)(a3 + 16 * a1) && *v5)
  {
    if (*(_DWORD *)(a3 + 16 * a1 + 8) == v5[2])
    {
      v6 = (_DWORD *)(a4 + 16 * a2);
      if (*(_DWORD *)(a3 + 16 * a2))
      {
        if (!*v6)
          return 1;
      }
      else if (*v6)
      {
        return -1;
      }
      return (v6[2] - *(_DWORD *)(a3 + 16 * a2 + 8));
    }
    return 0;
  }
  else
  {
    return 0;
  }
}

BOOL tre_tag_order(int a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v5;
  int i;

  for (i = 0; i < a1; ++i)
  {
    v5 = tre_tag_order_1(i, *(_DWORD *)(a2 + 4 * i), a3, a4);
    if (v5)
      return v5 > 0;
  }
  return 0;
}

uint64_t tre_bracket_match(_DWORD *a1, wint_t a2, uint64_t a3)
{
  unint64_t v4;
  _DWORD *v5;
  int v6;
  unsigned int v7;

  v7 = 0;
  if ((*(_DWORD *)(a3 + 96) & 2) != 0)
  {
    if (iswlower_l(a2, *(locale_t *)(a3 + 56)))
    {
      towupper_l(a2, *(locale_t *)(a3 + 56));
    }
    else if (iswupper_l(a2, *(locale_t *)(a3 + 56)))
    {
      towlower_l(a2, *(locale_t *)(a3 + 56));
    }
  }
  v6 = 0;
  v5 = a1 + 2;
  while (v6 < *a1)
  {
    v4 = (*v5 - 1);
    if (v4 <= 4)
      __asm { BR              X8 }
    ++v6;
    v5 += 2;
  }
  if ((a1[1] & 1) == 0)
    return v7;
  if ((*(_DWORD *)(a3 + 96) & 8) == 0 || a2 != 10)
    return 1;
  return 0;
}

uint64_t tre_tag_order_1(int a1, int a2, uint64_t a3, uint64_t a4)
{
  _DWORD *v5;
  _DWORD *v6;

  v6 = (_DWORD *)(a3 + 16 * a1);
  v5 = (_DWORD *)(a4 + 16 * a1);
  if (a2)
  {
    if (a2 == 1)
    {
      if (*v6)
      {
        if (*v5)
        {
          if (v6[1] == v5[1])
          {
            if (*v5 == *v6)
            {
              if (*v6 == 1)
                return 0;
              else
                return (v6[2] - v5[2]);
            }
            else
            {
              return (*v5 - *v6);
            }
          }
          else
          {
            return (v6[1] - v5[1]);
          }
        }
        else
        {
          return 1;
        }
      }
      else if (*v5)
      {
        return -1;
      }
      else
      {
        return 0;
      }
    }
    else if (a2 == 2)
    {
      if (*v6)
      {
        if (*v5)
        {
          if (v5[1] == v6[1])
          {
            if (*v5 == *v6)
            {
              if (*v6 == 1)
                return 0;
              else
                return (v6[2] - v5[2]);
            }
            else
            {
              return (*v5 - *v6);
            }
          }
          else
          {
            return (v5[1] - v6[1]);
          }
        }
        else
        {
          return 1;
        }
      }
      else if (*v5)
      {
        return -1;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return (v5[2] - v6[2]);
  }
}

uint64_t tre_tnfa_run_parallel(uint64_t a1, const char *a2, int a3, int a4, uint64_t a5, int a6, int *a7)
{
  const char *v7;
  __int32 *v8;
  const char *v9;
  const char *v10;
  __int32 *v11;
  const char *v12;
  const char *v13;
  __int32 *v14;
  const char *v15;
  int v17;
  BOOL v18;
  BOOL v19;
  BOOL v20;
  BOOL v21;
  BOOL v22;
  BOOL v23;
  BOOL v24;
  BOOL v25;
  BOOL v26;
  BOOL v27;
  BOOL v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  int v34;
  size_t v35;
  int v36;
  size_t v37;
  int v38;
  size_t v39;
  int k;
  int m;
  int v42;
  int v43;
  const char *v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  int i;
  int j;
  int jj;
  int v63;
  int *v64;
  int *v65;
  unint64_t v66;
  char *v67;
  char *v68;
  char *n;
  char *v70;
  char *v71;
  uint64_t kk;
  uint64_t ii;
  char *v74;
  int v75;
  int v76;
  int v77;
  __int32 *v78;
  int v79;
  int v80;
  const char *v81;
  __int32 v82;
  wint_t v83;
  int *v84;
  int v85;
  uint64_t v86;
  int v87;
  int v88;
  const char *v89;
  uint64_t v90;
  mbstate_t v92;

  v90 = a1;
  v89 = a2;
  v88 = a3;
  v87 = a4;
  v86 = a5;
  v85 = a6;
  v84 = a7;
  v83 = 0;
  v82 = 0;
  v81 = a2;
  v79 = 1;
  v78 = (__int32 *)a2;
  _platform_memset(&v92, 0, 128);
  v77 = v85 & 1;
  v76 = v85 & 2;
  v75 = *(_DWORD *)(v90 + 96) & 8;
  v59 = -1;
  v54 = 1;
  _platform_memset(&v92, 0, 128);
  if (v86)
    v63 = *(_DWORD *)(v90 + 80);
  else
    v63 = 0;
  v55 = 16 * v63;
  v53 = 16 * (*(_DWORD *)(v90 + 92) + 1);
  v52 = 16 * *(int *)(v90 + 92);
  v51 = 2 * (v53 + v55 * *(int *)(v90 + 92)) + 28 + v55 + v52;
  v74 = (char *)malloc_type_malloc(v51, 1278494475);
  if (v74)
  {
    _platform_bzero(v74, v51);
    v58 = (uint64_t)v74;
    v45 = (unint64_t)&v74[v55];
    if ((unint64_t)&v74[v55] % 8)
      v32 = 8 - v45 % 8;
    else
      v32 = 0;
    v70 = (char *)(v45 + v32);
    v46 = v45 + v32 + v53;
    if (v46 % 8)
      v31 = 8 - v46 % 8;
    else
      v31 = 0;
    v71 = (char *)(v46 + v31);
    v47 = v46 + v31 + v53;
    if (v47 % 8)
      v30 = 8 - v47 % 8;
    else
      v30 = 0;
    v66 = v47 + v30;
    v48 = v47 + v30 + v52;
    if (v48 % 8)
      v29 = 8 - v48 % 8;
    else
      v29 = 0;
    v49 = v48 + v29;
    for (i = 0; i < *(_DWORD *)(v90 + 92); ++i)
    {
      *(_QWORD *)&v71[16 * i + 8] = v49;
      v50 = v49 + v55;
      *(_QWORD *)&v70[16 * i + 8] = v50;
      v49 = v50 + v55;
    }
    for (j = 0; j < *(_DWORD *)(v90 + 92); ++j)
      *(_DWORD *)(v66 + 16 * j) = -1;
    if (*(int *)(v90 + 68) >= 0 && v81)
    {
      v44 = v81;
      v43 = *(_DWORD *)(v90 + 68);
      v42 = 0;
      if (v87 == 1)
      {
        if (v88 < 0)
          v81 = (const char *)_platform_strchr(v81, v43);
        else
          v81 = (const char *)_platform_memchr(v81, v43, v88);
      }
      else if (v87 == 2)
      {
        if (v43 >= 128)
        {
          if (v88 < 0)
          {
            while (1)
            {
              if (!*v81)
              {
                v81 = 0;
                goto LABEL_58;
              }
              if (*v81 < 0)
                break;
              ++v81;
            }
            v42 = 1;
          }
          else
          {
            for (k = 0; ; ++k)
            {
              if (k >= v88)
              {
                v81 = 0;
                goto LABEL_58;
              }
              if (*v81 < 0)
                break;
              ++v81;
            }
            v42 = 1;
          }
        }
        else if (v88 < 0)
        {
          while (1)
          {
            if (!*v81)
            {
              v81 = 0;
              goto LABEL_58;
            }
            if (*v81 == v43)
              goto LABEL_58;
            if (*v81 < 0)
              break;
            ++v81;
          }
          v42 = 1;
        }
        else
        {
          for (m = 0; ; ++m)
          {
            if (m >= v88)
            {
              v81 = 0;
              goto LABEL_58;
            }
            if (*v81 == v43)
              goto LABEL_58;
            if (*v81 < 0)
              break;
            ++v81;
          }
          v42 = 1;
        }
      }
LABEL_58:
      if (!v81)
      {
        free(v74);
        return 1;
      }
      if (!v42)
      {
        if (v81 >= v44 + 1)
          v83 = *((unsigned __int8 *)v81 - 1);
        v82 = *(unsigned __int8 *)v81;
        v80 = (_DWORD)v81 - (_DWORD)v44;
        if (v88 < 0 || v80 < v88)
          ++v81;
LABEL_121:
        v67 = v70;
        while (v59 >= 0)
        {
          if (!v63 || v67 == v70)
          {
LABEL_283:
            *v84 = v59;
            free(v74);
            return v59 < 0;
          }
LABEL_178:
          if (v88 >= 0)
          {
            if (v80 >= v88)
              goto LABEL_283;
          }
          else if (!v82)
          {
            goto LABEL_283;
          }
          v83 = v82;
          if (v87)
          {
            if (v87 == 1)
            {
              ++v80;
              if (v88 < 0 || v80 < v88)
              {
                v13 = v81++;
                v82 = *(unsigned __int8 *)v13;
              }
              else
              {
                v82 = 0;
              }
            }
            else if (v87 == 2)
            {
              v80 += v79;
              v22 = 0;
              if (v88 >= 0)
                v22 = v80 >= v88;
              if (v22)
              {
                v82 = 0;
                v79 = 1;
              }
              else if (*v81 < 0)
              {
                if (v88 < 0)
                  v34 = 32;
                else
                  v34 = v88 - v80;
                v35 = mbrtowc_l(&v82, v81, v34, &v92, *(locale_t *)(v90 + 56));
                if (v35 >= 0xFFFFFFFFFFFFFFFELL)
                  return 17;
                if (v35 || v88 < 0)
                {
                  v79 = v35;
                  v81 += v35;
                }
                else
                {
                  v79 = 1;
                  v82 = 0;
                  ++v81;
                }
              }
              else
              {
                v15 = v81++;
                v82 = *(unsigned __int8 *)v15;
                v79 = 1;
              }
            }
          }
          else
          {
            ++v80;
            if (v88 < 0 || v80 < v88)
            {
              v14 = v78++;
              v82 = *v14;
            }
            else
            {
              v82 = 0;
            }
          }
          v68 = v71;
          v71 = v70;
          v70 = v68;
          v67 = v68;
          for (n = v71; *(_QWORD *)n; n += 16)
          {
            for (ii = *(_QWORD *)n; *(_QWORD *)(ii + 8); ii += 56)
            {
              if (*(_DWORD *)ii <= v83 && *(_DWORD *)(ii + 4) >= v83)
              {
                if (!*(_DWORD *)(ii + 40))
                  goto LABEL_255;
                if (((*(_DWORD *)(ii + 40) & 1) == 0 || v80 <= 0 && !v77 || v83 == 10 && v75)
                  && ((*(_DWORD *)(ii + 40) & 2) == 0 || !v82 && !v76 || v82 == 10 && v75)
                  && ((*(_DWORD *)(ii + 40) & 8) == 0
                   || v83 != 95
                   && !iswalnum_l(v83, *(locale_t *)(v90 + 56))
                   && (v82 == 95 || iswalnum_l(v82, *(locale_t *)(v90 + 56))))
                  && ((*(_DWORD *)(ii + 40) & 0x10) == 0
                   || (v83 == 95 || iswalnum_l(v83, *(locale_t *)(v90 + 56)))
                   && v82 != 95
                   && !iswalnum_l(v82, *(locale_t *)(v90 + 56))))
                {
                  if ((*(_DWORD *)(ii + 40) & 0x20) == 0 || !v80 || !v82)
                    goto LABEL_244;
                  v21 = 1;
                  if (v83 != 95)
                    v21 = iswalnum_l(v83, *(locale_t *)(v90 + 56)) != 0;
                  v20 = 1;
                  if (v82 != 95)
                    v20 = iswalnum_l(v82, *(locale_t *)(v90 + 56)) != 0;
                  if (v21 != v20)
                  {
LABEL_244:
                    if ((*(_DWORD *)(ii + 40) & 0x40) == 0)
                      goto LABEL_287;
                    if (v80 && v82)
                    {
                      v19 = 1;
                      if (v83 != 95)
                        v19 = iswalnum_l(v83, *(locale_t *)(v90 + 56)) != 0;
                      v18 = 1;
                      if (v82 != 95)
                        v18 = iswalnum_l(v82, *(locale_t *)(v90 + 56)) != 0;
                      if (v19 == v18)
                      {
LABEL_287:
                        if ((*(_DWORD *)(ii + 40) & 4) == 0
                          || tre_bracket_match_0(*(_DWORD **)(ii + 48), v83, v90))
                        {
LABEL_255:
                          j___platform_memmove(v58, *((_QWORD *)n + 1), v55);
                          v65 = *(int **)(ii + 24);
                          if (v65)
                          {
                            while (*v65 >= 0)
                            {
                              if (*v65 < v63)
                                tre_tag_set(v58, *v65, v80, v54);
                              ++v65;
                            }
                            ++v54;
                          }
                          if (!*(_DWORD *)(v90 + 84) || v59 < 0)
                            goto LABEL_269;
                          v33 = 0;
                          for (jj = 0; *(int *)(*(_QWORD *)(v90 + 40) + 4 * jj) >= 0; jj += 2)
                          {
                            if ((int)tre_minimal_tag_order(*(_DWORD *)(*(_QWORD *)(v90 + 40) + 4 * (jj + 1)), *(_DWORD *)(*(_QWORD *)(v90 + 40) + 4 * jj), v86, v58) > 0)
                            {
                              v33 = 1;
                              break;
                            }
                          }
                          if (!v33)
                          {
LABEL_269:
                            if (*(_DWORD *)(v66 + 16 * *(int *)(ii + 16)) >= v80)
                            {
                              if (tre_tag_order(v63, *(_QWORD *)(v90 + 32), v58, **(_QWORD **)(v66 + 16 * *(int *)(ii + 16) + 8)))
                              {
                                v57 = **(_QWORD **)(v66 + 16 * *(int *)(ii + 16) + 8);
                                **(_QWORD **)(v66 + 16 * *(int *)(ii + 16) + 8) = v58;
                                if (*(_QWORD *)(ii + 8) == *(_QWORD *)(v90 + 16))
                                {
                                  v59 = v80;
                                  j___platform_memmove(v86, v58, v55);
                                }
                                v58 = v57;
                              }
                            }
                            else
                            {
                              *(_QWORD *)v67 = *(_QWORD *)(ii + 8);
                              v56 = *((_QWORD *)v67 + 1);
                              *((_QWORD *)v67 + 1) = v58;
                              v58 = v56;
                              *(_DWORD *)(v66 + 16 * *(int *)(ii + 16)) = v80;
                              *(_QWORD *)(v66 + 16 * *(int *)(ii + 16) + 8) = v67 + 8;
                              if (*(_QWORD *)v67 == *(_QWORD *)(v90 + 16))
                              {
                                if (v59 == -1
                                  || v63 > 0
                                  && (v17 = tre_tag_get(*((_QWORD *)v67 + 1), 0), v17 <= (int)tre_tag_get(v86, 0)))
                                {
                                  v59 = v80;
                                  j___platform_memmove(v86, *((_QWORD *)v67 + 1), v55);
                                }
                              }
                              v67 += 16;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          *(_QWORD *)v67 = 0;
        }
        for (kk = *(_QWORD *)(v90 + 8); ; kk += 56)
        {
          while (1)
          {
            if (!*(_QWORD *)(kk + 8))
            {
              *(_QWORD *)v67 = 0;
              goto LABEL_178;
            }
            if (*(_DWORD *)(v66 + 16 * *(int *)(kk + 16)) < v80)
              break;
LABEL_173:
            kk += 56;
          }
          if (!*(_DWORD *)(kk + 40))
            goto LABEL_164;
          if (((*(_DWORD *)(kk + 40) & 1) == 0 || v80 <= 0 && !v77 || v83 == 10 && v75)
            && ((*(_DWORD *)(kk + 40) & 2) == 0 || !v82 && !v76 || v82 == 10 && v75)
            && ((*(_DWORD *)(kk + 40) & 8) == 0
             || v83 != 95
             && !iswalnum_l(v83, *(locale_t *)(v90 + 56))
             && (v82 == 95 || iswalnum_l(v82, *(locale_t *)(v90 + 56))))
            && ((*(_DWORD *)(kk + 40) & 0x10) == 0
             || (v83 == 95 || iswalnum_l(v83, *(locale_t *)(v90 + 56)))
             && v82 != 95
             && !iswalnum_l(v82, *(locale_t *)(v90 + 56))))
          {
            if ((*(_DWORD *)(kk + 40) & 0x20) == 0 || !v80 || !v82)
              goto LABEL_155;
            v26 = 1;
            if (v83 != 95)
              v26 = iswalnum_l(v83, *(locale_t *)(v90 + 56)) != 0;
            v25 = 1;
            if (v82 != 95)
              v25 = iswalnum_l(v82, *(locale_t *)(v90 + 56)) != 0;
            if (v26 != v25)
            {
LABEL_155:
              if ((*(_DWORD *)(kk + 40) & 0x40) == 0)
                goto LABEL_164;
              if (v80 && v82)
              {
                v24 = 1;
                if (v83 != 95)
                  v24 = iswalnum_l(v83, *(locale_t *)(v90 + 56)) != 0;
                v23 = 1;
                if (v82 != 95)
                  v23 = iswalnum_l(v82, *(locale_t *)(v90 + 56)) != 0;
                if (v24 == v23)
                {
LABEL_164:
                  *(_QWORD *)v67 = *(_QWORD *)(kk + 8);
                  _platform_bzero(*((_QWORD *)v67 + 1), v55);
                  v64 = *(int **)(kk + 24);
                  if (v64)
                  {
                    while (*v64 >= 0)
                    {
                      if (*v64 < v63)
                        tre_tag_set(*((_QWORD *)v67 + 1), *v64, v80, v54);
                      ++v64;
                    }
                    ++v54;
                  }
                  if (*(_QWORD *)v67 == *(_QWORD *)(v90 + 16))
                  {
                    v59 = v80;
                    j___platform_memmove(v86, *((_QWORD *)v67 + 1), v55);
                  }
                  *(_DWORD *)(v66 + 16 * *(int *)(kk + 16)) = v80;
                  *(_QWORD *)(v66 + 16 * *(int *)(kk + 16) + 8) = v67 + 8;
                  v67 += 16;
                  goto LABEL_173;
                }
              }
            }
          }
        }
      }
      if (v81 != v44)
      {
        v82 = *((unsigned __int8 *)v81 - 1);
        v80 = (_DWORD)v81 - 1 - (_DWORD)v44;
        v83 = v82;
        if (v87)
        {
          if (v87 == 1)
          {
            v80 = (_DWORD)v81 - (_DWORD)v44;
            if (v88 < 0 || v80 < v88)
            {
              v7 = v81++;
              v82 = *(unsigned __int8 *)v7;
            }
            else
            {
              v82 = 0;
            }
          }
          else if (v87 == 2)
          {
            v80 = (_DWORD)v81 - (_DWORD)v44;
            v28 = 0;
            if (v88 >= 0)
              v28 = v80 >= v88;
            if (v28)
            {
              v82 = 0;
              v79 = 1;
            }
            else if (*v81 < 0)
            {
              if (v88 < 0)
                v38 = 32;
              else
                v38 = v88 - v80;
              v39 = mbrtowc_l(&v82, v81, v38, &v92, *(locale_t *)(v90 + 56));
              if (v39 >= 0xFFFFFFFFFFFFFFFELL)
                return 17;
              if (v39 || v88 < 0)
              {
                v79 = v39;
                v81 += v39;
              }
              else
              {
                v79 = 1;
                v82 = 0;
                ++v81;
              }
            }
            else
            {
              v9 = v81++;
              v82 = *(unsigned __int8 *)v9;
              v79 = 1;
            }
          }
        }
        else
        {
          v80 = (_DWORD)v81 - (_DWORD)v44;
          if (v88 < 0 || v80 < v88)
          {
            v8 = v78++;
            v82 = *v8;
          }
          else
          {
            v82 = 0;
          }
        }
        goto LABEL_121;
      }
    }
    v83 = v82;
    if (v87)
    {
      if (v87 == 1)
      {
        if (v88)
        {
          v10 = v81++;
          v82 = *(unsigned __int8 *)v10;
        }
        else
        {
          v82 = 0;
        }
      }
      else if (v87 == 2)
      {
        v27 = 0;
        if (v88 >= 0)
          v27 = v88 <= 0;
        if (v27)
        {
          v82 = 0;
          v79 = 1;
        }
        else if (*v81 < 0)
        {
          if (v88 < 0)
            v36 = 32;
          else
            v36 = v88;
          v37 = mbrtowc_l(&v82, v81, v36, &v92, *(locale_t *)(v90 + 56));
          if (v37 >= 0xFFFFFFFFFFFFFFFELL)
            return 17;
          if (v37 || v88 < 0)
          {
            v79 = v37;
            v81 += v37;
          }
          else
          {
            v79 = 1;
            v82 = 0;
            ++v81;
          }
        }
        else
        {
          v12 = v81++;
          v82 = *(unsigned __int8 *)v12;
          v79 = 1;
        }
      }
    }
    else if (v88)
    {
      v11 = v78++;
      v82 = *v11;
    }
    else
    {
      v82 = 0;
    }
    v80 = 0;
    goto LABEL_121;
  }
  return 12;
}

uint64_t tre_bracket_match_0(_DWORD *a1, wint_t a2, uint64_t a3)
{
  unint64_t v4;
  _DWORD *v5;
  int v6;
  unsigned int v7;

  v7 = 0;
  if ((*(_DWORD *)(a3 + 96) & 2) != 0)
  {
    if (iswlower_l(a2, *(locale_t *)(a3 + 56)))
    {
      towupper_l(a2, *(locale_t *)(a3 + 56));
    }
    else if (iswupper_l(a2, *(locale_t *)(a3 + 56)))
    {
      towlower_l(a2, *(locale_t *)(a3 + 56));
    }
  }
  v6 = 0;
  v5 = a1 + 2;
  while (v6 < *a1)
  {
    v4 = (*v5 - 1);
    if (v4 <= 4)
      __asm { BR              X8 }
    ++v6;
    v5 += 2;
  }
  if ((a1[1] & 1) == 0)
    return v7;
  if ((*(_DWORD *)(a3 + 96) & 8) == 0 || a2 != 10)
    return 1;
  return 0;
}

uint64_t tre_mem_new_impl(int a1, uint64_t a2)
{
  uint64_t v3;

  if (a1)
  {
    v3 = a2;
    _platform_memset(a2, 0, 48);
  }
  else
  {
    v3 = malloc_type_calloc(1, 48, 0x10B0040729534FELL);
  }
  if (v3)
    return v3;
  else
    return 0;
}

void tre_mem_destroy(void **a1)
{
  void **i;
  void **v2;

  for (i = (void **)*a1; i; i = v2)
  {
    free(*i);
    v2 = (void **)i[1];
    free(i);
  }
  free(a1);
}

uint64_t tre_mem_alloc_impl(uint64_t a1, int a2, uint64_t a3, int a4, unint64_t a5)
{
  unint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v11;

  if (*(_DWORD *)(a1 + 32))
    return 0;
  if (*(_QWORD *)(a1 + 24) < a5)
  {
    if (a2)
    {
      if (!a3)
      {
        *(_DWORD *)(a1 + 32) = 1;
        return 0;
      }
      *(_QWORD *)(a1 + 16) = a3;
      *(_QWORD *)(a1 + 24) = 1024;
    }
    else
    {
      if (8 * a5 <= 0x400)
        v7 = 1024;
      else
        v7 = 8 * a5;
      v8 = (_QWORD *)malloc_type_malloc(16, 0xA0040BD48D6D6);
      if (!v8)
      {
        *(_DWORD *)(a1 + 32) = 1;
        return 0;
      }
      *v8 = malloc_type_malloc(v7, 314679298);
      if (!*v8)
      {
        free(v8);
        *(_DWORD *)(a1 + 32) = 1;
        return 0;
      }
      v8[1] = 0;
      if (*(_QWORD *)(a1 + 8))
        *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) = v8;
      if (!*(_QWORD *)a1)
        *(_QWORD *)a1 = v8;
      *(_QWORD *)(a1 + 8) = v8;
      *(_QWORD *)(a1 + 16) = *v8;
      *(_QWORD *)(a1 + 24) = v7;
    }
  }
  if ((*(_QWORD *)(a1 + 16) + a5) % 8)
    v6 = 8 - (*(_QWORD *)(a1 + 16) + a5) % 8;
  else
    v6 = 0;
  v11 = a5 + v6;
  v9 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v9 + v11;
  *(_QWORD *)(a1 + 24) -= v11;
  if (a4)
    _platform_bzero(v9, v11);
  return v9;
}

uint64_t tre_parse(uint64_t a1)
{
  unint64_t v2;
  BOOL v3;
  int v4;
  uint64_t v5;
  unsigned int v6;

  v5 = *(_QWORD *)(a1 + 8);
  v4 = tre_stack_num_objects(v5);
  if (*(int *)(a1 + 56) > 0)
  {
    if (!*(_DWORD *)(a1 + 88))
    {
      tre_stack_push_int(v5, *(_DWORD *)(a1 + 84));
      tre_stack_push_int(v5, *(_DWORD *)(a1 + 60));
      tre_stack_push_int(v5, 2u);
      ++*(_DWORD *)(a1 + 60);
    }
    tre_stack_push_int(v5, 0);
    v6 = tre_stack_push_int(v5, 0);
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 40) = *(_QWORD *)(a1 + 24) + 4 * *(int *)(a1 + 56);
    while (1)
    {
      v3 = 0;
      if ((int)tre_stack_num_objects(v5) > v4)
        v3 = v6 == 0;
      if (!v3)
        break;
      v2 = tre_stack_pop_int(v5);
      if (v2 <= 9)
        __asm { BR              X8 }
    }
    if (v6)
    {
      return v6;
    }
    else
    {
      *(_QWORD *)(a1 + 16) = 0;
      return 0;
    }
  }
  else
  {
    return 14;
  }
}

uint64_t tre_parse_bound(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  _BOOL4 v6;
  int *v7;
  int v8;
  int v9;
  uint64_t *v10;
  uint64_t v11;

  v11 = a1;
  v10 = a2;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v7 = *(int **)(a1 + 24);
  v6 = (*(_DWORD *)(a1 + 84) & 0x40) != 0;
  v9 = -1;
  if ((unint64_t)v7 < *(_QWORD *)(a1 + 40))
  {
    if (*v7 < 48 || *v7 > 57)
    {
      if ((*(_DWORD *)(v11 + 84) & 1) != 0)
        return 1;
      else
        return 10;
    }
    else
    {
      v9 = tre_parse_int(&v7, *(_QWORD *)(v11 + 40));
      v8 = v9;
      if ((unint64_t)v7 < *(_QWORD *)(v11 + 40) && *v7 == 44)
      {
        ++v7;
        v8 = tre_parse_int(&v7, *(_QWORD *)(v11 + 40));
      }
      if ((v8 < 0 || v9 <= v8) && v9 <= 255 && v8 <= 255)
      {
        if ((unint64_t)v7 < *(_QWORD *)(v11 + 40))
        {
          if (v7 == *(int **)(v11 + 24))
          {
            return 10;
          }
          else
          {
            if ((*(_DWORD *)(v11 + 84) & 1) != 0)
            {
              if ((unint64_t)v7 >= *(_QWORD *)(v11 + 40) || *v7 != 125)
                return 10;
              if ((unint64_t)++v7 < *(_QWORD *)(v11 + 40))
              {
                if (*v7 == 63)
                {
                  if ((*(_DWORD *)(v11 + 84) & 0x100) == 0)
                    return 13;
                  v6 = (*(_DWORD *)(v11 + 84) & 0x40) == 0;
                  ++v7;
                }
                else if (*v7 == 42 || *v7 == 43)
                {
                  return 13;
                }
              }
            }
            else
            {
              if ((unint64_t)(v7 + 1) >= *(_QWORD *)(v11 + 40) || *v7 != 92 || v7[1] != 125)
                return 10;
              v7 += 2;
              if ((unint64_t)v7 < *(_QWORD *)(v11 + 40) && *v7 == 42)
                return 13;
            }
            if (v6)
              ++*(_DWORD *)(v11 + 76);
            if (!v10 || (v4 = tre_ast_new_iter(*(_QWORD *)v11, *v10, v9, v8, v6), (*v10 = v4) != 0))
            {
              *(_QWORD *)(v11 + 24) = v7;
              return 0;
            }
            else
            {
              return 12;
            }
          }
        }
        else
        {
          return 9;
        }
      }
      else
      {
        return 10;
      }
    }
  }
  else if ((*(_DWORD *)(v11 + 84) & 1) != 0)
  {
    return 1;
  }
  else
  {
    return 9;
  }
}

uint64_t tre_parse_bracket(uint64_t a1, _QWORD *a2)
{
  int v2;
  char *v4;
  char *v5;
  char *v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BYTE v12[16];
  uint64_t v13;
  char *v14;
  int v15;
  int v16;
  int v17;
  int v18;
  char *i;
  char *v20;
  char *v21;
  int *v22;
  int v23;
  _DWORD *v24;
  unsigned int v25;
  uint64_t *v26;
  _QWORD *v27;
  uint64_t v28;

  v28 = a1;
  v27 = a2;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 32;
  v22 = 0;
  if ((*(_QWORD *)(v28 + 40) - *(_QWORD *)(v28 + 24)) / 4 >= 6
    && **(_DWORD **)(v28 + 24) == 91
    && *(_DWORD *)(*(_QWORD *)(v28 + 24) + 4) == 58
    && (*(_DWORD *)(*(_QWORD *)(v28 + 24) + 8) == 60 || *(_DWORD *)(*(_QWORD *)(v28 + 24) + 8) == 62)
    && *(_DWORD *)(*(_QWORD *)(v28 + 24) + 12) == 58
    && *(_DWORD *)(*(_QWORD *)(v28 + 24) + 16) == 93
    && *(_DWORD *)(*(_QWORD *)(v28 + 24) + 20) == 93)
  {
    if (*(_DWORD *)(*(_QWORD *)(v28 + 24) + 8) == 60)
      v2 = 8;
    else
      v2 = 16;
    *v27 = tre_ast_new_literal(*(_QWORD *)v28, -2, v2, -1);
    *(_QWORD *)(v28 + 24) += 24;
    if (*v27)
      return 0;
    else
      return 12;
  }
  v24 = (_DWORD *)malloc_type_calloc(1, 8 * v23 + 8, 4294279788);
  if (!v24)
    return 12;
  if (**(_DWORD **)(v28 + 24) == 94)
  {
    v24[1] |= 1u;
    *(_QWORD *)(v28 + 24) += 4;
  }
  v25 = tre_parse_bracket_items(v28, (uint64_t *)&v24, &v23, (void **)&v22);
  if (v25)
  {
LABEL_44:
    free(v24);
    ++*(_DWORD *)(v28 + 68);
    *v27 = v26;
    return v25;
  }
  if (!v22)
  {
    v26 = (uint64_t *)tre_ast_new_literal(*(_QWORD *)v28, 0, 0x7FFFFFFF, *(_DWORD *)(v28 + 68));
    if (v26)
    {
      v8 = *v26;
      *(_QWORD *)(v8 + 16) = tre_mem_alloc_impl(*(_QWORD *)v28, 0, 0, 0, 8 * (int)*v24 + 8);
      if (*(_QWORD *)(v8 + 16))
        j___platform_memmove(*(_QWORD *)(v8 + 16), v24, 8 * (int)*v24 + 8);
      else
        v25 = 12;
    }
    else
    {
      v25 = 12;
    }
    goto LABEL_44;
  }
  v21 = 0;
  v20 = 0;
  i = 0;
  _platform_memset(v12, 0, 128);
  free(v24);
  v21 = (char *)malloc_type_malloc(4 * ((*(_QWORD *)v22 - *(_QWORD *)(v28 + 24)) / 4 + 2), 0x100004052888210);
  if (v21)
  {
    v20 = v21;
    if (v22[2] > 0)
    {
      v4 = v20;
      v20 += 4;
      *(_DWORD *)v4 = 91;
      v11 = *(_QWORD *)(v28 + 24);
      for (i = (char *)(v22 + 4); *(_QWORD *)i; i += 16)
      {
        v9 = (*(_QWORD *)i - v11) / 4 - 2;
        if (v9 > 0)
        {
          j___platform_memmove(v20, v11, 4 * v9);
          v20 += 4 * v9;
        }
        v11 = *(_QWORD *)i + 4 * *((int *)i + 2) + 8;
      }
      v10 = (*(_QWORD *)v22 - v11) / 4;
      j___platform_memmove(v20, v11, 4 * v10);
      v20 += 4 * v10;
      v5 = v20;
      v20 += 4;
      *(_DWORD *)v5 = 124;
    }
    for (i = (char *)(v22 + 4); *(_QWORD *)i; i += 16)
    {
      j___platform_memmove(v20, *(_QWORD *)i, 4 * *((int *)i + 2));
      v20 += 4 * *((int *)i + 2);
      if (*((_QWORD *)i + 2))
      {
        v6 = v20;
        v20 += 4;
        *(_DWORD *)v6 = 124;
      }
    }
    *(_DWORD *)v20 = 0;
    j___platform_memmove(v12, v28, 128);
    v14 = v21;
    v15 = (v20 - v21) / 4;
    v18 = 1;
    v17 |= 1u;
    v25 = tre_parse(v12);
    free(v21);
    if (v25)
    {
      free(v22);
      return v25;
    }
    else
    {
      *(_QWORD *)(v28 + 24) = *(_QWORD *)v22;
      *(_DWORD *)(v28 + 68) = v16;
      free(v22);
      *v27 = v13;
      return 0;
    }
  }
  else
  {
    free(v22);
    return 12;
  }
}

_DWORD *tre_expand_macro(_DWORD *result, unint64_t a2, _DWORD *a3, unint64_t a4)
{
  BOOL v4;
  unsigned int j;
  int i;

  *a3 = 0;
  if ((unint64_t)result < a2)
  {
    for (i = 0; *((_QWORD *)&tre_macros + 2 * i + 1); ++i)
    {
      if (*((char *)&tre_macros + 16 * i) == *result)
      {
        for (j = 0; ; ++j)
        {
          v4 = 0;
          if (*(_BYTE *)(*((_QWORD *)&tre_macros + 2 * i + 1) + j))
            v4 = j < a4;
          if (!v4)
            break;
          a3[j] = *(char *)(*((_QWORD *)&tre_macros + 2 * i + 1) + j);
        }
        a3[j] = 0;
        return result;
      }
    }
  }
  return result;
}

uint64_t tre_parse_int(_DWORD **a1, unint64_t a2)
{
  BOOL v3;
  _DWORD *i;
  int v5;

  v5 = -1;
  for (i = *a1; ; ++i)
  {
    v3 = 0;
    if ((unint64_t)i < a2)
    {
      v3 = 0;
      if ((int)*i >= 48)
        v3 = *i <= 57;
    }
    if (!v3)
      break;
    if (v5 < 0)
      v5 = 0;
    v5 = 10 * v5 + *i - 48;
  }
  *a1 = i;
  return v5;
}

uint64_t tre_parse_bracket_items(uint64_t a1, uint64_t *a2, int *a3, void **a4)
{
  int v4;
  int v5;
  int v6;
  uint64_t v8;
  __int32 v9;
  __int32 v10;
  int v11;
  int v12;
  __int32 *v13;
  size_t v14;
  int v15;
  __int32 v16;
  char *v17;
  int v18;
  __int32 *v19;
  int v20;
  int v21;
  __int32 v22;
  __int32 v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  int v28;
  char *v29;
  void *v30;
  unint64_t v31;
  __int32 *v32;
  void **v33;
  int *v34;
  uint64_t *v35;
  uint64_t *v36;
  mbstate_t v38;
  __int32 v39[64];
  char v40[64];

  v36 = (uint64_t *)a1;
  v35 = a2;
  v34 = a3;
  v33 = a4;
  v32 = 0;
  v32 = *(__int32 **)(a1 + 24);
  v31 = 0;
  v31 = *(_QWORD *)(a1 + 40);
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 0;
  v26 = 0;
  v26 = *a3;
  v25 = 0;
  v24 = -1;
  v23 = 0;
  v22 = 0;
  v21 = 0;
  v21 = *(_DWORD *)(*a2 + 4) & 1;
  v20 = 0;
  v19 = 0;
  while (1)
  {
    if ((unint64_t)v32 >= v31)
    {
      v27 = 7;
      goto LABEL_117;
    }
    v10 = *v32;
    if (*v32 == 45)
    {
      if (v32 == (__int32 *)v36[3])
      {
        v23 = 45;
        ++v25;
        v24 = 0;
        goto LABEL_115;
      }
      if (v24 > 0)
      {
        v22 = 45;
        goto LABEL_103;
      }
      if ((unint64_t)(v32 + 1) >= v31)
      {
        v27 = 7;
        goto LABEL_117;
      }
      if (v32[1] == 93)
      {
        v22 = 45;
        goto LABEL_109;
      }
      if (v24 < 0)
      {
        v27 = 11;
        goto LABEL_117;
      }
      v24 = 1;
      goto LABEL_115;
    }
    if (v10 != 91)
    {
      if (v10 != 93)
      {
        v22 = *v32;
        goto LABEL_102;
      }
      if (v32 != (__int32 *)v36[3])
      {
        if (v20)
        {
          if (v30)
          {
            *(_QWORD *)v30 = v32 + 1;
            *((_DWORD *)v30 + 2) = v25;
            *(_QWORD *)v29 = 0;
          }
          *v33 = v30;
          return 0;
        }
        else
        {
          if (!v24)
          {
            v27 = tre_new_item(*v36, 1, v23, &v26, v35);
            if (v27)
              goto LABEL_117;
          }
          *v34 = v26;
          v36[3] = (uint64_t)(v32 + 1);
          return 0;
        }
      }
      v23 = 93;
      v24 = 0;
      ++v25;
      goto LABEL_115;
    }
    if ((unint64_t)(v32 + 1) >= v31)
    {
      v27 = 7;
      goto LABEL_117;
    }
    v9 = v32[1];
    if (v9 != 46)
      break;
    v32 += 2;
    v19 = v32;
    while (1)
    {
      if ((unint64_t)v32 >= v31)
      {
        v27 = 3;
        goto LABEL_117;
      }
      if (*v32 == 46)
      {
        if ((unint64_t)(v32 + 1) >= v31)
        {
          v27 = 3;
          goto LABEL_117;
        }
        if (v32[1] == 93)
          break;
      }
      ++v32;
    }
    if (v32 == v19)
    {
      v27 = 3;
      goto LABEL_117;
    }
    v22 = tre_search_cnames(v19, v32 - v19);
    if (v22 != -1)
    {
      ++v32;
      goto LABEL_102;
    }
    if ((int)__collate_equiv_value(v36[6], v19, v32 - v19) <= 0)
    {
      v27 = 3;
      goto LABEL_117;
    }
    if (v32 - v19 == 1)
    {
      v22 = *v19;
      ++v32;
LABEL_102:
      if (v24 <= 0)
      {
LABEL_109:
        if (!v20)
        {
          if (!v24)
          {
            v27 = tre_new_item(*v36, 1, v23, &v26, v35);
            if (v27)
              goto LABEL_117;
          }
          v23 = v22;
        }
        v24 = 0;
      }
      else
      {
LABEL_103:
        v12 = __collate_equiv_value(v36[6], &v23, 1uLL);
        v11 = __collate_equiv_value(v36[6], &v22, 1uLL);
        if (v11 < v12)
        {
          v27 = 11;
          goto LABEL_117;
        }
        if (!v20)
        {
          v27 = tre_new_item(*v36, 2, v12, &v26, v35);
          if (v27)
            goto LABEL_117;
          v27 = tre_new_item(*v36, 3, v11, &v26, v35);
          if (v27)
            goto LABEL_117;
        }
        v24 = -1;
      }
      ++v25;
      goto LABEL_115;
    }
    if (v21)
    {
      v27 = 3;
      goto LABEL_117;
    }
    if (v24 > 0)
    {
      v27 = 11;
      goto LABEL_117;
    }
    v24 = -1;
    v20 = 1;
    if (!v29)
    {
      v30 = (void *)malloc_type_malloc(288, 0x1050040DB1D6C16);
      if (!v30)
        return 12;
      v29 = (char *)v30 + 16;
      v28 = 16;
    }
    if ((v29 - (_BYTE *)v30) / 16 - 1 >= v28)
    {
      v18 = v28;
      v17 = 0;
      v28 *= 2;
      v17 = (char *)malloc_type_realloc(v30, 16 * (v28 + 2), 0x1050040DB1D6C16);
      if (!v17)
      {
        free(v30);
        return 12;
      }
      v30 = v17;
      v29 = &v17[16 * v18 + 16];
    }
    *(_QWORD *)v29 = v19;
    *((_DWORD *)v29 + 2) = v32 - v19;
    v29 += 16;
    ++v32;
LABEL_115:
    ++v32;
  }
  if (v9 != 58 && v9 != 61)
  {
    v22 = 91;
    goto LABEL_102;
  }
  v16 = 0;
  v16 = v32[1];
  if (v24 > 0)
  {
    v27 = 11;
    goto LABEL_117;
  }
  if (v20 || v24 || (v27 = tre_new_item(*v36, 1, v23, &v26, v35)) == 0)
  {
    v24 = -1;
    v32 += 2;
    v19 = v32;
    while (1)
    {
      if ((unint64_t)v32 >= v31)
      {
        if (v16 == 61)
          v4 = 3;
        else
          v4 = 4;
        v27 = v4;
        goto LABEL_117;
      }
      if (*v32 == v16)
      {
        if ((unint64_t)(v32 + 1) >= v31)
        {
          if (v16 == 61)
            v5 = 3;
          else
            v5 = 4;
          v27 = v5;
          goto LABEL_117;
        }
        if (v32[1] == 93)
          break;
      }
      ++v32;
    }
    if (v32 == v19)
    {
      if (v16 == 61)
        v6 = 3;
      else
        v6 = 4;
      v27 = v6;
      goto LABEL_117;
    }
    if (v16 == 61)
    {
      v15 = 0;
      v15 = __collate_equiv_value(v36[6], v19, v32 - v19);
      if (v15 <= 0)
      {
        v22 = tre_search_cnames(v19, v32 - v19);
        if (v22 != -1)
        {
          ++v32;
          goto LABEL_102;
        }
        v27 = 3;
        goto LABEL_117;
      }
      if (!v20)
      {
        v27 = tre_new_item(*v36, 5, v15, &v26, v35);
        if (v27)
          goto LABEL_117;
      }
LABEL_91:
      ++v32;
      ++v25;
      goto LABEL_115;
    }
    if (v20)
      goto LABEL_91;
    v14 = 0;
    if (v32 - v19 > 63)
      LODWORD(v8) = 63;
    else
      v8 = v32 - v19;
    LODWORD(v14) = v8;
    wcsncpy(v39, v19, (int)v8);
    v39[(int)v14] = 0;
    _platform_memset(&v38, 0, 128);
    v13 = v39;
    _platform_memset(&v38, 0, 128);
    LODWORD(v14) = wcsrtombs_l(v40, (const __int32 **)&v13, 0x40uLL, &v38, (locale_t)v36[6]);
    v40[(int)v14] = 0;
    HIDWORD(v14) = wctype_l(v40, (locale_t)v36[6]);
    if (!HIDWORD(v14))
    {
      v27 = 4;
      goto LABEL_117;
    }
    v27 = tre_new_item(*v36, 4, SHIDWORD(v14), &v26, v35);
    if (!v27)
      goto LABEL_91;
  }
LABEL_117:
  if (v30)
    free(v30);
  return v27;
}

uint64_t tre_search_cnames(const __int32 *a1, size_t a2)
{
  int v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v6 = 0;
  v5 = 95;
  while (v6 <= v5)
  {
    v4 = (v6 + v5) / 2;
    v3 = wcsncmp(a1, (const __int32 *)*(&cnames + 2 * v4), a2);
    if (!v3 && !*((_DWORD *)*(&cnames + 2 * v4) + a2))
      return *((_DWORD *)&cnames + 4 * v4 + 2);
    if (v3 <= 0)
      v5 = v4 - 1;
    else
      v6 = v4 + 1;
  }
  return -1;
}

uint64_t tre_new_item(uint64_t a1, int a2, int a3, int *a4, uint64_t *a5)
{
  uint64_t v6;
  int v7;
  _DWORD *v8;

  v8 = (_DWORD *)*a5;
  v7 = *(_DWORD *)*a5;
  if (v7 < *a4)
    goto LABEL_7;
  if (*a4 < 1024)
  {
    *a4 *= 2;
    v6 = malloc_type_realloc(v8, 8 * *a4 + 8, 1746782517);
    if (!v6)
      return 12;
    v8 = (_DWORD *)v6;
    *a5 = v6;
LABEL_7:
    v8[2 * v7 + 2] = a2;
    v8[2 * v7 + 3] = a3;
    ++*v8;
    return 0;
  }
  return 12;
}

_QWORD *tre_stack_new(int a1, int a2, int a3)
{
  _QWORD *v4;

  v4 = (_QWORD *)malloc_type_malloc(24, 0x10200403ED2C137);
  if (!v4)
    return v4;
  v4[2] = malloc_type_malloc(8 * a1, 0x108204023715A0ELL);
  if (v4[2])
  {
    *(_DWORD *)v4 = a1;
    *((_DWORD *)v4 + 1) = a2;
    *((_DWORD *)v4 + 2) = a3;
    *((_DWORD *)v4 + 3) = 0;
    return v4;
  }
  free(v4);
  return 0;
}

void tre_stack_destroy(void **a1)
{
  free(a1[2]);
  free(a1);
}

uint64_t tre_stack_num_objects(uint64_t a1)
{
  return *(unsigned int *)(a1 + 12);
}

uint64_t tre_stack_push_int(uint64_t a1, unsigned int a2)
{
  return tre_stack_push(a1, a2);
}

uint64_t tre_stack_push(uint64_t a1, uint64_t a2)
{
  _BYTE v3[12];

  if (*(_DWORD *)(a1 + 12) < *(_DWORD *)a1)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * (int)(*(_DWORD *)(a1 + 12))++) = a2;
    return 0;
  }
  if (*(_DWORD *)a1 < *(_DWORD *)(a1 + 4))
  {
    *(_QWORD *)v3 = (*(_DWORD *)a1 + *(_DWORD *)(a1 + 8));
    if (*(int *)v3 > *(_DWORD *)(a1 + 4))
      *(_DWORD *)v3 = *(_DWORD *)(a1 + 4);
    *(_QWORD *)&v3[4] = malloc_type_realloc(*(_QWORD *)(a1 + 16), 8 * *(int *)v3, 0x108204023715A0ELL);
    if (*(_QWORD *)&v3[4])
    {
      *(_DWORD *)a1 = *(_DWORD *)v3;
      *(_QWORD *)(a1 + 16) = *(_QWORD *)&v3[4];
      tre_stack_push(a1, a2);
      return 0;
    }
    return 12;
  }
  else
  {
    return 12;
  }
}

uint64_t tre_stack_push_voidptr(uint64_t a1, uint64_t a2)
{
  return tre_stack_push(a1, a2);
}

uint64_t tre_stack_pop_int(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 12) - 1;
  *(_DWORD *)(a1 + 12) = v2;
  return *(unsigned int *)(v1 + 8 * v2);
}

uint64_t tre_stack_pop_voidptr(uint64_t a1)
{
  uint64_t v1;
  int v2;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 12) - 1;
  *(_DWORD *)(a1 + 12) = v2;
  return *(_QWORD *)(v1 + 8 * v2);
}

int creat(const char *a1, mode_t a2)
{
  return __open(a1, 1537, a2);
}

int sigpause(int a1)
{
  int v2;
  sigset_t v3;
  int v4;
  int v6;

  v4 = a1;
  v3 = 0;
  if (!__unix_conforming)
    __unix_conforming = 1;
  pthread_testcancel();
  if (v4 > 0 && v4 < 32)
  {
    if (sigprocmask(1, 0, &v3) >= 0)
    {
      v6 = v4;
      if (v4 <= 32)
        v2 = 1 << (v6 - 1);
      else
        v2 = 0;
      v3 &= ~v2;
      return sigsuspend_NOCANCEL(&v3);
    }
    else
    {
      return -1;
    }
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

int lockf(int a1, int a2, off_t a3)
{
  if (a2 <= 3uLL)
    __asm { BR              X8 }
  *__error() = 22;
  return -1;
}

int pause(void)
{
  sigset_t v1;

  v1 = 0;
  sigprocmask(0, 0, &v1);
  return sigsuspend(&v1);
}

unsigned int sleep(unsigned int a1)
{
  timespec __rmtp;
  timespec __rqtp;
  unsigned int v4;

  v4 = a1;
  __rqtp.tv_sec = 0;
  __rqtp.tv_nsec = 0;
  __rmtp.tv_sec = 0;
  __rmtp.tv_nsec = 0;
  if (a1 > 0x7FFFFFFF)
    return v4 - 0x7FFFFFFF + sleep(0x7FFFFFFFu);
  __rqtp.tv_sec = v4;
  __rqtp.tv_nsec = 0;
  if (nanosleep(&__rqtp, &__rmtp) != -1)
    return 0;
  if (*__error() == 4)
    return LODWORD(__rmtp.tv_sec) + (__rmtp.tv_nsec != 0);
  return v4;
}

int tcdrain(int a1)
{
  pthread_testcancel();
  return ioctl(a1, 0x2000745EuLL, 0);
}

int usleep(useconds_t a1)
{
  timespec __rqtp;
  useconds_t v3;

  v3 = a1;
  __rqtp.tv_nsec = 1000 * (a1 % 0xF4240);
  __rqtp.tv_sec = a1 / 0xF4240;
  return nanosleep(&__rqtp, 0);
}

pid_t wait(int *a1)
{
  return __wait4(0xFFFFFFFFLL, a1, 0, 0);
}

pid_t waitpid(pid_t a1, int *a2, int a3)
{
  if ((a3 & 0x13) == a3)
    return __wait4(a1, a2, a3, 0);
  *__error() = 22;
  return -1;
}

int nanosleep(const timespec *__rqtp, timespec *__rmtp)
{
  char *v2;
  char *v3;
  uint64_t v4;
  timespec *v5;
  uint64_t v7;
  uint64_t v8;
  FILE *v9;
  FILE *v10;
  mach_timespec_t cur_time;
  mach_timespec_t v12;
  mach_error_t time;
  mach_error_t v14;
  timespec *v15;
  const timespec *v16;

  v16 = __rqtp;
  v15 = __rmtp;
  v14 = 0;
  time = 0;
  v12 = 0;
  cur_time = 0;
  if (!__unix_conforming)
    __unix_conforming = 1;
  pthread_testcancel();
  if (v16 && v16->tv_sec >= 0 && v16->tv_nsec < 0x3B9ACA00uLL)
  {
    if (!v15 || (v14 = clock_get_time(clock_port, &cur_time)) == 0)
    {
      time = __semwait_signal(clock_sem, 0, 1, 1, v16->tv_sec, v16->tv_nsec);
      if (time < 0)
      {
        if (*__error() == 60)
          return 0;
        if (*__error() == 4)
        {
          if (v15)
          {
            time = clock_get_time(clock_port, &v12);
            if (time)
            {
              v9 = __stderrp;
              v3 = mach_error_string(time);
              fprintf(v9, "clock_get_time() failed: %s\n", v3);
              return -1;
            }
            v4 = cur_time.tv_nsec + v16->tv_nsec;
            cur_time.tv_nsec += LODWORD(v16->tv_nsec);
            if ((int)v4 >= 1000000000)
            {
              cur_time.tv_nsec -= 1000000000;
              ++cur_time.tv_sec;
            }
            cur_time.tv_sec += v16->tv_sec;
            if (cur_time.tv_sec <= v12.tv_sec)
            {
              if (cur_time.tv_sec >= v12.tv_sec)
                v7 = cur_time.tv_nsec - v12.tv_nsec;
              else
                v7 = -1000000000;
              v8 = v7;
            }
            else
            {
              v8 = 1000000000;
            }
            if (v8 <= 0)
            {
              v5 = v15;
              v15->tv_sec = 0;
              v5->tv_nsec = 0;
            }
            else
            {
              cur_time.tv_nsec -= v12.tv_nsec;
              if (cur_time.tv_nsec < 0)
              {
                cur_time.tv_nsec += 1000000000;
                --cur_time.tv_sec;
              }
              cur_time.tv_sec -= v12.tv_sec;
              v15->tv_sec = cur_time.tv_sec;
              v15->tv_nsec = cur_time.tv_nsec;
            }
          }
        }
        else
        {
          *__error() = 22;
        }
      }
      return -1;
    }
    v10 = __stderrp;
    v2 = mach_error_string(v14);
    fprintf(v10, "clock_get_time() failed: %s\n", v2);
    *__error() = 22;
    return -1;
  }
  else
  {
    *__error() = 22;
    return -1;
  }
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return __recvfrom(a1, a2, a3, a4, 0);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return __sendto(a1, a2, a3, a4, 0, 0);
}

int system(const char *a1)
{
  char ***v1;
  BOOL v3;
  int v4;
  __int16 v5;
  posix_spawnattr_t v6;
  sigset_t v7;
  sigset_t v8;
  sigset_t v9;
  sigaction v10;
  sigaction v11;
  sigaction v12;
  int v13;
  int v14;
  pid_t v15;
  pid_t v16;
  const char *v17;
  int v19;
  int v20;
  int v21;
  char *__argv[2];
  const char *v23;
  uint64_t v24;

  v17 = a1;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  v12.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v12.sa_mask = 0;
  v11.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v11.sa_mask = 0;
  v10.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v10.sa_mask = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v6 = 0;
  v5 = 8;
  __argv[0] = "sh";
  __argv[1] = "-c";
  v23 = a1;
  v24 = 0;
  if (!__unix_conforming)
    __unix_conforming = 1;
  pthread_testcancel();
  if (!v17)
    return access("/bin/sh", 0) != -1;
  v13 = posix_spawnattr_init(&v6);
  if (v13)
  {
    v4 = v13;
    *__error() = v4;
    return -1;
  }
  else
  {
    v7 = 0;
    pthread_mutex_lock(&__systemfn_mutex_0);
    v12.__sigaction_u.__sa_handler = (void (__cdecl *)(int))(&dword_0 + 1);
    v12.sa_mask = 0;
    v12.sa_flags = 0;
    sigaction(2, &v12, &v11);
    if (v11.__sigaction_u.__sa_handler != (void (__cdecl *)(int))((char *)&dword_0 + 1))
    {
      v21 = 2;
      v7 |= 2u;
      v5 = 12;
    }
    sigaction(3, &v12, &v10);
    if (v10.__sigaction_u.__sa_handler != (void (__cdecl *)(int))((char *)&dword_0 + 1))
    {
      v20 = 3;
      v7 |= 4u;
      v5 |= 4u;
    }
    v19 = 20;
    v9 = 0x80000;
    sigprocmask(1, &v9, &v8);
    posix_spawnattr_setsigmask(&v6, &v8);
    if ((v5 & 4) != 0)
      posix_spawnattr_setsigdefault(&v6, &v7);
    posix_spawnattr_setflags(&v6, v5);
    v1 = _NSGetEnviron();
    v13 = posix_spawn(&v16, "/bin/sh", 0, &v6, __argv, *v1);
    posix_spawnattr_destroy(&v6);
    if (v13)
    {
      if (v13 == 12 || v13 == 35)
        v14 = -1;
      else
        v14 = 32512;
    }
    else
    {
      v15 = v16;
      do
      {
        v16 = wait4(v15, &v14, 0, 0);
        v3 = 0;
        if (v16 == -1)
          v3 = *__error() == 4;
      }
      while (v3);
      if (v16 == -1)
        v14 = -1;
    }
    sigaction(2, &v11, 0);
    sigaction(3, &v10, 0);
    sigprocmask(3, &v8, 0);
    pthread_mutex_unlock(&__systemfn_mutex_0);
    return v14;
  }
}

FILE *popen_DARWIN_EXTSN(uint64_t a1, char *a2)
{
  char ***v2;
  int v4;
  posix_spawn_file_actions_t v5;
  uint64_t i;
  unsigned int v7;
  int v8;
  pid_t v9;
  FILE *v10;
  _QWORD *v11;
  char *v12;
  uint64_t v13;
  __int128 v15;
  __int128 v16;
  int v17;
  unsigned int v18;

  v13 = a1;
  v12 = a2;
  v11 = 0;
  v10 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v15 = 0u;
  v16 = 0u;
  i = 0;
  v5 = 0;
  libc_hooks_will_read_cstring(a1);
  libc_hooks_will_read_cstring((uint64_t)v12);
  if (!v12)
  {
LABEL_2:
    *__error() = 22;
    return 0;
  }
  if (_platform_strcmp(v12, "r+"))
  {
    v8 = 0;
    if (*v12 != 114 && *v12 != 119 || v12[1])
      goto LABEL_2;
    if (pipe(&v17) < 0)
      return 0;
  }
  else
  {
    v8 = 1;
    v12 = "r+";
    if (socketpair(1, 1, 0, &v17) < 0)
      return 0;
  }
  if (*v12 == 114)
  {
    v10 = (FILE *)fdopen_DARWIN_EXTSN(v17, v12);
    v7 = v18;
  }
  else
  {
    v10 = (FILE *)fdopen_DARWIN_EXTSN(v18, v12);
    v7 = v17;
  }
  if (v10)
  {
    v11 = (_QWORD *)malloc_type_malloc(24, 0x102004062D53EE8);
    if (v11)
    {
      v4 = posix_spawn_file_actions_init(&v5);
      if (v4)
        goto LABEL_21;
      if (*v12 == 114)
      {
        posix_spawn_file_actions_addclose(&v5, v17);
        if (v18 == 1)
        {
          if (v8)
            posix_spawn_file_actions_adddup2(&v5, v18, 0);
        }
        else
        {
          posix_spawn_file_actions_adddup2(&v5, v18, 1);
          posix_spawn_file_actions_addclose(&v5, v18);
          if (v8)
            posix_spawn_file_actions_adddup2(&v5, 1, 0);
        }
      }
      else
      {
        if (v17)
        {
          posix_spawn_file_actions_adddup2(&v5, v17, 0);
          posix_spawn_file_actions_addclose(&v5, v17);
        }
        posix_spawn_file_actions_addclose(&v5, v18);
      }
      pthread_mutex_lock(&__popen_pidlist_mutex);
      for (i = __popen_pidlist; i; i = *(_QWORD *)i)
        posix_spawn_file_actions_addclose(&v5, *(_DWORD *)(i + 16));
      *(_QWORD *)&v15 = "sh";
      *((_QWORD *)&v15 + 1) = "-c";
      v16 = (unint64_t)v13;
      v2 = _NSGetEnviron();
      v4 = posix_spawn(&v9, "/bin/sh", &v5, 0, (char *const *)&v15, *v2);
      pthread_mutex_unlock(&__popen_pidlist_mutex);
      posix_spawn_file_actions_destroy(&v5);
      if (v4 == 12 || v4 == 35)
      {
LABEL_21:
        fclose(v10);
        close_NOCANCEL(v7);
        free(v11);
        *__error() = v4;
        return 0;
      }
      else
      {
        if (v4)
          v9 = -1;
        if (*v12 == 114)
        {
          *((_DWORD *)v11 + 4) = v17;
          close_NOCANCEL(v18);
        }
        else
        {
          *((_DWORD *)v11 + 4) = v18;
          close_NOCANCEL(v17);
        }
        v11[1] = v10;
        *((_DWORD *)v11 + 5) = v9;
        pthread_mutex_lock(&__popen_pidlist_mutex);
        *v11 = __popen_pidlist;
        __popen_pidlist = (uint64_t)v11;
        pthread_mutex_unlock(&__popen_pidlist_mutex);
        fwide(v10, -1);
        return v10;
      }
    }
    else
    {
      fclose(v10);
      close_NOCANCEL(v7);
      return 0;
    }
  }
  else
  {
    close_NOCANCEL(v17);
    close_NOCANCEL(v18);
    return 0;
  }
}

uint64_t *fdopen_DARWIN_EXTSN(int a1, char *a2)
{
  int v3;
  int v4;
  int v5;
  uint64_t *v6;
  char *v7;
  int v8;

  v8 = a1;
  v7 = a2;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  libc_hooks_will_read_cstring((uint64_t)a2);
  if (v8 < 0x8000)
  {
    v5 = __sflags(v7, &v4);
    if (v5)
    {
      v3 = fcntl_NOCANCEL(v8, 3);
      if (v3 >= 0)
      {
        if ((v3 & 3) == 2 || (v3 & 3) == (v4 & 3))
        {
          v6 = __sfp(0);
          if (v6)
          {
            *((_WORD *)v6 + 8) = v5;
            if ((v4 & 8) != 0 && (v3 & 8) == 0)
              *((_WORD *)v6 + 8) |= 0x100u;
            *((_WORD *)v6 + 9) = v8;
            v6[6] = (uint64_t)v6;
            v6[8] = (uint64_t)__sread;
            v6[10] = (uint64_t)__swrite;
            v6[9] = (uint64_t)__sseek;
            v6[7] = (uint64_t)__sclose;
            return v6;
          }
          else
          {
            return 0;
          }
        }
        else
        {
          *__error() = 22;
          return 0;
        }
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *__error() = 24;
    return 0;
  }
}

uint64_t *fopen_DARWIN_EXTSN(uint64_t a1, char *a2)
{
  unsigned int v3;
  int v4;
  int v5;
  uint64_t *v6;
  char *v7;
  uint64_t v8;

  v8 = a1;
  v7 = a2;
  v6 = 0;
  v5 = 0;
  v4 = 0;
  v3 = 0;
  libc_hooks_will_read_cstring(a1);
  libc_hooks_will_read_cstring((uint64_t)v7);
  v4 = __sflags(v7, (int *)&v3);
  if (!v4)
    return 0;
  v6 = __sfp(0);
  if (!v6)
    return 0;
  v5 = open_NOCANCEL(v8, v3);
  if (v5 >= 0)
  {
    if (v5 < 0x8000)
    {
      *((_WORD *)v6 + 9) = v5;
      *((_WORD *)v6 + 8) = v4;
      v6[6] = (uint64_t)v6;
      v6[8] = (uint64_t)__sread;
      v6[10] = (uint64_t)__swrite;
      v6[9] = (uint64_t)__sseek;
      v6[7] = (uint64_t)__sclose;
      if ((v3 & 8) != 0)
        _sseek((uint64_t)v6, 0, 2u);
      return v6;
    }
    else
    {
      *((_WORD *)v6 + 8) = 0;
      close_NOCANCEL(v5);
      *__error() = 24;
      return 0;
    }
  }
  else
  {
    __sfprelease((uint64_t)v6);
    return 0;
  }
}

char *__cdecl realpath_DARWIN_EXTSN(const char *a1, char *a2)
{
  unint64_t v2;
  unsigned int v3;
  unint64_t v5;
  int v6;
  char *v7;
  int v8;
  char *__s;
  __darwin_ino64_t st_ino;
  dev_t st_dev;
  dev_t v12;
  ssize_t v13;
  _BOOL4 v14;
  int v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  uint64_t v22;
  stat v23;
  char *v24;
  const char *v25;
  char v27[1024];
  statfs v28;
  char v29[1024];
  _BYTE v30[1024];
  _BYTE v31[1024];
  _BYTE v32[4];
  _DWORD v33[262];

  v25 = a1;
  v24 = a2;
  _platform_bzero(v32, 512);
  _platform_memset(&v23, 0, 144);
  v14 = 0;
  v12 = 0;
  _platform_bzero(&v28, 512);
  st_ino = 0;
  if (!v25)
  {
    *__error() = 22;
    return 0;
  }
  if (!*v25)
  {
    *__error() = 2;
    return 0;
  }
  if (v24)
  {
    __s = v24;
  }
  else
  {
    __s = (char *)malloc_type_malloc(1024, 772935998);
    if (!__s)
      return 0;
  }
  if (!realpath_DARWIN_EXTSN_rootdev_inited)
  {
    realpath_DARWIN_EXTSN_rootdev_inited = 1;
    if (stat("/", &v23) < 0)
      goto LABEL_12;
    realpath_DARWIN_EXTSN_rootdev = v23.st_dev;
  }
  __error();
  v16 = 0;
  if (*v25 == 47)
  {
    *__s = 47;
    __s[1] = 0;
    if (!v25[1])
      return __s;
    v18 = 1;
    v19 = _platform_strlcpy(v31, v25 + 1, 1024);
  }
  else
  {
    if (!__private_getcwd(__s, 1024, 1))
    {
      _platform_strlcpy(__s, ".", 1024);
      goto LABEL_12;
    }
    v18 = _platform_strlen(__s);
    v19 = _platform_strlcpy(v31, v25, 1024);
  }
  if (v19 < 0x400 && v18 < 0x400)
  {
    if (v18 > 1)
    {
      if (stat(__s, &v23) >= 0)
      {
        st_dev = v23.st_dev;
        goto LABEL_30;
      }
      goto LABEL_12;
    }
    st_dev = realpath_DARWIN_EXTSN_rootdev;
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            do
            {
LABEL_30:
              if (!v19)
              {
                if (v18 > 1 && __s[v18 - 1] == 47)
                  __s[v18 - 1] = 0;
                return __s;
              }
              v22 = _platform_strchr(v31, 47);
              if (v22)
                v5 = v22 - (_QWORD)v31;
              else
                v5 = v19;
              j___platform_memmove(v30, v31, v5);
              v30[v5] = 0;
              if (v22)
              {
                v19 -= v5 + 1;
                _platform_memmove(v31, v22 + 1, v19 + 1);
              }
              else
              {
                v31[0] = 0;
                v19 = 0;
              }
              if (__s[v18 - 1] != 47)
              {
                if (v18 + 1 >= 0x400)
                  goto LABEL_93;
                v2 = v18++;
                __s[v2] = 47;
                __s[v18] = 0;
              }
            }
            while (!v30[0] || !_platform_strcmp(v30, "."));
            if (_platform_strcmp(v30, ".."))
              break;
            if (v18 > 1)
            {
              __s[v18 - 1] = 0;
              v20 = strrchr(__s, 47) + 1;
              *v20 = 0;
              v18 = v20 - __s;
            }
          }
          v17 = v18;
          v18 = _platform_strlcat(__s, v30, 1024);
          if (v18 >= 0x400)
            goto LABEL_93;
          if (getattrlist(__s, &_rp_alist, v32, 0x41CuLL, 1u))
          {
            if (*__error() == 45 || *__error() == 22)
            {
              v15 = lstat(__s, &v23);
              if (!v15)
              {
                v14 = (v23.st_mode & 0xF000) == 40960;
                v12 = v23.st_dev;
                st_ino = v23.st_ino;
              }
            }
            else
            {
              v15 = -1;
            }
          }
          else
          {
            v15 = 1;
            v14 = v33[3] == 5;
            v12 = v33[2];
            st_ino = v33[4];
          }
          if (v15 < 0)
            goto LABEL_12;
          if (v12 == st_dev)
            break;
          st_dev = v12;
          if (statfs(__s, &v28) || lstat(v28.f_mntonname, &v23) || v12 != v23.st_dev || st_ino != v23.st_ino)
            break;
          v6 = 1;
          _platform_strcpy(v27, v28.f_mntonname);
          do
          {
            v7 = strrchr(v27, 47);
            if (!v7)
            {
              v6 = 0;
              goto LABEL_70;
            }
            if (v7 <= v27)
              goto LABEL_70;
            *v7 = 0;
          }
          while (lstat(v27, &v23) >= 0 && (v23.st_mode & 0xF000) == 0x4000);
          v6 = 0;
LABEL_70:
          if (!v6)
            break;
          v18 = _platform_strlcpy(__s, v28.f_mntonname, 1024);
        }
        if (v14)
          break;
        if (v15)
        {
          __s[v17] = 0;
          v18 = _platform_strlcat(__s, (char *)v33 + v33[0], 1024);
          if (v18 >= 0x400)
            goto LABEL_93;
        }
      }
      v3 = v16++;
      if (v3 > 0x20)
      {
        *__error() = 62;
        goto LABEL_12;
      }
      v13 = readlink(__s, v29, 0x400uLL);
      if (v13 <= 0 || (unint64_t)v13 >= 0x400)
        break;
      v29[v13] = 0;
      if (v29[0] == 47)
      {
        __s[1] = 0;
        v18 = 1;
        st_dev = realpath_DARWIN_EXTSN_rootdev;
      }
      else
      {
        v21 = strrchr(__s, 47) + 1;
        *v21 = 0;
        v18 = v21 - __s;
      }
      if (v22)
      {
        if (v29[v13 - 1] != 47)
        {
          if ((unint64_t)(v13 + 1) >= 0x400)
            goto LABEL_93;
          v29[v13] = 47;
          v29[v13 + 1] = 0;
        }
        if ((unint64_t)_platform_strlcat(v29, v31, 1024) >= 0x400)
          goto LABEL_93;
      }
      v19 = _platform_strlcpy(v31, v29, 1024);
    }
    if (v13 < 0)
      goto LABEL_12;
    if (!v13)
    {
      *__error() = 2;
      goto LABEL_12;
    }
  }
LABEL_93:
  *__error() = 63;
LABEL_12:
  if (!v24)
  {
    v8 = *__error();
    free(__s);
    *__error() = v8;
  }
  return 0;
}

unint64_t __strlcat_chk(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v5;
  unint64_t v6;

  if (a4 < a3)
    __chk_fail_overflow();
  v6 = _platform_strlen(a2);
  v5 = _platform_strnlen(a1, a3);
  if (v5 == a3)
    return a3 + v6;
  if (v6 >= a3 - v5)
  {
    __chk_overlap(a1, a3, a2, a3 - v5 - 1);
    j___platform_memmove(a1 + v5, a2, a3 - v5 - 1);
    *(_BYTE *)(a1 + a3 - 1) = 0;
  }
  else
  {
    __chk_overlap(a1, v6 + v5 + 1, a2, v6 + 1);
    j___platform_memmove(a1 + v5, a2, v6 + 1);
  }
  return v6 + v5;
}

void __chk_fail_overflow()
{
  _os_crash((uint64_t)"detected buffer overflow");
  __break(1u);
}

void __chk_fail_overlap()
{
  _os_crash((uint64_t)"detected source and destination buffer overlap");
  __break(1u);
}

unint64_t __chk_overlap(unint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  BOOL v4;

  v4 = 1;
  if (a2)
    v4 = a4 == 0;
  if (!v4)
  {
    if (result == a3)
      __chk_fail_overlap();
    if (result >= a3)
    {
      if (a3 + a4 > result)
        __chk_fail_overlap();
    }
    else if (result + a2 > a3)
    {
      __chk_fail_overlap();
    }
  }
  return result;
}

uint64_t __memset_chk(uint64_t a1, unsigned int a2, unint64_t a3, unint64_t a4)
{
  if (a4 < a3)
    __chk_fail_overflow();
  _platform_memset(a1, a2, a3);
  return a1;
}

unint64_t __strlcpy_chk(unint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  unint64_t v5;
  unint64_t v6;

  v6 = a3;
  if (a4 < a3)
    __chk_fail_overflow();
  v5 = _platform_strlcpy(a1, a2, a3);
  if (v5 < v6)
    v6 = v5 + 1;
  __chk_overlap(a1, v6, a2, v6);
  return v5;
}

unint64_t __strncat_chk(unint64_t a1, unint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  v6 = _platform_strlen(a1);
  v5 = _platform_strnlen(a2, a3);
  if (a4 < v6 + v5 + 1)
    __chk_fail_overflow();
  if (__chk_assert_no_overlap)
    __chk_overlap(a1, v6 + v5 + 1, a2, v5 + 1);
  j___platform_memmove(a1 + v6, a2, v5);
  *(_BYTE *)(a1 + v6 + v5) = 0;
  return a1;
}

unint64_t __strncpy_chk(unint64_t a1, const char *a2, size_t a3, size_t a4)
{
  char *v5;

  if (a4 < a3)
    __chk_fail_overflow();
  v5 = &stpncpy((char *)a1, a2, a3)[-a1 + 1];
  if (v5 == (char *)(a3 + 1))
    --v5;
  if (__chk_assert_no_overlap)
    __chk_overlap(a1, (uint64_t)v5, (unint64_t)a2, (uint64_t)v5);
  return a1;
}

uint64_t __memmove_chk(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a4 < a3)
    __chk_fail_overflow();
  _platform_memmove(a1, a2, a3);
  return a1;
}

unint64_t __strcpy_chk(unint64_t a1, const char *a2, unint64_t a3)
{
  char *v4;

  v4 = &stpcpy((char *)a1, a2)[-a1 + 1];
  if (a3 < (unint64_t)v4)
    __chk_fail_overflow();
  if (__chk_assert_no_overlap)
    __chk_overlap(a1, (uint64_t)v4, (unint64_t)a2, (uint64_t)v4);
  return a1;
}

uint64_t __memccpy_chk(unint64_t a1, unint64_t a2, unsigned int a3, unint64_t a4, unint64_t a5)
{
  uint64_t v6;
  uint64_t v7;

  v7 = a4;
  if (a5 < a4)
    __chk_fail_overflow();
  v6 = _platform_memccpy(a1, a2, a3, a4);
  if (v6)
    v7 = v6 - a1;
  __chk_overlap(a1, v7, a2, v7);
  return v6;
}

int __snprintf_chk(char *a1, size_t a2, int a3, size_t a4, const char *a5, ...)
{
  va_list va;

  va_start(va, a5);
  if (a4 < a2)
    __chk_fail_overflow();
  return vsnprintf(a1, a2, a5, va);
}

uint64_t __snprintf_object_size_chk(char *a1, size_t a2, size_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a2 < a3)
    __chk_fail_overflow();
  return vsnprintf(a1, a3, a4, &a9);
}

unint64_t __strcat_chk(unint64_t a1, unint64_t a2, unint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v5 = _platform_strlen(a1);
  v4 = _platform_strlen(a2);
  if (a3 < v5 + v4 + 1)
    __chk_fail_overflow();
  if (__chk_assert_no_overlap)
    __chk_overlap(a1, v5 + v4 + 1, a2, v4 + 1);
  j___platform_memmove(a1 + v5, a2, v4 + 1);
  return a1;
}

int __vsprintf_chk(char *a1, int a2, size_t a3, const char *a4, va_list a5)
{
  BOOL v6;
  int v7;

  if (a3 > 0x7FFFFFFF)
    return vsprintf(a1, a4, a5);
  v7 = vsnprintf(a1, a3, a4, a5);
  v6 = 0;
  if (v7 >= 0)
    v6 = v7 >= a3;
  if (v6)
    __chk_fail_overflow();
  return v7;
}

char *__stpcpy_chk(char *a1, const char *a2, unint64_t a3)
{
  unint64_t v4;
  char *v5;

  v5 = stpcpy(a1, a2);
  v4 = v5 - a1 + 1;
  if (a3 < v4)
    __chk_fail_overflow();
  if (__chk_assert_no_overlap)
    __chk_overlap((unint64_t)a1, v4, (unint64_t)a2, v4);
  return v5;
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  BOOL v5;
  int v6;
  va_list va;

  va_start(va, a4);
  if (a3 > 0x7FFFFFFF)
    return vsprintf(a1, a4, va);
  v6 = vsnprintf(a1, a3, a4, va);
  v5 = 0;
  if (v6 >= 0)
    v5 = v6 >= a3;
  if (v5)
    __chk_fail_overflow();
  return v6;
}

uint64_t __sprintf_object_size_chk(char *a1, size_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  BOOL v10;
  int v11;

  if (a2 <= 0x7FFFFFFF)
  {
    v11 = vsnprintf(a1, a2, a3, &a9);
    v10 = 0;
    if (v11 >= 0)
      v10 = v11 >= a2;
    if (v10)
      __chk_fail_overflow();
  }
  else
  {
    return vsprintf(a1, a3, &a9);
  }
  return v11;
}

uint64_t __memcpy_chk(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  if (a4 < a3)
    __chk_fail_overflow();
  j___platform_memmove(a1, a2, a3);
  return a1;
}

char *__stpncpy_chk(char *a1, const char *a2, size_t a3, size_t a4)
{
  char *v5;
  uint64_t v6;

  if (a4 < a3)
    __chk_fail_overflow();
  v5 = stpncpy(a1, a2, a3);
  v6 = v5 - a1 + 1;
  if (v6 == a3 + 1)
    v6 = v5 - a1;
  if (__chk_assert_no_overlap)
    __chk_overlap((unint64_t)a1, v6, (unint64_t)a2, v6);
  return v5;
}

int __vsnprintf_chk(char *a1, size_t a2, int a3, size_t a4, const char *a5, va_list a6)
{
  if (a4 < a2)
    __chk_fail_overflow();
  return vsnprintf(a1, a2, a5, a6);
}

uint64_t _os_crash(uint64_t result)
{
  qword_DDB20 = result;
  return result;
}

BOOL _os_assumes_log(uint64_t a1)
{
  _BOOL8 result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  size_t __size;
  char *v8;
  uint64_t *v9;
  uint64_t v10;
  _BYTE v11[256];
  char v12[32];
  char v13[24];
  char __str[64];
  char v15[37];

  v3 = a1;
  _platform_memset(v11, 0, 256);
  v2 = 0;
  v10 = v3;
  v9 = &v2;
  v8 = v11;
  __size = 256;
  v6 = 0;
  v5 = 0;
  _platform_memset(v15, 0, 37);
  *v9 = 0;
  snprintf(__str, 0x40uLL, "%s:%lu", v15, v5);
  snprintf(v13, 0x18uLL, "0x%llx", v10);
  v4 = 32;
  _os_get_build(v12, 0x20uLL);
  snprintf(v8, __size, "assertion failed: %s: %s + %lu [%s]: %s", v12, v6, v5, v15, v13);
  _os_log_redirect(v2, (uint64_t)v11);
  result = _os_abort_on_assumes();
  if (result)
  {
    _os_crash((uint64_t)v11);
    __break(1u);
    JUMPOUT(0xCFE18);
  }
  return result;
}

char *_os_assert_log(uint64_t a1)
{
  uint64_t v2[4];
  uint64_t v3;
  const char *v4;
  size_t __size;
  char *v6;
  uint64_t *v7;
  uint64_t v8;
  char __s1[256];
  char v10[32];
  char v11[24];
  char __str[64];
  char v13[37];

  v2[2] = a1;
  v2[1] = 0;
  v2[0] = 0;
  v8 = a1;
  v7 = v2;
  v6 = __s1;
  __size = 256;
  v4 = 0;
  v3 = 0;
  _platform_memset(v13, 0, 37);
  *v7 = 0;
  snprintf(__str, 0x40uLL, "%s:%lu", v13, v3);
  snprintf(v11, 0x18uLL, "0x%llx", v8);
  v2[3] = 32;
  _os_get_build(v10, 0x20uLL);
  snprintf(v6, __size, "assertion failed: %s: %s + %lu [%s]: %s", v10, v4, v3, v13, v11);
  _os_log_redirect(v2[0], (uint64_t)__s1);
  return strdup(__s1);
}

BOOL _os_assumes_log_ctx(void (*a1)(uint64_t, uint64_t, _BYTE *), uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t, _BYTE *);
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  size_t __size;
  char *v14;
  uint64_t *v15;
  uint64_t v16;
  _BYTE v17[256];
  char v18[32];
  char v19[24];
  char __str[64];
  char v21[37];

  v9 = a1;
  v8 = a2;
  v7 = a3;
  _platform_memset(v17, 0, 256);
  v6 = 0;
  v16 = v7;
  v15 = &v6;
  v14 = v17;
  __size = 256;
  v12 = 0;
  v11 = 0;
  _platform_memset(v21, 0, 37);
  *v15 = 0;
  snprintf(__str, 0x40uLL, "%s:%lu", v21, v11);
  snprintf(v19, 0x18uLL, "0x%llx", v16);
  v10 = 32;
  _os_get_build(v18, 0x20uLL);
  v3 = snprintf(v14, __size, "assertion failed: %s: %s + %lu [%s]: %s", v18, v12, v11, v21, v19);
  v5 = _simple_asl_msg_new(v3);
  v9(v5, v8, v17);
  _simple_sfree(v5);
  result = _os_abort_on_assumes();
  if (result)
  {
    _os_crash((uint64_t)v17);
    __break(1u);
    JUMPOUT(0xD017CLL);
  }
  return result;
}

char *_os_assert_log_ctx(void (*a1)(uint64_t, uint64_t, char *), uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  _QWORD v6[2];
  uint64_t v7;
  uint64_t v8;
  void (*v9)(uint64_t, uint64_t, char *);
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  size_t __size;
  char *v14;
  _QWORD *v15;
  uint64_t v16;
  char v17[256];
  char v18[32];
  char v19[24];
  char __str[64];
  char v21[37];

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6[1] = 0;
  _platform_memset(v17, 0, 256);
  v6[0] = 0;
  v16 = v7;
  v15 = v6;
  v14 = v17;
  __size = 256;
  v12 = 0;
  v11 = 0;
  _platform_memset(v21, 0, 37);
  *v15 = 0;
  snprintf(__str, 0x40uLL, "%s:%lu", v21, v11);
  snprintf(v19, 0x18uLL, "0x%llx", v16);
  v10 = 32;
  _os_get_build(v18, 0x20uLL);
  v3 = snprintf(v14, __size, "assertion failed: %s: %s + %lu [%s]: %s", v18, v12, v11, v21, v19);
  v5 = _simple_asl_msg_new(v3);
  v9(v5, v8, v17);
  _simple_sfree(v5);
  return strdup(v17);
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1 == (const char *)-1)
  {
    if (!qword_DDB20)
    {
      v9 = _simple_salloc(v4);
      if (v9)
      {
        qword_DDB20 = _simple_string(v9);
      }
      else
      {
        qword_DDB20 = (uint64_t)a4;
      }
    }
  }
  else if (a1)
  {
    v6 = _simple_dprintf(2, "Assertion failed: (%s), function %s, file %s, line %d.\n", a4, a1, a2, a3);
    if (!qword_DDB20)
    {
      v7 = _simple_salloc(v6);
      if (v7)
      {
        _simple_sprintf(v7, "Assertion failed: (%s), function %s, file %s, line %d.\n", a4, a1, a2, a3);
        qword_DDB20 = _simple_string(v7);
      }
      else
      {
        qword_DDB20 = (uint64_t)a4;
      }
    }
  }
  else
  {
    v5 = _simple_dprintf(2, "Assertion failed: (%s), file %s, line %d.\n", a4, a2, a3);
    if (!qword_DDB20)
    {
      v8 = _simple_salloc(v5);
      if (v8)
      {
        _simple_sprintf(v8, "Assertion failed: (%s), file %s, line %d.\n", a4, a2, a3);
        qword_DDB20 = _simple_string(v8);
      }
      else
      {
        qword_DDB20 = (uint64_t)a4;
      }
    }
  }
  abort();
}

void err(int a1, const char *a2, ...)
{
  int *v2;
  va_list va;

  va_start(va, a2);
  v2 = __error();
  verrc(a1, *v2, a2, va);
}

void verrc(int a1, int a2, const char *a3, __darwin_va_list a4)
{
  const char *v4;
  char *v5;
  FILE *v6;
  FILE *v7;

  if (!_e_err_file)
    err_set_file(0);
  v7 = (FILE *)_e_err_file;
  v4 = getprogname();
  fprintf(v7, "%s: ", v4);
  if (a3)
  {
    _e_visprintf((FILE *)_e_err_file, a3, a4);
    fprintf((FILE *)_e_err_file, ": ");
  }
  v6 = (FILE *)_e_err_file;
  v5 = strerror(a2);
  fprintf(v6, "%s\n", v5);
  if (_e_err_exit)
  {
    if (_e_err_exit == 1)
      (*((void (**)(uint64_t (*)(_QWORD), _QWORD))off_E9768 + 2))(off_E9768, a1);
    else
      off_E9768(a1);
  }
  exit(a1);
}

void verr(int a1, const char *a2, __darwin_va_list a3)
{
  int *v3;

  v3 = __error();
  verrc(a1, *v3, a2, a3);
}

void errc(int a1, int a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  verrc(a1, a2, a3, va);
}

void errx(int a1, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  verrx(a1, a2, va);
}

void verrx(int a1, const char *a2, __darwin_va_list a3)
{
  const char *v3;
  FILE *v4;

  if (!_e_err_file)
    err_set_file(0);
  v4 = (FILE *)_e_err_file;
  v3 = getprogname();
  fprintf(v4, "%s: ", v3);
  if (a2)
    _e_visprintf((FILE *)_e_err_file, a2, a3);
  fprintf((FILE *)_e_err_file, "\n");
  if (_e_err_exit)
  {
    if (_e_err_exit == 1)
      (*((void (**)(uint64_t (*)(_QWORD), _QWORD))off_E9768 + 2))(off_E9768, a1);
    else
      off_E9768(a1);
  }
  exit(a1);
}

void warn(const char *a1, ...)
{
  int *v1;
  va_list va;

  va_start(va, a1);
  v1 = __error();
  vwarnc(*v1, a1, va);
}

void vwarnc(int a1, const char *a2, __darwin_va_list a3)
{
  const char *v3;
  char *v4;
  FILE *v5;
  FILE *v6;

  if (!_e_err_file)
    err_set_file(0);
  v6 = (FILE *)_e_err_file;
  v3 = getprogname();
  fprintf(v6, "%s: ", v3);
  if (a2)
  {
    _e_visprintf((FILE *)_e_err_file, a2, a3);
    fprintf((FILE *)_e_err_file, ": ");
  }
  v5 = (FILE *)_e_err_file;
  v4 = strerror(a1);
  fprintf(v5, "%s\n", v4);
}

void vwarn(const char *a1, __darwin_va_list a2)
{
  int *v2;

  v2 = __error();
  vwarnc(*v2, a1, a2);
}

void warnc(int a1, const char *a2, ...)
{
  va_list va;

  va_start(va, a2);
  vwarnc(a1, a2, va);
}

void warnx(const char *a1, ...)
{
  va_list va;

  va_start(va, a1);
  vwarnx(a1, va);
}

void vwarnx(const char *a1, __darwin_va_list a2)
{
  const char *v2;
  FILE *v3;

  if (!_e_err_file)
    err_set_file(0);
  v3 = (FILE *)_e_err_file;
  v2 = getprogname();
  fprintf(v3, "%s: ", v2);
  if (a1)
    _e_visprintf((FILE *)_e_err_file, a1, a2);
  fprintf((FILE *)_e_err_file, "\n");
}

void perror(const char *a1)
{
  int *v1;
  char **v2;
  char *v3;
  _QWORD v4[4];
  uint64_t v5;
  char __strerrbuf[2048];

  v2 = (char **)v4;
  if (a1 && *a1)
  {
    v4[0] = a1;
    v4[1] = _platform_strlen(a1);
    v4[2] = ": ";
    v4[3] = 2;
    v2 = (char **)&v5;
  }
  v1 = __error();
  strerror_r(*v1, __strerrbuf, 0x800uLL);
  *v2 = __strerrbuf;
  v2[1] = (char *)_platform_strlen(*v2);
  v3 = (char *)(v2 + 2);
  *(_QWORD *)v3 = "\n";
  *((_QWORD *)v3 + 1) = 1;
  flockfile(__stderrp);
  __sflush((uint64_t)__stderrp);
  writev_NOCANCEL(__stderrp->_file, v4, (v3 - (char *)v4) / 16 + 1);
  __stderrp->_flags &= ~0x1000u;
  funlockfile(__stderrp);
}

size_t regerror(int a1, const regex_t *a2, char *a3, size_t a4)
{
  uint64_t v4;
  void *v6;
  uint64_t v7;
  size_t v8;
  _QWORD *i;
  char v12[50];

  v7 = a1 & 0xFFFFFEFF;
  if (a1 == 255)
  {
    v6 = (void *)regatoi((uint64_t)a2, v12);
    v4 = _platform_strlen(v6);
  }
  else
  {
    for (i = &rerrs; *(_DWORD *)i && *(_DWORD *)i != (_DWORD)v7; i += 3)
      ;
    if ((a1 & 0x100) != 0)
    {
      if (*(_DWORD *)i)
        _platform_strcpy(v12, i[1]);
      else
        sprintf(v12, "REG_0x%x", v7);
      v6 = v12;
      v4 = _platform_strlen(v12);
    }
    else
    {
      v6 = (void *)i[2];
      v4 = _platform_strlen(v6);
    }
  }
  v8 = v4 + 1;
  if (a4)
  {
    if (a4 <= v8)
    {
      _platform_strncpy(a3, v6, a4 - 1);
      a3[a4 - 1] = 0;
    }
    else
    {
      _platform_strcpy(a3, v6);
    }
  }
  return v8;
}

void abort(void)
{
  sigset_t v0;
  pthread_t v1;
  uint64_t v2;
  sigset_t v3[3];
  int v4;
  int v5;
  int v6;

  v2 = 0;
  *(_QWORD *)v3 = 0;
  if (!qword_DDB20)
    qword_DDB20 = (uint64_t)"abort() called";
  v1 = pthread_self();
  if (__cleanup)
    _cleanup();
  v6 = 6;
  v5 = 11;
  v4 = 10;
  v3[0] = -1569;
  v0 = -1;
  sigprocmask(3, &v0, 0);
  __pthread_workqueue_setkill(1);
  pthread_sigmask(3, v3, 0);
  pthread_kill(v1, 6);
  usleep_NOCANCEL(0x2710u);
  __abort();
}

void __abort()
{
  sigset_t v0;
  pthread_t v1;
  sigaction v2;
  int v3;
  int v4;
  int v5;

  v2.__sigaction_u.__sa_handler = 0;
  *(_QWORD *)&v2.sa_mask = 0;
  if (!qword_DDB20)
    qword_DDB20 = (uint64_t)"__abort() called";
  v1 = pthread_self();
  v2.__sigaction_u.__sa_handler = 0;
  v2.sa_flags = 0;
  v2.sa_mask = -1;
  sigaction(6, &v2, 0);
  v5 = 6;
  v2.sa_mask &= ~0x20u;
  v0 = -1;
  sigprocmask(3, &v0, 0);
  __pthread_workqueue_setkill(1);
  pthread_sigmask(3, &v2.sa_mask, 0);
  pthread_kill(v1, 6);
  usleep_NOCANCEL(0x2710u);
  v4 = 4;
  v3 = 5;
  v2.sa_mask = -25;
  sigprocmask(3, &v2.sa_mask, 0);
  __break(1u);
}

void abort_report_np(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  v9 = _simple_salloc();
  if (v9)
  {
    _simple_vsprintf(v9, a1, &a9);
    qword_DDB20 = _simple_string(v9);
  }
  else
  {
    qword_DDB20 = a1;
  }
  abort();
}
