uint64_t sub_10000384C(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!result)
    sub_10004D708(0, a2, a3, a4);
  return result;
}

uint64_t sub_100003864(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!(_DWORD)a1)
    sub_10004D720(a1, a2, a3, a4);
  return 0;
}

uint64_t sub_100003880()
{
  os_map_str_init(&unk_100071B30, 0, 1);
  return os_map_32_init(&unk_100071B48, 0, 1);
}

_DWORD *sub_1000038B4(const char *a1, unsigned int a2)
{
  _DWORD *v4;

  v4 = sub_10001389C(55 * a2 + 32);
  *(_QWORD *)v4 = sub_1000121A0();
  v4[2] = a2;
  *((_QWORD *)v4 + 3) = sub_10001544C(a1);
  v4[5] = 0;
  return v4;
}

void sub_100003910(uint64_t a1)
{
  while (*(_DWORD *)(a1 + 16))
    sub_100003994(a1);
  *(_DWORD *)(a1 + 20) = 0;
  sub_1000122F8(*(void **)a1);
  free(*(void **)(a1 + 24));
  free((void *)a1);
}

void sub_10000395C(uint64_t a1)
{
  while (*(_DWORD *)(a1 + 16))
    sub_100003994(a1);
  *(_DWORD *)(a1 + 20) = 0;
}

double sub_100003994(uint64_t a1)
{
  uint64_t v2;
  double result;
  int v4;

  if (!*(_DWORD *)(a1 + 16))
    sub_10004D738();
  v2 = a1 + 55 * *(unsigned int *)(a1 + 12);
  sub_100012290(*(_QWORD *)a1, *(_QWORD *)(v2 + 32));
  *(_QWORD *)(v2 + 79) = 0;
  result = 0.0;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  v4 = *(_DWORD *)(a1 + 16) - 1;
  *(_DWORD *)(a1 + 12) = (*(_DWORD *)(a1 + 12) + 1) % *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a1 + 16) = v4;
  return result;
}

uint64_t sub_100003A00(uint64_t a1)
{
  return *(unsigned int *)(a1 + 8);
}

uint64_t sub_100003A08(uint64_t a1)
{
  return *(unsigned int *)(a1 + 16);
}

uint64_t sub_100003A10(_DWORD *a1, unsigned int a2)
{
  if (a1[4] < a2)
    sub_10004D738();
  return (uint64_t)a1 + 55 * ((a1[3] + a2) % a1[2]) + 32;
}

unint64_t sub_100003A4C(uint64_t a1, uint64_t a2)
{
  unint64_t result;

  result = os_map_32_count(&unk_100071B48);
  if (result > 0x7CF)
    return result;
  result = os_map_str_count(&unk_100071B30);
  if (result)
  {
    if (a2)
    {
LABEL_5:
      if (os_map_32_find(&unk_100071B48, a1))
        sub_10003E208("launch_service_stats_record_spawn() must not be called twice with the same pid (%d)", a1);
      return os_map_32_insert(&unk_100071B48, a1, a2);
    }
LABEL_11:
    sub_10003E208("launch_service_stats_record_spawn() must not be called with a zero timestamp");
  }
  if (dword_100071B60 == 500)
  {
    os_map_32_destroy(&unk_100071B48);
    result = os_map_32_init(&unk_100071B48, 0, 1);
    ++dword_100071B60;
    return result;
  }
  if (dword_100071B60 <= 0x1F3)
  {
    ++dword_100071B60;
    if (a2)
      goto LABEL_5;
    goto LABEL_11;
  }
  return result;
}

uint64_t sub_100003B4C(uint64_t a1)
{
  return os_map_32_delete(&unk_100071B48, a1);
}

size_t sub_100003B5C(size_t result, int a2, const char *a3, int a4, uint64_t a5, uint64_t a6, char a7, uint64_t a8, int a9, int a10, int a11, __int16 a12)
{
  size_t v18;
  unsigned int v19;
  unsigned int v20;
  const char *v21;
  uint64_t v22;
  size_t v23;

  if (a5)
  {
    v18 = result;
    v19 = *(_DWORD *)(result + 16);
    v20 = *(_DWORD *)(result + 8);
    if (v19 == v20)
    {
      v21 = a3;
      sub_100003994(result);
      a3 = v21;
      v19 = *(_DWORD *)(v18 + 16);
      ++*(_DWORD *)(v18 + 20);
      v20 = *(_DWORD *)(v18 + 8);
    }
    if (v19 >= v20)
      sub_10004D738();
    v22 = a6;
    v23 = v18 + 55 * ((*(_DWORD *)(v18 + 12) + v19) % v20);
    result = sub_1000121D4(*(_QWORD *)v18, a3);
    *(_QWORD *)(v23 + 32) = result;
    *(_QWORD *)(v23 + 40) = a5;
    *(_DWORD *)(v23 + 56) = a2;
    *(_DWORD *)(v23 + 60) = a4;
    *(_QWORD *)(v23 + 48) = v22;
    *(_BYTE *)(v23 + 64) = a7;
    *(_QWORD *)(v23 + 65) = a8;
    *(_DWORD *)(v23 + 73) = a9;
    *(_DWORD *)(v23 + 77) = a10;
    *(_DWORD *)(v23 + 81) = a11;
    *(_WORD *)(v23 + 85) = a12;
    ++*(_DWORD *)(v18 + 16);
  }
  return result;
}

uint64_t sub_100003C6C(const char *a1, unsigned int a2)
{
  _DWORD *v5;

  if (os_map_str_find(&unk_100071B30, a1))
    return 17;
  v5 = sub_1000038B4(a1, a2);
  os_map_str_insert(&unk_100071B30, *((_QWORD *)v5 + 3), v5);
  return 0;
}

uint64_t sub_100003CCC(uint64_t a1)
{
  uint64_t v1;

  v1 = os_map_str_delete(&unk_100071B30, a1);
  if (!v1)
    return 2;
  sub_100003910(v1);
  return 0;
}

uint64_t sub_100003D00(uint64_t a1)
{
  return os_map_str_find(&unk_100071B30, a1);
}

uint64_t sub_100003D10(uint64_t a1)
{
  _QWORD v2[5];

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = sub_100003D68;
  v2[3] = &unk_1000691A8;
  v2[4] = a1;
  return os_map_str_foreach(&unk_100071B30, v2);
}

uint64_t sub_100003D68(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  return 1;
}

uint64_t sub_100003D88()
{
  return _os_assert_log(0);
}

uint64_t sub_100003D90(char *key)
{
  xpc_object_t value;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  v6 = 0;
  if (qword_100071B68)
  {
    value = xpc_dictionary_get_value((xpc_object_t)qword_100071B68, key);
    if (value)
    {
      v2 = value;
      if (!sub_100003E44(value, "SampleRate", &v6))
        sub_100040F68(7, "Probabilistic Guard Malloc SampleRate has the wrong format");
      if (!sub_100003E44(v2, "ActivationRate", (_DWORD *)&v6 + 1))
        sub_100040F68(7, "Probabilistic Guard Malloc ActivationRate has the wrong format");
    }
  }
  if ((_DWORD)v6)
    v3 = v6;
  else
    v3 = qword_100071B70;
  if (HIDWORD(v6))
    v4 = HIDWORD(v6);
  else
    v4 = HIDWORD(qword_100071B70);
  return v3 | (v4 << 32);
}

BOOL sub_100003E44(void *a1, const char *a2, _DWORD *a3)
{
  unint64_t int64;
  _BOOL8 result;

  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    int64 = xpc_dictionary_get_int64(a1, a2);
    result = HIDWORD(int64) == 0;
    if (int64 >= (unint64_t)&_mh_execute_header)
      int64 = (unint64_t)&_mh_execute_header;
  }
  else
  {
    LODWORD(int64) = 0;
    result = 0;
  }
  *a3 = int64;
  return result;
}

void sub_100003EBC()
{
  int has_internal_diagnostics;
  uint64_t v1;
  xpc_object_t v2;
  uint64_t v3;
  char *v4;
  int v5;

  byte_100071B80 = sub_100003F84(&qword_100071B78);
  has_internal_diagnostics = os_variant_has_internal_diagnostics("com.apple.xpc.launchd");
  v1 = 0x3E800000000;
  if (has_internal_diagnostics)
    v1 = 0xFA00000000;
  qword_100071B70 = v1;
  qword_100071B68 = 0;
  v2 = sub_1000479B8("ProbGuardPolicy");
  if (!v2)
  {
    v4 = "Probabilistic Guard Malloc config absent";
    v5 = 7;
    goto LABEL_7;
  }
  v3 = (uint64_t)v2;
  if (xpc_get_type(v2) != (xpc_type_t)&_xpc_type_dictionary)
  {
    v4 = "Probabilistic Guard Malloc configuration file plist is not a dictionary";
    v5 = 5;
LABEL_7:
    sub_100040F68(v5, v4);
    return;
  }
  qword_100071B68 = v3;
  qword_100071B70 = sub_100003D90("GlobalPolicy");
}

BOOL sub_100003F84(unint64_t *a1)
{
  char *v2;
  _BOOL8 v3;
  char *v4;

  v2 = getenv("MallocProbGuard");
  v3 = sub_1000157A8(v2, "1");
  if (v3)
  {
    v4 = getenv("MallocProbGuardSampleRate");
    *a1 = 500;
    if (v4)
      *a1 = strtoul(v4, 0, 10);
  }
  return v3;
}

void sub_100003FEC(uint64_t a1)
{
  uint32_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  char v11;
  char __str[16];

  if (!byte_100071B80)
  {
    v2 = *(_DWORD *)(a1 + 1352);
    if (v2)
    {
      if (!arc4random_uniform(v2))
      {
        byte_100071B80 = 1;
        *(_QWORD *)(a1 + 1376) |= 0x200000000000000uLL;
        sub_100005AFC(a1, "MallocProbGuardViaLaunchd", "1", 1);
        v8 = *(_DWORD *)(a1 + 924);
        v9 = *(_DWORD *)(a1 + 928);
        if (v8 >= 1)
          *(_DWORD *)(a1 + 924) = v8 + 2;
        if (v9 >= 1)
          *(_DWORD *)(a1 + 928) = v9 + 2;
        v10 = *(_DWORD *)(a1 + 1348);
        if (v10)
        {
          *(_DWORD *)&__str[7] = 0;
          *(_QWORD *)__str = 0;
          snprintf(__str, 0xBuLL, "%u", v10);
          sub_100005AFC(a1, "MallocProbGuardSampleRate", __str, 0);
        }
        sub_10001D418(a1, 5, "Enabling Probabilistic Guard Malloc", v3, v4, v5, v6, v7, v11);
      }
    }
  }
}

void sub_100004108(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;

  v9 = *(_QWORD *)(a1 + 1376);
  if ((v9 & 0x200000000000000) != 0)
  {
    if (!byte_100071B80)
      sub_10004D74C();
    v11 = *(_QWORD *)(a1 + 1384);
    byte_100071B80 = 0;
    *(_QWORD *)(a1 + 1384) = v11;
    *(_QWORD *)(a1 + 1376) = v9 & 0xFDFFFFFFFFFFFFFFLL;
    v12 = a1 + 1008;
    v13 = a1 + 1008;
    do
      v13 = *(_QWORD *)v13;
    while (v13 && !sub_1000156F0((const char *)(v13 + 32), "MallocProbGuardViaLaunchd"));
    while (1)
    {
      v12 = *(_QWORD *)v12;
      if (!v12)
        break;
      if (sub_1000156F0((const char *)(v12 + 32), "MallocProbGuardSampleRate"))
      {
        if (v13)
        {
          sub_100005A94(a1, (char *)v13);
          v13 = v12;
          goto LABEL_11;
        }
LABEL_17:
        sub_10004D74C();
      }
    }
    if (!v13)
      goto LABEL_17;
LABEL_11:
    sub_100005A94(a1, (char *)v13);
    v19 = *(_DWORD *)(a1 + 924);
    v20 = *(_DWORD *)(a1 + 928);
    if (v19 >= 3)
      *(_DWORD *)(a1 + 924) = v19 - 2;
    if (v20 >= 3)
      *(_DWORD *)(a1 + 928) = v20 - 2;
    sub_10001D418(a1, 5, "Probabilistic Guard Malloc-enabled process exited", v14, v15, v16, v17, v18, a9);
  }
}

size_t sub_100004214(int a1, char *__s)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  int *v8;
  unsigned int v9;
  unsigned int v10;
  _DWORD *v11;
  size_t v12;
  size_t v13;
  BOOL v14;
  size_t result;
  uint64_t v16;
  uint64_t v17;
  BOOL v18;
  size_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  pthread_t v24;
  pthread_attr_t v25;

  v4 = 0;
  while (dword_100071268[v4] != a1)
  {
    v4 += 6;
    if (v4 == 18)
      sub_10003E208("unrecognized launch diagnostic thread type: %u", a1);
  }
  v5 = (unsigned int *)&dword_100071268[v4 + 1];
  do
  {
    v6 = __ldxr(v5);
    v7 = v6 + 1;
  }
  while (__stxr(v7, v5));
  v8 = &dword_100071268[v4];
  v9 = dword_100071268[v4 + 4];
  if (v7 > v9)
  {
    sub_100040F68(4, "Exceeded max diagnostic thread count for type %s (%u)", *((const char **)v8 + 1), v9);
    do
      v10 = __ldxr(v5);
    while (__stxr(v10 - 1, v5));
    return 0;
  }
  v12 = strlen(__s);
  v13 = v12 + 16;
  v14 = v12 >= 0xFFFFFFFFFFFFFFF0;
  result = v12 + 17;
  v16 = v13 == -1;
  v17 = v16 << 63 >> 63;
  v18 = v17 != v16;
  if (!v14 && !v18 && (v17 & 0x8000000000000000) == 0)
  {
    v11 = sub_10001389C(result);
    *(_QWORD *)v11 = dispatch_semaphore_create(0);
    v11[2] = a1;
    v19 = strlen(__s);
    memcpy(v11 + 3, __s, v19);
    memset(&v25, 0, sizeof(v25));
    v20 = pthread_attr_init(&v25);
    if (v20)
      sub_10004D764(v20);
    v21 = pthread_attr_setdetachstate(&v25, 2);
    if (v21)
      sub_10004D764(v21);
    v24 = 0;
    v22 = pthread_create(&v24, &v25, (void *(__cdecl *)(void *))sub_100004480, v11);
    v23 = pthread_attr_destroy(&v25);
    if (v23)
      sub_10004D764(v23);
    if (v22)
    {
      sub_1000043EC((uint64_t)v11);
      return 0;
    }
    return (size_t)v11;
  }
  __break(1u);
  return result;
}

void sub_1000043EC(uint64_t a1)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;

  v2 = 0;
  while (dword_100071268[v2] != *(_DWORD *)(a1 + 8))
  {
    v2 += 6;
    if (v2 == 18)
      sub_10003E208("unrecognized launch diagnostic thread type: %u", *(_DWORD *)(a1 + 8));
  }
  dispatch_release(*(dispatch_object_t *)a1);
  free((void *)a1);
  v3 = (unsigned int *)&dword_100071268[v2 + 1];
  do
    v4 = __ldxr(v3);
  while (__stxr(v4 - 1, v3));
}

intptr_t sub_100004478(dispatch_semaphore_t *a1)
{
  return dispatch_semaphore_signal(*a1);
}

uint64_t sub_100004480(dispatch_semaphore_t *a1)
{
  int v2;
  _OWORD v4[4];

  memset(v4, 0, sizeof(v4));
  __strlcpy_chk(v4, (char *)a1 + 12, 64, 64);
  v2 = pthread_setname_np((const char *)v4);
  if (v2)
    sub_10004D764(v2);
  dispatch_semaphore_wait(*a1, 0xFFFFFFFFFFFFFFFFLL);
  sub_1000043EC((uint64_t)a1);
  return 0;
}

uint64_t sub_100004518(int a1)
{
  return _os_assert_log(a1);
}

void sub_100004520(uint64_t a1, uint64_t (*a2)(const char *, void **))
{
  uint64_t v3;
  void *v4;
  void *v5;

  if (qword_100071B88)
    sub_10004D738();
  if (dword_100071B90)
    sub_10004D738();
  dword_100071B90 = 1;
  if (getenv("XPC_USERSPACE_REBOOT_TO_BOOT_MODE"))
  {
    sub_100040F68(65541, "not setting boot-mode to hw.osenvironment due to USR to boot-mode");
  }
  else
  {
    v5 = 0;
    v3 = a2("hw.osenvironment", &v5);
    v4 = v5;
    if (v3 && v5)
    {
      if (*(_BYTE *)v5)
      {
        sub_100040F68(65541, "boot-mode set by sysctl: %s", (const char *)v5);
        sub_1000045F8((const char *)v5);
        dword_100071B90 = 2;
        v4 = v5;
      }
    }
    free(v4);
  }
}

void sub_1000045F8(const char *a1)
{
  if (!a1)
    sub_10004D738();
  if (dword_100071B90 < 2)
  {
    free((void *)qword_100071B88);
    qword_100071B88 = (uint64_t)sub_10001544C(a1);
  }
  else if (dword_100071B90 == 2)
  {
    if (!qword_100071B88)
      sub_10004D738();
    sub_100040F68(65541, "boot-mode forced to (%s) skipping set: %s", (const char *)qword_100071B88, a1);
  }
  else if (dword_100071B90 == 3)
  {
    sub_10003E208("Cannot set boot-mode after it has been committed: (%s, %s)", (const char *)qword_100071B88, a1);
  }
}

char *sub_10000469C(int a1)
{
  uint64_t v1;

  if (!a1)
    sub_10003E208("can't ask for the string for 'none' boot mode!");
  v1 = 0;
  while (LODWORD((&off_1000712B0)[v1 + 1]) != a1)
  {
    v1 += 2;
    if (v1 == 14)
      sub_10003E208("Unknown boot-mode: %d", a1);
  }
  return (&off_1000712B0)[v1];
}

uint64_t sub_100004700(char *__s1)
{
  uint64_t v2;

  if (!__s1)
    sub_10003E208("empty boot-mode name given");
  v2 = 0;
  while (!sub_1000157A8(__s1, (&off_1000712B0)[v2]))
  {
    v2 += 2;
    if (v2 == 14)
      sub_10003E208("Unknown boot-mode: %s", __s1);
  }
  return LODWORD((&off_1000712B0)[v2 + 1]);
}

void sub_10000477C(int a1)
{
  char *v1;

  v1 = sub_10000469C(a1);
  sub_1000045F8(v1);
}

void sub_100004790()
{
  if (dword_100071B90 == 3)
    sub_10004D738();
  dword_100071B90 = 3;
  sub_100040F68(65541, "boot-mode committed: %s", (const char *)qword_100071B88);
}

uint64_t sub_1000047E4()
{
  if (dword_100071B90 != 3)
    sub_10004D738();
  return qword_100071B88;
}

BOOL sub_100004810()
{
  return dword_100071B90 == 2;
}

uint64_t sub_100004824(char *a1)
{
  uint64_t result;

  if (!a1)
    sub_10004D738();
  if (dword_100071B90 != 3)
    sub_10004D738();
  result = qword_100071B88;
  if (qword_100071B88)
    return strcasecmp((const char *)qword_100071B88, a1) == 0;
  return result;
}

uint64_t sub_10000486C(int a1)
{
  char *v1;

  v1 = sub_10000469C(a1);
  return sub_100004824(v1);
}

double xpc_binprefs_alloc()
{
  _OWORD *v0;
  double result;

  v0 = sub_10001389C(0x24uLL);
  result = 0.0;
  *v0 = 0u;
  v0[1] = 0u;
  *((_DWORD *)v0 + 8) = 0;
  return result;
}

double xpc_binprefs_init(uint64_t a1)
{
  double result;

  *(_DWORD *)(a1 + 32) = 0;
  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  return result;
}

void *xpc_binprefs_copy(const void *a1)
{
  return sub_10001541C(a1, 0x24uLL);
}

uint64_t xpc_binprefs_add(uint64_t result, int a2, int a3)
{
  uint64_t v3;

  v3 = *(unsigned int *)(result + 32);
  if (v3 >= 4)
    return _os_assumes_log(0);
  *(_DWORD *)(result + 4 * v3) = a2;
  *(_DWORD *)(result + 4 * (*(_DWORD *)(result + 32))++ + 16) = a3;
  return result;
}

uint64_t xpc_binprefs_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 32);
}

uint64_t xpc_binprefs_cpu_type(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 32) <= a2)
    sub_10004D74C();
  return *(unsigned int *)(a1 + 4 * a2);
}

uint64_t xpc_binprefs_cpu_subtype(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 32) <= a2)
    sub_10004D74C();
  return *(unsigned int *)(a1 + 4 * a2 + 16);
}

BOOL xpc_binprefs_equal(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  int v5;
  unsigned int v6;
  int v7;
  int v8;

  result = (a1 | a2) == 0;
  if (a1 && a2)
  {
    v5 = *(_DWORD *)(a1 + 32);
    if (v5 == *(_DWORD *)(a2 + 32))
    {
      if (!v5)
        return 1;
      v6 = 0;
      while (1)
      {
        v7 = xpc_binprefs_cpu_type(a1, v6);
        if (v7 != xpc_binprefs_cpu_type(a2, v6))
          break;
        v8 = xpc_binprefs_cpu_subtype(a1, v6);
        if (v8 != xpc_binprefs_cpu_subtype(a2, v6))
          break;
        if (++v6 >= *(_DWORD *)(a1 + 32))
          return 1;
      }
    }
    return 0;
  }
  return result;
}

char *xpc_binprefs_copy_description(uint64_t a1)
{
  const char **v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char v25;

  if (!a1)
    return sub_10001544C("(null)");
  v2 = (const char **)sub_1000106C8(0x80uLL);
  sub_100010740((uint64_t)v2, "%d: [", v3, v4, v5, v6, v7, v8, *(_DWORD *)(a1 + 32));
  if (*(_DWORD *)(a1 + 32))
  {
    v15 = 0;
    do
    {
      if (v15)
        sub_100010740((uint64_t)v2, ", ", v9, v10, v11, v12, v13, v14, v25);
      v16 = xpc_binprefs_cpu_type(a1, v15);
      xpc_binprefs_cpu_subtype(a1, v15);
      sub_100010740((uint64_t)v2, "%d.%d", v17, v18, v19, v20, v21, v22, v16);
      ++v15;
    }
    while (v15 < *(_DWORD *)(a1 + 32));
  }
  sub_100010740((uint64_t)v2, "]", v9, v10, v11, v12, v13, v14, v25);
  v23 = sub_100010710(v2);
  sub_100010718((void **)v2);
  return v23;
}

uint64_t xpc_binprefs_set_psattr(cpu_type_t *a1, posix_spawnattr_t *a2)
{
  uint64_t result;

  result = posix_spawnattr_setarchpref_np(a2, a1[8], a1, a1 + 4, 0);
  if ((_DWORD)result)
    sub_10004D778(result);
  return result;
}

size_t sub_100004B34(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t v6;
  int v7;
  _BOOL8 v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  size_t v26;
  uint64_t i;
  uint64_t j;
  const char *k;
  const char *v30;
  size_t v31;
  void *v32;
  uint64_t v33;
  const char **v34;
  const char *v35;
  size_t v36;
  const char *string;
  const char *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *m;
  unsigned int *v43;
  char *v44;
  size_t v45;
  void *v46;
  unsigned int count;
  size_t v48;
  char *v49;
  unsigned int v50;
  unint64_t v51;
  unsigned int v52;
  _QWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  char *n;
  char *ii;
  uint64_t jj;
  uint64_t v64;
  char *v65;
  char *v66;
  int v67;
  uint64_t v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  char *v76;
  char *v77;
  char *v78;
  char *v79;
  char *v80;
  char *v81;
  char *v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unint64_t v88;
  unsigned int v89;
  unsigned int v90;
  char v91;
  uint64_t v92;
  _QWORD *v93;
  int v94;
  unsigned int v95;
  uint64_t *v96;
  size_t v97;
  int v98;
  uint64_t v99;
  char v100;
  uint64_t v101;
  unsigned int v102;
  unsigned int *v103;
  size_t v104;
  uint64_t v105;
  unsigned int v106;
  int v107;
  int v108;
  unsigned int v109;
  unint64_t v110;
  unsigned int v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  unsigned int v119;
  char v121;
  char v122;
  size_t v123;
  size_t v124;
  unsigned int v125;
  uint64_t v126;
  uint64_t v127;
  void *v128;

  v6 = *(_QWORD *)(a1 + 248);
  v127 = 0;
  v128 = 0;
  v7 = *(_DWORD *)(a1 + 1296);
  v8 = v7 != 0;
  v57 = v7 == 0;
  v9 = 1;
  if (!v57)
    v9 = 2;
  if ((*(_DWORD *)(a1 + 1340) + 1) >= 2)
    v10 = v9;
  else
    v10 = v8;
  v11 = *(char **)(a1 + 888);
  if (v11)
  {
    v12 = sub_10002CCF8(v6, v11);
    if (v12)
    {
      v19 = sub_1000457E0(v12, 1, v13, v14, v15, v16, v17, v18);
      ++v10;
      goto LABEL_11;
    }
    sub_10001D418(a1, 3, "Could not find exception endpoint for service: %s", v14, v15, v16, v17, v18, *(_QWORD *)(a1 + 888));
  }
  v19 = 0;
LABEL_11:
  v126 = 0;
  sub_10002E9C0(v6, &v127, &v128, &v126, v10);
  v20 = *(unsigned int *)(a1 + 1296);
  if ((_DWORD)v20)
  {
    xpc_array_set_mach_send(v127, -1, v20);
    v21 = v126++;
    *((_DWORD *)v128 + v21) = 129;
  }
  v22 = *(unsigned int *)(a1 + 1340);
  if ((v22 + 1) >= 2)
  {
    xpc_array_set_mach_send(v127, -1, v22);
    v25 = v126++;
    *((_DWORD *)v128 + v25) = 130;
    if ((_DWORD)v19)
      goto LABEL_15;
  }
  else if ((_DWORD)v19)
  {
LABEL_15:
    xpc_array_set_mach_send(v127, -1, v19);
    v23 = v126;
    v24 = ++v126;
    *((_DWORD *)v128 + v23) = 128;
    goto LABEL_18;
  }
  v24 = v126;
LABEL_18:
  v26 = *(_QWORD *)(a1 + 592) + 4 * v24;
  for (i = qword_100072AD0; i; i = *(_QWORD *)i)
    v26 += strlen((const char *)(i + 32)) + 1;
  for (j = qword_100072AD8; j; j = *(_QWORD *)j)
    v26 += strlen((const char *)(j + 32)) + 1;
  for (k = *(const char **)(*(_QWORD *)(a1 + 248) + 96); k; k = *(const char **)k)
  {
    if (sub_10001D840())
      v26 += strlen(k + 32) + 1;
  }
  v123 = v26;
  if ((*(_BYTE *)(a1 + 1322) & 4) != 0)
  {
    if (*(_QWORD *)(a1 + 1256))
    {
      v30 = (const char *)sub_10001CFB8(a1);
      v31 = strlen(v30);
      v26 = strlen(*(const char **)(a1 + 1256)) + v26 - v31;
      v123 = v26;
    }
    v32 = *(void **)(a1 + 1264);
    if (v32)
    {
      v33 = *(unsigned int *)(a1 + 428);
      if ((_DWORD)v33)
      {
        v34 = *(const char ***)(a1 + 432);
        do
        {
          v35 = *v34++;
          v26 += ~strlen(v35);
          --v33;
        }
        while (v33);
      }
      if (xpc_array_get_count(v32))
      {
        v36 = 0;
        do
        {
          string = xpc_array_get_string(*(xpc_object_t *)(a1 + 1264), v36);
          if (string)
            v26 += strlen(string) + 1;
          ++v36;
        }
        while (v36 < xpc_array_get_count(*(xpc_object_t *)(a1 + 1264)));
      }
      v123 = v26;
    }
    v38 = *(const char **)(a1 + 1272);
    if (v38)
    {
      v39 = *(const char **)(a1 + 440);
      if (v39)
        v26 += ~strlen(v39);
      v123 = v26 + strlen(v38) + 1;
    }
    v40 = *(_QWORD *)(a1 + 1280);
    if (v40)
      xpc_dictionary_apply_f(v40);
    v41 = *(_QWORD *)(a1 + 1288);
    if (v41)
    {
      if (*(_QWORD *)(a1 + 904))
      {
        v123 -= _xpc_spawnattr_binprefs_size(*(_QWORD *)(a1 + 904));
        v41 = *(_QWORD *)(a1 + 1288);
      }
      v26 = v123 + _xpc_spawnattr_binprefs_size(v41);
    }
    else
    {
      v26 = v123;
    }
  }
  for (m = *(_QWORD **)(a1 + 680); m; m = (_QWORD *)*m)
    v26 += 20;
  v43 = (unsigned int *)sub_10001389C(v26);
  v125 = 0;
  v124 = v26 - 240;
  *v43 = v26;
  v43[1] = 0;
  v44 = *(char **)(a1 + 1256);
  if (!v44)
    v44 = (char *)sub_10001CFB8(a1);
  _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v44);
  *((_BYTE *)v43 + 230) = 0;
  v45 = *(unsigned int *)(a1 + 624);
  if ((_DWORD)v45)
  {
    v43[2] = v125;
    v43[3] = v45;
    _xpc_spawnattr_pack_bytes((uint64_t)v43, &v125, &v124, *(void **)(a1 + 616), v45);
  }
  v46 = *(void **)(a1 + 1264);
  if (v46)
  {
    count = xpc_array_get_count(v46);
    v43[4] = count;
    if (count)
    {
      v48 = 0;
      v43[5] = v125;
      do
      {
        v49 = (char *)xpc_array_get_string(*(xpc_object_t *)(a1 + 1264), v48);
        if (v49)
          _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v49);
        ++v48;
      }
      while (v48 < v43[4]);
    }
  }
  else
  {
    v50 = *(_DWORD *)(a1 + 428);
    if (v50)
    {
      v51 = 0;
      v52 = v125;
      v43[4] = v50;
      v43[5] = v52;
      do
        _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, *(char **)(*(_QWORD *)(a1 + 432) + 8 * v51++));
      while (v51 < *(unsigned int *)(a1 + 428));
    }
    else
    {
      v43[4] = 0;
    }
  }
  v53 = *(_QWORD **)(*(_QWORD *)(a1 + 248) + 96);
  if (v53)
  {
    v54 = 0;
    do
    {
      v54 += sub_10001D840();
      v53 = (_QWORD *)*v53;
    }
    while (v53);
  }
  else
  {
    v54 = 0;
  }
  v55 = qword_100072AD0;
  v56 = *(_QWORD *)(a1 + 1280);
  if (*(_WORD *)(a1 + 1016))
    v57 = 0;
  else
    v57 = qword_100072AD8 == 0;
  if (v57 && qword_100072AD0 == 0 && v56 == 0 && v54 == 0)
  {
    v43[7] = 0;
  }
  else
  {
    v43[7] = v125;
    if (v56)
    {
      xpc_dictionary_apply_f(v56);
      v55 = qword_100072AD0;
    }
    for (; v55; v55 = *(_QWORD *)v55)
    {
      _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, (char *)(v55 + 32));
      ++v43[6];
    }
    for (n = *(char **)(a1 + 1008); n; n = *(char **)n)
    {
      _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, n + 32);
      ++v43[6];
    }
    for (ii = *(char **)(*(_QWORD *)(a1 + 248) + 96); ii; ii = *(char **)ii)
    {
      if (sub_10001D840())
      {
        _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, ii + 32);
        ++v43[6];
      }
    }
    for (jj = qword_100072AD8; jj; jj = *(_QWORD *)jj)
    {
      _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, (char *)(jj + 32));
      ++v43[6];
    }
  }
  v64 = *(_QWORD *)(a1 + 1288);
  if (v64 || (v64 = *(_QWORD *)(a1 + 904)) != 0)
    _xpc_spawnattr_binprefs_pack((uint64_t)v43, v64, &v125, &v124);
  else
    v43[9] = 0;
  v65 = *(char **)(a1 + 800);
  if (v65)
  {
    v43[10] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v65);
  }
  else
  {
    v43[10] = 0;
  }
  v66 = *(char **)(a1 + 808);
  if (v66)
  {
    v43[11] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v66);
  }
  else
  {
    v43[11] = 0;
  }
  if ((*(_BYTE *)(a1 + 1380) & 1) != 0)
  {
    *((_WORD *)v43 + 26) = *(_WORD *)(a1 + 816);
    v67 = 0x2000;
  }
  else
  {
    v67 = 0;
  }
  v68 = *(_QWORD *)(a1 + 248);
  v43[12] = *(_DWORD *)(v68 + 56);
  v43[59] = v43[59] & 0xFFF7FFFF | ((*(_BYTE *)(v68 + 104) & 1) << 19);
  v69 = sub_100023BAC(a1);
  if (v69 != -1)
  {
    v43[59] |= 0x1000000u;
    v43[53] = v69;
  }
  if ((_UNKNOWN *)sub_10002E360(v6) == &unk_100071750)
    *((_QWORD *)v43 + 7) = sub_10002E368(*(_QWORD *)(a1 + 248));
  v75 = *(char **)(a1 + 1272);
  if (v75 || (v75 = *(char **)(a1 + 440)) != 0)
  {
    v43[16] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v75);
  }
  else
  {
    v43[16] = 0;
  }
  v76 = *(char **)(a1 + 448);
  if (v76)
  {
    v43[17] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v76);
  }
  else
  {
    v43[17] = 0;
  }
  v77 = *(char **)(a1 + 456);
  if (v77)
  {
    v43[18] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v77);
  }
  else
  {
    v43[18] = 0;
  }
  v78 = *(char **)(a1 + 464);
  if (v78)
  {
    v43[19] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v78);
  }
  else
  {
    v43[19] = 0;
  }
  v79 = *(char **)(a1 + 472);
  if (v79)
  {
    v43[20] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v79);
  }
  else
  {
    v43[20] = 0;
  }
  v80 = *(char **)(a1 + 480);
  if (v80)
  {
    v43[21] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v80);
  }
  else
  {
    v43[21] = 0;
  }
  v81 = *(char **)(a1 + 488);
  if (v81)
  {
    v43[22] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v81);
  }
  else
  {
    v43[22] = 0;
  }
  v82 = *(char **)(a1 + 1360);
  if (v82)
  {
    v43[26] = v125;
    _xpc_spawnattr_pack_string((uint64_t)v43, &v125, &v124, v82);
  }
  *((_QWORD *)v43 + 14) = *(_QWORD *)(a1 + 896);
  *((_BYTE *)v43 + 196) = *(_BYTE *)(a1 + 984);
  v83 = *(__int16 *)(a1 + 1320);
  if (!*(_WORD *)(a1 + 1320))
    v83 = *(_DWORD *)(a1 + 916);
  v43[30] = v83;
  v84 = *(_DWORD *)(a1 + 1312);
  if ((v84 & 0x80000000) != 0)
    v84 = *(_DWORD *)(a1 + 920);
  v43[31] = v84;
  v85 = *(_DWORD *)(a1 + 1316);
  v86 = v85;
  if (!v85)
  {
    v85 = *(_DWORD *)(a1 + 924);
    v86 = *(_DWORD *)(a1 + 928);
  }
  v43[32] = v85;
  v43[33] = v86;
  v87 = *(_DWORD *)(a1 + 932);
  if ((v87 & 0x80000000) == 0)
    v43[34] = v87;
  *(_QWORD *)(v43 + 35) = *(_QWORD *)(a1 + 936);
  *(_OWORD *)(v43 + 37) = *(_OWORD *)(a1 + 944);
  *(_QWORD *)(v43 + 41) = *(_QWORD *)(a1 + 960);
  v43[43] = *(_DWORD *)(a1 + 968);
  sub_10001D9DC(a1, (uint64_t)v43, v70, (uint64_t)v82, v71, v72, v73, v74, v121);
  v43[48] = sub_10001D950(a1);
  v43[47] = sub_10001D870(a1);
  v88 = *(_QWORD *)(a1 + 1376);
  v89 = (v88 >> 23) & 0x2000000 | v43[59] & 0xF9FFFFFF | (v88 >> 24) & 0x4000000;
  v43[59] = v89;
  v90 = *(_DWORD *)(a1 + 1020);
  v91 = *(_BYTE *)(a1 + 1018);
  if (v90 || *(_BYTE *)(a1 + 1018))
  {
    v89 |= 0x200000u;
    v43[59] = v89;
    v43[56] = v90;
    *((_BYTE *)v43 + 228) = v91;
  }
  v43[50] = *(_DWORD *)(a1 + 912);
  v92 = 1;
  v93 = (_QWORD *)(a1 + 680);
  do
  {
    v93 = (_QWORD *)*v93;
    --v92;
  }
  while (v93);
  if (v92)
  {
    v94 = -(int)v92;
    v95 = v125;
    v43[51] = v94;
    v43[52] = v95;
    v96 = *(uint64_t **)(a1 + 680);
    if (v96)
    {
      v97 = v124;
      do
      {
        v98 = *((_DWORD *)v96 + 8);
        v99 = (uint64_t)v43 + v95 + 240;
        *(_OWORD *)v99 = *((_OWORD *)v96 + 1);
        *(_DWORD *)(v99 + 16) = v98;
        v95 += 20;
        v97 -= 20;
        v96 = (uint64_t *)*v96;
      }
      while (v96);
      v125 = v95;
      v124 = v97;
    }
    if ((v88 & 0x800) == 0)
      goto LABEL_158;
  }
  else
  {
    v43[51] = 0;
    v43[52] = 0;
    if ((v88 & 0x800) == 0)
    {
LABEL_158:
      v100 = *(_BYTE *)(a1 + 1322) & 1;
      goto LABEL_161;
    }
  }
  v100 = 1;
LABEL_161:
  *((_BYTE *)v43 + 108) = v100;
  v101 = v126;
  v43[55] = v126;
  if (v101)
  {
    v102 = v125;
    v43[54] = v125;
    v103 = (unsigned int *)v128;
    v104 = v124;
    v105 = 4 * v101;
    do
    {
      v106 = *v103++;
      *(unsigned int *)((char *)v43 + v102 + 240) = v106;
      v102 += 4;
      v125 = v102;
      --v101;
    }
    while (v101);
    v124 = v104 - v105;
  }
  else
  {
    v43[54] = 0;
  }
  v107 = (8 * v88) & 0x10 | (v88 >> 12) & 3 | (v88 >> 3) & 0x20 | (v88 >> 24) & 0x800000 | v89 & 0xFF7FF200;
  v108 = *(_DWORD *)(a1 + 1160) == 11;
  v109 = (v88 >> 3) & 0xC | (v88 >> 11) & 0x100 | (((*(_DWORD *)(a1 + 368) >> 5) & 1) << 7);
  *((_BYTE *)v43 + 229) = *(_BYTE *)(a1 + 1332);
  v43[59] = (v88 >> 13) & 0x800 | (((v88 >> 9) & 1) << 10) | v109 | v107 | (v108 << 6);
  if (sub_10001D848(a1) && sub_10001D848(a1) != -1)
    v43[59] |= 0x200u;
  v110 = *(_QWORD *)(a1 + 1376);
  if ((v110 & 0x2000000) != 0 || (*(_BYTE *)(a1 + 1322) & 0x10) != 0)
    v43[59] |= 0x20000u;
  if ((v110 & 0x4000000) != 0)
  {
    v111 = v43[59];
    goto LABEL_176;
  }
  v111 = v43[59];
  if ((*(_BYTE *)(a1 + 1322) & 0x20) != 0)
LABEL_176:
    v111 |= 0x40000u;
  v43[59] = (v110 >> 11) & 0x400000 | v67 | (v110 >> 40) & 0x8000 | v111 & 0xFFBF5FFF;
  v112 = sub_10001D144(a1);
  if ((v110 & 0x20000000000000) != 0)
  {
    if (v112)
      sub_10001D418(a1, 3, "Conflicting request: resliding disabled, but requesting a shared cache reslide. No reslide will be performed.", v113, v114, v115, v116, v117, v122);
    v119 = v43[59] & 0xF7FFFFFF;
  }
  else
  {
    if (v112)
      v118 = 0x8000000;
    else
      v118 = 0;
    v119 = v43[59] & 0xF7FFFFFF | v118;
  }
  v43[59] = (*(_QWORD *)(a1 + 1376) >> 18) & 0x10000 | (*(_QWORD *)(a1 + 1376) >> 20) & 0x100000 | v119 & 0xFFEEFFFF;
  if ((_UNKNOWN *)sub_10002E360(*(_QWORD *)(a1 + 248)) == &unk_1000715B8)
    v43[59] |= 0x10000000u;
  if (v124 || v125 + 240 != v26)
    sub_10003E208("failed to marshall spawnattrs: offset = %u, left = %lu, expected = %lu", v125, v124, *(_QWORD *)(a1 + 592));
  free(v128);
  *a3 = v43;
  *a2 = v127;
  return v26;
}

void *sub_1000056A4(char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t v5;
  _DWORD *v6;
  _QWORD *v7;
  void *result;
  char *string_ptr;

  v5 = *a3;
  v6 = (_DWORD *)a3[1];
  v7 = (_QWORD *)a3[2];
  result = xpc_get_type(object);
  if (result == &_xpc_type_string)
  {
    _xpc_spawnattr_pack_string_fragment(v5, v6, v7, a1);
    _xpc_spawnattr_pack_string_fragment(v5, v6, v7, "=");
    string_ptr = (char *)xpc_string_get_string_ptr(object);
    result = (void *)_xpc_spawnattr_pack_string(v5, v6, v7, string_ptr);
    ++*(_DWORD *)(v5 + 24);
  }
  return result;
}

char *sub_100005748(const char *a1, xpc_object_t object, _QWORD *a3)
{
  char *result;
  size_t v7;

  result = (char *)xpc_get_type(object);
  if (result == (char *)&_xpc_type_string)
  {
    v7 = strlen(a1);
    result = (char *)xpc_string_get_length(object);
    *a3 += &result[v7 + 2];
  }
  return result;
}

void sub_1000057B4(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  char *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t *v15;
  void *v16;
  void *v17;
  mach_port_name_t v18;
  kern_return_t v19;

  if (*(_BYTE *)(a1 + 424))
    sub_10003E208("deallocation of active service");
  if (*(_QWORD *)(a1 + 24) != -1 || *(_QWORD *)(a1 + 32) != -1)
    sub_10003E208("service disposal while still in list");
  if (*(_QWORD *)(a1 + 40) != -1 || *(_QWORD *)(a1 + 48) != -1)
    sub_10003E208("service disposal while in parent instance list");
  if (*(_QWORD *)(a1 + 512))
    sub_10003E208("Service: %s has leaked pended requests", (const char *)(a1 + 1392));
  if (*(_QWORD *)(a1 + 872))
    sub_10004D738();
  if (*(_QWORD *)(a1 + 136))
    sub_10004D738();
  if (*(_QWORD *)(a1 + 144))
    sub_10004D738();
  if ((*(_BYTE *)(a1 + 1383) & 2) != 0)
    sub_10004D738();
  v2 = *(void **)(a1 + 576);
  if (v2 != (void *)(a1 + 1392))
    free(v2);
  free(*(void **)(a1 + 584));
  sub_10001962C(*(void **)(a1 + 16));
  free(*(void **)(a1 + 600));
  free(*(void **)(a1 + 432));
  free(*(void **)(a1 + 440));
  free(*(void **)(a1 + 888));
  free(*(void **)(a1 + 616));
  free(*(void **)(a1 + 472));
  free(*(void **)(a1 + 480));
  free(*(void **)(a1 + 488));
  free(*(void **)(a1 + 448));
  free(*(void **)(a1 + 456));
  free(*(void **)(a1 + 464));
  free(*(void **)(a1 + 800));
  free(*(void **)(a1 + 808));
  free(*(void **)(a1 + 904));
  free(*(void **)(a1 + 1360));
  free(*(void **)(a1 + 1368));
  free(*(void **)(a1 + 304));
  v3 = *(void **)(a1 + 976);
  if (v3)
    j__free(v3);
  v4 = *(void **)(a1 + 632);
  if (v4)
    xpc_release(v4);
  v5 = *(void **)(a1 + 640);
  if (v5)
    xpc_release(v5);
  v6 = *(void **)(a1 + 648);
  if (v6)
    xpc_release(v6);
  v7 = *(void **)(a1 + 656);
  if (v7)
    xpc_release(v7);
  v8 = *(void **)(a1 + 664);
  if (v8)
    xpc_release(v8);
  v9 = *(void **)(a1 + 496);
  if (v9)
    xpc_release(v9);
  v10 = *(void **)(a1 + 504);
  if (v10)
    xpc_release(v10);
  if (*(_QWORD *)(a1 + 712))
    sub_100005A58(a1);
  while (1)
  {
    v11 = *(char **)(a1 + 1008);
    if (!v11)
      break;
    sub_100005A94(a1, v11);
  }
  while (1)
  {
    v13 = *(uint64_t **)(a1 + 672);
    if (!v13)
      break;
    v12 = *v13;
    if (*v13)
      *(_QWORD *)(v12 + 8) = v13[1];
    *(_QWORD *)v13[1] = v12;
    free(v13);
  }
  while (1)
  {
    v15 = *(uint64_t **)(a1 + 680);
    if (!v15)
      break;
    v14 = *v15;
    if (*v15)
      *(_QWORD *)(v14 + 8) = v15[1];
    *(_QWORD *)v15[1] = v14;
    free(v15);
  }
  v16 = *(void **)(a1 + 1056);
  if (v16)
    xpc_release(v16);
  v17 = *(void **)(a1 + 1064);
  if (v17)
    xpc_release(v17);
  v18 = *(_DWORD *)(a1 + 1340);
  if (v18 + 1 >= 2)
  {
    v19 = mach_port_mod_refs(mach_task_self_, v18, 0, -1);
    if (v19)
      sub_10004D778(v19);
  }
  sub_10003C1C4(a1);
}

void sub_100005A58(uint64_t a1)
{
  NSObject *v2;

  v2 = *(NSObject **)(a1 + 712);
  if (!v2)
    sub_10004D738();
  dispatch_set_context(v2, v2);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 712));
  *(_QWORD *)(a1 + 712) = 0;
}

void sub_100005A94(uint64_t a1, char *a2)
{
  uint64_t v3;

  --*(_WORD *)(a1 + 1016);
  *(_QWORD *)(a1 + 592) += ~strlen(a2 + 32);
  v3 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
    *(_QWORD *)(v3 + 8) = *((_QWORD *)a2 + 1);
  **((_QWORD **)a2 + 1) = v3;
  *(_QWORD *)a2 = -1;
  *((_QWORD *)a2 + 1) = -1;
  j__free(a2);
}

void sub_100005AFC(uint64_t a1, char *__s, const char *a3, char a4)
{
  char *v5;
  uint64_t v6;
  size_t v7;

  v7 = 0;
  v5 = sub_10001967C(__s, a3, 0, &v7, a4);
  if (v5)
  {
    v6 = *(_QWORD *)(a1 + 1008);
    *(_QWORD *)v5 = v6;
    if (v6)
      *(_QWORD *)(v6 + 8) = v5;
    *(_QWORD *)(a1 + 1008) = v5;
    ++*(_WORD *)(a1 + 1016);
    *(_QWORD *)(a1 + 592) += v7;
    *((_QWORD *)v5 + 1) = a1 + 1008;
    *((_QWORD *)v5 + 2) = a1;
  }
}

uint64_t sub_100005BA8(uint64_t a1, int a2)
{
  uint64_t v2;
  unint64_t v4;
  uint64_t v5;
  xpc_object_t v6;
  void *v7;
  unint64_t v8;
  xpc_object_t array;
  size_t v11;
  int64_t int64;

  switch(a2)
  {
    case 0:
      v4 = *(_QWORD *)(a1 + 1376);
      if ((v4 & 0x40400000000) != 0)
      {
        if ((sub_10000FEF4(a1 + 376, 30) & 1) != 0)
          goto LABEL_17;
        v4 = *(_QWORD *)(a1 + 1376);
      }
      v2 = (v4 >> 44) & 1;
      return v2 & 1;
    case 1:
    case 2:
    case 3:
    case 5:
      LODWORD(v2) = (*(unsigned __int8 *)(a1 + 1381) >> 4) & 1;
      return v2 & 1;
    case 4:
      LOBYTE(v2) = (*(_BYTE *)(a1 + 1381) & 1) == 0;
      return v2 & 1;
    case 6:
      LOBYTE(v2) = *(_BYTE *)(a1 + 1381) & 1;
      return v2 & 1;
    case 7:
      v5 = *(unsigned __int8 *)(a1 + 984);
      if (!*(_BYTE *)(a1 + 984))
        goto LABEL_17;
      if ((_DWORD)v5 == 2)
        goto LABEL_14;
      v6 = sub_100040958(a1 + 376);
      if (!v6)
        goto LABEL_14;
      v7 = v6;
      if (xpc_get_type(v6) == (xpc_type_t)&_xpc_type_dictionary)
      {
        array = xpc_dictionary_get_array(v7, "com.apple.private.xpc.allowed-launch-types");
        if (xpc_array_get_count(array))
        {
          v11 = 0;
          do
          {
            int64 = xpc_array_get_int64(array, v11);
            LOBYTE(v2) = int64 == v5;
            if (int64 == v5)
              break;
            ++v11;
          }
          while (v11 < xpc_array_get_count(array));
        }
        else
        {
          LOBYTE(v2) = 0;
        }
        xpc_release(v7);
      }
      else
      {
        xpc_release(v7);
LABEL_14:
        LOBYTE(v2) = 0;
      }
      break;
    case 8:
      v8 = *(_QWORD *)(a1 + 1376);
      if ((v8 & 0x40400000000) == 0)
        goto LABEL_19;
      if ((sub_10000FEF4(a1 + 376, 31) & 1) != 0)
      {
LABEL_17:
        LOBYTE(v2) = 1;
      }
      else
      {
        v8 = *(_QWORD *)(a1 + 1376);
LABEL_19:
        v2 = (v8 >> 44) & 1;
      }
      break;
    default:
      return v2 & 1;
  }
  return v2 & 1;
}

void sub_100005D28(uint64_t a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  if (!strcasecmp(a2, "Interactive"))
  {
    v10 = 1024;
    goto LABEL_14;
  }
  if (!strcasecmp(a2, "Adaptive"))
  {
    v10 = 1536;
    goto LABEL_14;
  }
  if (!strcasecmp(a2, "Standard"))
  {
    v10 = 768;
    goto LABEL_14;
  }
  if (!strcasecmp(a2, "Background"))
  {
    v10 = 1280;
    goto LABEL_14;
  }
  if (!strcasecmp(a2, "SystemApp"))
  {
    *(_DWORD *)(a1 + 896) = 256;
    v9 = *(_QWORD *)(a1 + 1376) | 0x3000;
    goto LABEL_17;
  }
  if (!strcasecmp(a2, "App"))
  {
    *(_DWORD *)(a1 + 896) = 256;
    v9 = *(_QWORD *)(a1 + 1376) | 0x1000;
    goto LABEL_17;
  }
  if (strcasecmp(a2, "_AdaptiveUtility"))
  {
    if (strcasecmp(a2, "Driver"))
    {
      sub_10001D418(a1, 4, "Unknown ProcessType: %s", v4, v5, v6, v7, v8, (char)a2);
      v9 = *(_QWORD *)(a1 + 1376) | 1;
LABEL_17:
      *(_QWORD *)(a1 + 1376) = v9;
      return;
    }
    v10 = 1792;
LABEL_14:
    *(_DWORD *)(a1 + 896) = v10;
    return;
  }
  *(_DWORD *)(a1 + 896) = 1536;
  *(_DWORD *)(a1 + 912) = 17;
}

uint64_t sub_100005E7C(uint64_t a1)
{
  uint64_t v2;
  _BYTE *v3;

  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  if ((*(_BYTE *)(a1 + 1380) & 0x40) == 0)
    return 0;
  v3 = sub_100014738(*(_QWORD *)(a1 + 248), (const char *)(a1 + 1392));
  v2 = (*(uint64_t (**)(uint64_t, uint64_t, void *, _QWORD, _BYTE *, _QWORD))(a1 + 544))(a1, a1 + 1392, &_xpc_BOOL_true, 0, v3, *(_QWORD *)(a1 + 568));
  if (!v2)
  {
    *(_QWORD *)(a1 + 1376) |= 1uLL;
    sub_100014830(v3, 3, "Failed to create the implicit endpoint");
  }
  sub_1000147FC((uint64_t)v3);
  *(_QWORD *)(a1 + 1376) &= ~0x4000000000uLL;
  return v2;
}

uint64_t sub_100005F4C(_DWORD *a1, xpc_object_t object, char *a3, uint64_t a4, uint64_t a5, unint64_t a6, int *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  const char *string;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  size_t v28;
  size_t v29;
  uint64_t v30;
  char *v31;
  __darwin_ct_rune_t v32;
  uint64_t *v34;
  uint64_t *v35;
  _BYTE *v36;
  const char *v37;
  char *v38;
  _BOOL4 v39;
  _BOOL4 v40;
  xpc_object_t v41;
  xpc_object_t value;
  int v43;
  _BOOL4 v44;
  xpc_object_t v45;
  void *v46;
  size_t v47;
  char *v48;
  char *string_ptr;
  xpc_object_t v50;
  void *v51;
  xpc_object_t v52;
  void *v53;
  xpc_object_t v54;
  xpc_object_t v55;
  xpc_object_t v56;
  xpc_object_t v57;
  int v58;
  int v59;
  xpc_object_t v60;
  int v61;
  _BOOL4 v62;
  xpc_object_t v63;
  xpc_object_t v64;
  xpc_object_t v65;
  xpc_object_t v66;
  char *v67;
  const char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  char v87;
  uint64_t v88;
  char *__s1;
  uint64_t v90;

  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100028C34((uint64_t)a1, 3, "Root node of launchd.plist is not a dictionary.", v14, v15, v16, v17, v18, v87);
LABEL_3:
    v19 = 0;
    v20 = 109;
LABEL_16:
    *a7 = v20;
    return v19;
  }
  string = xpc_dictionary_get_string(object, "Label");
  if (!string)
  {
    v31 = "Service plist does not specify a label.";
LABEL_15:
    sub_100028C34((uint64_t)a1, 3, v31, v22, v23, v24, v25, v26, v87);
    v19 = 0;
    v20 = 110;
    goto LABEL_16;
  }
  v27 = string;
  v28 = strlen(string);
  if (!v28)
  {
    v31 = "Service plist has an empty label.";
    goto LABEL_15;
  }
  v29 = v28;
  __s1 = a3;
  v90 = a4;
  v88 = a5;
  v30 = 0;
  v31 = "Service plist has an empty label.";
  while (1)
  {
    v32 = v27[v30];
    if (v32 < 0)
      break;
    if ((_DefaultRuneLocale.__runetype[v32] & 0x4000) == 0)
      goto LABEL_18;
LABEL_11:
    if (v29 == ++v30)
      goto LABEL_15;
  }
  if (__maskrune(v32, 0x4000uLL))
    goto LABEL_11;
LABEL_18:
  v34 = sub_100007CBC(object, (uint64_t)a1, v27);
  if (!v34)
    goto LABEL_3;
  v35 = v34;
  v36 = sub_100014738((uint64_t)a1, v27);
  v37 = xpc_dictionary_get_string(v35, "Label");
  if (!v37)
  {
    sub_100014830(v36, 3, "Service plist does not specify a label.");
    v19 = 0;
    v43 = 110;
    goto LABEL_52;
  }
  v38 = (char *)v37;
  v39 = xpc_dictionary_get_BOOL(v35, "Disabled");
  v40 = xpc_dictionary_get_BOOL(v35, "ForceEnableHack");
  v41 = sub_10002E544((uint64_t)a1, v38);
  value = xpc_dictionary_get_value(v35, "_Conclave");
  if ((a6 & 0x800) == 0 && value)
  {
    sub_100014830(v36, 3, "Only LaunchDaemons are allowed to use the _Conclave key");
    v19 = 0;
    v43 = 109;
    goto LABEL_52;
  }
  if (v41)
    v44 = v41 == &_xpc_BOOL_true;
  else
    v44 = v39;
  if ((a6 & 0x20) == 0 && v44 && !((a6 >> 1) & 1 | v40))
  {
    v19 = 0;
    v43 = 119;
    goto LABEL_52;
  }
  if ((a6 >> 1) & 1 | v40)
    sub_10002C720((uint64_t)a1, v38, 2);
  v45 = xpc_dictionary_get_value(v35, "LimitLoadToSessionType");
  if (!v45)
  {
    string_ptr = 0;
    goto LABEL_43;
  }
  v46 = v45;
  if (xpc_get_type(v45) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = (char *)xpc_string_get_string_ptr(v46);
LABEL_43:
    if (sub_10002E3B0((uint64_t)a1, string_ptr))
      goto LABEL_44;
    goto LABEL_51;
  }
  if (xpc_get_type(v46) != (xpc_type_t)&_xpc_type_array || !xpc_array_get_count(v46))
  {
LABEL_51:
    v19 = 0;
    v43 = 134;
    goto LABEL_52;
  }
  v47 = 0;
  while (1)
  {
    v48 = (char *)xpc_array_get_string(v46, v47);
    if (sub_10002E3B0((uint64_t)a1, v48))
      break;
    if (++v47 >= xpc_array_get_count(v46))
      goto LABEL_51;
  }
LABEL_44:
  v50 = xpc_dictionary_get_value(v35, "LimitLoadToHardware");
  if (v50 && (v51 = v50, xpc_get_type(v50) == (xpc_type_t)&_xpc_type_dictionary) && (sub_100009204(v51) & 1) == 0
    || (v52 = xpc_dictionary_get_value(v35, "LimitLoadFromHardware")) != 0
    && (v53 = v52, xpc_get_type(v52) == (xpc_type_t)&_xpc_type_dictionary)
    && sub_100009204(v53))
  {
LABEL_50:
    v19 = 0;
    v43 = 138;
    goto LABEL_52;
  }
  v54 = xpc_dictionary_get_value(v35, "_LimitLoadToVariant");
  if (v54 && (sub_10000928C(v54) & 1) == 0
    || (v55 = xpc_dictionary_get_value(v35, "_LimitLoadFromVariant")) != 0 && sub_10000928C(v55))
  {
    v19 = 0;
    v43 = 158;
    goto LABEL_52;
  }
  v56 = xpc_dictionary_get_value(v35, "_PersistToBootMode");
  if (v56)
  {
    if ((a6 & 0x200) == 0)
    {
      sub_100014830(v36, 3, "Service specifies _PersistToBootMode which is not permitted for services that were not dynamically submitted");
      goto LABEL_94;
    }
    if ((a6 & 0x40000) == 0 && (sub_10000FEF4(v90, 36) & 1) == 0)
    {
      sub_100014830(v36, 3, "Unentitled submitter specifies _PersistToBootMode in service, which is not permitted");
LABEL_94:
      v19 = 0;
      v43 = 137;
LABEL_52:
      *a7 = v43;
      goto LABEL_53;
    }
  }
  v57 = xpc_dictionary_get_value(v35, "_LimitLoadToBootMode");
  if (!v57)
  {
    v59 = 0;
    goto LABEL_72;
  }
  v58 = sub_100009360(v57);
  if ((a6 & 0x40000) != 0)
    v59 = 0;
  else
    v59 = v58 ^ 1;
  if (!v56 && (v58 & 1) == 0)
  {
LABEL_103:
    v19 = 0;
    v43 = 152;
    goto LABEL_52;
  }
LABEL_72:
  v60 = xpc_dictionary_get_value(v35, "_LimitLoadFromBootMode");
  if (v60)
  {
    v61 = sub_100009360(v60);
    if (v61)
      v59 = (a6 & 0x40000) == 0;
    if (!v56 && v61)
      goto LABEL_103;
  }
  if (xpc_dictionary_get_BOOL(v35, "_LimitLoadToClarityMode") && (sub_100009428() & 1) == 0)
    goto LABEL_103;
  if (xpc_dictionary_get_BOOL(v35, "_LimitLoadFromClarityMode") && sub_100009428())
    goto LABEL_103;
  v62 = xpc_dictionary_get_BOOL(v35, "LimitLoadToDeveloperMode");
  if (((a6 & 0x4000) != 0 || v62) && (int)sub_100010698("security.mac.amfi.developer_mode_status") <= 0)
    goto LABEL_103;
  v63 = xpc_dictionary_get_value(v35, "_LimitLoadToDeviceTree");
  if (v63 && (sub_100009460(v63, v36) & 1) == 0)
    goto LABEL_50;
  v64 = xpc_dictionary_get_value(v35, "_LimitLoadFromDeviceTree");
  if (v64)
  {
    if (sub_100009460(v64, v36))
      goto LABEL_50;
  }
  v65 = xpc_dictionary_get_value(v35, "_LimitLoadToBootarg");
  if (v65 && (sub_100009578(v65, v36) & 1) == 0
    || (v66 = xpc_dictionary_get_value(v35, "_LimitLoadFromBootarg")) != 0 && sub_100009578(v66, v36))
  {
    v19 = 0;
    v43 = 160;
    goto LABEL_52;
  }
  if (byte_1000729F0 && !xpc_dictionary_get_BOOL(v35, "MinimalBootProfile"))
    goto LABEL_103;
  v67 = sub_10002C4E4(a1, v38);
  if (v67)
  {
    v68 = (const char *)sub_10001CFC4((uint64_t)v67);
    if (!strcmp(__s1, v68))
    {
      v43 = 37;
    }
    else
    {
      if (*v68 == 47 && *__s1 == 47)
        sub_100028C34((uint64_t)a1, 4, "Attempt to re-bootstrap service from different path, will use existing: service = %s, existing = %s, conflicting = %s", v69, v70, v71, v72, v73, (char)v38);
      v43 = 17;
    }
    v19 = 0;
    goto LABEL_52;
  }
  v74 = sub_100009690(v35, __s1, v90, a6, v88, a7, v36);
  v19 = (uint64_t)v74;
  if (v74)
  {
    *((_QWORD *)v74 + 173) = *((_QWORD *)v74 + 173) & 0xFFFFFFFFFFFFFFFELL | (v59 != 0);
    if (v59)
      sub_100028C34((uint64_t)a1, 5, "Retaining, but not starting, service %s", v75, v76, v77, v78, v79, (char)v38);
    v80 = sub_10000704C(v19, (uint64_t)a1, v36);
    *a7 = v80;
    if (v80)
    {
      sub_10001962C((void *)v19);
      v19 = 0;
    }
    else
    {
      sub_100009DA4(v19, (uint64_t)a1, v81, v82, v83, v84, v85, v86);
      if (*(_DWORD *)(v19 + 896) == 768 && !byte_100072A83)
        *(_DWORD *)(v19 + 912) = 17;
      if (byte_100072A47)
      {
        *(_QWORD *)(v19 + 924) = -1;
        *(_DWORD *)(v19 + 916) &= 0xFFFFFFF3;
      }
    }
  }
LABEL_53:
  sub_1000147FC((uint64_t)v36);
  xpc_release(v35);
  return v19;
}

BOOL sub_100006668(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 1377) & 0x40) != 0 || *(_BYTE *)(a1 + 1344) != 0;
}

char *sub_100006688(uint64_t a1, unsigned __int8 *uu, uint64_t a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, int *a8)
{
  uint64_t v9;
  char *v11;
  int v12;
  mach_port_name_t v20;
  _BYTE *v21;
  char *v22;
  const char *v23;
  uint64_t v24;
  int v25;
  char __str[16];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  char out[40];

  v9 = *(_QWORD *)(a1 + 1376);
  if ((v9 & 0x20000) != 0
    || *(_QWORD *)(*(_QWORD *)(a1 + 248) + 72) == a1
    || (v9 & 0x20000000) != 0
    || (~v9 & 0x40000001000) == 0
    || (v9 & 0x80) != 0
    || *(_QWORD *)(a1 + 144))
  {
    v11 = 0;
    v12 = 136;
LABEL_8:
    *a8 = v12;
    return v11;
  }
  if ((v9 & 0x4000) == 0 && !*(_BYTE *)(a1 + 1344) || (v9 & 0x8000) != 0 || (*(_BYTE *)(a1 + 368) & 0x20) != 0)
    goto LABEL_28;
  if ((v9 & 0x4000000000) != 0)
    sub_10003E208("multiple-instance service has no initialized endpoints");
  v20 = *(_DWORD *)(a1 + 1340);
  if (v20 + 1 >= 2)
  {
    if (sub_10000D964(v20))
    {
LABEL_28:
      v11 = 0;
      v12 = 137;
      goto LABEL_8;
    }
  }
  memset(out, 0, 37);
  uuid_unparse(uu, out);
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  *(_OWORD *)__str = 0u;
  v27 = 0u;
  snprintf(__str, 0x100uLL, "%s.%s", (const char *)(a1 + 1392), out);
  v21 = sub_100014738(*(_QWORD *)(a1 + 248), __str);
  v22 = sub_1000068BC(a1, uu, __str, a3, a5, a6, a7, v21, a8);
  v11 = v22;
  if (a4)
  {
    if (*(_QWORD *)a4)
      sub_100006F78((uint64_t)v22, *(const void **)a4);
    v23 = *(const char **)(a4 + 8);
    if (v23)
      sub_100006FD8((uint64_t)v11, v23);
    v24 = *(_QWORD *)(a4 + 16);
    if (v24)
      xpc_dictionary_apply_f(v24);
  }
  if (v11)
  {
    v25 = sub_10000704C((uint64_t)v11, *(_QWORD *)(a1 + 248), v21);
    *a8 = v25;
    if (v25)
    {
      sub_10001962C(v11);
      v11 = 0;
    }
  }
  sub_1000147FC((uint64_t)v21);
  return v11;
}

char *sub_1000068BC(uint64_t a1, const unsigned __int8 *a2, char *a3, uint64_t a4, _OWORD *a5, uint64_t a6, uint64_t a7, _BYTE *a8, int *a9)
{
  xpc_object_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  const char *v31;
  const char *v32;
  const char *v33;
  const char *v34;
  const char *v35;
  const char *v36;
  const char *v37;
  const char *v38;
  const char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  const char *v46;
  uint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const void *v51;
  _QWORD *v52;
  uint64_t *v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  uint64_t v83;
  void *v84;
  void *v85;
  void *v86;
  const char *v87;
  const char *v88;
  const void *v89;
  const void *v90;
  char v92;
  const unsigned __int8 *v93;
  size_t out[5];

  if (*(_DWORD *)(a1 + 428))
  {
    v17 = xpc_array_create(0, 0);
    if (*(_DWORD *)(a1 + 428))
    {
      v93 = a2;
      v18 = 0;
      do
        xpc_array_set_string(v17, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(*(_QWORD *)(a1 + 432) + 8 * v18++));
      while (v18 < *(unsigned int *)(a1 + 428));
      a2 = v93;
    }
  }
  else
  {
    v17 = 0;
  }
  v22 = sub_100007D2C(*(void **)(a1 + 16), a5, a3, v17, a6, a7 | 4, a9, a8);
  if (v17)
    xpc_release(v17);
  if (v22)
  {
    if ((_DWORD)a4 == -1
      || (v23 = sub_10001DE5C(v22, *(_QWORD *)(a1 + 448), *(_QWORD *)(a1 + 456), *(_QWORD *)(a1 + 464), a4, v19, v20, v21)) == 0)
    {
      if (!a5)
      {
        v30 = *(_OWORD *)(a1 + 392);
        *(_OWORD *)(v22 + 376) = *(_OWORD *)(a1 + 376);
        *(_OWORD *)(v22 + 392) = v30;
      }
      v31 = *(const char **)(a1 + 576);
      if (v31)
        *((_QWORD *)v22 + 72) = sub_10001544C(v31);
      v32 = *(const char **)(a1 + 440);
      if (v32)
        *((_QWORD *)v22 + 55) = sub_10001544C(v32);
      v33 = *(const char **)(a1 + 888);
      if (v33)
        *((_QWORD *)v22 + 111) = sub_10001544C(v33);
      v34 = *(const char **)(a1 + 448);
      if (v34)
        *((_QWORD *)v22 + 56) = sub_10001544C(v34);
      v35 = *(const char **)(a1 + 456);
      if (v35)
        *((_QWORD *)v22 + 57) = sub_10001544C(v35);
      v36 = *(const char **)(a1 + 464);
      if (v36)
        *((_QWORD *)v22 + 58) = sub_10001544C(v36);
      sub_10003D574(a1, (uint64_t)v22);
      sub_10003D600(a1, (uint64_t)v22);
      v37 = *(const char **)(a1 + 480);
      if (v37)
        *((_QWORD *)v22 + 60) = sub_10001544C(v37);
      v38 = *(const char **)(a1 + 472);
      if (v38)
        *((_QWORD *)v22 + 74) += ~strlen(v38);
      v39 = *(const char **)(a1 + 488);
      if (v39)
        *((_QWORD *)v22 + 61) = sub_10001544C(v39);
      uuid_copy((unsigned __int8 *)v22 + 408, a2);
      v45 = *(const char **)(a1 + 800);
      if (v45)
        *((_QWORD *)v22 + 100) = sub_10001544C(v45);
      v46 = *(const char **)(a1 + 808);
      if (v46)
        *((_QWORD *)v22 + 101) = sub_10001544C(v46);
      *((_QWORD *)v22 + 112) = *(_QWORD *)(a1 + 896);
      v47 = *((_QWORD *)v22 + 173);
      v48 = *((_QWORD *)v22 + 172) & 0xDFFFFFFFFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 61) & 1) << 61);
      *((_QWORD *)v22 + 172) = v48;
      *(_OWORD *)(v22 + 916) = *(_OWORD *)(a1 + 916);
      *((_DWORD *)v22 + 233) = *(_DWORD *)(a1 + 932);
      *((_QWORD *)v22 + 117) = *(_QWORD *)(a1 + 936);
      *((_OWORD *)v22 + 59) = *(_OWORD *)(a1 + 944);
      *((_QWORD *)v22 + 120) = *(_QWORD *)(a1 + 960);
      *((_DWORD *)v22 + 242) = *(_DWORD *)(a1 + 968);
      v22[984] = *(_BYTE *)(a1 + 984);
      v49 = v48 | 0x20000000000;
      *((_QWORD *)v22 + 172) = v48 | 0x20000000000;
      v22[356] = *(_BYTE *)(a1 + 356);
      v22[1030] = *(_BYTE *)(a1 + 1030);
      v50 = *(_QWORD *)(a1 + 1376) >> 59;
      *((_QWORD *)v22 + 173) = v47;
      *((_QWORD *)v22 + 172) = v49 & 0xF7FFFFFFFFFFFFFFLL | ((unint64_t)(v50 & 1) << 59);
      v22[1018] = *(_BYTE *)(a1 + 1018);
      *((_DWORD *)v22 + 255) = *(_DWORD *)(a1 + 1020);
      v51 = *(const void **)(a1 + 904);
      if (v51)
        *((_QWORD *)v22 + 113) = xpc_binprefs_copy(v51);
      *((_DWORD *)v22 + 228) = *(_DWORD *)(a1 + 912);
      v52 = *(_QWORD **)(a1 + 1008);
      if (v52)
      {
        v53 = (uint64_t *)(v22 + 1008);
        do
        {
          out[0] = 0;
          v54 = (_QWORD *)sub_100019770((uint64_t)v52, out);
          v55 = *v53;
          *v54 = *v53;
          if (v55)
            *(_QWORD *)(v55 + 8) = v54;
          *((_QWORD *)v22 + 126) = v54;
          v54[1] = v53;
          ++*((_WORD *)v22 + 508);
          *((_QWORD *)v22 + 74) += out[0];
          v52 = (_QWORD *)*v52;
        }
        while (v52);
      }
      v56 = *((_QWORD *)v22 + 172);
      v57 = *((_QWORD *)v22 + 173) & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(a1 + 1384) & 1;
      *((_QWORD *)v22 + 173) = v57;
      v58 = v56 & 0xFFFFFFFFFFFFFFFELL | *(_QWORD *)(a1 + 1376) & 1;
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v58;
      v59 = v58 & 0xFFFFFFFFFFFFFFFDLL | (2 * ((*(_QWORD *)(a1 + 1376) >> 1) & 1));
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v59;
      v60 = v59 & 0xFFFFFFFFFFFFFFFBLL | (4 * ((*(_QWORD *)(a1 + 1376) >> 2) & 1));
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v60;
      v61 = v60 & 0xFFFFFFFFFFFFFFF7 | (8 * ((*(_QWORD *)(a1 + 1376) >> 3) & 1));
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v61;
      v62 = v61 & 0xFFFFFFFFFFFFFFDFLL | (32 * ((*(_QWORD *)(a1 + 1376) >> 5) & 1));
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v62;
      v63 = v62 & 0xFFFFFFFFFFFFFFBFLL | (((*(_QWORD *)(a1 + 1376) >> 6) & 1) << 6);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v63;
      v22[1332] = *(_BYTE *)(a1 + 1332);
      v64 = v63 & 0xFFFFFFFFFFFFFEFFLL | (((*(_QWORD *)(a1 + 1376) >> 8) & 1) << 8);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v64;
      v65 = v64 & 0xFFFFFFFFFFFFFDFFLL | (((*(_QWORD *)(a1 + 1376) >> 9) & 1) << 9);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v65;
      v66 = v65 & 0xFFFFFFFFFFFFFBFFLL | (((*(_QWORD *)(a1 + 1376) >> 10) & 1) << 10);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v66;
      v67 = v66 & 0xFFFFFFFFFFFEFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 16) & 1) << 16);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v67;
      v68 = v67 & 0xFFFFFFFFFF7FFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 23) & 1) << 23);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v68;
      v69 = v68 & 0xFFFFFFFFFEFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 24) & 1) << 24);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v69;
      v70 = v69 & 0xFF7FFFFFFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 55) & 1) << 55);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v70;
      v71 = v70 & 0xFFFFFFFFBFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 30) & 1) << 30);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v71;
      *((_OWORD *)v22 + 62) = *(_OWORD *)(a1 + 992);
      v72 = v71 & 0xFFFFFFFDFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 33) & 1) << 33);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v72;
      v22[1040] = *(_BYTE *)(a1 + 1040);
      v73 = v72 & 0xFFDFFFFFFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 53) & 1) << 53);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v73;
      *((_WORD *)v22 + 514) = *(_WORD *)(a1 + 1028);
      v74 = v73 & 0xFFEFFFFFFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 52) & 1) << 52);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v74;
      v75 = v74 & 0xFFFFFFFBFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 34) & 1) << 34);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v75;
      v76 = *(const char **)(a1 + 584);
      if (v76)
      {
        *((_QWORD *)v22 + 73) = sub_10001544C(v76);
        v57 = *((_QWORD *)v22 + 173);
        v75 = *((_QWORD *)v22 + 172);
      }
      *((_DWORD *)v22 + 217) = *(_DWORD *)(a1 + 868);
      v77 = v75 & 0xFFFFFEFFFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 40) & 1) << 40);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v77;
      v78 = v77 & 0xFFFFF7FFFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 43) & 1) << 43);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v78;
      v79 = v78 & 0xFFFFEFFFFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 44) & 1) << 44);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v79;
      *((_DWORD *)v22 + 332) = *(_DWORD *)(a1 + 1328);
      v80 = v79 & 0xFFFFBFFFFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 46) & 1) << 46);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v80;
      v81 = v80 & 0xFFFF7FFFFFFFFFFFLL | (((*(_QWORD *)(a1 + 1376) >> 47) & 1) << 47);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v81;
      v82 = v81 & 0xFFFEFFFFFFFFFFFFLL | ((HIWORD(*(_QWORD *)(a1 + 1376)) & 1) << 48);
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v82;
      v83 = *(_QWORD *)(a1 + 1376) >> 50;
      *((_QWORD *)v22 + 173) = v57;
      *((_QWORD *)v22 + 172) = v82 & 0xFFFBFFFFFFFFFFFFLL | ((unint64_t)(v83 & 1) << 50);
      *((_DWORD *)v22 + 335) = *(_DWORD *)(a1 + 1340);
      v84 = *(void **)(a1 + 640);
      if (v84)
        *((_QWORD *)v22 + 80) = xpc_retain(v84);
      v85 = *(void **)(a1 + 648);
      if (v85)
        *((_QWORD *)v22 + 81) = xpc_retain(v85);
      v86 = *(void **)(a1 + 496);
      if (v86)
      {
        if (*(_BYTE *)(a1 + 1344) == 2)
          *((_QWORD *)v22 + 62) = xpc_retain(v86);
        else
          sub_10001D418((uint64_t)v22, 4, "Service instances do not support XPC events.", v40, v41, v42, v43, v44, v92);
      }
      v87 = *(const char **)(a1 + 1360);
      if (v87)
        *((_QWORD *)v22 + 170) = sub_10001544C(v87);
      v88 = *(const char **)(a1 + 1368);
      if (v88)
        *((_QWORD *)v22 + 171) = sub_10001544C(v88);
      v89 = *(const void **)(a1 + 600);
      if (v89)
      {
        *((_QWORD *)v22 + 75) = sub_10001541C(v89, *(unsigned int *)(a1 + 608));
        *((_DWORD *)v22 + 152) = *(_DWORD *)(a1 + 608);
      }
      v90 = *(const void **)(a1 + 616);
      if (v90)
      {
        *((_QWORD *)v22 + 77) = sub_10001541C(v90, *(unsigned int *)(a1 + 624));
        *((_DWORD *)v22 + 156) = *(_DWORD *)(a1 + 624);
      }
      *((_QWORD *)v22 + 74) = *(_QWORD *)(a1 + 592);
      memset(out, 0, 37);
      uuid_unparse(a2, (char *)out);
      sub_100005AFC((uint64_t)v22, "LaunchInstanceID", (const char *)out, 1);
    }
    else
    {
      v24 = v23;
      *a9 = v23;
      strerror(v23);
      sub_10001D418(a1, 3, "Could not set up nowait inetd service: %d: %s", v25, v26, v27, v28, v29, v24);
      sub_10001962C(v22);
      return 0;
    }
  }
  return v22;
}

uint64_t sub_100006F78(uint64_t a1, const void *a2)
{
  uint64_t v4;
  uint64_t result;

  v4 = *(_QWORD *)(a1 + 904);
  if (v4)
  {
    *(_QWORD *)(a1 + 592) -= _xpc_spawnattr_binprefs_size(v4);
    free(*(void **)(a1 + 904));
  }
  *(_QWORD *)(a1 + 904) = xpc_binprefs_copy(a2);
  result = _xpc_spawnattr_binprefs_size((uint64_t)a2);
  *(_QWORD *)(a1 + 592) += result;
  return result;
}

size_t sub_100006FD8(uint64_t a1, const char *a2)
{
  void *v4;
  size_t result;

  v4 = *(void **)(a1 + 480);
  if (v4)
  {
    *(_QWORD *)(a1 + 592) += ~strlen(*(const char **)(a1 + 480));
    free(v4);
  }
  *(_QWORD *)(a1 + 480) = sub_10001544C(a2);
  result = strlen(a2);
  *(_QWORD *)(a1 + 592) += result + 1;
  return result;
}

uint64_t sub_10000704C(uint64_t a1, uint64_t a2, _BYTE *a3)
{
  uint64_t v6;
  void *v7;
  void *v8;
  unint64_t v9;
  const char *v10;
  void *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  char v17;
  char *v18;
  char **v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  _BYTE *v32;
  _QWORD *v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const char *v42;
  char *v43;
  const char *v45;
  char v46;
  _QWORD applier[5];

  if (!sub_1000291BC(a2))
  {
    v7 = (void *)sub_10002E360(a2);
    v8 = v7;
    v9 = *(_QWORD *)(a1 + 1376);
    if ((v9 & 0x40000000) != 0 && v7 != &unk_100071750)
    {
      sub_100014830(a3, 3, "_AbandonCoalition is only available to Application services.");
      v9 = *(_QWORD *)(a1 + 1376) & 0xFFFFFFFFBFFFFFFFLL;
      *(_QWORD *)(a1 + 1376) = v9;
    }
    if ((v9 & 0x80000000000) != 0 && v8 != &unk_1000715B8)
    {
      sub_100014830(a3, 3, "DisallowAllLookups is not supported for non-System services.");
      *(_QWORD *)(a1 + 1376) &= ~0x80000000000uLL;
    }
    if (!sub_100028DB4(a2))
    {
      if (*(_QWORD *)(a1 + 800))
      {
        v10 = (*(_QWORD *)(a1 + 1376) & 2) != 0 ? "_RoleAccount" : "UserName";
        sub_100014830(a3, 3, "%s is not supported by the domain, ignoring.", v10);
        v11 = *(void **)(a1 + 800);
        if (v11)
        {
          *(_QWORD *)(a1 + 592) += ~strlen(*(const char **)(a1 + 800));
          free(v11);
          *(_QWORD *)(a1 + 800) = 0;
        }
      }
      if (*(_QWORD *)(a1 + 808))
      {
        sub_100014830(a3, 3, "GroupName is not supported by the domain, ignoring.");
        v12 = *(char **)(a1 + 808);
        *(_QWORD *)(a1 + 592) += ~strlen(v12);
        free(v12);
        *(_QWORD *)(a1 + 808) = 0;
      }
    }
    v13 = *(_QWORD *)(a1 + 1376);
    if ((v13 & 0x400000000000) != 0)
    {
      if ((v13 & 0x40400000000) == 0)
      {
        v6 = 144;
        sub_100014830(a3, 3, "persona can only be set on submitted jobs and extensions");
        return v6;
      }
      if ((sub_10000FEF4(a1 + 376, 3) & 1) == 0 && !sub_10000FEF4(a1 + 376, 15))
      {
        v6 = 144;
        sub_100014830(a3, 3, "setting persona requires an entitlement");
        return v6;
      }
    }
    v14 = *(_QWORD *)(a1 + 1384);
    v15 = *(_QWORD *)(a1 + 1376);
    if ((v15 & 0x1000000000000000) != 0)
    {
      if ((v15 & 0x40400000000) == 0
        || (v16 = sub_10000FEF4(a1 + 376, 30),
            v14 = *(_QWORD *)(a1 + 1384),
            v15 = *(_QWORD *)(a1 + 1376),
            (v16 & 1) == 0))
      {
        if ((v15 & 0x100000000000) == 0)
        {
          v6 = 1;
          sub_100014830(a3, 3, "_Cryptex can only be set on trusted services");
          return v6;
        }
      }
    }
    if (*(_QWORD *)(a1 + 1368))
    {
      if ((v15 & 0x40400000000) == 0
        || (v17 = sub_10000FEF4(a1 + 376, 31),
            v14 = *(_QWORD *)(a1 + 1384),
            v15 = *(_QWORD *)(a1 + 1376),
            (v17 & 1) == 0))
      {
        if ((v15 & 0x100000000000) == 0)
        {
          v6 = 1;
          sub_100014830(a3, 3, "_Conclave can only be set on trusted services");
          return v6;
        }
      }
    }
    if ((v15 & 0x8000000) != 0)
      sub_10004D738();
    *(_QWORD *)(a1 + 1384) = v14;
    *(_QWORD *)(a1 + 1376) = v15 | 0x8000000;
    *(_QWORD *)(a1 + 248) = a2;
    (*(void (**)(uint64_t, _QWORD))(a1 + 560))(a1, *(_QWORD *)(a1 + 568));
    v18 = *(char **)(*(_QWORD *)(a1 + 248) + 48);
    while (v18)
    {
      v19 = (char **)v18;
      v18 = *(char **)v18;
      if (sub_1000157A8(v19[2], (const char *)(a1 + 1392)))
      {
        sub_10001D418(a1, 5, "matched domain attach request on creation", v20, v21, v22, v23, v24, v46);
        sub_100044BF8(dword_100072A00, v19[3]);
        xpc_release(v19[3]);
        v25 = *v19;
        if (*v19)
          *((_QWORD *)v25 + 1) = v19[1];
        *(_QWORD *)v19[1] = v25;
        free(v19);
        break;
      }
    }
    if (*(_QWORD *)(a1 + 496))
    {
      if (sub_100023BD4(a1))
      {
        sub_10001D418(a1, 5, "Ignoring events for retain only services", v26, v27, v28, v29, v30, v46);
      }
      else
      {
        if (byte_100072A79)
          sub_10001D418(a1, 5, "Operating in pure on-demand mode. Ignoring events", v26, v27, v28, v29, v30, v46);
        else
          xpc_dictionary_apply_f(*(_QWORD *)(a1 + 496));
        if ((*(_BYTE *)(a1 + 1377) & 0x40) == 0 && !*(_BYTE *)(a1 + 1344))
        {
          xpc_release(*(xpc_object_t *)(a1 + 496));
          *(_QWORD *)(a1 + 496) = 0;
        }
      }
    }
    v31 = *(void **)(a1 + 504);
    if (v31)
    {
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000;
      applier[2] = sub_10000825C;
      applier[3] = &unk_1000691C8;
      applier[4] = a1;
      xpc_dictionary_apply(v31, applier);
      xpc_release(*(xpc_object_t *)(a1 + 504));
      *(_QWORD *)(a1 + 504) = 0;
      v32 = sub_10001389C(0x28uLL);
      v32[32] = 1;
      *((_QWORD *)v32 + 2) = sub_10001D274;
      *((_QWORD *)v32 + 3) = "provides events";
      v33 = (_QWORD *)(a1 + 672);
      v34 = *(_QWORD *)(a1 + 672);
      *(_QWORD *)v32 = v34;
      if (v34)
        *(_QWORD *)(v34 + 8) = v32;
      *v33 = v32;
      *((_QWORD *)v32 + 1) = v33;
    }
    v35 = sub_100039000();
    v41 = *(_QWORD *)(a1 + 1376);
    if (v35 || (v41 & 0x400001000) == 0)
    {
      v6 = 0;
      *(_QWORD *)(a1 + 1384) = *(_QWORD *)(a1 + 1384);
      *(_QWORD *)(a1 + 1376) = v41 | 0x2000000000000;
      return v6;
    }
    if ((v41 & 0x80000) != 0)
    {
      v42 = "it has a roleaccount set";
    }
    else if (*(_QWORD *)(a1 + 680))
    {
      v42 = "it has limits set";
    }
    else if (*(_QWORD *)(a1 + 440))
    {
      v42 = "it set a non standard working directory";
    }
    else if ((v41 & 0x100000000) != 0)
    {
      v42 = "it set a non standard umask";
    }
    else if ((v41 & 0x60) != 0)
    {
      v42 = "it set an io priority";
    }
    else
    {
      v45 = (const char *)sub_10001CFB8(a1);
      if (access(v45, 1))
      {
        v42 = "its binary is missing or not executable";
      }
      else if (*(_QWORD *)(a1 + 1360))
      {
        v42 = "is from a cryptex";
      }
      else if ((*(_BYTE *)(a1 + 1379) & 0x80) != 0)
      {
        v42 = "it disabled initgroups";
      }
      else
      {
        sub_100008424(a1);
        if (!v42)
        {
          if (byte_100071AC4)
          {
            v43 = "service will attempt to elide xpcproxy";
          }
          else
          {
            *(_QWORD *)(a1 + 1376) |= 0x2000000000000uLL;
            v43 = "service will always use xpcproxy, elision was disabled by boot-arg";
          }
          goto LABEL_63;
        }
      }
    }
    *(_QWORD *)(a1 + 1376) |= 0x2000000000000uLL;
    v46 = (char)v42;
    v43 = "service will always use xpcproxy because %s";
LABEL_63:
    sub_10001D418(a1, 5, v43, v36, v37, v38, v39, v40, v46);
    return 0;
  }
  return 124;
}

void sub_1000075A0(_QWORD *guard)
{
  uint64_t v1;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;

  v1 = guard[172];
  if ((v1 & 0x10000000) != 0)
    sub_10003E208("attempted to petrify a service twice");
  guard[173] = guard[173];
  guard[172] = v1 | 0x10000000;
  if ((v1 & 0x8000000) == 0)
    sub_10003E208("attempted to petrify a service that hasn't been animated");
  v3 = (_QWORD *)guard[17];
  if (v3)
  {
    do
    {
      v4 = (_QWORD *)v3[2];
      sub_10003ACA8(v3);
      sub_10001962C(v3);
      v3 = v4;
    }
    while (v4);
  }
  v5 = (_QWORD *)guard[18];
  if (v5)
  {
    do
    {
      v6 = (_QWORD *)v5[2];
      sub_10003A788((uint64_t)v5);
      sub_10001962C(v5);
      v5 = v6;
    }
    while (v6);
  }
  sub_100023A6C((mach_port_context_t)guard);
  sub_10001D2D4((uint64_t)guard, 9, 0);
}

char *sub_10000766C(uint64_t a1, uint64_t a2, _OWORD *a3, void *a4, uint64_t a5, unint64_t a6, int *a7)
{
  uint64_t property;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  void *info_dictionary;
  void *v22;
  const char *string;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  xpc_object_t value;
  uint64_t *v31;
  uint64_t *v32;
  _BYTE *v33;
  uint64_t v34;
  const char *v35;
  void *v36;
  void *v37;
  uint64_t executable_path;
  char *v39;
  xpc_object_t v40;
  void *v41;
  xpc_type_t type;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  xpc_object_t v48;
  xpc_object_t dictionary;
  const char *v50;
  xpc_object_t v51;
  xpc_object_t v52;
  xpc_object_t v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  uint64_t *v57;
  _BYTE *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  _BOOL4 v67;
  uint64_t v68;
  uint64_t *v69;
  xpc_object_t v70;
  xpc_object_t v71;
  int v72;
  BOOL v73;
  int v74;
  char v75;
  const char *v76;
  xpc_object_t v77;
  xpc_object_t object;
  char *v79;
  _BYTE *v80;

  property = xpc_bundle_get_property(a2, 2);
  if (!property)
  {
    *a7 = 107;
    v43 = "Could not get path for service bundle.";
LABEL_18:
    sub_100028C34(a1, 3, v43, v15, v16, v17, v18, v19, v75);
    return 0;
  }
  v20 = property;
  info_dictionary = (void *)xpc_bundle_get_info_dictionary(a2);
  if (!info_dictionary)
  {
    *a7 = 107;
    v75 = v20;
    v43 = "Could not get Info.plist for bundle at %s";
    goto LABEL_18;
  }
  v22 = info_dictionary;
  string = xpc_dictionary_get_string(info_dictionary, "CFBundleIdentifier");
  if (!string)
  {
    sub_100028C34(a1, 3, "Bundle Info.plist at %s does not have a CFBundleIdentifier", v24, v25, v26, v27, v28, v20);
    goto LABEL_20;
  }
  v29 = string;
  value = xpc_dictionary_get_value(v22, "XPCService");
  if (value)
  {
    v31 = sub_100007CBC(value, a1, v29);
    if (v31)
    {
      v32 = v31;
      xpc_dictionary_set_value(v22, "XPCService", v31);
      xpc_release(v32);
      goto LABEL_7;
    }
LABEL_20:
    v44 = 0;
    *a7 = 107;
    return v44;
  }
LABEL_7:
  v33 = sub_100014738(a1, v29);
  v34 = xpc_bundle_get_property(a2, 2);
  if (!v34)
    sub_10004D738();
  v35 = (const char *)v34;
  v36 = (void *)xpc_bundle_get_info_dictionary(a2);
  if (!v36)
    sub_10004D738();
  v37 = v36;
  v79 = (char *)xpc_dictionary_get_string(v36, "CFBundleIdentifier");
  if (!v79)
    sub_10004D738();
  executable_path = xpc_bundle_get_executable_path(a2);
  if (!executable_path)
  {
    sub_100014830(v33, 3, "Bundle has no executable");
LABEL_26:
    *a7 = 107;
    goto LABEL_27;
  }
  v39 = (char *)executable_path;
  v80 = v33;
  v40 = xpc_dictionary_get_value(v37, "XPCService");
  if (!v40)
  {
    v45 = "XPC Service Info.plist is missing XPCService dictionary";
LABEL_25:
    v33 = v80;
    sub_100014830(v80, 3, v45);
    goto LABEL_26;
  }
  v41 = v40;
  type = xpc_get_type(v40);
  if (v41 == &_xpc_BOOL_false && type == (xpc_type_t)&_xpc_type_BOOL)
  {
    *a7 = 107;
LABEL_15:
    v33 = v80;
LABEL_27:
    v46 = (uint64_t)v33;
LABEL_28:
    sub_1000147FC(v46);
    return 0;
  }
  if (xpc_get_type(v41) != (xpc_type_t)&_xpc_type_dictionary)
  {
    v45 = "XPCService must be dictionary";
    goto LABEL_25;
  }
  if ((a6 & 0x40) != 0)
  {
    dictionary = xpc_dictionary_get_dictionary(v37, "EXAppExtensionAttributes");
    if (dictionary)
    {
      v50 = xpc_dictionary_get_string(dictionary, "EXExtensionPointIdentifier");
      if (!v50)
      {
        v45 = "App Extension Info.plist is missing EXExtentionPointIdentifier";
        goto LABEL_25;
      }
    }
    else
    {
      v51 = xpc_dictionary_get_dictionary(v37, "NSExtension");
      if (!v51 || (v50 = xpc_dictionary_get_string(v51, "NSExtensionPointIdentifier")) == 0)
      {
        v45 = "App Extension Info.plist is missing NSExtentionPointIdentifier";
        goto LABEL_25;
      }
    }
    if (a4 && (v52 = xpc_dictionary_get_value(a4, "XPCService")) != 0)
      v77 = xpc_dictionary_get_value(v52, "ProgramArguments");
    else
      v77 = 0;
    v76 = v50;
    v48 = sub_10000F2CC(v50);
  }
  else
  {
    v48 = sub_10000F348(v79, v41);
    v76 = 0;
    v77 = 0;
  }
  sub_10000E810(v48, v80);
  sub_100008520(v41, v48, v80, 1);
  object = v48;
  v53 = xpc_dictionary_get_value(v48, "ExecuteAllowed");
  if (v53)
  {
    v54 = v53;
    if (xpc_get_type(v53) == (xpc_type_t)&_xpc_type_BOOL)
    {
      v73 = xpc_BOOL_get_value(v54);
      if ((a6 & 0x200) == 0 && !v73)
      {
        *a7 = 157;
        goto LABEL_62;
      }
    }
  }
  v55 = sub_1000432C8((uint64_t)v41);
  v56 = sub_10001CED4((uint64_t)v79, v39, v35, v55);
  sub_10001962C(v55);
  v44 = sub_100007D2C(v56, a3, v79, v77, a5, a6, a7, v80);
  sub_10001962C(v56);
  if (!v44)
  {
LABEL_62:
    xpc_release(object);
    goto LABEL_15;
  }
  *((_QWORD *)v44 + 172) |= 0x4000000002uLL;
  if ((a6 & 0x40) != 0)
  {
    v67 = sub_1000156F0(v79, "com.apple.");
    v68 = *((_QWORD *)v44 + 172);
    if (!v67)
      v68 |= 0x8000000000uLL;
    *((_QWORD *)v44 + 172) = v68 | 0x40000000;
    v69 = sub_10001952C(v44, 1, (uint64_t)v80, 0);
    xpc_dictionary_apply_f(v41);
    sub_1000195F8(v69);
    v58 = v80;
    sub_100008E84((uint64_t)v44, v41);
    sub_10000E974((uint64_t)v44, object, (uint64_t)v80);
    nullsub_23(v44, object);
    xpc_release(object);
    if (v76)
      *((_QWORD *)v44 + 73) = sub_10001544C(v76);
    if (a4)
    {
      v70 = xpc_dictionary_get_value(a4, "XPCService");
      if (v70)
      {
        v71 = xpc_dictionary_get_value(v70, "PersonaEnterprise");
        if (v71)
        {
          *((_DWORD *)v44 + 332) = xpc_int64_get_value(v71);
          *((_QWORD *)v44 + 172) |= 0x400000000000uLL;
        }
      }
    }
    v65 = *((_QWORD *)v44 + 173);
    v66 = *((_QWORD *)v44 + 172) & 0xFFFFFFFFFFFFFCFFLL;
  }
  else
  {
    v57 = sub_10001952C(v44, 1, (uint64_t)v80, 0);
    xpc_dictionary_apply_f(v41);
    sub_1000195F8(v57);
    v58 = v80;
    sub_100008E84((uint64_t)v44, v41);
    sub_10000E974((uint64_t)v44, object, (uint64_t)v80);
    nullsub_23(v44, object);
    xpc_release(object);
    v65 = *((_QWORD *)v44 + 173);
    v66 = *((_QWORD *)v44 + 172);
  }
  *((_QWORD *)v44 + 72) = v44 + 1392;
  *((_QWORD *)v44 + 173) = v65;
  *((_QWORD *)v44 + 172) = v66 | 0x1000000000;
  sub_100008F1C((uint64_t)v44, a6, v59, v60, v61, v62, v63, v64);
  sub_100008FA4((uint64_t)v44);
  v72 = sub_10000704C((uint64_t)v44, a1, v58);
  *a7 = v72;
  if (v72)
  {
    sub_10001962C(v44);
    v46 = (uint64_t)v58;
    goto LABEL_28;
  }
  if (*((_QWORD *)v44 + 62))
  {
    sub_100014830(v58, 4, "Ignoring launch events for a bundle");
    xpc_release(*((xpc_object_t *)v44 + 62));
    *((_QWORD *)v44 + 62) = 0;
  }
  sub_1000147FC((uint64_t)v58);
  v74 = byte_100072A47;
  if ((v44[1380] & 4) != 0)
    v74 = byte_100072A48 | byte_100072A47;
  if (v74)
  {
    *(_QWORD *)(v44 + 924) = -1;
    *((_DWORD *)v44 + 229) &= 0xFFFFFFF3;
  }
  return v44;
}

uint64_t *sub_100007CBC(void *a1, uint64_t a2, const char *a3)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char v12;

  v4 = sub_100014738(a2, a3);
  v10 = sub_100039524(a1, v4);
  if (*((_BYTE *)v4 + 16))
  {
    sub_100041468((const char *)v4[1], 3, "Plist preprocessing failed, rejecting", v5, v6, v7, v8, v9, v12);
    xpc_release(v10);
    v10 = 0;
  }
  sub_1000147FC((uint64_t)v4);
  return v10;
}

char *sub_100007D2C(void *a1, _OWORD *a2, char *__s1, void *a4, uint64_t a5, unint64_t a6, int *a7, _BYTE *a8)
{
  const char *v13;
  char *v16;
  int v17;
  char *v18;
  uint64_t v19;
  size_t v20;
  xpc_object_t value;
  char *result;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  size_t v29;
  char *v30;
  xpc_object_t v31;
  const char *string_ptr;
  size_t length;
  __int128 v34;
  const char *v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  unint64_t v41;
  void *v42;
  const char *v43;
  int v44;

  v13 = __s1;
  if (!strcmp(__s1, "shell"))
  {
    v16 = 0;
    v17 = 140;
    goto LABEL_7;
  }
  if (!a4)
  {
    v18 = 0;
    v19 = 0;
    v44 = 0;
LABEL_24:
    v16 = sub_100019CC8(v13);
    *((_QWORD *)v16 + 2) = sub_100019580(a1);
    if (a2)
    {
      v34 = a2[1];
      *(_OWORD *)(v16 + 376) = *a2;
      *(_OWORD *)(v16 + 392) = v34;
    }
    v16[424] = 0;
    v35 = (const char *)sub_10001CFB8((uint64_t)v16);
    *((_QWORD *)v16 + 74) = v19 + strlen(v35) + 241;
    *((_DWORD *)v16 + 107) = v44;
    *((_QWORD *)v16 + 54) = v18;
    *((_DWORD *)v16 + 209) = 10;
    *((_DWORD *)v16 + 208) = dword_100071A90;
    *((_OWORD *)v16 + 75) = 0u;
    *((_OWORD *)v16 + 76) = 0u;
    *((_OWORD *)v16 + 77) = 0u;
    *((_QWORD *)v16 + 156) = 0;
    *((_DWORD *)v16 + 216) = 5;
    *((_DWORD *)v16 + 217) = dword_100071A98;
    *((_QWORD *)v16 + 112) = 1536;
    *((_WORD *)v16 + 660) = 0;
    *((_QWORD *)v16 + 164) = 0xFFFFFFFFLL;
    *((_DWORD *)v16 + 232) = -1;
    v16[1018] = 0;
    *((_DWORD *)v16 + 255) = 0;
    *((_OWORD *)v16 + 57) = xmmword_10004FCC0;
    v36 = *(_OWORD *)(a5 + 32);
    *(_OWORD *)(v16 + 536) = *(_OWORD *)(a5 + 16);
    *(_OWORD *)(v16 + 552) = v36;
    *(_OWORD *)(v16 + 520) = *(_OWORD *)a5;
    *((_QWORD *)v16 + 71) = *(_QWORD *)(a5 + 48);
    *((_QWORD *)v16 + 86) = -1;
    *((_DWORD *)v16 + 174) = -1;
    v16[1041] = 1;
    *((_QWORD *)v16 + 172) |= 0x300uLL;
    v37 = sub_100003D90(v16 + 1392);
    *((_QWORD *)v16 + 25) = 0;
    *(_QWORD *)(v16 + 1348) = v37;
    v38 = *((_QWORD *)v16 + 173);
    v39 = *((_QWORD *)v16 + 172) | 0x8000000000000;
    *((_QWORD *)v16 + 172) = v39;
    *((_WORD *)v16 + 514) = 10;
    *((_DWORD *)v16 + 60) = *((_DWORD *)v16 + 56);
    *((_QWORD *)v16 + 29) = *((_QWORD *)v16 + 27);
    *((_DWORD *)v16 + 56) = 3044;
    *((_QWORD *)v16 + 26) = v16 + 200;
    *((_QWORD *)v16 + 27) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/service_create.c";
    *(_QWORD *)&v40 = -1;
    *((_QWORD *)&v40 + 1) = -1;
    *(_OWORD *)(v16 + 24) = v40;
    *(_OWORD *)(v16 + 40) = v40;
    if ((a6 & 4) == 0)
    {
      sub_100005AFC((uint64_t)v16, "XPC_SERVICE_NAME", v13, 1);
      v38 = *((_QWORD *)v16 + 173);
      v39 = *((_QWORD *)v16 + 172);
    }
    if ((a6 & 0x202C0) != 0)
    {
      *((_QWORD *)v16 + 173) = v38;
      *((_QWORD *)v16 + 172) = v39 | (a6 << 33) & 0x10000000000 | (a6 << 27) & 0x100000000000 | (a6 << 33) & 0x40000000000 | (((a6 >> 6) & 1) << 34);
    }
    *((_DWORD *)v16 + 335) = 0;
    v16[984] = (v39 & 0x100000000000 | (a6 << 27) & 0x100000000000) != 0;
    if ((a6 & 0x8000) != 0)
      sub_100008124((uint64_t)v16, "com.apple.cryptex.app");
    return v16;
  }
  if (xpc_get_type(a4) != (xpc_type_t)&_xpc_type_array)
  {
    sub_100014830(a8, 3, "ProgramArguments is not an array.");
LABEL_5:
    v16 = 0;
    v17 = 111;
LABEL_7:
    *a7 = v17;
    return v16;
  }
  v42 = a1;
  v43 = v13;
  v41 = a6;
  if (xpc_array_get_count(a4))
  {
    v20 = 0;
    v19 = 0;
    while (1)
    {
      value = xpc_array_get_value(a4, v20);
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_string)
        break;
      v19 += xpc_string_get_length(value) + 1;
      if (++v20 >= xpc_array_get_count(a4))
        goto LABEL_15;
    }
    sub_100014830(a8, 3, "ProgramArguments is not an array of strings.", a6);
    goto LABEL_5;
  }
  v19 = 0;
LABEL_15:
  result = (char *)xpc_array_get_count(a4);
  v23 = result + 1;
  v24 = v23 << 31 >> 31;
  if (v24 == v23 && (v24 & 0x8000000000000000) == 0)
  {
    v25 = (uint64_t)result;
    v26 = v24 & 0x1FFFFFFFFLL;
    result = (char *)(v19 + 8 * v26);
    a1 = v42;
    v13 = v43;
    if (!__CFADD__(v19, 8 * v26))
    {
      v27 = (char *)sub_10001389C((size_t)result);
      v18 = v27;
      v28 = v25;
      v44 = v25;
      if ((_DWORD)v25)
      {
        v29 = 0;
        v30 = &v27[(8 * v25 + 8) & 0x7FFFFFFF8];
        do
        {
          v31 = xpc_array_get_value(a4, v29);
          string_ptr = xpc_string_get_string_ptr(v31);
          length = xpc_string_get_length(v31);
          *(_QWORD *)&v18[8 * v29] = v30;
          strcpy(v30, string_ptr);
          v30 += length + 1;
          ++v29;
        }
        while (v28 != v29);
        a6 = v41;
        a1 = v42;
        v13 = v43;
      }
      else
      {
        a6 = v41;
      }
      goto LABEL_24;
    }
  }
  __break(1u);
  return result;
}

size_t sub_100008124(uint64_t a1, const char *a2)
{
  void *v4;
  size_t result;

  v4 = *(void **)(a1 + 1360);
  if (v4)
  {
    *(_QWORD *)(a1 + 592) += ~strlen(*(const char **)(a1 + 1360));
    free(v4);
    *(_QWORD *)(a1 + 1360) = 0;
  }
  *(_QWORD *)(a1 + 1360) = sub_10001544C(a2);
  result = strlen(a2);
  *(_QWORD *)(a1 + 592) += result + 1;
  return result;
}

void sub_10000819C(char *a1, xpc_object_t object, uint64_t a3)
{
  const _xpc_type_s *type;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *string_ptr;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    if ((*(_BYTE *)(a3 + 1380) & 0x80) != 0 || !sub_1000198D8(a1))
    {
      string_ptr = xpc_string_get_string_ptr(object);
      sub_100005AFC(a3, a1, string_ptr, 0);
    }
    else
    {
      sub_10001D418(a3, 3, "Disallowing environment variable: %s", v12, v13, v14, v15, v16, (char)a1);
    }
  }
  else
  {
    type = xpc_get_type(object);
    xpc_type_get_name(type);
    sub_10001D418(a3, 3, "Invalid type for environment variable value (env/type): %s/%s", v7, v8, v9, v10, v11, (char)a1);
  }
}

uint64_t sub_10000825C(uint64_t a1, const void *a2, xpc_object_t object)
{
  uint64_t v6;
  char value;

  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_uint64)
    sub_10004D738();
  v6 = *(_QWORD *)(a1 + 32);
  value = xpc_uint64_get_value(object);
  sub_10003A32C(v6, a2, value, 0);
  return 1;
}

void sub_1000082C8(uint64_t a1, xpc_object_t object, uint64_t a3)
{
  const _xpc_type_s *type;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD applier[6];

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_100008384;
    applier[3] = &unk_1000691E8;
    applier[4] = a3;
    applier[5] = a1;
    xpc_dictionary_apply(object, applier);
  }
  else
  {
    type = xpc_get_type(object);
    xpc_type_get_name(type);
    sub_10001D418(a3, 3, "Invalid type for event stream (stream/type): %s/%s", v7, v8, v9, v10, v11, a1);
    *(_QWORD *)(a3 + 1376) |= 1uLL;
  }
}

uint64_t sub_100008384(uint64_t a1, const char *a2, xpc_object_t object)
{
  xpc_type_t type;
  uint64_t v7;
  const _xpc_type_s *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  type = xpc_get_type(object);
  v7 = *(_QWORD *)(a1 + 32);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10003AAC4(*(_QWORD **)(a1 + 32), *(const void **)(a1 + 40), a2, object);
  }
  else
  {
    v8 = xpc_get_type(object);
    xpc_type_get_name(v8);
    sub_10001D418(v7, 3, "Invalid type for event (event/type): %s/%s", v9, v10, v11, v12, v13, (char)a2);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1376) |= 1uLL;
  }
  return 1;
}

double sub_100008424(uint64_t a1)
{
  const char *v2;
  uint64_t v3;
  double result;
  __int128 v5;
  __int128 v6;
  _DWORD v7[4];
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int v13;

  *(_QWORD *)(a1 + 720) = 0x6400000064;
  bzero(v7, 0x1090uLL);
  v2 = *(const char **)(a1 + 800);
  if (!v2)
  {
    v3 = *(_QWORD *)(a1 + 248);
    if ((*(_BYTE *)(v3 + 104) & 1) != 0)
    {
      if (sub_100019EF0(*(_DWORD *)(v3 + 56), v7))
        return result;
      goto LABEL_6;
    }
  }
  if (!sub_10001A02C(v2, *(const char **)(a1 + 808), (uint64_t)v7))
  {
LABEL_6:
    *(_QWORD *)(a1 + 720) = v8;
    v5 = v10;
    *(_OWORD *)(a1 + 728) = v9;
    *(_OWORD *)(a1 + 744) = v5;
    result = *(double *)&v11;
    v6 = v12;
    *(_OWORD *)(a1 + 760) = v11;
    *(_OWORD *)(a1 + 776) = v6;
    *(_DWORD *)(a1 + 792) = v13;
  }
  return result;
}

void sub_100008520(void *a1, xpc_object_t xdict, _BYTE *a3, int a4)
{
  xpc_object_t value;
  xpc_object_t v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;

  value = xpc_dictionary_get_value(xdict, "EnablePressuredExit");
  v9 = xpc_dictionary_get_value(xdict, "EnableTransactions");
  if (xpc_dictionary_get_BOOL(a1, "KeepAlive"))
  {
    if (a4)
      sub_10003E208("XPC bundles can't have KeepAlive, they can't even set it as a plist key, how did we get here?");
    v10 = 1;
    if (!v9)
    {
      v11 = 4;
      v12 = 1;
      goto LABEL_19;
    }
LABEL_18:
    v12 = xpc_BOOL_get_value(v9);
    v11 = 0;
LABEL_19:
    v13 = 0;
    if (!value)
      goto LABEL_23;
    goto LABEL_20;
  }
  if (value)
  {
    v10 = 0;
    if (xpc_BOOL_get_value(value))
    {
      v11 = 3;
      v12 = 1;
      v13 = 1;
    }
    else
    {
      if (v9)
        goto LABEL_18;
      v13 = 0;
      if (a4)
        v11 = 5;
      else
        v11 = 4;
      v12 = 1;
    }
LABEL_20:
    v14 = xpc_BOOL_get_value(value);
    if (v10 == 1 && v13 != v14)
    {
      sub_100014830(a3, 3, "EnablePressuredExit is not compatible with KeepAlive=true. Ignoring EnablePressuredExit.");
      goto LABEL_25;
    }
LABEL_23:
    if (v10 == 2)
      sub_100014830(a3, 4, "Assuming EnablePressuredExit=false given EnableTransactions=false.");
LABEL_25:
    if (!v9)
      goto LABEL_29;
    goto LABEL_26;
  }
  if (!v9)
  {
    LOBYTE(v13) = 1;
    LOBYTE(v12) = 1;
    goto LABEL_29;
  }
  if (!xpc_BOOL_get_value(v9))
  {
    v10 = 2;
    goto LABEL_18;
  }
  v11 = 3;
  LOBYTE(v13) = 1;
  v12 = 1;
LABEL_26:
  v15 = xpc_BOOL_get_value(v9);
  if (v11 == 3 && v12 != v15)
    sub_100014830(a3, 3, "Service sets EnableTransactions=false and EnablePressuredExit=true, which makes no sense. Enabling Transactions.");
LABEL_29:
  xpc_dictionary_set_BOOL(xdict, "EnablePressuredExit", v13);
  xpc_dictionary_set_BOOL(xdict, "EnableTransactions", v12);
}

void sub_1000086E4(char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t v5;
  _BYTE *v6;
  xpc_type_t type;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  int v15;
  _BOOL4 value;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int64_t v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  _BOOL4 v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *string_ptr;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  __darwin_ct_rune_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;
  __darwin_ct_rune_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  unint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char **v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  _QWORD *v80;
  xpc_object_t v81;
  char v82;
  char v83;
  _QWORD applier[6];
  _QWORD v85[6];

  v5 = *a3;
  v6 = (_BYTE *)a3[1];
  type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_BOOL)
  {
    value = xpc_BOOL_get_value(object);
    v22 = *a1;
    switch(v22)
    {
      case 'j':
        goto LABEL_14;
      case '_':
        v36 = value;
        if (!strcmp(a1, "_MultipleInstances"))
        {
          *(_BYTE *)(v5 + 1344) = v36;
          return;
        }
        if (!strcmp(a1, "_JoinGUISession"))
          return;
        if (!strcmp(a1, "_AbandonCoalition"))
        {
          v65 = 0x40000000;
          if (!v36)
            v65 = 0;
          v66 = *(_QWORD *)(v5 + 1376) & 0xFFFFFFFFBFFFFFFFLL;
        }
        else
        {
          if (!strcmp(a1, "_OmitSandboxParameters"))
            return;
          if (strcasecmp(a1, "_HighBitsASLR"))
          {
            if (!strcasecmp(a1, "_ExponentialThrottling"))
            {
              v37 = *(_QWORD *)(v5 + 1376) & 0xFFE7FFFFFFFFFFFFLL;
              *(_WORD *)(v5 + 1028) = 3;
              v38 = 0x10000000000000;
              if (v36)
                v38 = 0x18000000000000;
              v39 = v38 | v37;
              goto LABEL_70;
            }
            break;
          }
          v65 = 0x200000000;
          if (!v36)
            v65 = 0;
          v66 = *(_QWORD *)(v5 + 1376) & 0xFFFFFFFDFFFFFFFFLL;
        }
        v39 = v66 | v65;
        goto LABEL_70;
      case 'J':
LABEL_14:
        if (!strcmp(a1, "JoinExistingSession"))
          return;
        break;
    }
    sub_10001D418(v5, 4, "Unknown key for Boolean: %s", v17, v18, v19, v20, v21, (char)a1);
    goto LABEL_69;
  }
  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    v23 = xpc_int64_get_value(object);
    v24 = *a1;
    if (v24 == 80 || v24 == 112)
    {
      if (!strcasecmp(a1, "PersonaEnterprise") || !strcasecmp(a1, "Platform"))
        return;
    }
    else if (v24 == 95)
    {
      v25 = v23;
      if (!strcasecmp(a1, "_VoluntaryExitTimeOut"))
      {
        *(_DWORD *)(v5 + 864) = v25;
        return;
      }
      if (!strcasecmp(a1, "_LaunchWatchdogTimeOut"))
      {
        sub_10001D418(v5, 4, "setting launch watchdog timeout to %u secs from overlay", v26, v27, v28, v29, v30, v25);
        *(_DWORD *)(v5 + 868) = v25;
        return;
      }
      if (!strcasecmp(a1, "_ThrottleInterval"))
      {
        if ((v25 & 0x8000000000000000) != 0)
        {
          v83 = (char)a1;
          v13 = "%s less than zero. Ignoring.";
        }
        else
        {
          if (!HIDWORD(v25))
          {
            if (v25)
            {
              *(_DWORD *)(v5 + 836) = v25;
            }
            else
            {
              sub_10001D418(v5, 3, "_ThrottleInterval set to zero. You're not that important. Ignoring.", v8, v9, v10, v11, v12, v82);
              *(_DWORD *)(v5 + 836) = 1;
            }
            return;
          }
          v83 = (char)a1;
          v13 = "%s is too large. Ignoring.";
        }
        v14 = v5;
        v15 = 4;
        goto LABEL_10;
      }
    }
    sub_10001D418(v5, 4, "Unknown key for integer: %s", v8, v9, v10, v11, v12, (char)a1);
LABEL_69:
    v39 = *(_QWORD *)(v5 + 1376) | 1;
LABEL_70:
    *(_QWORD *)(v5 + 1376) = v39;
    return;
  }
  if (type == (xpc_type_t)&_xpc_type_double)
  {
    xpc_double_get_value(object);
    sub_10001D418(v5, 4, "Unknown key for double: %s", v31, v32, v33, v34, v35, (char)a1);
    goto LABEL_69;
  }
  if (type == (xpc_type_t)&_xpc_type_data)
  {
    xpc_data_get_bytes_ptr(object);
    xpc_data_get_length(object);
    sub_10001D418(v5, 4, "Unknown key for data: %s", v40, v41, v42, v43, v44, (char)a1);
    goto LABEL_69;
  }
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    v51 = *a1;
    if (v51 <= 94)
    {
      if (v51 == 82)
        goto LABEL_60;
      if (v51 == 83)
      {
LABEL_54:
        v58 = "ServiceType";
        goto LABEL_61;
      }
    }
    else
    {
      if (v51 != 95)
      {
        if (v51 != 114)
        {
          if (v51 != 115)
            goto LABEL_62;
          goto LABEL_54;
        }
LABEL_60:
        v58 = "RunLoopType";
LABEL_61:
        if (sub_1000157A8(a1, v58))
          return;
        goto LABEL_62;
      }
      v67 = (char *)string_ptr;
      if (sub_1000157E0(a1, "_RoleAccount"))
      {
        if (sub_1000157A8(v67, "root"))
        {
          v39 = *(_QWORD *)(v5 + 1376) | 0x80000;
          goto LABEL_70;
        }
        v73 = (char **)(v5 + 800);
LABEL_96:
        *(_QWORD *)(v5 + 592) += strlen(v67) + 1;
        v74 = j__strdup(v67);
        *v73 = v74;
        if (!v74)
        {
          sub_10001D418(v5, 3, "Could not set string argument for key: %s", v75, v76, v77, v78, v79, (char)a1);
          goto LABEL_69;
        }
        return;
      }
      if (sub_1000157E0(a1, "_SandboxProfile"))
      {
        sub_100006FD8(v5, v67);
        return;
      }
      if (sub_1000157E0(a1, "_SandboxContainer"))
      {
        v73 = (char **)(v5 + 472);
        goto LABEL_96;
      }
      if (sub_1000157E0(a1, "_ProcessType"))
        return;
      if (sub_1000157A8(a1, "_Cryptex"))
      {
        sub_100008124(v5, v67);
        v39 = *(_QWORD *)(v5 + 1376) | 0x1000000000000000;
        goto LABEL_70;
      }
      if (sub_1000157A8(a1, "_ManagedBy"))
      {
        v81 = xpc_string_create(v67);
        sub_10003D488(v5, v81);
        xpc_release(v81);
        return;
      }
      if (sub_1000157A8(a1, "_Conclave"))
      {
        sub_100008FFC(v5, v67);
        return;
      }
    }
LABEL_62:
    sub_10001D418(v5, 4, "Unknown key for string: %s", v46, v47, v48, v49, v50, (char)a1);
    goto LABEL_69;
  }
  if (type != (xpc_type_t)&_xpc_type_array)
  {
    if (type != (xpc_type_t)&_xpc_type_dictionary)
    {
      v83 = (char)a1;
      xpc_type_get_name(type);
      v13 = "Invalid type for service dictionary (key/type): %s/%s";
LABEL_9:
      v14 = v5;
      v15 = 3;
LABEL_10:
      sub_10001D418(v14, v15, v13, v8, v9, v10, v11, v12, v83);
      return;
    }
    v59 = __tolower(*a1);
    if (v59 != 95)
    {
      if (v59 == 101 && !strcmp(a1, "EnvironmentVariables"))
      {
        xpc_dictionary_apply_f(object);
        return;
      }
      goto LABEL_58;
    }
    if (!strcmp(a1, "_LaunchEvents"))
    {
      v83 = (char)a1;
      v13 = "The %s key is not yet implemented. %s";
      goto LABEL_9;
    }
    if (!strcmp(a1, "_AdditionalServices"))
    {
      sub_10001D418(v5, 3, "The %s key is no longer respected. %s", v68, v69, v70, v71, v72, (char)a1);
      v85[0] = _NSConcreteStackBlock;
      v85[1] = 0x40000000;
      v85[2] = sub_100009110;
      v85[3] = &unk_100069208;
      v85[4] = v5;
      v85[5] = v6;
      v80 = v85;
    }
    else
    {
      if (strcmp(a1, "_AdditionalSubServices"))
      {
        if (!strcasecmp(a1, "_AdditionalProperties"))
        {
          *(_QWORD *)(v5 + 640) = xpc_retain(object);
          return;
        }
LABEL_58:
        sub_10001D418(v5, 4, "Unknown key for dictionary: %s", v60, v61, v62, v63, v64, (char)a1);
        goto LABEL_69;
      }
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000;
      applier[2] = sub_100009130;
      applier[3] = &unk_100069228;
      applier[4] = v5;
      applier[5] = v6;
      v80 = applier;
    }
    xpc_dictionary_apply(object, v80);
    return;
  }
  v52 = __tolower(*a1);
  if (v52 == 112)
  {
    if (sub_1000157A8(a1, "ProgramArguments"))
      return;
    goto LABEL_68;
  }
  if (v52 != 95)
  {
LABEL_68:
    sub_10001D418(v5, 4, "Unknown key for array: %s", v53, v54, v55, v56, v57, (char)a1);
    goto LABEL_69;
  }
  if (!strcmp(a1, "_AdditionalServices"))
  {
    sub_100009074(v5, a1, (uint64_t)&_xpc_BOOL_true, v6);
    return;
  }
  if (strcmp(a1, "_AllowedClients"))
  {
    if (!strcmp(a1, "_ManagedBy"))
    {
      sub_10003D488(v5, object);
      return;
    }
    if (!strcmp(a1, "_ManagedBy_Services"))
    {
      sub_10003D594(v5, object);
      return;
    }
    goto LABEL_68;
  }
}

void sub_100008E84(uint64_t a1, xpc_object_t xdict)
{
  int v4;
  const char *string;
  char *v6;

  if ((*(_QWORD *)(a1 + 1376) & 0x400000000) != 0)
    v4 = 1024;
  else
    v4 = 1536;
  string = xpc_dictionary_get_string(xdict, "RunLoopType");
  if (string && !strcmp(string, "_UIApplicationMain"))
    v4 = 256;
  *(_DWORD *)(a1 + 896) = v4;
  v6 = (char *)xpc_dictionary_get_string(xdict, "_ProcessType");
  if (v6)
    sub_100005D28(a1, v6);
}

void sub_100008F1C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;

  if ((a2 & 0x400) != 0)
  {
    v8 = 3;
  }
  else if ((a2 & 0x800) != 0)
  {
    v8 = 1;
  }
  else if ((a2 & 0x1000) != 0)
  {
    v8 = 2;
  }
  else if ((a2 & 0x40) != 0)
  {
    v8 = 6;
  }
  else if ((*(_BYTE *)(a1 + 1376) & 2) != 0)
  {
    v8 = 5;
  }
  else if ((a2 & 0x40000) != 0)
  {
    v8 = 7;
  }
  else
  {
    if ((a2 & 0x200) == 0)
    {
      sub_10001D418(a1, 3, "Unknown service type. flags: %llx", a4, a5, a6, a7, a8, a2);
      return;
    }
    v8 = 4;
  }
  *(_BYTE *)(a1 + 356) = v8;
}

uint64_t sub_100008FA4(uint64_t result)
{
  int v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_DWORD *)(result + 896);
  if (v1 == 256)
  {
    v2 = *(_QWORD *)(result + 1384);
    v3 = *(_QWORD *)(result + 1376);
    *(_QWORD *)(result + 1376) = v3 | 0x2000000;
    if ((v3 & 0x2000000000000000) == 0)
    {
      *(_DWORD *)(result + 900) = 1;
      *(_QWORD *)(result + 1384) = v2;
      *(_QWORD *)(result + 1376) = v3 | 0x2000000002000000;
    }
  }
  else if (v1 == 1792)
  {
    *(_QWORD *)(result + 1376) |= 0x100000000000000uLL;
  }
  return result;
}

void sub_100008FFC(uint64_t a1, char *__s)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;

  if (strlen(__s) < 0x80)
  {
    v9 = *(void **)(a1 + 1368);
    if (v9)
    {
      free(v9);
      *(_QWORD *)(a1 + 1368) = 0;
    }
    *(_QWORD *)(a1 + 1368) = sub_10001544C(__s);
  }
  else
  {
    sub_10001D418(a1, 3, "%s failed: conclave id too long", v4, v5, v6, v7, v8, (char)"_launch_service_set_conclave");
  }
}

void sub_100009074(uint64_t a1, char *__s1, uint64_t a3, _BYTE *a4)
{
  if ((*(_BYTE *)(a1 + 1380) & 0x40) != 0 && !strcmp(__s1, (const char *)(a1 + 1392)))
  {
    sub_100014830(a4, 4, "MachService endpoint name specified was same as implicitly created endpoint: %s", __s1);
  }
  else if ((*(uint64_t (**)(uint64_t, char *, uint64_t, _QWORD, _BYTE *, _QWORD))(a1 + 544))(a1, __s1, a3, 0, a4, *(_QWORD *)(a1 + 568)))
  {
    return;
  }
  *(_QWORD *)(a1 + 1376) |= 1uLL;
}

uint64_t sub_100009110(uint64_t a1, char *a2, uint64_t a3)
{
  sub_100009074(*(_QWORD *)(a1 + 32), a2, a3, *(_BYTE **)(a1 + 40));
  return 1;
}

uint64_t sub_100009130(uint64_t a1, const char *a2, uint64_t a3)
{
  const char *v5;
  char __str[16];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;

  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v9 = 0u;
  v10 = 0u;
  v5 = (const char *)(*(_QWORD *)(a1 + 32) + 1392);
  *(_OWORD *)__str = 0u;
  v8 = 0u;
  snprintf(__str, 0x200uLL, "%s.%s", v5, a2);
  sub_100009074(*(_QWORD *)(a1 + 32), __str, a3, *(_BYTE **)(a1 + 40));
  return 1;
}

uint64_t sub_100009204(void *a1)
{
  uint64_t v1;
  _QWORD applier[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  char v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2000000000;
  v7 = 0;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = sub_100009E08;
  applier[3] = &unk_100069250;
  applier[4] = &v4;
  xpc_dictionary_apply(a1, applier);
  v1 = *((unsigned __int8 *)v5 + 24);
  _Block_object_dispose(&v4, 8);
  return v1;
}

size_t sub_10000928C(void *a1)
{
  const char *string_ptr;
  size_t result;
  size_t v4;
  xpc_object_t value;

  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    result = xpc_array_get_count(a1);
    if (result)
    {
      v4 = 0;
      while (1)
      {
        value = xpc_array_get_value(a1, v4);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string && (sub_10000928C(value) & 1) != 0)
          break;
        if (++v4 >= xpc_array_get_count(a1))
          return 0;
      }
      return 1;
    }
  }
  else if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return os_variant_check("com.apple.xpc.launchd", string_ptr);
  }
  else
  {
    return 0;
  }
  return result;
}

size_t sub_100009360(void *a1)
{
  char *string_ptr;
  size_t result;
  size_t v4;
  xpc_object_t value;

  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    result = xpc_array_get_count(a1);
    if (result)
    {
      v4 = 0;
      while (1)
      {
        value = xpc_array_get_value(a1, v4);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string && (sub_100009360(value) & 1) != 0)
          break;
        if (++v4 >= xpc_array_get_count(a1))
          return 0;
      }
      return 1;
    }
  }
  else if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = (char *)xpc_string_get_string_ptr(a1);
    return sub_100004824(string_ptr);
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t sub_100009428()
{
  uint64_t result;

  result = j___os_feature_enabled_impl("Accessibility", "ClarityUI");
  if ((_DWORD)result)
    return sub_10003BCB0("/var/mobile/Library/Accessibility/ClarityBoardEnabled");
  return result;
}

size_t sub_100009460(void *a1, _BYTE *a2)
{
  const char *string_ptr;
  size_t result;
  size_t v6;
  xpc_object_t value;
  const char *v8;

  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return sub_10003E10C((_BOOL8)string_ptr);
  }
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    result = xpc_array_get_count(a1);
    if (result)
    {
      v6 = 0;
      while (1)
      {
        value = xpc_array_get_value(a1, v6);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string)
        {
          v8 = xpc_string_get_string_ptr(value);
          if (sub_10003E10C((_BOOL8)v8))
            return 1;
        }
        else
        {
          sub_100014830(a2, 4, "Unsupported type for index %lu of _LimitLoadToDeviceTree", v6);
        }
        if (++v6 >= xpc_array_get_count(a1))
          return 0;
      }
    }
  }
  else
  {
    sub_100014830(a2, 4, "Unsupported type for _LimitLoadToDeviceTree");
    return 0;
  }
  return result;
}

size_t sub_100009578(void *a1, _BYTE *a2)
{
  const char *string_ptr;
  size_t result;
  size_t v6;
  xpc_object_t value;

  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return sub_100046FB0((uint64_t)string_ptr);
  }
  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_array)
  {
    result = xpc_array_get_count(a1);
    if (result)
    {
      v6 = 0;
      while (1)
      {
        value = xpc_array_get_value(a1, v6);
        if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string)
        {
          if ((sub_100009578(value, a2) & 1) != 0)
            return 1;
        }
        else
        {
          sub_100014830(a2, 4, "Unsupported type for index: %lu of _LimitLoadToBootarg", v6);
        }
        if (++v6 >= xpc_array_get_count(a1))
          return 0;
      }
    }
  }
  else
  {
    sub_100014830(a2, 4, "Unsupported type for _LimitLoadToBootarg");
    return 0;
  }
  return result;
}

char *sub_100009690(void *a1, char *a2, uint64_t a3, unint64_t a4, uint64_t a5, int *a6, _BYTE *a7)
{
  const char *v14;
  char *v15;
  const char *v16;
  const char *v17;
  char *v18;
  xpc_object_t value;
  xpc_object_t v20;
  char *v21;
  xpc_object_t v22;
  xpc_object_t v23;
  void *v24;
  xpc_object_t v25;
  void *v26;
  int v27;
  xpc_object_t v28;
  uint64_t v29;
  BOOL v30;
  char *v31;
  int v32;
  BOOL v33;
  int v34;
  xpc_object_t v35;
  void *v36;
  int v37;
  int v38;
  xpc_object_t v39;
  void *v40;
  char *v41;
  int v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  int v60;
  int v61;
  _OWORD *v62;
  int v63;
  uint64_t v64;
  char *string;

  v14 = xpc_dictionary_get_string(a1, "Label");
  if (!v14)
    sub_10004D738();
  v15 = (char *)v14;
  v16 = xpc_dictionary_get_string(a1, "Program");
  v17 = v16;
  if (v16)
  {
    v64 = a5;
    string = a2;
    v18 = (char *)v16;
    if (*v16 == 47)
    {
LABEL_4:
      value = xpc_dictionary_get_value(a1, "ProgramArguments");
      goto LABEL_5;
    }
    v29 = a3;
    v30 = xpc_dictionary_get_BOOL(a1, "ResolveProgramIdentifier");
    v31 = (char *)xpc_dictionary_get_string(a1, "BundleProgram");
    if (v30 || v31)
    {
      a3 = v29;
      if (!v31 || sub_1000157A8(v31, v17))
        goto LABEL_4;
      sub_100014830(a7, 3, "BundleProgram(%s) is not the same as Program(%s). Bug in ServiceManagement?");
    }
    else
    {
      sub_100014830(a7, 3, "Service specifies non-absolute Program path.");
    }
    goto LABEL_55;
  }
  v28 = xpc_dictionary_get_value(a1, "ProgramArguments");
  if (!v28 || (value = v28, xpc_get_type(v28) != (xpc_type_t)&_xpc_type_array))
  {
    sub_100014830(a7, 3, "Service specifies neither Program nor ProgramArguments.");
LABEL_55:
    v18 = 0;
    goto LABEL_56;
  }
  if (!xpc_array_get_count(value))
  {
    sub_100014830(a7, 3, "Service specifies no Program and empty ProgramArguments.");
    goto LABEL_55;
  }
  v64 = a5;
  string = a2;
  v18 = (char *)xpc_array_get_string(value, 0);
  if (!v18)
  {
    sub_100014830(a7, 3, "Service does not specify a valid argument array.");
LABEL_56:
    v37 = 111;
LABEL_57:
    *a6 = v37;
    return v18;
  }
LABEL_5:
  v20 = xpc_dictionary_get_value(a1, "ProcessType");
  if (v20)
    xpc_dictionary_set_value(a1, "POSIXSpawnType", v20);
  if ((a4 & 0x400) != 0)
    xpc_dictionary_set_BOOL(a1, "__Angel", 1);
  v21 = (char *)xpc_dictionary_get_string(a1, "POSIXSpawnType");
  if (sub_1000157A8(v21, "Driver") && (sub_10000FEF4(a3, 24) & 1) == 0)
  {
    if (a3)
      v32 = *(_DWORD *)(a3 + 20);
    else
      v32 = 0;
    sub_100014830(a7, 3, "Service (pid %d) does not have spawn driver entitlement", v32);
    v18 = 0;
    v37 = 144;
    goto LABEL_57;
  }
  v62 = (_OWORD *)a3;
  if ((a4 & 0x200) == 0 && xpc_dictionary_get_string(a1, "_JetsamPropertiesIdentifier"))
  {
    sub_100014830(a7, 3, "Ignoring _JetsamPropertiesIdentifier on a service which isn't submitted");
    xpc_dictionary_set_value(a1, "_JetsamPropertiesIdentifier", 0);
  }
  v22 = sub_10000EEA4(a1);
  sub_10000E810(v22, a7);
  sub_100008520(a1, v22, a7, 0);
  v23 = xpc_dictionary_get_value(v22, "ExecuteAllowed");
  if (v23)
  {
    v24 = v23;
    if (xpc_get_type(v23) == (xpc_type_t)&_xpc_type_BOOL)
    {
      v33 = xpc_BOOL_get_value(v24);
      if ((a4 & 0x200) == 0 && !v33)
      {
        v34 = 157;
LABEL_40:
        *a6 = v34;
        xpc_release(v22);
        return 0;
      }
    }
  }
  v25 = xpc_dictionary_get_value(a1, "_StandardInFd");
  if (v25 && (v26 = v25, xpc_get_type(v25) == (xpc_type_t)&_xpc_type_fd))
    v27 = xpc_fd_dup(v26);
  else
    v27 = -1;
  if (xpc_dictionary_get_string(a1, "StandardInPath") && v27 != -1)
  {
    close(v27);
    sub_100014830(a7, 3, "Service specifies both standard out file descriptor and path.");
    v34 = 111;
    goto LABEL_40;
  }
  v63 = v27;
  v35 = xpc_dictionary_get_value(a1, "_StandardOutFd");
  if (v35 && (v36 = v35, xpc_get_type(v35) == (xpc_type_t)&_xpc_type_fd))
    v61 = xpc_fd_dup(v36);
  else
    v61 = -1;
  if (xpc_dictionary_get_string(a1, "StandardOutPath") && v61 != -1)
  {
    close(v61);
    sub_100014830(a7, 3, "Service specifies both standard out file descriptor and path.");
    *a6 = 111;
    xpc_release(v22);
    if (v63 == -1)
      return 0;
    v38 = v63;
LABEL_77:
    close(v38);
    return 0;
  }
  v39 = xpc_dictionary_get_value(a1, "_StandardErrorFd");
  if (v39 && (v40 = v39, xpc_get_type(v39) == (xpc_type_t)&_xpc_type_fd))
    v60 = xpc_fd_dup(v40);
  else
    v60 = -1;
  if (xpc_dictionary_get_string(a1, "StandardErrorPath") && v60 != -1)
  {
    close(v60);
    sub_100014830(a7, 3, "Service specifies both standard out file descriptor and path.");
    *a6 = 111;
    xpc_release(v22);
    if (v63 != -1)
      close(v63);
    v38 = v61;
    goto LABEL_76;
  }
  v41 = sub_10001CE9C((uint64_t)v15, v18, string);
  v18 = sub_100007D2C(v41, v62, v15, value, v64, a4, a6, a7);
  sub_10001962C(v41);
  if (!v18)
  {
    xpc_release(v22);
    if (v63 != -1)
      close(v63);
    if (v61 != -1)
      close(v61);
    v38 = v60;
LABEL_76:
    if (v38 == -1)
      return 0;
    goto LABEL_77;
  }
  v42 = sub_10000FEF4((uint64_t)v62, 3);
  v43 = *((_QWORD *)v18 + 172);
  if (v42)
    v43 |= 0x8000000000uLL;
  *((_QWORD *)v18 + 172) = v43 & 0xFFFFFFFFFEFFFFFFLL | ((unint64_t)(v17 == 0) << 24);
  v44 = sub_10001952C(v18, 1, (uint64_t)a7, 0);
  xpc_dictionary_apply_f(a1);
  sub_1000195F8(v44);
  if (*((_QWORD *)v18 + 81))
  {
    *((_QWORD *)v18 + 82) = xpc_retain(a1);
    *((_QWORD *)v18 + 83) = xpc_string_create(string);
  }
  sub_10000E974((uint64_t)v18, v22, (uint64_t)a7);
  nullsub_23(v18, v22);
  xpc_release(v22);
  v51 = *((_QWORD *)v18 + 173);
  v52 = *((_QWORD *)v18 + 172);
  if ((v52 & 0x80000000) != 0)
  {
    v53 = v63;
    v55 = v60;
    v54 = v61;
    if (!*((_QWORD *)v18 + 100))
    {
      v52 &= ~0x80000000uLL;
      *((_QWORD *)v18 + 173) = v51;
      *((_QWORD *)v18 + 172) = v52;
    }
  }
  else
  {
    v53 = v63;
    v55 = v60;
    v54 = v61;
  }
  v57 = a4 & 0x10 | v52 & 0x20000;
  if (v57)
    v52 |= 0x200000uLL;
  v58 = v52 & 0x20000000;
  v59 = v52 | (v58 >> 7);
  if (v57 || v58)
  {
    *((_QWORD *)v18 + 172) = v59;
    *((_QWORD *)v18 + 173) = v51;
  }
  if (((v58 == 0) & ~v42) == 0 && *((_DWORD *)v18 + 224) != 1792)
  {
    *((_DWORD *)v18 + 224) = 256;
    if (v58)
      *((_DWORD *)v18 + 230) = 160;
    *((_QWORD *)v18 + 173) = v51;
    *((_QWORD *)v18 + 172) = v59 & 0xFFFFFFFFFFFFECFFLL | 0x1000;
  }
  if (v53 != -1)
    *((_DWORD *)v18 + 172) = v53;
  if (v54 != -1)
    *((_DWORD *)v18 + 173) = v54;
  if (v55 != -1)
    *((_DWORD *)v18 + 174) = v55;
  sub_100008F1C((uint64_t)v18, a4, v45, v46, v47, v48, v49, v50);
  if ((v18[1383] & 4) != 0)
    sub_1000239BC((uint64_t)v18, 15);
  sub_100008FA4((uint64_t)v18);
  return v18;
}

void sub_100009DA4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  if ((*(_BYTE *)(a1 + 1379) & 0x20) != 0)
  {
    v9 = *(_QWORD *)(a2 + 72);
    if (v9)
    {
      sub_10001D418(a1, 3, "Service tried to claim home screen from: %s", a4, a5, a6, a7, a8, v9 + 112);
      *(_QWORD *)(a1 + 1376) &= ~0x20000000uLL;
    }
    else
    {
      *(_QWORD *)(a2 + 72) = a1;
    }
  }
}

uint64_t sub_100009E08(uint64_t a1, const char *a2, void *a3)
{
  uint64_t result;
  size_t v6;
  xpc_object_t value;
  char __str[16];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  *(_OWORD *)__str = 0u;
  v9 = 0u;
  snprintf(__str, 0x80uLL, "hw.%s", a2);
  if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_array)
  {
    if (xpc_array_get_count(a3))
    {
      v6 = 0;
      while (1)
      {
        value = xpc_array_get_value(a3, v6);
        if ((sub_100009F14(__str, value) & 1) != 0)
          break;
        if (++v6 >= xpc_array_get_count(a3))
          return 1;
      }
      goto LABEL_3;
    }
  }
  else if (sub_100009F14(__str, a3))
  {
LABEL_3:
    result = 0;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    return result;
  }
  return 1;
}

size_t sub_100009F14(const char *a1, xpc_object_t object)
{
  int v4;
  size_t v5;
  _BOOL4 v6;
  _BOOL4 v8;
  const char *string_ptr;
  char *v10;
  char *value;
  size_t v13;
  char *__s2[2];

  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_string)
  {
    if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_int64)
    {
      __s2[0] = 0;
      if (sub_10003FE74(a1, __s2))
      {
        value = (char *)xpc_int64_get_value(object);
        return value == __s2[0];
      }
    }
    else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
    {
      __s2[0] = 0;
      __s2[1] = 0;
      v13 = 16;
      v4 = sysctlbyname(a1, __s2, &v13, 0, 0);
      v5 = 0;
      if (v4 != -1 && v13)
      {
        v6 = xpc_BOOL_get_value(object);
        v8 = v13 < 9 && __s2[0] == 0;
        return v6 ^ v8;
      }
      return v5;
    }
    return 0;
  }
  __s2[0] = 0;
  v5 = sub_10003FCE8(a1, __s2);
  if (v5)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    v10 = __s2[0];
    v5 = strncmp(string_ptr, __s2[0], v5) == 0;
    free(v10);
  }
  return v5;
}

uint64_t sub_10000A084(const char *a1, void *a2, uint64_t *a3)
{
  void *v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t result;

  v3 = a2;
  v5 = *a3;
  v6 = a3[1];
  v7 = (uint64_t *)qword_100071B98;
  if (!qword_100071B98)
  {
    qword_100071B98 = (uint64_t)sub_10000DD14("plist");
    sub_10000DDC0(qword_100071B98, "AbandonProcessGroup", (char *)&stru_100069290);
    sub_10000DDC0(qword_100071B98, "AuxiliaryBootstrapper", (char *)&stru_1000692D0);
    sub_10000DDC0(qword_100071B98, "AuxiliaryBootstrapperAllowDemand", (char *)&stru_100069310);
    sub_10000DFE0(qword_100071B98, "AlwaysSIGTERMOnShutdown");
    sub_10000DDC0(qword_100071B98, "BootShell", (char *)&stru_100069350);
    sub_10000DDC0(qword_100071B98, "DisabledInSafeBoot", (char *)&stru_100069390);
    sub_10000DDC0(qword_100071B98, "KeepAlive", (char *)&stru_1000693D0);
    sub_10000DDC0(qword_100071B98, "OnDemand", (char *)&stru_100069410);
    sub_10000DDC0(qword_100071B98, "Debug", (char *)&stru_100069450);
    sub_10000DFE0(qword_100071B98, "Disabled");
    sub_10000DDC0(qword_100071B98, "DisableASLR", (char *)&stru_100069490);
    sub_10000DDC0(qword_100071B98, "DisallowAllLookups", (char *)&stru_1000694D0);
    sub_10000DDC0(qword_100071B98, "DrainMessagesOnFailedInit", (char *)&stru_100069510);
    sub_10000DDC0(qword_100071B98, "DisableReslide", (char *)&stru_100069550);
    sub_10000DDC0(qword_100071B98, "HopefullyExitsLast", (char *)&stru_100069590);
    sub_10000DDC0(qword_100071B98, "SessionCreate", (char *)&stru_1000695D0);
    sub_10000DDC0(qword_100071B98, "StartOnMount", (char *)&stru_100069610);
    sub_10000DDC0(qword_100071B98, "ServiceIPC", (char *)&stru_100069650);
    sub_10000DDC0(qword_100071B98, "ShutdownMonitor", (char *)&stru_100069690);
    sub_10000DDC0(qword_100071B98, "LowPriorityIO", (char *)&stru_1000696D0);
    sub_10000DDC0(qword_100071B98, "LowPriorityBackgroundIO", (char *)&stru_100069710);
    sub_10000DDC0(qword_100071B98, "LegacyTimers", (char *)&stru_100069750);
    sub_10000DDC0(qword_100071B98, "LaunchOnlyOnce", (char *)&stru_100069790);
    sub_10000DDC0(qword_100071B98, "MachExceptionHandler", (char *)&stru_1000697D0);
    sub_10000DDC0(qword_100071B98, "MultipleInstances", (char *)&stru_100069810);
    sub_10000DDC0(qword_100071B98, "MaterializeDatalessFiles", (char *)&stru_100069850);
    sub_10000DFE0(qword_100071B98, "MinimalBootProfile");
    sub_10000DDC0(qword_100071B98, "InitGroups", (char *)&stru_100069890);
    sub_10000DDC0(qword_100071B98, "IgnoreProcessGroupAtShutdown", (char *)&stru_1000698D0);
    sub_10000DDC0(qword_100071B98, "RunAtLoad", (char *)&stru_100069910);
    sub_10000DDC0(qword_100071B98, "ResolveProgramIdentifier", (char *)&stru_100069950);
    sub_10000DEC0(qword_100071B98, "BundleProgram", (char *)&stru_100069990);
    sub_10000DDC0(qword_100071B98, "ReslideSharedCache", (char *)&stru_1000699D0);
    sub_10000DDC0(qword_100071B98, "EnableGlobbing", (char *)&stru_100069A10);
    sub_10000DDC0(qword_100071B98, "EnableTransactions", (char *)&stru_100069A50);
    sub_10000DDC0(qword_100071B98, "EnterKernelDebuggerBeforeKill", (char *)&stru_100069A90);
    sub_10000DDC0(qword_100071B98, "EmbeddedHomeScreen", (char *)&stru_100069AD0);
    sub_10000DDC0(qword_100071B98, "EventMonitor", (char *)&stru_100069B10);
    sub_10000DDC0(qword_100071B98, "_InitialSystemSupport", (char *)&stru_100069B50);
    sub_10000DDC0(qword_100071B98, "EnablePressuredExit", (char *)&stru_100069B90);
    sub_10000DFE0(qword_100071B98, "ExecuteAllowed");
    sub_10000DDC0(qword_100071B98, "WaitForDebugger", (char *)&stru_100069BD0);
    sub_10000DFE0(qword_100071B98, "ForceEnableHack");
    sub_10000DDC0(qword_100071B98, "NSBuiltWithThreadSanitizer", (char *)&stru_100069C10);
    sub_10000DDC0(qword_100071B98, "_NullBootstrapPort", (char *)&stru_100069C50);
    sub_10000DFE0(qword_100071B98, "_Protected");
    sub_10000DDC0(qword_100071B98, "_ExponentialThrottling", (char *)&stru_100069C90);
    sub_10000DFE0(qword_100071B98, "__Proxyless");
    sub_10000DDC0(qword_100071B98, "_DisablePointerAuth", (char *)&stru_100069CD0);
    sub_10000DE78(qword_100071B98, "ExitTimeOut", (char *)&stru_100069D10);
    sub_10000DE78(qword_100071B98, "EmbeddedMainThreadPriority", (char *)&stru_100069D50);
    sub_10000DE78(qword_100071B98, "CPUMonitorPercentage", (char *)&stru_100069D90);
    sub_10000DE78(qword_100071B98, "CPUMonitorInterval", (char *)&stru_100069DD0);
    sub_10000DE78(qword_100071B98, "PersonaEnterprise", (char *)&stru_100069E10);
    sub_10000DE78(qword_100071B98, "Platform", (char *)&stru_100069E50);
    sub_10000DE78(qword_100071B98, "JetsamPriority", (char *)&stru_100069E90);
    sub_10000DE78(qword_100071B98, "JetsamMemoryLimit", (char *)&stru_100069ED0);
    sub_10000DE78(qword_100071B98, "Nice", (char *)&stru_100069F10);
    sub_10000DE78(qword_100071B98, "TimeOut", (char *)&stru_100069F50);
    sub_10000DE78(qword_100071B98, "ThrottleInterval", (char *)&stru_100069F90);
    sub_10000DE78(qword_100071B98, "Umask", (char *)&stru_100069FD0);
    sub_10000DEC0(qword_100071B98, "Umask", (char *)&stru_10006A010);
    sub_10000DE78(qword_100071B98, "StartInterval", (char *)&stru_10006A050);
    sub_10000DE78(qword_100071B98, "SandboxFlags", (char *)&stru_10006A090);
    sub_10000DFE0(qword_100071B98, "ActiveHardMemoryLimit");
    sub_10000DFE0(qword_100071B98, "ActiveSoftMemoryLimit");
    sub_10000DFE0(qword_100071B98, "InactiveHardMemoryLimit");
    sub_10000DFE0(qword_100071B98, "InactiveSoftMemoryLimit");
    sub_10000DE78(qword_100071B98, "InitialTaskRole", (char *)&stru_10006A0D0);
    sub_10000DEC0(qword_100071B98, "CFBundleIdentifier", (char *)&stru_10006A110);
    sub_10000DEC0(qword_100071B98, "ContainingBundleID", (char *)&stru_10006A150);
    sub_10000DF98(qword_100071B98, "_BTMItemUUID", (char *)&stru_10006A190);
    sub_10000DF98(qword_100071B98, "_LightweightCodeRequirement", (char *)&stru_10006A1D0);
    sub_10000DF98(qword_100071B98, "_ProvenanceData", (char *)&stru_10006A210);
    sub_10000DEC0(qword_100071B98, "ContainingBundleVersion", (char *)&stru_10006A250);
    sub_10000DEC0(qword_100071B98, "MachExceptionHandler", (char *)&stru_10006A290);
    sub_10000DEC0(qword_100071B98, "MultipleInstances", (char *)&stru_10006A2D0);
    sub_10000DFE0(qword_100071B98, "Program");
    sub_10000DEC0(qword_100071B98, "POSIXSpawnType", (char *)&stru_10006A310);
    sub_10000DEC0(qword_100071B98, "ProcessType", (char *)&stru_10006A310);
    sub_10000DEC0(qword_100071B98, "PublishesEvents", (char *)&stru_10006A350);
    sub_10000DFE0(qword_100071B98, "Label");
    sub_10000DEC0(qword_100071B98, "LimitLoadToHosts", (char *)&stru_10006A390);
    sub_10000DEC0(qword_100071B98, "LimitLoadFromHosts", (char *)&stru_10006A3D0);
    sub_10000DFE0(qword_100071B98, "LimitLoadToSessionType");
    sub_10000DEC0(qword_100071B98, "LoginWindowUserName", (char *)&stru_10006A410);
    sub_10000DEC0(qword_100071B98, "RootDirectory", (char *)&stru_10006A450);
    sub_10000DEC0(qword_100071B98, "WorkingDirectory", (char *)&stru_10006A490);
    sub_10000DEC0(qword_100071B98, "UserName", (char *)&stru_10006A4D0);
    sub_10000DEC0(qword_100071B98, "GroupName", (char *)&stru_10006A510);
    sub_10000DEC0(qword_100071B98, "StandardOutPath", (char *)&stru_10006A550);
    sub_10000DEC0(qword_100071B98, "StandardErrorPath", (char *)&stru_10006A590);
    sub_10000DEC0(qword_100071B98, "StandardInPath", (char *)&stru_10006A5D0);
    sub_10000DEC0(qword_100071B98, "SandboxProfile", (char *)&stru_10006A610);
    sub_10000DEC0(qword_100071B98, "SandboxContainer", (char *)&stru_10006A650);
    sub_10000DFE0(qword_100071B98, "_LimitLoadToDeviceTree");
    sub_10000DFE0(qword_100071B98, "_LimitLoadFromDeviceTree");
    sub_10000DFE0(qword_100071B98, "_LimitLoadToVariant");
    sub_10000DFE0(qword_100071B98, "_LimitLoadFromVariant");
    sub_10000DEC0(qword_100071B98, "_ResourceCoalition", (char *)&stru_10006A690);
    sub_10000DFE0(qword_100071B98, "_LimitLoadToBootMode");
    sub_10000DFE0(qword_100071B98, "_LimitLoadFromBootMode");
    sub_10000DFE0(qword_100071B98, "_LimitLoadToClarityMode");
    sub_10000DFE0(qword_100071B98, "_LimitLoadFromClarityMode");
    sub_10000DFE0(qword_100071B98, "_LimitLoadToBootarg");
    sub_10000DFE0(qword_100071B98, "_LimitLoadFromBootarg");
    sub_10000DEC0(qword_100071B98, "_ManagedBy", (char *)&stru_10006A6D0);
    sub_10000DF08(qword_100071B98, "_ManagedBy", (char *)&stru_10006A710);
    sub_10000DF08(qword_100071B98, "_ManagedBy_Services", (char *)&stru_10006A750);
    sub_10000DEC0(qword_100071B98, "_SubsystemRoot", (char *)&stru_10006A790);
    sub_10000DFE0(qword_100071B98, "ProgramArguments");
    sub_10000DF08(qword_100071B98, "PublishesEvents", (char *)&stru_10006A7D0);
    sub_10000DF08(qword_100071B98, "LimitLoadToHosts", (char *)&stru_10006A830);
    sub_10000DF08(qword_100071B98, "LimitLoadFromHosts", (char *)&stru_10006A870);
    sub_10000DFE0(qword_100071B98, "LimitLoadToSessionType");
    sub_10000DF08(qword_100071B98, "BinaryOrderPreference", (char *)&stru_10006A8B0);
    sub_10000DF08(qword_100071B98, "StartCalendarInterval", (char *)&stru_10006A8F0);
    sub_10000DF08(qword_100071B98, "QueueDirectories", (char *)&stru_10006A930);
    sub_10000DF08(qword_100071B98, "WatchPaths", (char *)&stru_10006A970);
    sub_10000DF50(qword_100071B98, "Policies", (char *)&stru_10006A9B0);
    sub_10000DF50(qword_100071B98, "PublishesEvents", (char *)&stru_10006A9F0);
    sub_10000DF50(qword_100071B98, "KeepAlive", (char *)&stru_10006AA50);
    sub_10000DF50(qword_100071B98, "inetdCompatibility", (char *)&stru_10006AAB0);
    sub_10000DF50(qword_100071B98, "JetsamProperties", (char *)&stru_10006AAF0);
    sub_10000DF50(qword_100071B98, "EnvironmentVariables", (char *)&stru_10006AB30);
    sub_10000DF50(qword_100071B98, "UserEnvironmentVariables", (char *)&stru_10006AB70);
    sub_10000DF50(qword_100071B98, "Sockets", (char *)&stru_10006ABB0);
    sub_10000DF50(qword_100071B98, "StartCalendarInterval", (char *)&stru_10006AC10);
    sub_10000DF50(qword_100071B98, "SoftResourceLimits", (char *)&stru_10006AC50);
    sub_10000DF50(qword_100071B98, "SandboxFlags", (char *)&stru_10006AC90);
    sub_10000DF50(qword_100071B98, "HardResourceLimits", (char *)&stru_10006ACD0);
    sub_10000DF50(qword_100071B98, "MachServices", (char *)&stru_10006AD10);
    sub_10000DF50(qword_100071B98, "LaunchEvents", (char *)&stru_10006AD70);
    sub_10000DFE0(qword_100071B98, "LimitLoadToHardware");
    sub_10000DFE0(qword_100071B98, "LimitLoadFromHardware");
    sub_10000DF50(qword_100071B98, "Datastores", (char *)&stru_10006ADD0);
    sub_10000DF50(qword_100071B98, "RemoteServices", (char *)&stru_10006AE30);
    sub_10000DF50(qword_100071B98, "_AdditionalProperties", (char *)&stru_10006AE90);
    sub_10000DEC0(qword_100071B98, "_PersistToBootMode", (char *)&stru_10006AED0);
    sub_10000DF08(qword_100071B98, "_PersistToBootMode", (char *)&stru_10006AF10);
    sub_10000DF98(qword_100071B98, "_DextCheckInPort", (char *)&stru_10006AF50);
    sub_10000DDC0(qword_100071B98, "__Angel", (char *)&stru_10006AF90);
    sub_10000DFE0(qword_100071B98, "_StandardInFd");
    sub_10000DFE0(qword_100071B98, "_StandardOutFd");
    sub_10000DFE0(qword_100071B98, "_StandardErrorFd");
    sub_10000DDC0(qword_100071B98, "_PanicOnCrash", (char *)&stru_10006AFD0);
    sub_10000DF50(qword_100071B98, "_PanicOnCrash", (char *)&stru_10006B010);
    sub_10000DEC0(qword_100071B98, "_Cryptex", (char *)&stru_10006B050);
    sub_10000DEC0(qword_100071B98, "_Conclave", (char *)&stru_10006B090);
    sub_10000DFE0(qword_100071B98, "AssociatedBundleIdentifiers");
    sub_10000DE78(qword_100071B98, "_LaunchType", (char *)&stru_10006B0D0);
    sub_10000DF50(qword_100071B98, "SpawnConstraint", (char *)&stru_10006B110);
    sub_10000DDC0(qword_100071B98, "_NeedsSystemThreadGroup", (char *)&stru_10006B150);
    v3 = a2;
    v7 = (uint64_t *)qword_100071B98;
  }
  result = sub_10000E0DC(v7, v5, a1, v3, v6);
  if ((result & 1) == 0)
    *(_QWORD *)(v5 + 1376) |= 1uLL;
  return result;
}

void sub_10000AE68(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x10000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFEFFFFLL | v4;
}

void sub_10000AE98(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  if (a3)
  {
    sub_10001D418((uint64_t)a2, 5, "This service is defined to be constantly running and is inherently inefficient.", (uint64_t)a4, v4, v5, v6, v7, v9);
    *((_QWORD *)&a2->var4 + 125) |= 4uLL;
  }
}

void sub_10000AED8(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;
  char v10;

  if (a3)
  {
    sub_10001D418((uint64_t)a2, 5, "This key does not do anything: OnDemand", (uint64_t)a4, v4, v5, v6, v7, v10);
  }
  else
  {
    sub_10001D418((uint64_t)a2, 5, "Please switch away from OnDemand to KeepAlive.", (uint64_t)a4, v4, v5, v6, v7, v9);
    *((_QWORD *)&a2->var4 + 125) |= 4uLL;
  }
}

void sub_10000AF34(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"Debug");
}

void sub_10000AF74(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"DisableASLR");
}

void sub_10000AFB4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x80000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFF7FFFFFFFFFFLL | v4;
}

void sub_10000AFD4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x1000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFEFFFFFFFFFLL | v4;
}

void sub_10000AFF4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x20000000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFDFFFFFFFFFFFFFLL | v4;
}

void sub_10000B014(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"HopefullyExitsLast");
}

void sub_10000B05C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"ServiceIPC");
}

void sub_10000B09C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"ShutdownMonitor");
}

void sub_10000B0DC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 32;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFFDFLL | v4;
}

void sub_10000B0FC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 64;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFFBFLL | v4;
}

void sub_10000B120(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x100000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFEFFFFFLL | v4;
}

void sub_10000B140(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 128;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFF7FLL | v4;
}

void sub_10000B160(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  a2->var4.var92 = a3;
}

void sub_10000B168(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  unsigned __int8 v4;

  if (a3)
    v4 = 2;
  else
    v4 = 1;
  a2->var4.var89 = v4;
}

void sub_10000B17C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x80000000;
  if (a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFF7FFFFFFFLL | v4;
}

void sub_10000B19C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is not yet implemented. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"IgnoreProcessGroupAtShutdown");
}

void sub_10000B1DC(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 16;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFFEFLL | v4;
}

void sub_10000B204(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  a2->var4.var83.var0 = a3;
}

void sub_10000B20C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"EnableGlobbing");
}

void sub_10000B250(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 1024;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFBFFLL | v4;
}

void sub_10000B270(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  *((_QWORD *)&a2->var4 + 125) |= 0x20000000uLL;
}

void sub_10000B280(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x20000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFDFFFFLL | v4;
}

void sub_10000B2A0(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x400000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFBFFFFFLL | v4;
}

void sub_10000B2C4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 2048;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFFF7FFLL | v4;
}

void sub_10000B2E4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x1000000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFEFFFFFFFFFFFFLL | v4;
}

void sub_10000B304(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x4000000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFBFFFFFFFFFFFFLL | v4;
}

void sub_10000B324(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x8000000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFF7FFFFFFFFFFFFLL | v4;
  a2->var4.var80 = 3;
}

void sub_10000B34C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v8 = *((_QWORD *)&a2->var4 + 125);
  if ((v8 & 0x40000000000) != 0)
  {
    v9 = 0x80000000000000;
    if (!a3)
      v9 = 0;
    *((_QWORD *)&a2->var4 + 126) = *((_QWORD *)&a2->var4 + 126);
    *((_QWORD *)&a2->var4 + 125) = v8 & 0xFF7FFFFFFFFFFFFFLL | v9;
  }
  else
  {
    sub_10001D418((uint64_t)a2, 3, "%s not permitted to be set on non-submitted jobs", (uint64_t)a4, v4, v5, v6, v7, (char)"_DisablePointerAuth");
  }
}

void sub_10000B3B0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v9;
  int v10;
  BOOL v11;

  if (a3 < 0)
  {
    sub_10001D418((uint64_t)a2, 4, "%s less than zero. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ExitTimeOut");
  }
  else
  {
    v9 = a3;
    if ((unint64_t)a3 >> 31)
    {
      sub_10001D418((uint64_t)a2, 4, "%s is too large. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ExitTimeOut");
    }
    else
    {
      v10 = a3 + dword_100071A94 + 2;
      if (dword_100071A9C)
        v11 = v10 <= dword_100071A9C;
      else
        v11 = 1;
      if (!v11)
      {
        sub_10001D418((uint64_t)a2, 4, "Service has increased maximum shutdown time to %d seconds. This will create a poor experience for the user.", (uint64_t)a4, v4, v5, v6, v7, a3 + dword_100071A94 + 2);
        dword_100071A9C = v10;
      }
      a2->var4.var44 = v9;
    }
  }
}

void sub_10000B480(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var88 = a3;
  *((_QWORD *)&a2->var4 + 125) |= 0x400000000000uLL;
}

void sub_10000B498(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"JetsamPriority");
}

void sub_10000B4D8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"JetsamMemoryLimit");
}

void sub_10000B51C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"TimeOut");
}

void sub_10000B55C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v9;

  if (a3 < 0)
  {
    sub_10001D418((uint64_t)a2, 4, "%s less than zero. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ThrottleInterval");
  }
  else if (HIDWORD(a3))
  {
    sub_10001D418((uint64_t)a2, 4, "%s is too large. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"ThrottleInterval");
  }
  else if (a3)
  {
    a2->var4.var45 = a3;
  }
  else
  {
    sub_10001D418((uint64_t)a2, 3, "ThrottleInterval set to zero. You're not that important. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, v9);
    a2->var4.var45 = 1;
  }
}

void sub_10000B5F0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  *((_QWORD *)&a2->var4 + 125) |= (unint64_t)&_mh_execute_header;
  a2->var4.var41 = a3;
}

void sub_10000B604(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  unsigned __int16 v5;

  v5 = strtoul(a3, 0, 0);
  *((_QWORD *)&a2->var4 + 125) |= (unint64_t)&_mh_execute_header;
  a2->var4.var41 = v5;
}

void sub_10000B640(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var52 = a3;
}

void sub_10000B648(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"SandboxFlags");
}

void sub_10000B688(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var55 = a3;
  *((_QWORD *)&a2->var4 + 125) |= 0x2000000000000000uLL;
}

void sub_10000B69C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var16 = sub_10001544C(a3);
}

void sub_10000B6D0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  const _xpc_type_s *type;

  if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_data)
  {
    if (!(xpc_data_get_length(a3) >> 32))
    {
      sub_10001F1A8(a2, a3);
      return;
    }
    sub_100014830(a4, 3, "Provenance data too big: %zu");
  }
  else
  {
    type = xpc_get_type(a3);
    xpc_type_get_name(type);
    sub_100014830(a4, 3, "Invalid type (%s) for _ProvenanceData");
  }
  *((_QWORD *)&a2->var4 + 125) |= 1uLL;
}

void sub_10000B78C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var53 = sub_10001544C(a3);
}

void sub_10000B7B4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (sub_1000157A8(a3, "Managed"))
  {
    a2->var4.var92 = 2;
    sub_1000239BC((uint64_t)a2, 16);
  }
  else
  {
    sub_100014830(a4, 3, "Invalid value for MultipleInstances '%s'", a3);
  }
}

void sub_10000B838(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  sub_100005D28((uint64_t)a2, a3);
}

void sub_10000B844(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v7;

  v7 = xpc_BOOL_create(1);
  sub_10000B888((uint64_t)a2, a3, v7, (uint64_t)a4);
}

void sub_10000B888(uint64_t a1, const char *a2, xpc_object_t object, uint64_t a4)
{
  _QWORD applier[7];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  int v12;

  if (!*(_QWORD *)(a1 + 504))
    *(_QWORD *)(a1 + 504) = xpc_dictionary_create(0, 0, 0);
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
  {
    if (xpc_BOOL_get_value(object))
      xpc_dictionary_set_uint64(*(xpc_object_t *)(a1 + 504), a2, 0);
  }
  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v9 = 0;
    v10 = &v9;
    v11 = 0x2000000000;
    v12 = 0;
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_10000D364;
    applier[3] = &unk_10006B178;
    applier[4] = &v9;
    applier[5] = a4;
    applier[6] = a1;
    xpc_dictionary_apply(object, applier);
    xpc_dictionary_set_uint64(*(xpc_object_t *)(a1 + 504), a2, *((unsigned int *)v10 + 6));
    _Block_object_dispose(&v9, 8);
  }
}

void sub_10000B9B4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"LimitLoadToHosts");
}

void sub_10000B9F4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"LimitLoadFromHosts");
}

void sub_10000BA34(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var39 = sub_10001544C(a3);
  a2->var4.var18 += strlen(a3) + 1;
  *((_QWORD *)&a2->var4 + 125) |= 0x40000000000000uLL;
}

void sub_10000BA84(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is not yet implemented. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"RootDirectory");
}

void sub_10000BAC4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  char *v5;

  v5 = sub_10001544C(a3);
  a2->var4.var5 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000BB00(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (strcmp(a3, "root"))
  {
    a2->var4.var39 = sub_10001544C(a3);
    a2->var4.var18 += strlen(a3) + 1;
  }
}

void sub_10000BB58(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (strcmp(a3, "wheel"))
  {
    a2->var4.var40 = sub_10001544C(a3);
    a2->var4.var18 += strlen(a3) + 1;
  }
}

void sub_10000BBB0(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  char *v5;

  v5 = sub_10001544C(a3);
  a2->var4.var7 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000BBEC(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  char *v5;

  v5 = sub_10001544C(a3);
  a2->var4.var8 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000BC28(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  char *v5;

  v5 = sub_10001544C(a3);
  a2->var4.var6 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000BC64(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  sub_100006FD8((uint64_t)a2, a3);
}

void sub_10000BC70(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var4.var9 = sub_10001544C(a3);
  a2->var4.var18 += strlen(a3) + 1;
}

void sub_10000BCB4(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  a2->var3.var19 = sub_10001544C(a3);
}

void sub_10000BCDC(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v5;

  v5 = xpc_string_create(a3);
  sub_10003D488((uint64_t)a2, v5);
  xpc_release(v5);
}

void sub_10000BD14(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  sub_10003D488((uint64_t)a2, a3);
}

void sub_10000BD20(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  sub_10003D594((uint64_t)a2, a3);
}

void sub_10000BD2C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  char *v5;

  v5 = sub_100015630("%s/", a3);
  a2->var4.var11 = v5;
  a2->var4.var18 += strlen(v5) + 1;
}

void sub_10000BD78(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  _QWORD v4[6];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000BDCC;
  v4[3] = &unk_10006A7F0;
  v4[4] = a2;
  v4[5] = a4;
  xpc_array_apply(a3, v4);
}

uint64_t sub_10000BDCC(uint64_t a1, int a2, xpc_object_t object)
{
  _BYTE *v5;
  const _xpc_type_s *type;
  const char *name;
  uint64_t v8;
  const char *string_ptr;
  xpc_object_t v10;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    v8 = *(_QWORD *)(a1 + 32);
    string_ptr = xpc_string_get_string_ptr(object);
    v10 = xpc_BOOL_create(1);
    sub_10000B888(v8, string_ptr, v10, *(_QWORD *)(a1 + 40));
  }
  else
  {
    v5 = *(_BYTE **)(a1 + 40);
    type = xpc_get_type(object);
    name = xpc_type_get_name(type);
    sub_100014830(v5, 3, "Invalid item type %s in PublishesEvents, expected string", name);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1376) |= 1uLL;
  }
  return 1;
}

void sub_10000BE80(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"LimitLoadToHosts");
}

void sub_10000BEC0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"LimitLoadFromHosts");
}

void sub_10000BF00(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  size_t i;
  xpc_object_t value;
  const _xpc_type_s *type;
  int v10;
  int v11;
  xpc_object_t v12;
  void *v13;
  int v14;
  xpc_object_t v15;
  void *v16;
  uint64_t v17;
  _OWORD v18[2];
  int v19;

  v19 = 0;
  memset(v18, 0, sizeof(v18));
  xpc_binprefs_init((uint64_t)v18);
  if (xpc_array_get_count(a3))
  {
    for (i = 0; i < xpc_array_get_count(a3); ++i)
    {
      value = xpc_array_get_value(a3, i);
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
      {
        v10 = xpc_int64_get_value(value);
        v11 = -1;
      }
      else
      {
        if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
        {
          type = xpc_get_type(value);
          xpc_type_get_name(type);
          sub_100014830(a4, 3, "Invalid CPU type value type specified: %s");
          continue;
        }
        v12 = xpc_dictionary_get_value(value, "CPUType");
        if (!v12)
        {
          sub_100014830(a4, 3, "Missing CPUType", v17);
          continue;
        }
        v13 = v12;
        if (xpc_get_type(v12) != (xpc_type_t)&_xpc_type_int64)
        {
          sub_100014830(a4, 3, "Wrong CPUType type - expecting int64", v17);
          continue;
        }
        v14 = xpc_int64_get_value(v13);
        v15 = xpc_dictionary_get_value(value, "CPUSubtype");
        if (v15)
        {
          v16 = v15;
          if (xpc_get_type(v15) != (xpc_type_t)&_xpc_type_int64)
          {
            sub_100014830(a4, 3, "Wrong CPUSubtype type - expecting int64");
            continue;
          }
          v11 = xpc_int64_get_value(v16);
        }
        else
        {
          v11 = -1;
        }
        v10 = v14;
      }
      xpc_binprefs_add((uint64_t)v18, v10, v11);
    }
  }
  sub_100006F78((uint64_t)a2, v18);
}

void sub_10000C0C8(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  size_t v6;
  xpc_object_t value;

  if (xpc_array_get_count(a3))
  {
    v6 = 0;
    do
    {
      value = xpc_array_get_value(a3, v6);
      sub_10000C12C((uint64_t)a2, value);
      ++v6;
    }
    while (v6 < xpc_array_get_count(a3));
  }
}

void sub_10000C12C(uint64_t a1, void *a2)
{
  uint64_t v4;
  char __str[1024];

  bzero(__str, 0x400uLL);
  v4 = qword_100071320++;
  snprintf(__str, 0x400uLL, "%s.%llu", (const char *)(a1 + 1392), v4);
  sub_10000C244(a1, "com.apple.launchd.calendarinterval", __str, a2);
}

void sub_10000C1D8(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  xpc_object_t v6;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_value(v6, "QueueDirectories", a3);
  sub_10000C244((uint64_t)a2, "com.apple.fsevents.matching", "com.apple.launchd.QueueDirectories", v6);
  xpc_release(v6);
}

void sub_10000C244(uint64_t a1, char *key, const char *a3, void *a4)
{
  xpc_object_t v8;
  xpc_object_t value;

  v8 = *(xpc_object_t *)(a1 + 496);
  if (!v8)
  {
    v8 = xpc_dictionary_create(0, 0, 0);
    *(_QWORD *)(a1 + 496) = v8;
  }
  value = xpc_dictionary_get_value(v8, key);
  if (!value)
  {
    value = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 496), key, value);
    xpc_release(value);
  }
  xpc_dictionary_set_value(value, a3, a4);
}

void sub_10000C2D8(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  xpc_object_t v6;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_value(v6, "WatchPaths", a3);
  sub_10000C244((uint64_t)a2, "com.apple.fsevents.matching", "com.apple.launchd.WatchPaths", v6);
  xpc_release(v6);
}

void sub_10000C344(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"Policies");
}

void sub_10000C384(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  _QWORD v4[6];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000C3D8;
  v4[3] = &unk_10006AA10;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000C3D8(uint64_t a1, const char *a2, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary || xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
  {
    sub_10000B888(*(_QWORD *)(a1 + 32), a2, object, *(_QWORD *)(a1 + 40));
  }
  else
  {
    sub_100014830(*(_BYTE **)(a1 + 40), 3, "Invalid item %s in PublishesEvents, expected dictionary or BOOL", a2);
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 1376) |= 1uLL;
  }
  return 1;
}

void sub_10000C47C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  _QWORD v4[6];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000C4D0;
  v4[3] = &unk_10006AA70;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000C4D0(uint64_t a1, const char *a2, void *a3)
{
  _QWORD *v5;
  _BYTE *v6;
  __darwin_ct_rune_t v7;
  const char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  xpc_object_t v16;
  _BYTE *v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  BOOL v19;
  const char *v20;
  _QWORD *v22;
  uint64_t v23;

  v5 = *(_QWORD **)(a1 + 32);
  v6 = *(_BYTE **)(a1 + 40);
  v5[172] |= 8uLL;
  v7 = __tolower(*a2);
  switch(v7)
  {
    case 'n':
      v8 = "NetworkState";
      goto LABEL_10;
    case 'o':
      if (strcasecmp(a2, "OtherJobActive"))
      {
        v8 = "OtherJobEnabled";
LABEL_10:
        if (strcasecmp(a2, v8))
          goto LABEL_19;
      }
      sub_10001D418((uint64_t)v5, 3, "The %s key is no longer respected. %s", v11, v12, v13, v14, v15, (char)a2);
      return 1;
    case 'p':
      if (strcmp(a2, "PathState"))
        goto LABEL_19;
      if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_dictionary)
        goto LABEL_23;
      v16 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_value(v16, "PathState", a3);
      sub_10000C244((uint64_t)v5, "com.apple.fsevents.matching", "com.apple.launchd.PathState", v16);
      xpc_release(v16);
      return 1;
    case 'q':
    case 'r':
      goto LABEL_19;
    case 's':
      if (strcmp(a2, "SuccessfulExit"))
        goto LABEL_19;
      if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_BOOL)
        goto LABEL_23;
      v17 = sub_10001389C(0x28uLL);
      v18 = sub_10001D1C8;
      v19 = a3 == &_xpc_BOOL_true;
      v20 = "successful exit";
      goto LABEL_27;
    default:
      if (v7 != 99)
      {
        if (v7 == 97 && !strcasecmp(a2, "AfterInitialDemand"))
        {
          if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_BOOL)
          {
            v9 = v5[173];
            v10 = v5[172] & 0xFFFFFFFFFF7FFFFFLL | ((unint64_t)(a3 != 0) << 23);
          }
          else
          {
            sub_100014830(v6, 3, "Improper type for KeepAlive key: %s", a2);
            v9 = v5[173];
            v10 = v5[172] | 1;
          }
          v5[172] = v10;
          v5[173] = v9;
          return 1;
        }
        goto LABEL_19;
      }
      if (strcasecmp(a2, "Crashed"))
      {
LABEL_19:
        sub_100014830(v6, 3, "Unknown key for KeepAlive: %s");
LABEL_20:
        v5[172] |= 1uLL;
        return 1;
      }
      if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_BOOL)
      {
LABEL_23:
        sub_100014830(v6, 3, "Improper type for KeepAlive key: %s");
        goto LABEL_20;
      }
      v17 = sub_10001389C(0x28uLL);
      v18 = sub_10001D174;
      v19 = a3 == &_xpc_BOOL_true;
      v20 = "after crash";
LABEL_27:
      v17[32] = v19;
      *((_QWORD *)v17 + 2) = v18;
      *((_QWORD *)v17 + 3) = v20;
      v22 = v5 + 84;
      v23 = v5[84];
      *(_QWORD *)v17 = v23;
      if (v23)
        *(_QWORD *)(v23 + 8) = v17;
      *v22 = v17;
      *((_QWORD *)v17 + 1) = v22;
      return 1;
  }
}

void sub_10000C79C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  *((_QWORD *)&a2->var4 + 125) |= 0x14000uLL;
  xpc_dictionary_apply_f(a3);
}

int64_t sub_10000C7C0(const char *a1, void *a2, uint64_t a3)
{
  int64_t result;
  uint64_t v7;

  if (!strcasecmp(a1, "Wait"))
  {
    result = xpc_BOOL_get_value(a2);
    v7 = 0x8000;
    if (!(_DWORD)result)
      v7 = 0;
    *(_QWORD *)(a3 + 1376) = *(_QWORD *)(a3 + 1376) & 0xFFFFFFFFFFFF7FFFLL | v7;
  }
  else
  {
    result = strcasecmp(a1, "Instances");
    if (!(_DWORD)result)
    {
      result = xpc_int64_get_value(a2);
      *(_DWORD *)(a3 + 268) = result;
    }
  }
  return result;
}

void sub_10000C848(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  xpc_dictionary_apply_f(a3);
}

void sub_10000C858(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is not yet implemented. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"UserEnvironmentVariables");
}

void sub_10000C898(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  _QWORD v4[6];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000C8EC;
  v4[3] = &unk_10006ABD0;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000C8EC(uint64_t a1, uint64_t a2, xpc_object_t object)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t v12;
  xpc_object_t value;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v5 = *(_QWORD *)(a1 + 32);
  v6 = *(_QWORD *)(a1 + 40);
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
  {
    if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_array)
    {
      sub_10001D418(v5, 3, "Socket entry is not a dictionary or array. Skipping: %s", v7, v8, v9, v10, v11, a2);
LABEL_5:
      *(_QWORD *)(v5 + 1376) |= 1uLL;
      return 1;
    }
    if (!xpc_array_get_count(object))
      return 1;
    v12 = 0;
    while (1)
    {
      value = xpc_array_get_value(object, v12);
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary)
      {
        if ((*(uint64_t (**)(uint64_t, uint64_t, xpc_object_t, uint64_t, _QWORD))(v5 + 552))(v5, a2, value, v6, *(_QWORD *)(v5 + 568)))
        {
          goto LABEL_12;
        }
      }
      else
      {
        sub_10001D418(v5, 3, "Socket entry is not a dictionary. Skipping: %s", v14, v15, v16, v17, v18, a2);
      }
      *(_QWORD *)(v5 + 1376) |= 1uLL;
LABEL_12:
      if (++v12 >= xpc_array_get_count(object))
        return 1;
    }
  }
  if (!(*(uint64_t (**)(uint64_t, uint64_t, xpc_object_t, uint64_t, _QWORD))(v5 + 552))(v5, a2, object, v6, *(_QWORD *)(v5 + 568)))goto LABEL_5;
  return 1;
}

void sub_10000CA3C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  sub_10000C12C((uint64_t)a2, a3);
}

void sub_10000CA48(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  xpc_dictionary_apply_f(a3);
}

uint64_t sub_10000CA58(const char *a1, xpc_object_t object, uint64_t a3)
{
  uint64_t result;
  int64_t value;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int64_t *v13;

  result = (uint64_t)xpc_get_type(object);
  if ((_UNKNOWN *)result == &_xpc_type_int64)
  {
    value = xpc_int64_get_value(object);
    v8 = 0;
    while (1)
    {
      result = strcasecmp((&off_10006B198)[v8], a1);
      if (!(_DWORD)result)
        break;
      v8 += 2;
      if (v8 == 18)
        return result;
    }
    v9 = LOWORD((&off_10006B198)[v8 + 1]);
    v10 = *(_QWORD *)(a3 + 1376);
    v11 = (uint64_t *)(a3 + 680);
    result = (uint64_t)v11;
    while (1)
    {
      result = *(_QWORD *)result;
      if (!result)
        break;
      if (*(unsigned __int16 *)(result + 32) == v9)
        goto LABEL_13;
    }
    result = (uint64_t)sub_10001389C(0x28uLL);
    *(_WORD *)(result + 32) = v9;
    v12 = *v11;
    *(_QWORD *)result = *v11;
    if (v12)
      *(_QWORD *)(v12 + 8) = result;
    *v11 = result;
    *(_QWORD *)(result + 8) = v11;
LABEL_13:
    if ((v10 & 0x800000000) != 0)
    {
      *(_BYTE *)(result + 34) = 1;
      v13 = (int64_t *)(result + 24);
    }
    else
    {
      *(_BYTE *)(result + 35) = 1;
      v13 = (int64_t *)(result + 16);
    }
    *v13 = value;
  }
  return result;
}

void sub_10000CB4C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10001D418((uint64_t)a2, 3, "The %s key is no longer respected. %s", (uint64_t)a4, v4, v5, v6, v7, (char)"SandboxFlags");
}

void sub_10000CB8C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  *((_QWORD *)&a2->var4 + 125) |= 0x800000000uLL;
  xpc_dictionary_apply_f(a3);
  *((_QWORD *)&a2->var4 + 125) &= ~0x800000000uLL;
}

void sub_10000CBD0(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  _QWORD v4[6];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000CC24;
  v4[3] = &unk_10006AD30;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000CC24(uint64_t a1, char *a2, uint64_t a3)
{
  sub_100009074(*(_QWORD *)(a1 + 32), a2, a3, *(_BYTE **)(a1 + 40));
  return 1;
}

void sub_10000CC44(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  _QWORD v4[6];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000CC98;
  v4[3] = &unk_10006AD90;
  v4[4] = a2;
  v4[5] = a4;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000CC98(uint64_t a1, const char *a2, xpc_object_t object)
{
  _BYTE *v5;
  uint64_t v6;
  const _xpc_type_s *type;
  const char *name;
  _QWORD applier[8];

  v6 = *(_QWORD *)(a1 + 32);
  v5 = *(_BYTE **)(a1 + 40);
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_10000D45C;
    applier[3] = &unk_10006B228;
    applier[4] = object;
    applier[5] = v5;
    applier[6] = a2;
    applier[7] = v6;
    xpc_dictionary_apply(object, applier);
  }
  else
  {
    type = xpc_get_type(object);
    name = xpc_type_get_name(type);
    sub_100014830(v5, 3, "Invalid type for a LaunchEvent stream, should be a dictionary (stream/type): %s/%s", a2, name);
    *(_QWORD *)(v6 + 1376) |= 1uLL;
  }
  return 1;
}

void sub_10000CD5C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  _QWORD v4[6];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000CDB0;
  v4[3] = &unk_10006ADF0;
  v4[4] = a4;
  v4[5] = a2;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000CDB0(uint64_t a1, const char *a2, xpc_object_t object)
{
  _BYTE *v6;
  const _xpc_type_s *type;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    if (xpc_dictionary_get_int64(object, "SizeLimit"))
    {
      sub_10000C244(*(_QWORD *)(a1 + 40), "com.apple.xpc.datastores.publish", a2, object);
      return 1;
    }
    sub_100014830(*(_BYTE **)(a1 + 32), 3, "Size limit for Datastore entry not specified: %s");
  }
  else
  {
    v6 = *(_BYTE **)(a1 + 32);
    type = xpc_get_type(object);
    xpc_type_get_name(type);
    sub_100014830(v6, 3, "Invalid type for a Datastores entry, should be a dictionary (key/type): %s/%s");
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1376) |= 1uLL;
  return 1;
}

void sub_10000CE7C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  _QWORD v4[6];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000CED0;
  v4[3] = &unk_10006AE50;
  v4[4] = a4;
  v4[5] = a2;
  xpc_dictionary_apply(a3, v4);
}

uint64_t sub_10000CED0(uint64_t a1, const char *a2, xpc_object_t object)
{
  _BYTE *v6;
  const _xpc_type_s *type;
  const char *name;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10000C244(*(_QWORD *)(a1 + 40), "com.apple.remoted.service", a2, object);
  }
  else
  {
    v6 = *(_BYTE **)(a1 + 32);
    type = xpc_get_type(object);
    name = xpc_type_get_name(type);
    sub_100014830(v6, 3, "Invalid type for a RemoteServices entry, should be a dictionary (key/type): %s/%s", a2, name);
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 1376) |= 1uLL;
  }
  return 1;
}

void sub_10000CF74(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  a2->var4.var24 = xpc_retain(a3);
}

void sub_10000CF9C(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  xpc_object_t v5;

  v5 = xpc_string_create(a3);
  a2->var4.var25 = xpc_array_create(&v5, 1uLL);
}

void sub_10000D008(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  size_t v7;
  xpc_object_t value;

  a2->var4.var25 = xpc_array_create_empty();
  if (xpc_array_get_count(a3))
  {
    v7 = 0;
    do
    {
      value = xpc_array_get_value(a3, v7);
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_string)
      {
        xpc_array_append_value(a2->var4.var25, value);
      }
      else
      {
        sub_100014830(a4, 3, "Invalid type for _PersistToBootMode at index: %lu", v7);
        *((_QWORD *)&a2->var4 + 125) |= 1uLL;
      }
      ++v7;
    }
    while (v7 < xpc_array_get_count(a3));
  }
}

void sub_10000D0D4(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_mach_send)
    a2->var4.var91 = xpc_mach_send_copy_right(a3);
  else
    sub_10004D790((uint64_t)a2);
}

void sub_10000D124(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x400000000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFBFFFFFFFFFFFFFFLL | v4;
}

void sub_10000D144(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  if (a3)
    a2->var4.var81 = 1;
}

void sub_10000D154(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  unint64_t v5;
  _QWORD applier[9];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  char v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2000000000;
  v22 = 1;
  v15 = 0;
  v16 = &v15;
  v17 = 0x2000000000;
  v18 = 0;
  v11 = 0;
  v12 = &v11;
  v13 = 0x2000000000;
  v14 = 0;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2000000000;
  v10 = 0;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = sub_10000D50C;
  applier[3] = &unk_10006B250;
  applier[7] = &v11;
  applier[8] = a4;
  applier[4] = &v7;
  applier[5] = &v19;
  applier[6] = &v15;
  xpc_dictionary_apply(a3, applier);
  if (!*((_BYTE *)v16 + 24))
  {
    if (*((_BYTE *)v12 + 24))
    {
      *((_QWORD *)&a2->var4 + 125) |= 0x800000000000000uLL;
      v5 = v8[3];
      if (!v5)
        v5 = qword_100071AA8;
    }
    else
    {
      a2->var4.var81 = *((_BYTE *)v20 + 24);
      v5 = v8[3];
    }
    a2->var4.var82 = v5;
  }
  _Block_object_dispose(&v7, 8);
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);
}

void sub_10000D294(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  sub_100008124((uint64_t)a2, a3);
  *((_QWORD *)&a2->var4 + 125) |= 0x1000000000000000uLL;
}

void sub_10000D2C8(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  sub_100008FFC((uint64_t)a2, a3);
}

void sub_10000D2D4(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  unsigned __int8 var72;

  var72 = a2->var4.var72;
  a2->var4.var72 = a3;
  if ((sub_100005BA8((uint64_t)a2, 7) & 1) == 0)
  {
    sub_100014830(a4, 3, "Supplied value (%lld) for _LaunchType key not allowed", a3);
    a2->var4.var72 = var72;
  }
}

void sub_10000D33C(id a1, _launch_service_s *a2, void *a3, _launch_lint_s *a4)
{
  sub_10001F098((uint64_t)a2, a3);
}

void sub_10000D348(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  unint64_t v4;

  v4 = 0x8000000000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = v4 & 0x8000000000000000 | *((_QWORD *)&a2->var4 + 125) & 0x7FFFFFFFFFFFFFFFLL;
}

uint64_t sub_10000D364(uint64_t a1, char *a2, xpc_object_t object)
{
  uint64_t v7;
  int v8;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_BOOL)
  {
    if (sub_1000157E0(a2, "DomainInternal"))
    {
      if (!xpc_BOOL_get_value(object))
        return 1;
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v8 = *(_DWORD *)(v7 + 24) | 1;
    }
    else
    {
      if (!sub_1000157E0(a2, "RequireTrusted"))
      {
        sub_100014830(*(_BYTE **)(a1 + 40), 3, "Unknown property %s for PublishesEvents");
        goto LABEL_3;
      }
      if (!xpc_BOOL_get_value(object))
        return 1;
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v8 = *(_DWORD *)(v7 + 24) | 2;
    }
    *(_DWORD *)(v7 + 24) = v8;
    return 1;
  }
  sub_100014830(*(_BYTE **)(a1 + 40), 3, "Invalid type for PublishesEvents property %s, expected BOOL");
LABEL_3:
  *(_QWORD *)(*(_QWORD *)(a1 + 48) + 1376) |= 1uLL;
  return 1;
}

uint64_t sub_10000D45C(uint64_t a1, const char *a2, void *a3)
{
  xpc_type_t type;
  const char *v7;
  _BYTE *v8;
  const _xpc_type_s *v9;
  const char *name;

  type = xpc_get_type(*(xpc_object_t *)(a1 + 32));
  v7 = *(const char **)(a1 + 48);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10000C244(*(_QWORD *)(a1 + 56), *(char **)(a1 + 48), a2, a3);
  }
  else
  {
    v8 = *(_BYTE **)(a1 + 40);
    v9 = xpc_get_type(a3);
    name = xpc_type_get_name(v9);
    sub_100014830(v8, 3, "Invalid type for a LaunchEvent (stream/name/type): %s/%s/%s", v7, a2, name);
    *(_QWORD *)(*(_QWORD *)(a1 + 56) + 1376) |= 1uLL;
  }
  return 1;
}

uint64_t sub_10000D50C(uint64_t a1, char *a2, xpc_object_t object)
{
  int64_t value;
  _BYTE *v7;
  char *v8;
  uint64_t v9;
  char v10;
  uint64_t v12;
  int64_t v13;

  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_int64)
  {
    if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_BOOL)
    {
      sub_100014830(*(_BYTE **)(a1 + 64), 3, "Improper type for _PanicOnCrash key: %s");
      return 1;
    }
    if (object == &_xpc_BOOL_false)
      return 1;
    if (sub_1000157E0(a2, "PanicOnNonZeroExit"))
    {
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v10 = 3;
LABEL_25:
      *(_BYTE *)(v9 + 24) = v10;
      return 1;
    }
    if (sub_1000157E0(a2, "InternalOnly"))
    {
      if (byte_100072A66)
        return 1;
      sub_100014830(*(_BYTE **)(a1 + 64), 4, "_PanicOnCrash key: InternalOnly not enabled in the current environment");
    }
    else
    {
      if (!sub_1000157E0(a2, "AutomationOnly"))
      {
        if (!sub_1000157E0(a2, "PanicOnConsecutiveCrash"))
          return 1;
        v12 = *(_QWORD *)(a1 + 56);
        goto LABEL_24;
      }
      if (byte_100072A67)
        return 1;
      sub_100014830(*(_BYTE **)(a1 + 64), 4, "_PanicOnCrash key: AutomationOnly not enabled in the current environment");
    }
    v12 = *(_QWORD *)(a1 + 48);
LABEL_24:
    v9 = *(_QWORD *)(v12 + 8);
    v10 = 1;
    goto LABEL_25;
  }
  value = xpc_int64_get_value(object);
  if (sub_1000157E0(a2, "PanicOnCrashDeadline"))
  {
    if (value < 0)
    {
      v7 = *(_BYTE **)(a1 + 64);
      v8 = "_PanicOnCrash key: PanicOnCrashDeadline less than zero. Ignoring.";
    }
    else
    {
      if (is_mul_ok(value, 0x3B9ACA00uLL))
      {
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1000000000 * value;
        return 1;
      }
      v7 = *(_BYTE **)(a1 + 64);
      v13 = value;
      v8 = "_PanicOnCrash key: PanicOnCrashDeadline overflowed converting to ns (%lld)";
    }
    sub_100014830(v7, 4, v8, v13);
  }
  return 1;
}

uint64_t sub_10000D6D0(uint64_t a1)
{
  unint64_t v1;

  v1 = mach_absolute_time() - a1;
  return sub_10000D6F4(v1);
}

uint64_t sub_10000D6F4(unint64_t a1)
{
  if (qword_100071BA0 != -1)
    dispatch_once_f(&qword_100071BA0, 0, (dispatch_function_t)sub_10000DCF0);
  if (dword_100071BA8 != *(_DWORD *)algn_100071BAC)
    return __udivti3(dword_100071BA8 * a1, (dword_100071BA8 * (unsigned __int128)a1) >> 64);
  return a1;
}

void sub_10000D76C(unint64_t a1)
{
  if (qword_100071BA0 != -1)
    dispatch_once_f(&qword_100071BA0, 0, (dispatch_function_t)sub_10000DCF0);
  if (dword_100071BA8 != *(_DWORD *)algn_100071BAC
    && !is_mul_ok(a1 / dword_100071BA8, *(unsigned int *)algn_100071BAC))
  {
    __break(1u);
  }
}

uint64_t sub_10000D7E4(mach_port_options_ptr_t options, mach_port_context_t context, mach_port_name_t *name)
{
  uint64_t v6;
  uint64_t v7;
  BOOL v8;

  do
  {
    v6 = mach_port_construct(mach_task_self_, options, context, name);
    v7 = v6;
    v8 = (_DWORD)v6 == 6 || (_DWORD)v6 == 3;
  }
  while (v8 && sub_100015400());
  return v7;
}

uint64_t sub_10000D850(mach_port_options_t *a1, mach_port_context_t a2)
{
  int v2;
  mach_port_name_t name;

  name = 0;
  v2 = sub_10000D7E4(a1, a2, &name);
  if (v2)
    sub_10004D7CC(v2);
  return name;
}

uint64_t sub_10000D880(uint32_t a1, mach_port_msgcount_t a2, mach_port_context_t a3)
{
  mach_port_options_t v4;

  v4.flags = a1;
  v4.mpl.mpl_qlimit = a2;
  v4.8 = 0uLL;
  return sub_10000D850(&v4, a3);
}

uint64_t sub_10000D8AC(mach_port_name_t name, mach_port_context_t guard)
{
  return mach_port_unguard(mach_task_self_, name, guard);
}

uint64_t sub_10000D8C4(mach_port_name_t name, uint64_t a2)
{
  uint64_t result;
  integer_t info[2];

  *(_QWORD *)info = a2;
  result = mach_port_assert_attributes(mach_task_self_, name, 8, info, 2u);
  if ((_DWORD)result)
    sub_10004D7F4(result);
  return result;
}

uint64_t sub_10000D90C(mach_port_name_t name)
{
  return mach_port_insert_right(mach_task_self_, name, name, 0x14u);
}

uint64_t sub_10000D928(mach_port_name_t name, mach_port_t *poly)
{
  mach_msg_type_name_t polyPoly;

  polyPoly = 0;
  return mach_port_extract_right(mach_task_self_, name, 0x15u, poly, &polyPoly);
}

uint64_t sub_10000D964(mach_port_name_t name)
{
  return mach_port_mod_refs(mach_task_self_, name, 0, 1);
}

uint64_t sub_10000D980(mach_port_name_t name)
{
  return mach_port_deallocate(mach_task_self_, name);
}

uint64_t sub_10000D994(mach_port_name_t name, mach_port_delta_t srdelta, mach_port_context_t guard)
{
  return mach_port_destruct(mach_task_self_, name, srdelta, guard);
}

uint64_t sub_10000D9B0(mach_port_name_t name)
{
  return mach_port_set_attributes(mach_task_self_, name, 4, 0, 0);
}

uint64_t sub_10000D9D0(mach_port_name_t name, mach_port_t notify, mach_port_t *previous)
{
  mach_msg_type_name_t v3;

  if (notify)
    v3 = 21;
  else
    v3 = 18;
  return mach_port_request_notification(mach_task_self_, name, 69, 0, notify, v3, previous);
}

uint64_t sub_10000DA04(uint64_t a1)
{
  return a1 + ((*(unsigned int *)(a1 + 4) + 3) & 0x1FFFFFFFCLL) + 20;
}

uint64_t sub_10000DA1C()
{
  uint64_t v0;

  if (_os_alloc_once_table[2] == -1)
    v0 = _os_alloc_once_table[3];
  else
    v0 = _os_alloc_once(&_os_alloc_once_table[2], 216, 0);
  if (*(_BYTE *)(v0 + 41))
  {
    if (*(_QWORD *)(v0 + 48) != -1)
      dispatch_once_f((dispatch_once_t *)(v0 + 48), (void *)(v0 + 56), (dispatch_function_t)sub_10000DAA0);
  }
  else
  {
    sub_10000DAA0((task_info_t)(v0 + 56));
  }
  return v0 + 56;
}

uint64_t sub_10000DAA0(task_info_t task_info_out)
{
  integer_t v2;
  uint64_t result;
  mach_msg_type_number_t task_info_outCnt;

  task_info_outCnt = 8;
  if (task_info(mach_task_self_, 0xFu, task_info_out, &task_info_outCnt))
    sub_10004D81C();
  v2 = task_info_out[5];
  result = getpid();
  if (v2 != (_DWORD)result || !task_info_out[7])
    sub_10004D81C();
  return result;
}

uint64_t sub_10000DB0C(posix_spawnattr_t *a1, mach_port_t new_port)
{
  uint64_t v4;
  exception_mask_t v5;
  uint64_t result;

  if (_os_alloc_once_table[2] == -1)
    v4 = _os_alloc_once_table[3];
  else
    v4 = _os_alloc_once(&_os_alloc_once_table[2], 216, 0);
  if (*(_BYTE *)(v4 + 42))
    v5 = 7168;
  else
    v5 = 10240;
  if (!a1)
    return task_set_exception_ports(mach_task_self_, v5, new_port, -1610612732, 1);
  result = posix_spawnattr_setexceptionports_np(a1, v5, new_port, -1610612732, 1);
  if ((_DWORD)result)
    sub_10004D764(result);
  return result;
}

uint64_t sub_10000DBB8(task_t task)
{
  uint64_t v2;
  exception_mask_t v3;
  kern_return_t exception_ports;
  mach_port_t v5;
  mach_msg_type_number_t masksCnt;
  thread_state_flavor_t old_flavors[4];
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  exception_behavior_t old_behaviors[4];
  __int128 v13;
  __int128 v14;
  uint64_t v15;
  _OWORD old_handlers[3];
  uint64_t v17;
  _OWORD masks[3];
  uint64_t v19;

  if (_os_alloc_once_table[2] == -1)
    v2 = _os_alloc_once_table[3];
  else
    v2 = _os_alloc_once(&_os_alloc_once_table[2], 216, 0);
  v19 = 0;
  memset(masks, 0, sizeof(masks));
  masksCnt = 0;
  v17 = 0;
  memset(old_handlers, 0, sizeof(old_handlers));
  v15 = 0;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)old_behaviors = 0u;
  v11 = 0;
  v9 = 0u;
  v10 = 0u;
  *(_OWORD *)old_flavors = 0u;
  if (*(_BYTE *)(v2 + 42))
    v3 = 1024;
  else
    v3 = 0x2000;
  if (mach_task_self_ == task)
  {
    exception_ports = task_get_exception_ports(task, v3, (exception_mask_array_t)masks, &masksCnt, (exception_handler_array_t)old_handlers, old_behaviors, old_flavors);
  }
  else
  {
    v5 = mach_host_self();
    exception_ports = host_get_exception_ports(v5, v3, (exception_mask_array_t)masks, &masksCnt, (exception_handler_array_t)old_handlers, old_behaviors, old_flavors);
  }
  if (exception_ports)
    sub_10004D764(exception_ports);
  return LODWORD(old_handlers[0]);
}

uint64_t sub_10000DCF0()
{
  uint64_t result;

  result = mach_timebase_info((mach_timebase_info_t)&dword_100071BA8);
  if ((_DWORD)result)
    sub_10004D764(result);
  return result;
}

_QWORD *sub_10000DD14(const char *a1)
{
  _QWORD *v2;

  v2 = sub_10001389C(0xB0uLL);
  *v2 = sub_10001544C(a1);
  os_map_str_init(v2 + 1, 0, 1);
  os_map_str_init(v2 + 4, 0, 1);
  os_map_str_init(v2 + 7, 0, 1);
  os_map_str_init(v2 + 10, 0, 1);
  os_map_str_init(v2 + 13, 0, 1);
  os_map_str_init(v2 + 16, 0, 1);
  os_map_str_init(v2 + 19, 0, 1);
  return v2;
}

uint64_t sub_10000DDC0(uint64_t a1, const char *a2, char *a3)
{
  char **v6;

  v6 = (char **)sub_10001389C(0x10uLL);
  v6[1] = a3;
  return sub_10000DE08(a1, a1 + 8, a2, v6);
}

uint64_t sub_10000DE08(uint64_t a1, uint64_t a2, const char *a3, char **a4)
{
  char *v7;

  v7 = sub_10000E08C(a3);
  if (os_map_str_find(a1 + 152, v7))
    sub_10004D738();
  if (os_map_str_find(a2, v7))
    sub_10004D738();
  *a4 = v7;
  return os_map_str_insert(a2, v7, a4);
}

uint64_t sub_10000DE78(uint64_t a1, const char *a2, char *a3)
{
  char **v6;

  v6 = (char **)sub_10001389C(0x10uLL);
  v6[1] = a3;
  return sub_10000DE08(a1, a1 + 32, a2, v6);
}

uint64_t sub_10000DEC0(uint64_t a1, const char *a2, char *a3)
{
  char **v6;

  v6 = (char **)sub_10001389C(0x10uLL);
  v6[1] = a3;
  return sub_10000DE08(a1, a1 + 56, a2, v6);
}

uint64_t sub_10000DF08(uint64_t a1, const char *a2, char *a3)
{
  char **v6;

  v6 = (char **)sub_10001389C(0x10uLL);
  v6[1] = a3;
  return sub_10000DE08(a1, a1 + 80, a2, v6);
}

uint64_t sub_10000DF50(uint64_t a1, const char *a2, char *a3)
{
  char **v6;

  v6 = (char **)sub_10001389C(0x10uLL);
  v6[1] = a3;
  return sub_10000DE08(a1, a1 + 104, a2, v6);
}

uint64_t sub_10000DF98(uint64_t a1, const char *a2, char *a3)
{
  char **v6;

  v6 = (char **)sub_10001389C(0x10uLL);
  v6[1] = a3;
  return sub_10000DE08(a1, a1 + 128, a2, v6);
}

uint64_t sub_10000DFE0(uint64_t a1, const char *a2)
{
  char *v3;

  v3 = sub_10000E08C(a2);
  if (os_map_str_find(a1 + 8, v3))
    sub_10004D738();
  if (os_map_str_find(a1 + 32, v3))
    sub_10004D738();
  if (os_map_str_find(a1 + 56, v3))
    sub_10004D738();
  if (os_map_str_find(a1 + 80, v3))
    sub_10004D738();
  if (os_map_str_find(a1 + 104, v3))
    sub_10004D738();
  if (os_map_str_find(a1 + 128, v3))
    sub_10004D738();
  return os_map_str_insert(a1 + 152, v3, 1);
}

char *sub_10000E08C(const char *a1)
{
  char *v1;
  size_t v2;

  v1 = sub_10001544C(a1);
  if (*v1)
  {
    v2 = 0;
    do
    {
      v1[v2] = __tolower(v1[v2]);
      ++v2;
    }
    while (v2 < strlen(v1));
  }
  return v1;
}

uint64_t sub_10000E0DC(uint64_t *a1, uint64_t a2, const char *a3, void *a4, uint64_t a5)
{
  char *v9;
  uint64_t v10;
  xpc_type_t type;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  _BOOL8 v16;
  uint64_t v17;
  uint64_t v18;
  int64_t value;
  void (*v20)(uint64_t, uint64_t, int64_t, uint64_t);
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const _xpc_type_s *v26;
  void **v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _BOOL4 v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char v90;

  v9 = sub_10000E08C(a3);
  if (os_map_str_find(a1 + 19, v9))
    goto LABEL_2;
  type = xpc_get_type(a4);
  if (type != (xpc_type_t)&_xpc_type_BOOL)
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      v17 = os_map_str_find(a1 + 4, v9);
      if (!v17)
        goto LABEL_22;
      v18 = *(_QWORD *)(v17 + 8);
      value = xpc_int64_get_value(a4);
      v20 = *(void (**)(uint64_t, uint64_t, int64_t, uint64_t))(v18 + 16);
      v21 = v18;
    }
    else
    {
      if (type != (xpc_type_t)&_xpc_type_string)
      {
        if (type == (xpc_type_t)&_xpc_type_array)
        {
          v13 = a1 + 10;
        }
        else if (type == (xpc_type_t)&_xpc_type_dictionary)
        {
          v13 = a1 + 13;
        }
        else
        {
          v13 = a1 + 16;
        }
        v25 = os_map_str_find(v13, v9);
        if (v25)
        {
          v21 = *(_QWORD *)(v25 + 8);
          v20 = *(void (**)(uint64_t, uint64_t, int64_t, uint64_t))(v21 + 16);
          v24 = a2;
          value = (int64_t)a4;
          goto LABEL_21;
        }
LABEL_22:
        v26 = xpc_get_type(a4);
        v27 = (void **)sub_1000106C8(0x80uLL);
        v28 = *a1;
        xpc_type_get_name(v26);
        sub_100010740((uint64_t)v27, "Invalid type for %s importer (key: %s type: %s), accepted types: [", v29, v30, v31, v32, v33, v34, v28);
        v35 = os_map_str_find(a1 + 1, v9);
        v42 = v35 != 0;
        if (v35)
          sub_100010740((uint64_t)v27, "BOOL, ", v36, v37, v38, v39, v40, v41, v90);
        if (os_map_str_find(a1 + 4, v9))
        {
          sub_100010740((uint64_t)v27, "integer, ", v43, v44, v45, v46, v47, v48, v90);
          v42 = 1;
        }
        if (os_map_str_find(a1 + 7, v9))
        {
          sub_100010740((uint64_t)v27, "string, ", v49, v50, v51, v52, v53, v54, v90);
          v42 = 1;
        }
        if (os_map_str_find(a1 + 10, v9))
        {
          sub_100010740((uint64_t)v27, "array, ", v55, v56, v57, v58, v59, v60, v90);
          v42 = 1;
        }
        if (os_map_str_find(a1 + 13, v9))
        {
          sub_100010740((uint64_t)v27, "dictionary, ", v61, v62, v63, v64, v65, v66, v90);
          if (!os_map_str_find(a1 + 16, v9))
            goto LABEL_35;
        }
        else if (!os_map_str_find(a1 + 16, v9))
        {
          if (!v42)
          {
            v84 = *a1;
            xpc_type_get_name(v26);
            sub_10001D418(a2, 3, "Unknown key for %s importer (key: %s type: %s)", v85, v86, v87, v88, v89, v84);
            goto LABEL_36;
          }
LABEL_35:
          sub_100010840(v27, 2uLL);
          sub_100010740((uint64_t)v27, "]", v73, v74, v75, v76, v77, v78, v90);
          sub_10001D418(a2, 3, "%s", v79, v80, v81, v82, v83, (char)*v27);
LABEL_36:
          sub_100010718(v27);
          v10 = 0;
          goto LABEL_3;
        }
        sub_100010740((uint64_t)v27, "object, ", v67, v68, v69, v70, v71, v72, v90);
        goto LABEL_35;
      }
      v22 = os_map_str_find(a1 + 7, v9);
      if (!v22)
        goto LABEL_22;
      v23 = v22;
      value = (int64_t)xpc_string_get_string_ptr(a4);
      v21 = *(_QWORD *)(v23 + 8);
      v20 = *(void (**)(uint64_t, uint64_t, int64_t, uint64_t))(v21 + 16);
    }
    v24 = a2;
LABEL_21:
    v20(v21, v24, value, a5);
    goto LABEL_2;
  }
  v14 = os_map_str_find(a1 + 1, v9);
  if (!v14)
    goto LABEL_22;
  v15 = *(_QWORD *)(v14 + 8);
  v16 = xpc_BOOL_get_value(a4);
  (*(void (**)(uint64_t, uint64_t, _BOOL8, uint64_t))(v15 + 16))(v15, a2, v16, a5);
LABEL_2:
  v10 = 1;
LABEL_3:
  free(v9);
  return v10;
}

void sub_10000E410(const void *a1)
{
  NSObject *v2;
  NSObject *v3;
  dispatch_time_t v4;
  void *v5;

  if (dword_100072EE0)
  {
    v2 = sub_1000146E4();
    v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 1uLL, v2);
    v4 = dispatch_time(0, 1000000000 * dword_100072EE0);
    dispatch_source_set_timer(v3, v4, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_event_handler_f(v3, (dispatch_function_t)sub_10000E4C8);
    v5 = _Block_copy(a1);
    dispatch_set_context(v3, v5);
    dispatch_activate(v3);
  }
}

void sub_10000E4C8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_10002E190();
  v1 = mach_absolute_time();
  if (!*(_DWORD *)(v0 + 188))
    sub_100040F68(65541, "Shutdown stall event fired with no activations (skipping report)");
  v2 = mach_absolute_time();
  v3 = sub_10000D768(v2 - v1);
  sub_10001862C(v3);
}

uint64_t sub_10000E518(void *a1)
{
  xpc_object_t dictionary;
  uint64_t result;
  xpc_object_t v4;
  _QWORD v5[5];

  dictionary = xpc_dictionary_get_dictionary(a1, "Version4");
  if (!dictionary)
    return 22;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10000E618;
  v5[3] = &unk_10006B270;
  v5[4] = dictionary;
  sub_10000E5B8((uint64_t)v5);
  result = os_variant_is_darwinos("com.apple.xpc.launchd");
  if ((_DWORD)result)
  {
    v4 = xpc_retain(a1);
    xpc_array_append_value((xpc_object_t)qword_100072968, v4);
    return 0;
  }
  return result;
}

uint64_t sub_10000E5B8(uint64_t result)
{
  uint64_t v1;
  uint64_t i;

  v1 = result;
  for (i = 0; i != 256; i += 32)
  {
    if ((*((_BYTE *)&unk_100071328 + i + 16) & 2) != 0)
    {
      if (!*(_QWORD *)((char *)&unk_100071328 + i + 24))
        sub_10004D74C();
      result = (*(uint64_t (**)(uint64_t))(v1 + 16))(v1);
    }
  }
  return result;
}

void *sub_10000E618(uint64_t a1, uint64_t a2)
{
  const char *v3;
  void *result;
  void *v5;
  void *v6;
  _QWORD v7[6];

  v3 = *(const char **)(a2 + 24);
  result = xpc_dictionary_get_dictionary(*(xpc_object_t *)(a1 + 32), v3);
  if (result)
  {
    v5 = result;
    result = xpc_get_type(result);
    if (result == &_xpc_type_dictionary)
    {
      result = xpc_dictionary_get_dictionary(v5, "Override");
      if (result)
      {
        v6 = result;
        result = xpc_get_type(result);
        if (result == &_xpc_type_dictionary)
        {
          v7[0] = _NSConcreteStackBlock;
          v7[1] = 0x40000000;
          v7[2] = sub_10000F40C;
          v7[3] = &unk_10006B2F0;
          v7[4] = a2;
          v7[5] = v3;
          return (void *)xpc_dictionary_apply(v6, v7);
        }
      }
    }
  }
  return result;
}

uint64_t sub_10000E6D4(const char *a1)
{
  char *v2;
  uint64_t v3;
  char *v4;

  v2 = sub_100015630("%s%s", a1, "/Library/JetsamProperties/com.apple.jetsamproperties.DDI.plist");
  sub_100040F68(5, "Loading DDI overlay plist from: %s", v2);
  v3 = sub_10000E79C(v2);
  free(v2);
  if ((_DWORD)v3 == 2)
  {
    v4 = sub_100015630("%s%s", a1, "/System/Library/JetsamProperties/com.apple.jetsamproperties.cryptex.plist");
    sub_100040F68(5, "Loading Cryptex overlay plist from: %s", v4);
    LODWORD(v3) = sub_10000E79C(v4);
    free(v4);
    if ((_DWORD)v3 == 2)
      return 0;
    else
      return v3;
  }
  return v3;
}

uint64_t sub_10000E79C(const char *a1)
{
  void *v2;
  void *v3;
  uint64_t v4;

  sub_100040F68(5, "Loading overlay plist from: %s", a1);
  v2 = sub_10003BB38(a1);
  if (v2)
  {
    v3 = v2;
    v4 = sub_10000E518(v2);
    xpc_release(v3);
    return v4;
  }
  else
  {
    sub_100040F68(3, "Overlay plist is missing.");
    return 2;
  }
}

void sub_10000E810(void *a1, _BYTE *a2)
{
  unint64_t int64;
  unint64_t v5;
  _BOOL4 v6;

  sub_10000F4C0(a1, "ActiveSoftMemoryLimit", "ActiveHardMemoryLimit", a2);
  sub_10000F4C0(a1, "InactiveSoftMemoryLimit", "InactiveHardMemoryLimit", a2);
  int64 = xpc_dictionary_get_int64(a1, "CPUMonitorInterval");
  v5 = xpc_dictionary_get_int64(a1, "CPUMonitorPercentage");
  if (int64 >= 0x100)
  {
    sub_100014830(a2, 3, "CPUMonitorInterval is out of range, ignoring");
    xpc_dictionary_set_value(a1, "CPUMonitorInterval", 0);
    int64 = 0;
  }
  if (v5 >= 0x65)
  {
    sub_100014830(a2, 3, "CPUMonitorPercentage is out of range, ignoring");
    xpc_dictionary_set_value(a1, "CPUMonitorPercentage", 0);
    if (!int64)
      return;
LABEL_11:
    sub_100014830(a2, 3, "incomplete CPUMonitor, ignoring");
    xpc_dictionary_set_value(a1, "CPUMonitorInterval", 0);
    xpc_dictionary_set_value(a1, "CPUMonitorPercentage", 0);
    return;
  }
  if (int64)
    v6 = 0;
  else
    v6 = v5 == 100;
  if (!v6 && (v5 == 0) != (int64 == 0))
    goto LABEL_11;
}

BOOL sub_10000E974(uint64_t a1, xpc_object_t xdict, uint64_t a3)
{
  _QWORD v4[6];

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10000E9CC;
  v4[3] = &unk_10006B290;
  v4[4] = a1;
  v4[5] = a3;
  return xpc_dictionary_apply(xdict, v4);
}

uint64_t sub_10000E9CC(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;

  v6 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(a1 + 40);
  v7 = (uint64_t *)qword_100071BB0;
  if (!qword_100071BB0)
  {
    qword_100071BB0 = (uint64_t)sub_10000DD14("JetsamProperties");
    sub_10000DDC0(qword_100071BB0, "AlwaysSIGTERMOnShutdown", (char *)&stru_10006B330);
    sub_10000DDC0(qword_100071BB0, "EnableTransactions", (char *)&stru_10006B370);
    sub_10000DDC0(qword_100071BB0, "EnablePressuredExit", (char *)&stru_10006B3B0);
    sub_10000DFE0(qword_100071BB0, "ExecuteAllowed");
    sub_10000DDC0(qword_100071BB0, "EnableIdleHysteresis", (char *)&stru_10006B3F0);
    sub_10000DDC0(qword_100071BB0, "MallocSpaceEfficient", (char *)&stru_10006B430);
    sub_10000DDC0(qword_100071BB0, "MallocNanoZone", (char *)&stru_10006B470);
    sub_10000DDC0(qword_100071BB0, "MallocLargeCache", (char *)&stru_10006B4B0);
    sub_10000DDC0(qword_100071BB0, "MallocAggressiveMadvise", (char *)&stru_10006B4F0);
    sub_10000DDC0(qword_100071BB0, "MallocMediumZone", (char *)&stru_10006B530);
    sub_10000DE78(qword_100071BB0, "MallocMaxMagazines", (char *)&stru_10006B570);
    sub_10000DE78(qword_100071BB0, "ActiveSoftMemoryLimit", (char *)&stru_10006B5B0);
    sub_10000DE78(qword_100071BB0, "ActiveHardMemoryLimit", (char *)&stru_10006B5F0);
    sub_10000DE78(qword_100071BB0, "AddressLimit", (char *)&stru_10006B630);
    sub_10000DE78(qword_100071BB0, "CPUMonitorInterval", (char *)&stru_10006B670);
    sub_10000DE78(qword_100071BB0, "CPUMonitorPercentage", (char *)&stru_10006B6B0);
    sub_10000DE78(qword_100071BB0, "SoftFileDescriptorLimit", (char *)&stru_10006B6F0);
    sub_10000DE78(qword_100071BB0, "HardFileDescriptorLimit", (char *)&stru_10006B730);
    sub_10000DE78(qword_100071BB0, "SoftKqWorkloopLimit", (char *)&stru_10006B770);
    sub_10000DE78(qword_100071BB0, "HardKqWorkloopLimit", (char *)&stru_10006B7B0);
    sub_10000DE78(qword_100071BB0, "InactiveSoftMemoryLimit", (char *)&stru_10006B7F0);
    sub_10000DE78(qword_100071BB0, "InactiveHardMemoryLimit", (char *)&stru_10006B830);
    sub_10000DE78(qword_100071BB0, "JetsamPriority", (char *)&stru_10006B870);
    sub_10000DE78(qword_100071BB0, "LogicalWritesLimit", (char *)&stru_10006B8B0);
    sub_10000DE78(qword_100071BB0, "SoftPortLimit", (char *)&stru_10006B8F0);
    sub_10000DE78(qword_100071BB0, "HardPortLimit", (char *)&stru_10006B930);
    sub_10000DE78(qword_100071BB0, "ThreadLimit", (char *)&stru_10006B970);
    sub_10000DEC0(qword_100071BB0, "EnergyEfficiencyMode", (char *)&stru_10006B9B0);
    sub_10000DE78(qword_100071BB0, "WiredMemoryLimit", (char *)&stru_10006B9F0);
    v7 = (uint64_t *)qword_100071BB0;
  }
  sub_10000E0DC(v7, v6, a2, a3, v5);
  return 1;
}

uint64_t sub_10000ECE8()
{
  qword_100072968 = (uint64_t)xpc_array_create_empty();
  return sub_10000E5B8((uint64_t)&stru_10006B2D0);
}

void sub_10000ED0C(id a1, $EF9ABC46253DC4DB0B45B7482BF5FBB0 *a2)
{
  a2->var2 &= ~4u;
}

void sub_10000ED1C()
{
  void *v0;
  char *v1;
  void *v2;
  void *v3;
  xpc_object_t dictionary;
  _QWORD v5[5];

  if (!qword_100072A50)
    sub_10003E208("sysctl hw.targettype was not set");
  v0 = sub_10003BB38("/System/Library/LaunchDaemons/com.apple.jetsamproperties.NonUI.plist");
  v1 = sub_100015630("%s.%s%s.plist", "/AppleInternal/Library/LaunchDaemons/com.apple.jetsamproperties", (const char *)qword_100072A50, (const char *)qword_100072A58);
  v2 = sub_10003BB38(v1);
  if (v2
    || (free(v1),
        v1 = sub_100015630("%s.%s%s.plist", "/System/Library/LaunchDaemons/com.apple.jetsamproperties", (const char *)qword_100072A50, (const char *)qword_100072A58), (v2 = sub_10003BB38(v1)) != 0))
  {
    v3 = v2;
    if (v0)
      sub_10003E208("both NonUI & target-specific JetsamProperties plists are present. This is an error in the OS build configuration.");
  }
  else
  {
    free(v1);
    if (!v0)
      return;
    v1 = "/System/Library/LaunchDaemons/com.apple.jetsamproperties.NonUI.plist";
    v3 = v0;
  }
  qword_100072960 = (uint64_t)v1;
  if (xpc_get_type(v3) != (xpc_type_t)&_xpc_type_dictionary)
    sub_10003E208("JetsamProperties plist is malformed");
  dictionary = xpc_dictionary_get_dictionary(v3, "Version4");
  if (!dictionary)
    sub_10003E208("JetsamProperties plist is malformed - missing Version4 dictionary");
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10000F9C0;
  v5[3] = &unk_10006BA10;
  v5[4] = dictionary;
  sub_10000E5B8((uint64_t)v5);
  xpc_release(v3);
}

xpc_object_t sub_10000EEA4(void *a1)
{
  char *string;
  unsigned int v3;
  const char *v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  char *v10;
  xpc_object_t v11;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;

  string = (char *)xpc_dictionary_get_string(a1, "POSIXSpawnType");
  if (!string)
    string = (char *)xpc_dictionary_get_string(a1, "ProcessType");
  if (xpc_dictionary_get_BOOL(a1, "__Angel"))
  {
    v3 = 1;
  }
  else if (sub_1000157A8(string, "Driver"))
  {
    v3 = 3;
  }
  else
  {
    v4 = xpc_dictionary_get_string(a1, "Label");
    if (!sub_1000156F0(v4, "lockdown.")
      && ((v5 = xpc_dictionary_get_string(a1, "Label"), sub_1000156F0(v5, "UIKitApplication:"))
       || (v6 = xpc_dictionary_get_string(a1, "Label"), sub_1000156F0(v6, "AlternateSystemApplication:"))))
    {
      if (sub_1000157A8(string, "SystemApp"))
        v3 = 7;
      else
        v3 = 2;
    }
    else
    {
      v3 = 0;
    }
  }
  v7 = v3;
  if ((*((_BYTE *)&unk_100071328 + 32 * v3 + 16) & 2) == 0)
    sub_10003E208("invalid jetsam property category type: 0x%x", v3);
  v8 = xpc_dictionary_get_string(a1, "_JetsamPropertiesIdentifier");
  if (v8)
    goto LABEL_16;
  v13 = (char *)xpc_dictionary_get_string(a1, "Label");
  if (sub_1000156F0(v13, "lockdown."))
  {
    v14 = strchr(v13 + 9, 46);
    if (v14)
    {
      v8 = v14 + 1;
LABEL_16:
      v9 = sub_10001544C(v8);
LABEL_17:
      v10 = v9;
      goto LABEL_18;
    }
  }
  if (!sub_1000156F0(v13, "UIKitApplication:") && !sub_1000156F0(v13, "AlternateSystemApplication:"))
  {
    v9 = strdup(v13);
    goto LABEL_17;
  }
  v15 = strchr(v13, 58);
  v10 = sub_10001544C(v15 + 1);
  v16 = strrchr(v10, 91);
  if (v16)
  {
    *v16 = 0;
    v17 = strrchr(v10, 91);
    if (v17)
      *v17 = 0;
  }
LABEL_18:
  v11 = sub_10000F0CC(v10, (uint64_t)a1, (uint64_t)&unk_100071328 + 32 * v7);
  free(v10);
  return v11;
}

xpc_object_t sub_10000F0CC(const void *a1, uint64_t a2, uint64_t a3)
{
  xpc_object_t v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  rb_tree_t **v11;
  rb_tree_t **v12;
  rb_tree_t **v13;
  rb_tree_t **v14;
  xpc_object_t v15;
  uint64_t i;
  const char *v17;
  xpc_object_t value;
  xpc_object_t v19;

  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_apply_f(a2);
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if ((*(_BYTE *)(a3 + 16) & 4) != 0)
  {
    v11 = sub_10004310C(*(rb_tree_t ***)a3, "Global");
    if (v11)
      v10 = (void *)sub_100043334((uint64_t)v11);
    else
      v10 = 0;
    v12 = sub_10004310C(*(rb_tree_t ***)a3, a1);
    if (v12)
      v9 = (void *)sub_100043334((uint64_t)v12);
    else
      v9 = 0;
    v13 = sub_10004310C(*(rb_tree_t ***)(a3 + 8), "Global");
    if (v13)
      v7 = (void *)sub_100043334((uint64_t)v13);
    else
      v7 = 0;
    v14 = sub_10004310C(*(rb_tree_t ***)(a3 + 8), a1);
    if (v14)
      v8 = (void *)sub_100043334((uint64_t)v14);
    else
      v8 = 0;
  }
  v15 = xpc_dictionary_create(0, 0, 0);
  for (i = 0; i != 29; ++i)
  {
    v17 = (&off_10006BA70)[i];
    if (v8)
    {
      value = xpc_dictionary_get_value(v8, (&off_10006BA70)[i]);
      if (!v7)
        goto LABEL_21;
    }
    else
    {
      value = 0;
      if (!v7)
        goto LABEL_21;
    }
    if (!value)
      value = xpc_dictionary_get_value(v7, v17);
LABEL_21:
    if (!value)
    {
      v19 = xpc_dictionary_get_value(v6, v17);
      value = v19;
      if (v9 && !v19)
        value = xpc_dictionary_get_value(v9, v17);
      if (v10 && !value)
        value = xpc_dictionary_get_value(v10, v17);
    }
    xpc_dictionary_set_value(v15, v17, value);
  }
  if (v8)
    xpc_release(v8);
  if (v7)
    xpc_release(v7);
  if (v9)
    xpc_release(v9);
  if (v10)
    xpc_release(v10);
  xpc_release(v6);
  return v15;
}

xpc_object_t sub_10000F2CC(const void *a1)
{
  xpc_object_t v2;
  void *v3;
  xpc_object_t v4;

  v2 = xpc_dictionary_create(0, 0, 0);
  if ((byte_1000713B8 & 2) == 0)
    sub_10003E208("invalid jetsam property category type: 0x%x", 4);
  v3 = v2;
  v4 = sub_10000F0CC(a1, (uint64_t)v2, (uint64_t)&unk_1000713A8);
  xpc_release(v3);
  return v4;
}

xpc_object_t sub_10000F348(const void *a1, xpc_object_t xdict)
{
  const char *string;
  unsigned int v4;
  unsigned int v5;
  char *v6;
  xpc_object_t v7;
  xpc_object_t v8;

  string = xpc_dictionary_get_string(xdict, "ServiceType");
  v4 = 5;
  if (string)
  {
    if (!strcasecmp(string, "System"))
      v4 = 6;
    else
      v4 = 5;
  }
  v5 = v4;
  v6 = (char *)&unk_100071328 + 32 * v4;
  if ((v6[16] & 2) == 0)
    sub_10003E208("invalid jetsam property category type: 0x%x", v5);
  v7 = xpc_dictionary_create(0, 0, 0);
  v8 = sub_10000F0CC(a1, (uint64_t)v7, (uint64_t)v6);
  xpc_release(v7);
  return v8;
}

uint64_t sub_10000F400()
{
  return qword_100072968;
}

uint64_t sub_10000F40C(uint64_t a1, char *__s1, void *a3)
{
  _QWORD *v6;
  uint64_t v7;
  void *v8;

  if (!sub_1000157A8(__s1, "Global") && xpc_get_type(a3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v6 = sub_1000432C8((uint64_t)a3);
    v7 = *(_QWORD *)(a1 + 32);
    if ((*(_BYTE *)(v7 + 16) & 4) == 0)
      sub_10003E208("jetsam property category (%s) is not initialized", *(const char **)(a1 + 40));
    v8 = v6;
    sub_100043048(*(_QWORD *)(v7 + 8), __s1, v6);
    sub_10001962C(v8);
  }
  return 1;
}

void sub_10000F4C0(void *a1, const char *a2, const char *a3, _BYTE *a4)
{
  int v8;
  int v9;
  int v10;

  v8 = sub_10000F5B8(a1, a2, a4);
  v9 = sub_10000F5B8(a1, a3, a4);
  v10 = v9;
  if (v8 >= 1 && v9 >= 1)
  {
    if (v9 >= v8)
    {
      sub_100014830(a4, 6, "%s is ignored in favor of %s", a3, a2);
    }
    else
    {
      sub_100014830(a4, 6, "%s is ignored in favor of %s", a2, a3);
      a3 = a2;
    }
    goto LABEL_11;
  }
  if (v8 < 0)
  {
    xpc_dictionary_set_value(a1, a2, 0);
    if (v10 < 0)
LABEL_11:
      xpc_dictionary_set_value(a1, a3, 0);
  }
  else if (v9 < 0)
  {
    goto LABEL_11;
  }
}

int64_t sub_10000F5B8(void *a1, const char *a2, _BYTE *a3)
{
  xpc_object_t value;
  void *v7;
  int64_t result;

  value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    v7 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
    {
      result = xpc_int64_get_value(v7);
      if ((unint64_t)(result - 0x7FFFFFFF) > 0xFFFFFFFF00000001)
        return result;
      sub_100014830(a3, 3, "%s is out of range, ignoring");
    }
    else
    {
      sub_100014830(a3, 3, "%s is not an int, ignoring");
    }
    xpc_dictionary_set_value(a1, a2, 0);
  }
  return 0xFFFFFFFFLL;
}

void sub_10000F664(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x200000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFDFFFFFFFFFFFLL | v4;
}

void sub_10000F684(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 256;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFEFFLL | v4;
}

void sub_10000F6A4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 512;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFFFFFFFFFFFDFFLL | v4;
}

void sub_10000F6C4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  uint64_t v4;

  v4 = 0x800000000000;
  if (!a3)
    v4 = 0;
  *((_QWORD *)&a2->var4 + 125) = *((_QWORD *)&a2->var4 + 125) & 0xFFFF7FFFFFFFFFFFLL | v4;
}

void sub_10000F6E4(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  const char *v4;

  if (a3)
    v4 = "1";
  else
    v4 = "0";
  sub_100005AFC((uint64_t)a2, "MallocSpaceEfficient", v4, 0);
}

void sub_10000F710(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  const char *v4;

  if (a3)
    v4 = "1";
  else
    v4 = "0";
  sub_100005AFC((uint64_t)a2, "MallocNanoZone", v4, 0);
}

void sub_10000F73C(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  const char *v4;

  if (a3)
    v4 = "1";
  else
    v4 = "0";
  sub_100005AFC((uint64_t)a2, "MallocLargeCache", v4, 0);
}

void sub_10000F768(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  const char *v4;

  if (a3)
    v4 = "1";
  else
    v4 = "0";
  sub_100005AFC((uint64_t)a2, "MallocAggressiveMadvise", v4, 0);
}

void sub_10000F794(id a1, _launch_service_s *a2, BOOL a3, _launch_lint_s *a4)
{
  const char *v4;

  if (a3)
    v4 = "1";
  else
    v4 = "0";
  sub_100005AFC((uint64_t)a2, "MallocMediumZone", v4, 0);
}

void sub_10000F7C0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v11;
  char *v12;

  if (a3 < 0)
  {
    sub_10001D418((uint64_t)a2, 4, "%s less than zero. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"MallocMaxMagazines");
  }
  else if (HIDWORD(a3))
  {
    sub_10001D418((uint64_t)a2, 4, "%s is too large. Ignoring.", (uint64_t)a4, v4, v5, v6, v7, (char)"MallocMaxMagazines");
  }
  else
  {
    v11 = sub_100015630("%u", a3);
    if (v11)
    {
      v12 = v11;
      sub_100005AFC((uint64_t)a2, "MallocMaxMagazines", v11, 0);
      free(v12);
    }
    else
    {
      sub_100014830(a4, 3, "Could not convert value for MallocMaxMagazines to str: %lld", a3);
    }
  }
}

void sub_10000F89C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var60 = a3;
}

void sub_10000F8A4(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var60 = a3;
  a2->var4.var58 |= 4u;
}

void sub_10000F8B8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var63 = a3;
}

void sub_10000F8C0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var78 = a3;
}

void sub_10000F8C8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var77 = a3;
}

void sub_10000F8D0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var66 = a3;
}

void sub_10000F8D8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var67 = a3;
}

void sub_10000F8E0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var68 = a3;
}

void sub_10000F8E8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var69 = a3;
}

void sub_10000F8F0(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var61 = a3;
}

void sub_10000F8F8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var61 = a3;
  a2->var4.var58 |= 8u;
}

void sub_10000F90C(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var59 = a3;
}

void sub_10000F914(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var74 = (int)a3;
}

void sub_10000F920(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var64 = a3;
}

void sub_10000F928(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var65 = a3;
}

void sub_10000F930(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var62 = a3;
}

void sub_10000F938(id a1, _launch_service_s *a2, char *a3, _launch_lint_s *a4)
{
  if (sub_1000157E0(a3, "Efficient"))
  {
    a2->var4.var73 = 1;
  }
  else if (!sub_1000157E0(a3, "UserInterface"))
  {
    sub_100014830(a4, 3, "Unsupported value for EnergyEfficiencyMode: %s", a3);
  }
}

void sub_10000F9B8(id a1, _launch_service_s *a2, int64_t a3, _launch_lint_s *a4)
{
  a2->var4.var70 = a3;
}

void sub_10000F9C0(uint64_t a1, uint64_t a2)
{
  xpc_object_t dictionary;
  void *v4;
  xpc_object_t v5;
  void *v6;
  xpc_object_t v7;
  void *v8;
  _QWORD v9[5];
  _QWORD applier[5];

  if ((*(_BYTE *)(a2 + 16) & 4) != 0)
    sub_10003E208("found multiple jetsam property plists for category %s", *(const char **)(a2 + 24));
  dictionary = xpc_dictionary_get_dictionary(*(xpc_object_t *)(a1 + 32), *(const char **)(a2 + 24));
  if (dictionary)
  {
    v4 = dictionary;
    *(_QWORD *)a2 = sub_1000431D8();
    *(_QWORD *)(a2 + 8) = sub_1000431D8();
    v5 = xpc_dictionary_get_dictionary(v4, "Default");
    if (v5)
    {
      v6 = v5;
      if (xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary)
      {
        applier[0] = _NSConcreteStackBlock;
        applier[1] = 0x40000000;
        applier[2] = sub_10000FB20;
        applier[3] = &unk_10006BA30;
        applier[4] = a2;
        xpc_dictionary_apply(v6, applier);
      }
    }
    v7 = xpc_dictionary_get_dictionary(v4, "Override");
    if (v7)
    {
      v8 = v7;
      if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
      {
        v9[0] = _NSConcreteStackBlock;
        v9[1] = 0x40000000;
        v9[2] = sub_10000FB9C;
        v9[3] = &unk_10006BA50;
        v9[4] = a2;
        xpc_dictionary_apply(v8, v9);
      }
    }
    *(_DWORD *)(a2 + 16) |= 4u;
  }
  else
  {
    sub_100040F68(65540, "did not initialize jetsam properties category: %s", *(const char **)(a2 + 24));
  }
}

uint64_t sub_10000FB20(uint64_t a1, const void *a2, xpc_object_t object)
{
  _QWORD *v6;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v6 = sub_1000432C8((uint64_t)object);
    sub_100043048(**(_QWORD **)(a1 + 32), a2, v6);
    sub_10001962C(v6);
  }
  return 1;
}

uint64_t sub_10000FB9C(uint64_t a1, const void *a2, xpc_object_t object)
{
  _QWORD *v6;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v6 = sub_1000432C8((uint64_t)object);
    sub_100043048(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8), a2, v6);
    sub_10001962C(v6);
  }
  return 1;
}

void sub_10000FC18(char *a1, void *a2, void *a3)
{
  uint64_t v6;
  const char *v7;

  v6 = 0;
  while (1)
  {
    v7 = (&off_10006BA70)[v6];
    if (!strcasecmp(a1, v7))
      break;
    if (++v6 == 29)
      return;
  }
  xpc_dictionary_set_value(a3, v7, a2);
}

void sub_10000FC98(const char *a1)
{
  char *v1;

  v1 = sub_10001544C(a1);
  if (qword_100071BC0 != -1)
    dispatch_once(&qword_100071BC0, &stru_10006BB78);
  dispatch_sync_f((dispatch_queue_t)qword_100071BB8, v1, (dispatch_function_t)sub_10000FCF4);
}

void sub_10000FCF4(char *__s)
{
  int v2;
  ssize_t v3;

  v2 = dword_100071428;
  if (dword_100071428 == -1)
  {
    v2 = open("/dev/console", 131073);
    dword_100071428 = v2;
  }
  v3 = strlen(__s);
  if (write(v2, __s, v3) < v3 && *__error() == 5)
  {
    sub_10003BAF4((int *)dword_100071428);
    dword_100071428 = -1;
  }
  free(__s);
}

void sub_10000FD8C(char *a1, ...)
{
  void *context[2];
  va_list va;

  va_start(va, a1);
  context[0] = 0;
  va_copy((va_list)&context[1], va);
  if (vasprintf((char **)context, a1, va) != -1)
  {
    if (qword_100071BC0 != -1)
      dispatch_once(&qword_100071BC0, &stru_10006BB78);
    dispatch_async_f((dispatch_queue_t)qword_100071BB8, context[0], (dispatch_function_t)sub_10000FCF4);
  }
}

void sub_10000FE04(char *a1, ...)
{
  void *v1[2];
  va_list va;

  va_start(va, a1);
  v1[0] = 0;
  va_copy((va_list)&v1[1], va);
  if (vasprintf((char **)v1, a1, va) != -1)
  {
    sub_10000FC98((const char *)v1[0]);
    free(v1[0]);
  }
}

void sub_10000FE4C(id a1)
{
  qword_100071BB8 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.serialq", 0);
}

uint64_t sub_10000FE74()
{
  return 49197;
}

uint64_t sub_10000FE80()
{
  return sub_10000FE74();
}

uint64_t sub_10000FE8C()
{
  return sub_10000FE74();
}

double sub_10000FEB0()
{
  double result;

  result = 0.0;
  xmmword_100071C68 = 0u;
  unk_100071C78 = 0u;
  xmmword_100071C48 = 0u;
  unk_100071C58 = 0u;
  xmmword_100071C28 = 0u;
  unk_100071C38 = 0u;
  xmmword_100071C08 = 0u;
  unk_100071C18 = 0u;
  xmmword_100071BE8 = 0u;
  unk_100071BF8 = 0u;
  xmmword_100071BC8 = 0u;
  unk_100071BD8 = 0u;
  qword_100071C88 = 0;
  xmmword_10007142C = 0uLL;
  qword_10007143C = 0x7FFFFFFF00000000;
  unk_100071444 = 0;
  return result;
}

uint64_t sub_10000FEF4(uint64_t result, uint64_t a2)
{
  char v2;
  __int128 *v3;
  BOOL v4;
  BOOL v5;
  uint64_t v7;
  _QWORD *v8;
  BOOL v9;
  BOOL v10;
  unint64_t v12;
  __int128 *v13;
  __int128 v14;
  unint64_t v15;
  __int128 v16;

  if (result)
  {
    v2 = a2;
    v3 = (__int128 *)result;
    if (a2 == 7)
    {
      if ((__int128 *)result != &xmmword_10007142C)
      {
        v4 = *(_QWORD *)result == (_QWORD)xmmword_10007142C
          && *(_QWORD *)(result + 8) == *((_QWORD *)&xmmword_10007142C + 1);
        v5 = v4 && *(_QWORD *)(result + 16) == qword_10007143C;
        if (!v5 || *(_QWORD *)(result + 24) != unk_100071444)
        {
          if ((sub_100010040(result) & 0x80) == 0)
            return 0;
          v16 = v3[1];
          xmmword_10007142C = *v3;
          *(_OWORD *)&qword_10007143C = v16;
        }
      }
      return 1;
    }
    else
    {
      v7 = 0;
      while (1)
      {
        if (BYTE8(xmmword_100071BC8[3 * ((qword_100071C88 + v7) & 3) + 2]))
        {
          v8 = (_QWORD *)&xmmword_100071BC8[3 * ((qword_100071C88 + v7) & 3)] + 1;
          if (v8 == (_QWORD *)result)
            break;
          v9 = *(_QWORD *)result == *v8
            && *(_QWORD *)(result + 8) == *(_QWORD *)&xmmword_100071BC8[3
                                                                      * ((qword_100071C88
                                                                        + v7) & 3)
                                                                      + 1];
          v10 = v9
             && *(_QWORD *)(result + 16) == *((_QWORD *)&xmmword_100071BC8[3
                                                                         * ((qword_100071C88
                                                                           + v7) & 3)
                                                                         + 1]
                                            + 1);
          if (v10
            && *(_QWORD *)(result + 24) == *(_QWORD *)&xmmword_100071BC8[3
                                                                       * ((qword_100071C88
                                                                         + v7) & 3)
                                                                       + 2])
          {
            break;
          }
        }
        if (++v7 == 4)
        {
          v12 = sub_100010040(result);
          qword_100071C88 = ((_BYTE)qword_100071C88 - 1) & 3;
          v13 = &xmmword_100071BC8[3 * qword_100071C88];
          v14 = v3[1];
          *(__int128 *)((char *)v13 + 8) = *v3;
          *(__int128 *)((char *)v13 + 24) = v14;
          *(_QWORD *)v13 = v12;
          *((_BYTE *)v13 + 40) = 1;
          v15 = v12 >> v2;
          return v15 & 1;
        }
      }
      v15 = *(_QWORD *)&xmmword_100071BC8[3 * ((qword_100071C88 + v7) & 3)] >> a2;
      return v15 & 1;
    }
  }
  return result;
}

uint64_t sub_100010040(uint64_t a1)
{
  xpc_object_t v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  xpc_object_t value;
  void *v6;

  v1 = sub_100040958(a1);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = 0;
  v4 = 0;
  do
  {
    value = xpc_dictionary_get_value(v2, off_10006BB98[v3]);
    if (value)
    {
      v6 = value;
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL || xpc_BOOL_get_value(v6))
        v4 |= 1 << v3;
    }
    ++v3;
  }
  while (v3 != 39);
  xpc_release(v2);
  return v4;
}

uint64_t sub_1000100EC(unsigned int *a1)
{
  unsigned int v1;
  unint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v7;

  v1 = *a1;
  if (*a1 >= 2)
    sub_10004D858(v1 == 1);
  v7 = 0;
  HIDWORD(v3) = a1[6];
  LODWORD(v3) = HIDWORD(v3) - 256;
  v4 = 512;
  switch((v3 >> 8))
  {
    case 0u:
    case 3u:
      v4 = 1024;
      break;
    case 4u:
      break;
    case 5u:
      v4 = 768;
      break;
    case 6u:
      if (*((_BYTE *)a1 + 48))
        v4 = 256;
      else
        v4 = 1024;
      break;
    default:
      v4 = 0;
      break;
  }
  v5 = v4 | (16 * (v1 & 0xF));
  if (v1 == 1)
  {
    if (*((_QWORD *)a1 + 4))
      v5 = v5 | 2;
    else
      v5 = v5;
  }
  if (coalition_create(&v7, v5) == -1)
    sub_10004D83C();
  if (!*a1 && *((_QWORD *)a1 + 5) && coalition_ledger_set_logical_writes_limit(v7) == -1)
    sub_10004D83C();
  return v7;
}

uint64_t sub_1000101E4(uint64_t a1)
{
  uint64_t result;

  result = coalition_terminate(a1, 0);
  if ((_DWORD)result == -1)
    return sub_10004D870();
  return result;
}

uint64_t sub_10001020C(uint64_t a1)
{
  uint64_t result;

  result = coalition_reap(a1, 0);
  if ((_DWORD)result == -1)
    return sub_10004D870();
  return result;
}

uint64_t sub_100010234(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  result = posix_spawnattr_setcoalition_np(a2, *(_QWORD *)a4, a3, *(unsigned int *)(a4 + 8));
  if ((_DWORD)result)
    return _os_assumes_log_ctx(sub_10001F174, a1);
  return result;
}

void sub_100010280(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  void *v4;
  void *v5;

  free(*(void **)(a1 + 64));
  v2 = *(NSObject **)(a1 + 72);
  if (v2)
    dispatch_release(v2);
  v3 = *(NSObject **)(a1 + 248);
  if (v3)
    dispatch_release(v3);
  v4 = *(void **)(a1 + 80);
  if (v4)
    xpc_release(v4);
  v5 = *(void **)(a1 + 88);
  if (v5)
    xpc_release(v5);
  _Block_release(*(const void **)(a1 + 256));
}

uint64_t sub_1000102D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;

  v0 = sub_1000146FC();
  qword_100071C90 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v0);
  dispatch_source_set_timer((dispatch_source_t)qword_100071C90, 0, 1000000000 * dword_100071AB0, 0);
  dispatch_source_set_event_handler_f((dispatch_source_t)qword_100071C90, (dispatch_function_t)j__sync);
  dispatch_activate((dispatch_object_t)qword_100071C90);
  qword_100072970 = (uint64_t)dispatch_semaphore_create(10);
  v1 = setiopolicy_np(9, 0, 1);
  if ((_DWORD)v1)
    v1 = _os_assumes_log((int)v1);
  return nullsub_23(v1, v2);
}

void sub_100010384()
{
  NSObject *v0;
  NSObject *v1;
  void **block;
  uint64_t v3;
  void (*v4)(uint64_t);
  void *v5;
  dispatch_queue_t v6;

  block = _NSConcreteStackBlock;
  v3 = 0x40000000;
  v4 = sub_100010604;
  v5 = &unk_10006BCD0;
  v6 = (dispatch_queue_t)sub_1000146F0();
  dispatch_sync(v6, &block);
  v0 = sub_1000146FC();
  block = _NSConcreteStackBlock;
  v3 = 0x40000000;
  v4 = sub_100010604;
  v5 = &unk_10006BCD0;
  v6 = v0;
  dispatch_sync(v0, &block);
  v1 = sub_100014708();
  block = _NSConcreteStackBlock;
  v3 = 0x40000000;
  v4 = sub_100010604;
  v5 = &unk_10006BCD0;
  v6 = v1;
  dispatch_sync(v1, &block);
}

uint64_t sub_100010428()
{
  return qword_100072970;
}

_BYTE *sub_100010434(char a1, uint64_t a2)
{
  _BYTE *v4;
  const char *v5;
  char v6;

  v4 = sub_100019C64(0);
  v4[56] = a1;
  if (a2)
  {
    v5 = (const char *)xpc_bundle_copy_normalized_cryptex_path(a2);
    *((_QWORD *)v4 + 8) = v5;
    if (sub_10001886C(v5))
      v6 = 4;
    else
      v6 = 0;
    v4[264] = v4[264] & 0xFB | v6;
  }
  return v4;
}

_BYTE *sub_1000104A0(int a1, uint64_t a2, int a3)
{
  _BYTE *result;

  result = sub_100010434(a1, a2);
  if (a1 == 4)
    *((_DWORD *)result + 60) = a3;
  return result;
}

void sub_1000104D0(uint64_t a1, dispatch_object_t object, const void *a3)
{
  int v6;

  dispatch_retain(object);
  *(_QWORD *)(a1 + 248) = object;
  *(_QWORD *)(a1 + 256) = _Block_copy(a3);
  if (*(_BYTE *)(a1 + 56) == 4 || (*(_BYTE *)(a1 + 264) & 1) != 0)
    goto LABEL_7;
  if (!sub_100019088())
    goto LABEL_9;
  if (!sub_10001886C(*(const char **)(a1 + 64)))
  {
    if ((*(_BYTE *)(a1 + 264) & 4) != 0)
      sub_10003E208("refusing to read cache protected location from disk: %s", *(const char **)(a1 + 64));
LABEL_9:
    sub_1000148A4(a1);
    return;
  }
  v6 = sub_1000188BC(a1);
  if (v6)
  {
    *(_DWORD *)(a1 + 240) = v6;
LABEL_7:
    dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 248));
    (*(void (**)(void))(*(_QWORD *)(a1 + 256) + 16))();
  }
}

uint64_t sub_1000105B4(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 56);
}

uint64_t sub_1000105BC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 72);
}

uint64_t sub_1000105C4(uint64_t a1)
{
  return *(_BYTE *)(a1 + 264) & 1;
}

uint64_t sub_1000105D0(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 264) >> 2) & 1;
}

xpc_object_t sub_1000105DC(uint64_t a1)
{
  xpc_object_t result;

  result = *(xpc_object_t *)(a1 + 88);
  if (result)
    return xpc_retain(result);
  return result;
}

uint64_t sub_1000105EC(uint64_t a1)
{
  return a1 + 96;
}

uint64_t sub_1000105F4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t sub_1000105FC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 80);
}

void sub_100010604(uint64_t a1)
{
  dispatch_suspend(*(dispatch_object_t *)(a1 + 32));
}

BOOL sub_10001060C(const char *a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return sysctlbyname(a1, 0, 0, __s, v4 + 1) == 0;
}

void *sub_100010654(const char *a1)
{
  size_t v1;
  void *result;
  void *v3;

  v3 = 0;
  v1 = sub_10003FCE8(a1, (char **)&v3);
  result = v3;
  if (v1)
  {
    if (!v3)
      sub_10004D74C();
  }
  else
  {
    free(v3);
    return 0;
  }
  return result;
}

uint64_t sub_100010698(const char *a1)
{
  uint64_t v2;

  v2 = 0;
  if (sub_10003FE74(a1, &v2) == 8)
    return v2;
  else
    return 0;
}

_QWORD *sub_1000106C8(size_t a1)
{
  _QWORD *v2;
  _BYTE *v3;

  if (!a1)
    sub_10004D738();
  v2 = sub_10001389C(0x18uLL);
  v3 = sub_10001389C(a1);
  *v3 = 0;
  *v2 = v3;
  v2[1] = a1;
  v2[2] = 0;
  return v2;
}

char *sub_100010710(const char **a1)
{
  return sub_10001544C(*a1);
}

void sub_100010718(void **a1)
{
  free(*a1);
  free(a1);
}

void sub_100010740(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v10;
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  size_t v18;
  size_t v19;
  char *__source[2];

  __source[0] = 0;
  __source[1] = &a9;
  v10 = vasprintf(__source, a2, &a9);
  if (v10 == -1)
  {
    sub_10004D870();
    return;
  }
  v11 = *(_QWORD *)(a1 + 16);
  v12 = __CFADD__(v11, v10);
  v13 = v11 + v10;
  if (v12)
    v14 = ((uint64_t)v10 >> 63) + 1;
  else
    v14 = (uint64_t)v10 >> 63;
  v15 = v14 << 63 >> 63;
  if (v15 != v14 || v15 < 0)
    goto LABEL_20;
  v16 = *(_QWORD *)(a1 + 8);
  if (v16 <= v13)
  {
    if ((v13 & 0x8000000000000000) == 0)
    {
      v18 = 2 * v13;
      if (2 * v13 < 2 * v16)
        sub_10004D738();
      v17 = (char *)sub_10001389C(2 * v13);
      if (strlcpy(v17, *(const char **)a1, v18) >= v18)
        sub_10004D738();
      free(*(void **)a1);
      *(_QWORD *)a1 = v17;
      *(_QWORD *)(a1 + 8) = v18;
      goto LABEL_13;
    }
LABEL_20:
    __break(1u);
    return;
  }
  v17 = *(char **)a1;
  v18 = *(_QWORD *)(a1 + 8);
LABEL_13:
  v19 = strlcat(v17, __source[0], v18);
  *(_QWORD *)(a1 + 16) = v19;
  if (v19 >= *(_QWORD *)(a1 + 8))
    sub_10004D738();
  free(__source[0]);
}

_QWORD *sub_100010840(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = result[2];
  v3 = v2 >= a2;
  v4 = v2 - a2;
  if (!v3)
    sub_10004D738();
  result[2] = v4;
  *(_BYTE *)(*result + v4) = 0;
  return result;
}

uint64_t sub_10001086C(__int128 *a1)
{
  __int128 v2;
  __int128 v3;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;

  v2 = a1[1];
  v5 = *a1;
  v6 = v2;
  v7 = a1[2];
  v8 = *((_QWORD *)a1 + 6);
  if (!sub_10004B70C((uint64_t)&v5))
    return 0;
  v3 = a1[1];
  v5 = *a1;
  v6 = v3;
  v7 = a1[2];
  v8 = *((_QWORD *)a1 + 6);
  return sub_1000108DC((uint64_t *)&v5);
}

uint64_t sub_1000108DC(uint64_t *a1)
{
  uint64_t v2;
  __int128 v3;
  xpc_object_t empty;
  uint64_t v5;
  __int128 v6;
  int64_t v7;
  xpc_object_t no_copy;
  __int128 v9;
  void *v10;
  __int128 v11;
  char v12;
  __int128 v13;
  const void *v14;
  size_t v15;
  uint64_t result;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;

  v2 = *a1;
  v3 = *((_OWORD *)a1 + 1);
  v22 = *(_OWORD *)a1;
  v23 = v3;
  v24 = *((_OWORD *)a1 + 2);
  v25 = a1[6];
  switch(sub_10004B714((uint64_t)&v22, 0))
  {
    case 1u:
      v18 = *(_OWORD *)a1;
      v19 = *((_OWORD *)a1 + 1);
      v20 = *((_OWORD *)a1 + 2);
      v21 = a1[6];
      empty = xpc_dictionary_create_empty();
      goto LABEL_4;
    case 2u:
      v18 = *(_OWORD *)a1;
      v19 = *((_OWORD *)a1 + 1);
      v20 = *((_OWORD *)a1 + 2);
      v21 = a1[6];
      empty = xpc_array_create_empty();
LABEL_4:
      v5 = (uint64_t)empty;
      v22 = v18;
      v23 = v19;
      v24 = v20;
      v25 = v21;
      sub_10004B818((unint64_t)&v22, (uint64_t)empty, (uint64_t)sub_100010B48);
      goto LABEL_10;
    case 3u:
      v6 = *((_OWORD *)a1 + 1);
      v22 = *(_OWORD *)a1;
      v23 = v6;
      v24 = *((_OWORD *)a1 + 2);
      v25 = a1[6];
      v7 = sub_10004BB40((uint64_t)&v22);
      no_copy = xpc_int64_create(v7);
      goto LABEL_9;
    case 4u:
      v9 = *((_OWORD *)a1 + 1);
      v22 = *(_OWORD *)a1;
      v23 = v9;
      v24 = *((_OWORD *)a1 + 2);
      v25 = a1[6];
      v10 = sub_100010E08((uint64_t)&v22);
      no_copy = (xpc_object_t)xpc_string_create_no_copy(v10);
      goto LABEL_9;
    case 5u:
      v11 = *((_OWORD *)a1 + 1);
      v22 = *(_OWORD *)a1;
      v23 = v11;
      v24 = *((_OWORD *)a1 + 2);
      v25 = a1[6];
      v12 = sub_10004BD14((uint64_t)&v22);
      no_copy = xpc_BOOL_create(v12);
      goto LABEL_9;
    case 6u:
      v13 = *((_OWORD *)a1 + 1);
      v22 = *(_OWORD *)a1;
      v23 = v13;
      v24 = *((_OWORD *)a1 + 2);
      v25 = a1[6];
      v14 = (const void *)sub_10004BDF8((uint64_t)&v22);
      no_copy = xpc_data_create(v14, v15);
LABEL_9:
      v5 = (uint64_t)no_copy;
LABEL_10:
      result = v5;
      break;
    default:
      v17 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))(v2, "[%s]: %s\n", "_objectForActiveContext", "CoreEntitlements: unknown DER type");
      result = xpc_create_from_ce_der(v17);
      break;
  }
  return result;
}

uint64_t xpc_create_from_ce_der(unint64_t a1, uint64_t a2)
{
  void *v2;
  uint64_t result;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;

  v12 = 0uLL;
  v13 = 0;
  v2 = (void *)sub_10004BEAC((uint64_t)&unk_10006BCF0, (uint64_t *)&v12, a1, a1 + a2);
  result = 0;
  if (v2 == &unk_10006DFA8)
  {
    v10 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0u;
    v4 = v12;
    *(_QWORD *)&v5 = v13;
    if ((_UNKNOWN *)sub_10004C22C((uint64_t)&unk_10006BCF0, &v4, (uint64_t)&v8) == &unk_10006DFA8)
    {
      v4 = v8;
      v5 = v9;
      v6 = v10;
      v7 = v11;
      return sub_10001086C(&v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100010B48(uint64_t *a1)
{
  uint64_t v2;
  int v3;
  __int128 v4;
  void *v5;
  void *v6;
  void *v7;
  __int128 v8;
  char *v9;
  xpc_object_t empty;
  __int128 v11;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  _OWORD v18[3];
  uint64_t v19;
  _OWORD v20[3];
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  _OWORD v26[16];

  v2 = *a1;
  v3 = *((_DWORD *)a1 + 29);
  if (v3 == 2)
  {
    if (*((_DWORD *)a1 + 28) == 1)
    {
      v7 = (void *)a1[15];
      v14 = *(_OWORD *)(a1 + 7);
      v15 = *(_OWORD *)(a1 + 9);
      v16 = *(_OWORD *)(a1 + 11);
      v17 = a1[13];
      v25 = 0;
      v23 = 0u;
      v24 = 0u;
      v22 = 0u;
      memset((char *)v26 + 8, 0, 248);
      v8 = *(_OWORD *)(a1 + 9);
      v20[0] = *(_OWORD *)(a1 + 7);
      v20[1] = v8;
      v20[2] = *(_OWORD *)(a1 + 11);
      v21 = a1[13];
      *(_QWORD *)&v26[0] = 2;
      sub_10004B6B8((uint64_t)v20, (unint64_t)v26, (uint64_t)&v22);
      v26[0] = v22;
      v26[1] = v23;
      v26[2] = v24;
      *(_QWORD *)&v26[3] = v25;
      v9 = (char *)sub_100010E08((uint64_t)v26);
      v18[0] = v14;
      v18[1] = v15;
      v18[2] = v16;
      v19 = v17;
      v26[0] = xmmword_10004FCE0;
      memset(&v26[1], 0, 240);
      sub_10004B6B8((uint64_t)v18, (unint64_t)v26, (uint64_t)v20);
      empty = (xpc_object_t)sub_1000108DC(v20);
      xpc_dictionary_set_value(v7, v9, empty);
      free(v9);
    }
    else
    {
      empty = xpc_array_create_empty();
      v11 = *(_OWORD *)(a1 + 9);
      v26[0] = *(_OWORD *)(a1 + 7);
      v26[1] = v11;
      v26[2] = *(_OWORD *)(a1 + 11);
      *(_QWORD *)&v26[3] = a1[13];
      if ((_UNKNOWN *)sub_10004B818((unint64_t)v26, (uint64_t)empty, (uint64_t)sub_100010B48) != &unk_10006DFA8)
      {
        v13 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))(v2, "[%s]: %s\n", "_manufacturingCallback", "CoreEntitlements: Couldn't iterate over DER entitlements\n");
        return (uint64_t)sub_100010E08(v13);
      }
      xpc_array_set_value((xpc_object_t)a1[15], 0xFFFFFFFFFFFFFFFFLL, empty);
    }
    v6 = empty;
    goto LABEL_10;
  }
  if (v3)
  {
    if (*((_DWORD *)a1 + 28) == 2)
    {
      v4 = *(_OWORD *)(a1 + 9);
      v26[0] = *(_OWORD *)(a1 + 7);
      v26[1] = v4;
      v26[2] = *(_OWORD *)(a1 + 11);
      *(_QWORD *)&v26[3] = a1[13];
      v5 = (void *)sub_1000108DC(v26);
      xpc_array_set_value((xpc_object_t)a1[15], 0xFFFFFFFFFFFFFFFFLL, v5);
      v6 = v5;
LABEL_10:
      xpc_release(v6);
      return 1;
    }
    v13 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))(v2, "[%s]: %s\n", "_manufacturingCallback", "CoreEntitlements: not a sequence");
  }
  else
  {
    v13 = (*(uint64_t (**)(uint64_t, const char *, ...))(v2 + 32))(v2, "[%s]: %s\n", "_manufacturingCallback", "CoreEntitlements: unknown DER type");
  }
  return (uint64_t)sub_100010E08(v13);
}

void *sub_100010E08(uint64_t a1)
{
  __int128 v1;
  const void *v2;
  size_t v3;
  size_t v4;
  void *v5;
  _OWORD v7[3];
  uint64_t v8;

  v1 = *(_OWORD *)(a1 + 16);
  v7[0] = *(_OWORD *)a1;
  v7[1] = v1;
  v7[2] = *(_OWORD *)(a1 + 32);
  v8 = *(_QWORD *)(a1 + 48);
  v2 = (const void *)sub_10004BC60((uint64_t)v7);
  v4 = v3;
  v5 = sub_10001389C(v3 + 1);
  memcpy(v5, v2, v4);
  return v5;
}

void *sub_100010E74(int a1, size_t size)
{
  return malloc_type_malloc(size, 0x78220757uLL);
}

void sub_100010E84(int a1, void *a2)
{
  free(a2);
}

void sub_100010E8C(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  vsyslog(7, a2, &a9);
}

void sub_100010EB8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  vsyslog(2, a2, &a9);
  qword_100071AF8 = (uint64_t)"Data corruption: CoreEntitlements has aborted due to an unrecoverable error";
  __break(1u);
}

void sub_100010EF8()
{
  qword_100071C98 = 0;
}

void sub_100010F04()
{
  char *v0;
  char *v1;
  char *v2;
  const char *v3;
  const char *v4;
  char *v5;
  char *v6;
  int *v7;

  v0 = (char *)sub_10001105C("ReleaseType");
  sub_100011178("kern.osreleasetype", v0);
  if (byte_100072A80)
  {
    v1 = (char *)sub_100010654("kern.osversion");
    if (v1)
    {
      v2 = v1;
      v3 = sub_10001105C("ProductBuildVersion");
      if (v3)
      {
        v4 = v3;
        if (!sub_1000157A8(v2, v3))
          sub_10003E264("Userspace reboot changed system version: previous %s != current %s", v2, v4);
        free(v2);
      }
      else
      {
        sub_100040F68(65539, "Missing ProductBuildVersion");
      }
    }
    else
    {
      v7 = __error();
      sub_100040F68(65539, "Unable to reload kern.osversion: %d", *v7);
    }
  }
  else
  {
    v5 = (char *)sub_10001105C("ProductVersion");
    sub_100011178("kern.osproductversion", v5);
    v6 = (char *)sub_10001105C("ProductBuildVersion");
    sub_100011178("kern.osversion", v6);
  }
}

const char *sub_100011030()
{
  const char *result;

  result = sub_10001105C("ProductBuildVersion");
  if (!result)
    return "99Z999";
  return result;
}

const char *sub_10001105C(char *key)
{
  void *v2;
  void *v3;
  xpc_object_t v4;

  if (!qword_100071C98)
  {
    v2 = sub_10003BB38("/System/Library/CoreServices/SystemVersion.plist");
    if (qword_100071C98)
      sub_10004D74C();
    v3 = v2;
    v4 = xpc_dictionary_create(0, 0, 0);
    qword_100071C98 = (uint64_t)v4;
    if (v3)
    {
      sub_1000111F4(v4, v3, "ProductVersion");
      sub_1000111F4((void *)qword_100071C98, v3, "ProductBuildVersion");
      sub_1000111F4((void *)qword_100071C98, v3, "iOSSupportVersion");
      sub_1000111F4((void *)qword_100071C98, v3, "ReleaseType");
      v4 = (xpc_object_t)qword_100071C98;
    }
    if (!xpc_dictionary_get_string(v4, "ReleaseType"))
      xpc_dictionary_set_string((xpc_object_t)qword_100071C98, "ReleaseType", "User");
    if (v3)
      xpc_release(v3);
  }
  return xpc_dictionary_get_string((xpc_object_t)qword_100071C98, key);
}

BOOL sub_10001114C(const char *a1)
{
  char *v2;

  v2 = (char *)sub_10001105C("ReleaseType");
  return sub_10001578C(v2, a1);
}

void sub_100011178(const char *a1, char *a2)
{
  unsigned __int8 *v4;
  int v5;

  if (a2)
  {
    v4 = (unsigned __int8 *)sub_100010654(a1);
    if (v4 && (v5 = *v4, free(v4), v5))
    {
      sub_100040F68(4, "%s is already set, skipping", a1);
    }
    else if (!sub_10001060C(a1, a2))
    {
      sub_10004D88C(a1);
    }
  }
}

void sub_1000111F4(void *a1, xpc_object_t xdict, char *key)
{
  const char *string;

  string = xpc_dictionary_get_string(xdict, key);
  if (string)
    xpc_dictionary_set_string(a1, key, string);
}

_QWORD *sub_10001123C()
{
  _QWORD *v0;

  v0 = sub_100019A6C(0);
  v0[4] = 8;
  v0[2] = sub_10001389C(0x40uLL);
  return v0;
}

void sub_100011278(uint64_t a1)
{
  unint64_t v2;

  if (*(_QWORD *)(a1 + 24))
  {
    v2 = 0;
    do
      os_release(*(void **)(*(_QWORD *)(a1 + 16) + 8 * v2++));
    while (v2 < *(_QWORD *)(a1 + 24));
  }
  free(*(void **)(a1 + 16));
}

_QWORD *sub_1000112C0(_QWORD *result, void *object)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  void *v8;
  uint64_t v9;

  v3 = result;
  v4 = result[3];
  v5 = result[4];
  if (v4 == v5)
  {
    result[4] = 2 * v4;
    if ((v4 & 0x8000000000000000) != 0 || (2 * v4) >> 61 || (result = sub_10001389C(16 * v4), v6 = v3[3], v6 >> 61))
    {
      __break(1u);
      return result;
    }
    v7 = result;
    v8 = (void *)v3[2];
    memcpy(result, v8, 8 * v6);
    free(v8);
    v3[2] = v7;
    v4 = v3[3];
    v5 = v3[4];
  }
  if (v4 >= v5)
    sub_10004D738();
  result = os_retain(object);
  v9 = v3[3];
  *(_QWORD *)(v3[2] + 8 * v9) = result;
  v3[3] = v9 + 1;
  return result;
}

void sub_100011368(uint64_t a1, unint64_t a2)
{
  uint64_t v4;

  if (*(_QWORD *)(a1 + 24) <= a2)
    sub_10004D738();
  os_release(*(void **)(*(_QWORD *)(a1 + 16) + 8 * a2));
  v4 = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * a2) = 0;
  *(_QWORD *)(a1 + 24) = v4 - 1;
  if (v4 - 1 > a2)
    memmove((void *)(*(_QWORD *)(a1 + 16) + 8 * a2), (const void *)(*(_QWORD *)(a1 + 16) + 8 * a2 + 8), 8 * (v4 - 1 - a2));
}

uint64_t sub_1000113D8(uint64_t a1, unint64_t a2)
{
  if (*(_QWORD *)(a1 + 24) <= a2)
    sub_10004D738();
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8 * a2);
}

uint64_t sub_100011400(uint64_t a1)
{
  return *(_QWORD *)(a1 + 24);
}

uint64_t sub_10001140C(uint64_t a1)
{
  return kdebug_trace(a1, 0, 0, 0, 0);
}

uint64_t sub_100011420(uint64_t a1, uint64_t a2)
{
  return kdebug_trace(a1, a2, 0, 0, 0);
}

uint64_t sub_100011430(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return kdebug_trace(a1, a2, a3, 0, 0);
}

uint64_t sub_10001143C(uint64_t a1, const char *a2)
{
  char __dst[8];
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  strncpy(__dst, a2, 0x20uLL);
  return kdebug_trace(a1, *(_QWORD *)__dst, v5, v6, v7);
}

uint64_t sub_1000114A8(void *a1)
{
  size_t count;
  size_t v3;
  size_t i;
  xpc_object_t value;
  xpc_object_t v6;
  const char *string_ptr;
  const char *v8;
  uint64_t v9;
  _QWORD applier[5];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  xpc_object_t empty;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2000000000;
  empty = 0;
  empty = xpc_array_create_empty();
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = sub_10001161C;
  applier[3] = &unk_10006BD40;
  applier[4] = &v12;
  xpc_dictionary_apply(a1, applier);
  count = xpc_array_get_count((xpc_object_t)v13[3]);
  do
  {
    if (count < 2)
      break;
    v3 = 0;
    for (i = 1; i != count; ++i)
    {
      value = xpc_array_get_value((xpc_object_t)v13[3], i - 1);
      v6 = xpc_array_get_value((xpc_object_t)v13[3], i);
      string_ptr = xpc_string_get_string_ptr(value);
      v8 = xpc_string_get_string_ptr(v6);
      if (strcmp(string_ptr, v8) >= 1)
      {
        xpc_retain(value);
        xpc_array_set_value((xpc_object_t)v13[3], i - 1, v6);
        xpc_array_set_value((xpc_object_t)v13[3], i, value);
        xpc_release(value);
        v3 = i;
      }
    }
    count = v3;
  }
  while (v3);
  v9 = v13[3];
  _Block_object_dispose(&v12, 8);
  return v9;
}

uint64_t sub_10001161C(uint64_t a1, char *string)
{
  xpc_array_set_string(*(xpc_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), 0xFFFFFFFFFFFFFFFFLL, string);
  return 1;
}

xpc_object_t sub_100011648(int64_t a1, int64_t a2, xpc_object_t object)
{
  xpc_object_t empty;

  if (object && xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
    return 0;
  empty = xpc_dictionary_create_empty();
  xpc_dictionary_set_int64(empty, "vers", a1);
  xpc_dictionary_set_int64(empty, "comp", 1);
  xpc_dictionary_set_int64(empty, "ccat", a2);
  if (object)
    xpc_dictionary_set_value(empty, "reqs", object);
  return empty;
}

size_t sub_1000116F4(void *a1)
{
  xpc_object_t empty;
  xpc_object_t v3;
  size_t result;
  char *v5;
  size_t count;
  void *v7;
  size_t v8;
  size_t v9;
  void **v10;
  size_t length[5];
  char v12;

  if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_dictionary)
    return 0;
  empty = xpc_array_create_empty();
  if (sub_100011B10(a1, empty))
  {
    xpc_release(empty);
    return 0;
  }
  if (!empty)
    return 0;
  result = xpc_array_get_count(empty);
  if (!(result >> 59))
  {
    v5 = (char *)sub_10001389C(32 * result);
    length[0] = (size_t)_NSConcreteStackBlock;
    length[1] = 0x40000000;
    length[2] = (size_t)sub_10001216C;
    length[3] = (size_t)&unk_10006BDB0;
    length[4] = (size_t)v5;
    xpc_array_apply(empty, length);
    count = xpc_array_get_count(empty);
    length[0] = 0;
    v3 = 0;
    if (sub_10004A20C(v5, count, length) == (char *)&unk_10006DFA8)
    {
      v7 = sub_10001389C(length[0]);
      v12 = 1;
      if ((_UNKNOWN *)sub_10004A2E8((uint64_t)&unk_10006BCF0, &v12, (unint64_t)v5, count, (unint64_t)v7, (unint64_t)v7 + length[0]) == &unk_10006DFA8)v3 = xpc_data_create(v7, length[0]);
      else
        v3 = 0;
      free(v7);
    }
    v8 = xpc_array_get_count(empty);
    if (v8)
    {
      v9 = v8;
      v10 = (void **)(v5 + 8);
      do
      {
        if (*(v10 - 1) == (void *)3)
          free(*v10);
        v10 += 4;
        --v9;
      }
      while (v9);
    }
    free(v5);
    xpc_release(empty);
    return (size_t)v3;
  }
  __break(1u);
  return result;
}

uint64_t sub_1000118AC(unint64_t a1, uint64_t a2)
{
  void *v2;
  uint64_t result;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  char v12;
  __int128 v13;
  uint64_t v14;

  v13 = 0uLL;
  v14 = 0;
  v12 = 1;
  v2 = (void *)sub_10004BEE8((uint64_t)&unk_10006BCF0, &v12, (uint64_t *)&v13, a1, a1 + a2);
  result = 0;
  if (v2 == &unk_10006DFA8)
  {
    v10 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0u;
    v4 = v13;
    *(_QWORD *)&v5 = v14;
    if ((_UNKNOWN *)sub_10004C22C((uint64_t)&unk_10006BCF0, &v4, (uint64_t)&v8) == &unk_10006DFA8)
    {
      v4 = v8;
      v5 = v9;
      v6 = v10;
      v7 = v11;
      return sub_10001086C(&v4);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

size_t sub_10001197C(unint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  xpc_object_t v6;
  void *v7;
  xpc_object_t v8;
  void *v9;
  size_t v10;
  xpc_object_t empty;
  xpc_object_t v12;
  xpc_object_t v13;
  __int128 v15;

  *((_QWORD *)&v15 + 1) = 0;
  v6 = sub_100011A9C(a1, a2, (int64_t *)&v15 + 1);
  if (!v6)
    return 0;
  v7 = v6;
  *(_QWORD *)&v15 = 0;
  v8 = sub_100011A9C(a3, a4, (int64_t *)&v15);
  if (v8)
  {
    v9 = v8;
    if (v15 == 0)
    {
      empty = xpc_dictionary_create_empty();
      xpc_dictionary_set_value(empty, "$and", v9);
      v12 = xpc_dictionary_create_empty();
      xpc_dictionary_set_value(v12, "$and", v7);
      xpc_dictionary_set_value(v12, "$or", empty);
      xpc_release(empty);
      v13 = sub_100011648(1, 0, v12);
      xpc_release(v12);
      v10 = sub_1000116F4(v13);
      xpc_release(v13);
    }
    else
    {
      v10 = 0;
    }
    xpc_release(v7);
  }
  else
  {
    v10 = 0;
    v9 = v7;
  }
  xpc_release(v9);
  return v10;
}

xpc_object_t sub_100011A9C(unint64_t a1, uint64_t a2, int64_t *a3)
{
  void *v4;
  void *v5;
  xpc_object_t value;
  xpc_object_t v7;

  v4 = (void *)sub_1000118AC(a1, a2);
  if (!v4)
    return 0;
  v5 = v4;
  value = xpc_dictionary_get_value(v4, "reqs");
  v7 = value;
  if (value)
    xpc_retain(value);
  *a3 = xpc_dictionary_get_int64(v5, "ccat");
  xpc_release(v5);
  return v7;
}

uint64_t sub_100011B10(void *a1, void *a2)
{
  void *v4;
  uint64_t v5;
  _QWORD applier[7];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t bytes;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2000000000;
  v11 = 4;
  v4 = (void *)sub_1000114A8(a1);
  v14 = 0;
  v15 = 0;
  bytes = 7;
  v13 = 0;
  xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = sub_100011C10;
  applier[3] = &unk_10006BD68;
  applier[5] = a2;
  applier[6] = a1;
  applier[4] = &v8;
  xpc_array_apply(v4, applier);
  xpc_release(v4);
  v5 = *((unsigned int *)v9 + 6);
  if (!(_DWORD)v5)
  {
    v14 = 0;
    v15 = 0;
    bytes = 8;
    v13 = 0;
    xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
    v5 = *((unsigned int *)v9 + 6);
  }
  _Block_object_dispose(&v8, 8);
  return v5;
}

uint64_t sub_100011C10(uint64_t a1, uint64_t a2, void *a3)
{
  void *v5;
  const char *string_ptr;
  void *v7;
  const char *v8;
  xpc_object_t value;
  uint64_t shared_cache_range;
  uint64_t v11;
  void *v12;
  uint64_t result;
  const char *v14;
  const char *v15;
  uint64_t v16;
  _QWORD v17[4];
  uint64_t v18;
  uint64_t v19;
  uint64_t bytes;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v5 = *(void **)(a1 + 40);
  v22 = 0;
  v23 = 0;
  bytes = 5;
  v21 = 0;
  xpc_array_set_data(v5, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
  string_ptr = xpc_string_get_string_ptr(a3);
  v17[3] = 0;
  v17[0] = 3;
  v17[1] = sub_10001544C(string_ptr);
  v17[2] = xpc_string_get_length(a3);
  xpc_array_set_data(*(xpc_object_t *)(a1 + 40), 0xFFFFFFFFFFFFFFFFLL, v17, 0x20uLL);
  v7 = *(void **)(a1 + 48);
  v8 = xpc_string_get_string_ptr(a3);
  value = xpc_dictionary_get_value(v7, v8);
  if (value)
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_100011E44(value, *(void **)(a1 + 40));
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    {
      bytes = 0;
      v21 = 0;
      v18 = 0;
      v19 = 0;
      if ((_dyld_get_image_uuid(&_mh_execute_header, &bytes) & 1) == 0)
      {
        bytes = 0;
        v21 = 0;
      }
      if ((_dyld_get_shared_cache_uuid(&v18) & 1) != 0)
      {
        v16 = 0;
        shared_cache_range = _dyld_get_shared_cache_range(&v16);
      }
      else
      {
        shared_cache_range = 0;
        v18 = 0;
        v19 = 0;
      }
      v14 = xpc_string_get_string_ptr(a3);
      _os_log_simple(&_mh_execute_header, &bytes, &v18, shared_cache_range, 16, 0, "failed to serialized value for key: %s", v14);
      return 0;
    }
    else
    {
      v12 = *(void **)(a1 + 40);
      v22 = 0;
      v23 = 0;
      bytes = 6;
      v21 = 0;
      xpc_array_set_data(v12, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
      return 1;
    }
  }
  else
  {
    bytes = 0;
    v21 = 0;
    v18 = 0;
    v19 = 0;
    if ((_dyld_get_image_uuid(&_mh_execute_header, &bytes) & 1) == 0)
    {
      bytes = 0;
      v21 = 0;
    }
    if ((_dyld_get_shared_cache_uuid(&v18) & 1) != 0)
    {
      v16 = 0;
      v11 = _dyld_get_shared_cache_range(&v16);
    }
    else
    {
      v11 = 0;
      v18 = 0;
      v19 = 0;
    }
    v15 = xpc_string_get_string_ptr(a3);
    _os_log_simple(&_mh_execute_header, &bytes, &v18, v11, 16, 0, "no value for key: %s", v15);
    result = 0;
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 2;
  }
  return result;
}

uint64_t sub_100011E44(void *a1, void *a2)
{
  xpc_type_t type;
  const _xpc_type_s *v5;
  uint64_t shared_cache_range;
  size_t length;
  uint64_t v8;
  const char *name;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  int v14;
  uint64_t bytes;
  int64_t string_ptr;
  BOOL (*v17)(uint64_t, uint64_t, uint64_t);
  void *v18;
  uint64_t *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  type = xpc_get_type(a1);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    v18 = 0;
    bytes = 2;
    string_ptr = (int64_t)xpc_string_get_string_ptr(a1);
    length = xpc_string_get_length(a1);
LABEL_12:
    v17 = (BOOL (*)(uint64_t, uint64_t, uint64_t))length;
LABEL_16:
    LOBYTE(v18) = 0;
    xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
    return 0;
  }
  v5 = type;
  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    bytes = 4;
    v18 = 0;
    string_ptr = xpc_int64_get_value(a1);
LABEL_15:
    v17 = 0;
    goto LABEL_16;
  }
  if (type == (xpc_type_t)&_xpc_type_BOOL)
  {
    bytes = 1;
    v18 = 0;
    string_ptr = xpc_BOOL_get_value(a1);
    goto LABEL_15;
  }
  if (type == (xpc_type_t)&_xpc_type_data)
  {
    v18 = 0;
    bytes = 9;
    string_ptr = (int64_t)xpc_data_get_bytes_ptr(a1);
    length = xpc_data_get_length(a1);
    goto LABEL_12;
  }
  if (type != (xpc_type_t)&_xpc_type_dictionary)
  {
    if (type == (xpc_type_t)&_xpc_type_array)
    {
      v11 = 0;
      v12 = &v11;
      v13 = 0x2000000000;
      v14 = 4;
      v17 = 0;
      v18 = 0;
      bytes = 5;
      string_ptr = 0;
      xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &bytes, 0x20uLL);
      bytes = (uint64_t)_NSConcreteStackBlock;
      string_ptr = 0x40000000;
      v17 = sub_100012124;
      v18 = &unk_10006BD90;
      v19 = &v11;
      v20 = a2;
      xpc_array_apply(a1, &bytes);
      v8 = *((unsigned int *)v12 + 6);
      if (!(_DWORD)v8)
      {
        v23 = 0;
        v24 = 0;
        v21 = 6;
        v22 = 0;
        xpc_array_set_data(a2, 0xFFFFFFFFFFFFFFFFLL, &v21, 0x20uLL);
        v8 = *((unsigned int *)v12 + 6);
      }
      _Block_object_dispose(&v11, 8);
    }
    else
    {
      bytes = 0;
      string_ptr = 0;
      v21 = 0;
      v22 = 0;
      if ((_dyld_get_image_uuid(&_mh_execute_header, &bytes) & 1) == 0)
      {
        bytes = 0;
        string_ptr = 0;
      }
      if ((_dyld_get_shared_cache_uuid(&v21) & 1) != 0)
      {
        v11 = 0;
        shared_cache_range = _dyld_get_shared_cache_range(&v11);
      }
      else
      {
        shared_cache_range = 0;
        v21 = 0;
        v22 = 0;
      }
      name = xpc_type_get_name(v5);
      _os_log_simple(&_mh_execute_header, &bytes, &v21, shared_cache_range, 16, 0, "unsupported type: %s", name);
      return 1;
    }
    return v8;
  }
  return sub_100011B10(a1, a2);
}

BOOL sub_100012124(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_100011E44(a3, *(_QWORD *)(a1 + 40));
  return *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) == 0;
}

uint64_t sub_10001216C(uint64_t a1, uint64_t a2, xpc_object_t xdata)
{
  _OWORD *v3;
  _OWORD *bytes_ptr;
  __int128 v5;

  v3 = (_OWORD *)(*(_QWORD *)(a1 + 32) + 32 * a2);
  bytes_ptr = xpc_data_get_bytes_ptr(xdata);
  v5 = bytes_ptr[1];
  *v3 = *bytes_ptr;
  v3[1] = v5;
  return 1;
}

void *sub_1000121A0()
{
  void *v0;

  v0 = sub_10001389C(0x18uLL);
  os_map_str_init(v0, 0, 1);
  return v0;
}

size_t sub_1000121D4(uint64_t a1, const char *a2)
{
  _DWORD *v4;
  _DWORD *v5;
  size_t v6;
  size_t v7;
  BOOL v8;
  size_t result;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  _DWORD *v13;
  size_t v14;

  v4 = (_DWORD *)os_map_str_find(a1, a2);
  if (v4)
  {
    ++*v4;
    return (size_t)(v4 + 1);
  }
  v6 = strlen(a2);
  v7 = v6 + 4;
  v8 = v6 >= 0xFFFFFFFFFFFFFFFCLL;
  result = v6 + 5;
  v10 = v7 == -1;
  v11 = v10 << 63 >> 63;
  v12 = v11 != v10;
  if (!v8 && !v12 && (v11 & 0x8000000000000000) == 0)
  {
    v13 = sub_10001389C(result);
    v5 = v13 + 1;
    v14 = strlen(a2);
    memcpy(v13 + 1, a2, v14);
    *v13 = 1;
    os_map_str_insert(a1, v13 + 1, v13);
    return (size_t)v5;
  }
  __break(1u);
  return result;
}

void sub_100012290(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;

  v4 = (_DWORD *)os_map_str_find(a1, a2);
  if (!v4)
    sub_10004D8E4(0, v5, v6, v7);
  v8 = v4;
  if ((*v4)-- == 1)
  {
    os_map_str_delete(a1, a2);
    free(v8);
  }
}

void sub_1000122F8(void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v2 = os_map_str_count(a1);
  if (v2)
    sub_10004D8FC(v2, v3, v4, v5);
  os_map_str_destroy(a1);
  free(a1);
}

_BYTE *sub_10001232C(uint64_t a1, const char *a2, const char *a3, int a4, uint64_t a5)
{
  _BYTE *v10;

  if (!a1)
    sub_10004D738();
  v10 = sub_100019DE4(0);
  v10[16] = 0;
  *((_DWORD *)v10 + 5) = a4;
  *((_QWORD *)v10 + 3) = a1;
  *((_QWORD *)v10 + 4) = 1;
  *((_QWORD *)v10 + 5) = 0;
  if (a2)
    *((_QWORD *)v10 + 5) = sub_10001544C(a2);
  *((_QWORD *)v10 + 6) = 0;
  if (a3)
    *((_QWORD *)v10 + 6) = sub_10001544C(a3);
  *((_QWORD *)v10 + 7) = 0;
  *((_QWORD *)v10 + 8) = a5;
  return v10;
}

void sub_1000123BC(uint64_t a1)
{
  if (*(_BYTE *)(a1 + 16) != 2)
    sub_10004D738();
  if (*(_QWORD *)(a1 + 32))
    sub_10004D738();
  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  free(*(void **)(a1 + 56));
}

uint64_t sub_100012408(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 32);
  if (!v1)
    sub_10004D738();
  if (*(_BYTE *)(result + 16))
    sub_10004D738();
  *(_QWORD *)(result + 32) = v1 + 1;
  return result;
}

uint64_t sub_100012438(uint64_t a1)
{
  uint64_t v1;
  uint64_t v3;

  v1 = *(_QWORD *)(a1 + 32);
  if (!v1)
    sub_10004D738();
  if (*(_BYTE *)(a1 + 16))
    sub_10004D738();
  v3 = v1 - 1;
  *(_QWORD *)(a1 + 32) = v3;
  if (!v3)
  {
    *(_BYTE *)(a1 + 16) = 1;
    (*(void (**)(_QWORD))(a1 + 64))(*(_QWORD *)(a1 + 24));
  }
  return a1;
}

_QWORD *sub_100012490(_QWORD *result, const void *a2)
{
  _QWORD *v2;

  if (result[4])
    sub_10004D738();
  v2 = result;
  if (*((_BYTE *)result + 16) != 1)
    sub_10004D738();
  *((_BYTE *)result + 16) = 2;
  if (a2)
  {
    result = sub_10001541C(a2, 0x160uLL);
    v2[7] = result;
  }
  return result;
}

uint64_t sub_1000124E4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t sub_1000124EC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

uint64_t sub_1000124F4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56);
}

uint64_t sub_1000124FC(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t sub_100012504(uint64_t result, int a2)
{
  if (*(unsigned __int8 *)(result + 16) != a2)
    sub_10004D738();
  return result;
}

uint64_t sub_100012524()
{
  return os_map_str_init(&unk_100071CA0, 0, 1);
}

void sub_100012538(void **a1)
{
  if ((void **)os_map_str_delete(&unk_100071CA0, a1[4]) != a1)
    sub_10004D74C();
  xpc_release(a1[3]);
  free(a1[2]);
  free(a1[4]);
}

_QWORD *sub_100012584(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t property;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const char *v12;
  void *info_dictionary;
  void *v14;
  const char *string;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  char *executable_path;
  uint64_t v23;
  const char **v24;
  const char *v25;
  _QWORD *v26;
  char *v27;
  char *v28;
  char v30;

  property = xpc_bundle_get_property(a2, 2);
  if (!property)
  {
    *a3 = 107;
    v27 = "Could not get path for service bundle.";
LABEL_11:
    sub_100028C34(a1, 3, v27, v7, v8, v9, v10, v11, v30);
    return 0;
  }
  v12 = (const char *)property;
  info_dictionary = (void *)xpc_bundle_get_info_dictionary(a2);
  if (!info_dictionary)
  {
    *a3 = 107;
    v30 = (char)v12;
    v27 = "Could not get Info.plist for bundle at %s";
    goto LABEL_11;
  }
  v14 = info_dictionary;
  string = xpc_dictionary_get_string(info_dictionary, "CFBundleIdentifier");
  if (!string)
  {
    sub_100028C34(a1, 3, "Bundle Info.plist at %s does not have a CFBundleIdentifier", v16, v17, v18, v19, v20, (char)v12);
    v26 = 0;
    *a3 = 107;
    return v26;
  }
  v21 = (char *)string;
  executable_path = (char *)xpc_bundle_get_executable_path(a2);
  v23 = os_map_str_find(&unk_100071CA0, v12);
  if (!v23)
  {
LABEL_15:
    v26 = sub_100019E3C(v21);
    v26[2] = sub_10001544C(executable_path);
    v26[3] = xpc_retain(v14);
    v28 = sub_10001544C(v12);
    v26[4] = v28;
    os_map_str_insert(&unk_100071CA0, v28, v26);
    return v26;
  }
  v24 = (const char **)v23;
  v25 = (const char *)(v23 + 40);
  if (!sub_1000157A8(v21, (const char *)(v23 + 40)))
  {
    sub_100040F68(65539, "CACHE INVARIANT VIOLATED: %s | %s != %s", v12, v21, v25);
    goto LABEL_15;
  }
  if (!sub_1000157A8(executable_path, v24[2]))
  {
    sub_100040F68(65539, "CACHE INVARIANT VIOLATED: %s | %s != %s", v12, executable_path, v24[2]);
    goto LABEL_15;
  }
  v26 = sub_100019580(v24);
  if (!v26)
    goto LABEL_15;
  return v26;
}

uint64_t sub_100012734(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t result;

  bzero((void *)a1, 0x728uLL);
  *(_QWORD *)(a1 + 1128) = 0x6400000064;
  v4 = posix_spawnattr_init((posix_spawnattr_t *)a1);
  if (v4)
    sub_10004D764(v4);
  result = posix_spawn_file_actions_init((posix_spawn_file_actions_t *)(a1 + 8));
  if ((_DWORD)result)
    sub_10004D764(result);
  *(_QWORD *)(a1 + 1208) = a2;
  return result;
}

void sub_100012788(uint64_t a1)
{
  _QWORD *v2;

  posix_spawnattr_destroy((posix_spawnattr_t *)a1);
  posix_spawn_file_actions_destroy((posix_spawn_file_actions_t *)(a1 + 8));
  while (1)
  {
    v2 = *(_QWORD **)(a1 + 1824);
    if (!v2)
      break;
    *(_QWORD *)(a1 + 1824) = *v2;
    free(v2);
  }
  free(*(void **)(a1 + 1216));
  free(*(void **)(a1 + 1232));
  if (*(_QWORD *)(a1 + 1248))
    free(*(void **)(a1 + 1240));
}

uint64_t sub_1000127F0(posix_spawnattr_t *a1, __int16 a2, __int16 a3)
{
  int v6;
  uint64_t result;
  __int16 v8;

  v8 = 0;
  v6 = posix_spawnattr_getflags(a1, &v8);
  if (v6)
    sub_10004D764(v6);
  v8 = v8 & ~a3 | a2;
  result = posix_spawnattr_setflags(a1, v8);
  if ((_DWORD)result)
    sub_10004D764(result);
  return result;
}

uint64_t sub_10001285C(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  __int16 v12;
  unsigned int v13;
  __int16 v15;
  int v16;
  int v17;
  int v18;
  cpu_type_t *v19;
  cpu_type_t *v20;
  qos_class_t v21;
  int v22;
  int v23;
  int v24;
  const char *v25;
  uint64_t v26;
  int v27;
  uint64_t result;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  unsigned int v46;
  const char *v47;
  uint64_t v48;
  uint64_t v49;
  const char *v50;
  unsigned int v51;
  uint64_t v52;
  const char *v53;
  const char *v54;
  int v55;
  const char *v56;
  uint64_t v57;
  int v58;
  unsigned int v59;
  const char *v60;
  int v61;
  uint64_t v62;
  const char **v63;
  uint64_t v64;
  uint64_t v65;
  _QWORD *v66;
  _QWORD *v67;
  const char **v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  const char *v79;
  uint64_t v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  unsigned int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  int v111;
  int v112;
  int v113;
  int v114;
  xpc_object_t v115;
  uint64_t v116;
  uint64_t v117;
  char *v118;
  char *v119;
  uint64_t v120;
  uint64_t v121;
  char *v123;
  unsigned int v124;
  uint64_t v125;
  uint64_t v126;
  const char *v127;
  const char *v128;
  uint64_t v129;
  int v130;
  unsigned int v131;
  const char *v132;
  char *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  int v138;
  unsigned int v139;
  const char *v140;
  char *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  int v145;
  int v146;
  unsigned int v147;
  const char *v148;
  char *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  int v153;
  int v154;
  int v155;
  char v156;
  const char *v157;
  const char *v158;
  const char *v159;
  char __str[1024];

  v8 = a1;
  if (!*(_QWORD *)(a1 + 1208))
  {
    v25 = "Missing program";
    v26 = 22;
    v27 = 580;
    return sub_10001EC4C(a1, v26, 0, v27, 0, v25, a7, a8, v156);
  }
  if (*(_BYTE *)(a2 + 108))
    v12 = 16512;
  else
    v12 = 0x4000;
  v13 = *(_DWORD *)(a2 + 236);
  if ((v13 & 0x4000) == 0 || MEMORY[0xFFFFF4084] == 0)
    v15 = 1024;
  else
    v15 = 1280;
  v16 = *(_DWORD *)(a2 + 236);
  if ((v13 & 0x8000) != 0)
  {
    v17 = posix_spawnattr_disable_ptr_auth_a_keys_np(a1, 0);
    if (v17)
      sub_10004D764(v17);
    v16 = *(_DWORD *)(a2 + 236);
  }
  if ((v16 & 0x40000) != 0)
  {
    v18 = posix_spawnattr_set_use_sec_transition_shims_np(v8, 1);
    if (v18)
      sub_10004D764(v18);
    v16 = *(_DWORD *)(a2 + 236);
  }
  sub_1000127F0((posix_spawnattr_t *)v8, (v13 >> 8) & 0x200 | v12 | (v13 >> 7) & 0x8000 | v15 | HIWORD(v16) & 0x800, 0);
  v19 = (cpu_type_t *)_xpc_spawnattr_binprefs_unpack(a2, a3);
  if (v19)
  {
    v20 = v19;
    xpc_binprefs_set_psattr(v19, (posix_spawnattr_t *)v8);
    free(v20);
  }
  v21 = *(_DWORD *)(a2 + 200);
  if (v21)
  {
    v22 = posix_spawnattr_set_qos_class_np((posix_spawnattr_t *)v8, v21);
    if (v22)
      sub_10004D764(v22);
  }
  v23 = *(_DWORD *)(a2 + 236);
  if ((v23 & 0x200000) != 0)
  {
    if (*(_BYTE *)(a2 + 228) != 100 || *(_DWORD *)(a2 + 224))
    {
      v29 = posix_spawnattr_setcpumonitor(v8);
      if (v29)
        sub_10004D764(v29);
    }
  }
  else if ((v23 & 2) != 0)
  {
    v30 = posix_spawnattr_setcpumonitor_default(v8);
    if (v30)
      sub_10004D764(v30);
  }
  else if ((v23 & 1) == 0)
  {
    v24 = posix_spawnattr_setcpumonitor_default(v8);
    if (v24)
      sub_10004D764(v24);
  }
  v31 = posix_spawnattr_setjetsam_ext(v8, *(__int16 *)(a2 + 120), *(unsigned int *)(a2 + 124), *(unsigned int *)(a2 + 128), *(unsigned int *)(a2 + 132));
  if (v31)
    sub_10004D764(v31);
  v32 = posix_spawnattr_set_threadlimit_ext(v8, *(unsigned int *)(a2 + 136));
  if (v32)
    sub_10004D764(v32);
  v33 = posix_spawnattr_set_max_addr_np(v8, *(_QWORD *)(a2 + 140));
  if (v33)
    sub_10004D764(v33);
  v34 = posix_spawnattr_set_portlimits_ext(v8, *(unsigned int *)(a2 + 148), *(unsigned int *)(a2 + 152));
  if (v34)
    sub_10004D764(v34);
  v35 = posix_spawnattr_set_filedesclimit_ext(v8, *(unsigned int *)(a2 + 156), *(unsigned int *)(a2 + 160));
  if (v35)
    sub_10004D764(v35);
  v36 = posix_spawnattr_set_kqworklooplimit_ext(v8, *(unsigned int *)(a2 + 164), *(unsigned int *)(a2 + 168));
  if (v36)
    sub_10004D764(v36);
  if ((*(_BYTE *)(a2 + 239) & 2) != 0)
  {
    v37 = posix_spawnattr_set_max_addr_np(v8, -1);
    if (v37)
      sub_10004D764(v37);
  }
  v38 = posix_spawnattr_set_crash_behavior_np(v8, *(unsigned __int8 *)(a2 + 176));
  if (v38)
    sub_10004D764(v38);
  v39 = posix_spawnattr_set_crash_behavior_deadline_np(v8, *(_QWORD *)(a2 + 180), 0);
  if (v39)
    sub_10004D764(v39);
  v40 = posix_spawnattr_set_launch_type_np(v8, *(unsigned __int8 *)(a2 + 196));
  if (v40)
    sub_10004D764(v40);
  v41 = posix_spawnattr_set_crash_count_np(v8, *(unsigned int *)(a2 + 188), *(unsigned int *)(a2 + 192));
  if (v41)
    sub_10004D764(v41);
  v42 = posix_spawnattr_set_darwin_role_np(v8, *(unsigned int *)(a2 + 116));
  if (v42)
    sub_10004D764(v42);
  v43 = *(unsigned __int8 *)(a2 + 229);
  if (v43 == 1)
  {
    v45 = posix_spawnattr_setdataless_iopolicy_np(v8, 1);
    if (v45)
      sub_10004D764(v45);
  }
  else if (v43 == 2)
  {
    v44 = posix_spawnattr_setdataless_iopolicy_np(v8, 2);
    if (v44)
      sub_10004D764(v44);
  }
  v46 = *(_DWORD *)(a2 + 80);
  if (v46)
  {
    v47 = _xpc_spawnattr_unpack_string(a2, a3, v46);
    if (!v47)
    {
      v56 = "Unable to unpack container_id";
      v57 = v8;
      v58 = 126;
      goto LABEL_65;
    }
    v50 = v47;
    v51 = *(_DWORD *)(a2 + 84);
    if (!v51)
    {
      v52 = v8 + 16;
      sandbox_spawnattrs_init(v8 + 16);
LABEL_60:
      if (sandbox_spawnattrs_setcontainer(v52, v50) == -1)
        sub_10004D83C();
LABEL_61:
      v55 = posix_spawnattr_setmacpolicyinfo_np(v8, "Sandbox", v52, 1104);
      if (v55)
        sub_10004D764(v55);
      goto LABEL_66;
    }
  }
  else
  {
    v51 = *(_DWORD *)(a2 + 84);
    if (!v51)
      goto LABEL_66;
    v50 = 0;
  }
  v53 = _xpc_spawnattr_unpack_string(a2, a3, v51);
  if (v53)
  {
    v54 = v53;
    v52 = v8 + 16;
    sandbox_spawnattrs_init(v8 + 16);
    if (sandbox_spawnattrs_setprofilename(v8 + 16, v54) == -1)
      sub_10004D83C();
    if (!v50)
      goto LABEL_61;
    goto LABEL_60;
  }
  v56 = "Unable to unpack sandbox profile";
  v57 = v8;
  v58 = 135;
LABEL_65:
  result = sub_10001EC4C(v57, 22, 0, v58, 0, v56, v48, v49, v156);
  if ((_DWORD)result)
    return result;
LABEL_66:
  v59 = *(_DWORD *)(a2 + 88);
  if (v59)
  {
    v60 = _xpc_spawnattr_unpack_string(a2, a3, v59);
    v61 = posix_spawnattr_set_subsystem_root_path_np(v8, v60);
    if (v61)
      sub_10004D764(v61);
  }
  v62 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v62)
  {
    v63 = (const char **)sub_10001389C(8 * v62 + 8);
    *(_QWORD *)(v8 + 1216) = v63;
    if (!_xpc_spawnattr_unpack_strings(a2, a3, *(_DWORD *)(a2 + 20), v63, *(unsigned int *)(a2 + 16)))
    {
      v79 = "Unable to unpack argv";
      v80 = v8;
      v81 = 537;
      goto LABEL_78;
    }
    v66 = (_QWORD *)(*(_QWORD *)(v8 + 1216) + 8 * *(unsigned int *)(a2 + 16));
  }
  else
  {
    v67 = sub_10001389C(0x10uLL);
    *(_QWORD *)(v8 + 1216) = v67;
    *v67 = *(_QWORD *)(v8 + 1208);
    v66 = v67 + 1;
  }
  *v66 = 0;
  v68 = (const char **)sub_10001389C(8 * *(unsigned int *)(a2 + 24) + 56);
  *(_QWORD *)(v8 + 1232) = v68;
  v72 = *(unsigned int *)(a2 + 24);
  if (!(_DWORD)v72)
  {
LABEL_75:
    sub_1000137DC((_QWORD *)v8, "XXXXXXXX%s=%llx", v69, v70, v72, v71, v64, v65, (char)"XPC_FLAGS");
    goto LABEL_79;
  }
  if (_xpc_spawnattr_unpack_strings(a2, a3, *(_DWORD *)(a2 + 28), v68, v72))
  {
    *(_QWORD *)(v8 + 1224) = *(unsigned int *)(a2 + 24);
    goto LABEL_75;
  }
  v79 = "Unable to unpack environment";
  v80 = v8;
  v81 = 565;
LABEL_78:
  result = sub_10001EC4C(v80, 22, 0, v81, 0, v79, v64, v65, v156);
  if ((_DWORD)result)
    return result;
LABEL_79:
  if (*(_DWORD *)(v8 + 1128) != -101)
  {
    if (a4)
    {
      *(_QWORD *)(v8 + 1120) = sub_1000137DC((_QWORD *)v8, "XXXXXXXX%s=%s", v73, v74, v75, v76, v77, v78, (char)"LOGNAME")+ 8;
      sub_1000137DC((_QWORD *)v8, "XXXXXXXX%s=%s", v82, v83, v84, v85, v86, v87, (char)"USER");
      sub_1000137DC((_QWORD *)v8, "XXXXXXXX%s=%s", v88, v89, v90, v91, v92, v93, (char)"HOME");
      sub_1000137DC((_QWORD *)v8, "XXXXXXXX%s=%s", v94, v95, v96, v97, v98, v99, (char)"SHELL");
      v106 = *(_DWORD *)(v8 + 1128);
      if (v106 >= 0x1F5 && v106 != -2)
        sub_1000137DC((_QWORD *)v8, "XXXXXXXX%s=%s/tmp", v100, v101, v102, v103, v104, v105, (char)"TMPDIR");
      v107 = posix_spawnattr_set_login_np(v8, *(_QWORD *)(v8 + 1120));
      if (v107)
        sub_10004D764(v107);
      v108 = posix_spawnattr_set_uid_np(v8, *(unsigned int *)(v8 + 1128));
      if (v108)
        sub_10004D764(v108);
      v109 = posix_spawnattr_set_gid_np(v8, *(unsigned int *)(v8 + 1132));
      if (v109)
        sub_10004D764(v109);
      v110 = *(_DWORD *)(a2 + 236);
      if ((v110 & 0x1000) == 0)
      {
        v111 = posix_spawnattr_set_groups_np(v8, *(unsigned int *)(v8 + 1136), v8 + 1140, 4294967195);
        if (v111)
          sub_10004D764(v111);
        v110 = *(_DWORD *)(a2 + 236);
      }
      if ((v110 & 0x1000000) != 0)
      {
        v112 = posix_spawnattr_set_persona_uid_np(v8, *(unsigned int *)(v8 + 1128));
        if (v112)
          sub_10004D764(v112);
        v113 = posix_spawnattr_set_persona_gid_np(v8, *(unsigned int *)(v8 + 1132));
        if (v113)
          sub_10004D764(v113);
        if ((*(_BYTE *)(a2 + 237) & 0x10) == 0)
        {
          v114 = posix_spawnattr_set_persona_groups_np(v8, *(unsigned int *)(v8 + 1136), v8 + 1140, 4294967195);
          if (v114)
            sub_10004D764(v114);
        }
      }
    }
    else
    {
      result = sub_10001EC4C(v8, 22, 0, 354, 0, "Unable to setup identify", v77, v78, v156);
      if ((_DWORD)result)
        return result;
    }
  }
  v115 = xpc_dictionary_create(0, 0, 0);
  if (*(_QWORD *)(v8 + 1224))
  {
    v116 = 0;
    v117 = 0;
    while (1)
    {
      v118 = *(char **)(*(_QWORD *)(v8 + 1232) + 8 * v117);
      v119 = strchr(v118, 61);
      if (!v119 || v119 == v118)
        break;
      v123 = sub_1000154A0(v118, v119 - v118);
      if (!xpc_dictionary_get_value(v115, v123))
      {
        xpc_dictionary_set_BOOL(v115, v123, 1);
        *(_QWORD *)(*(_QWORD *)(v8 + 1232) + 8 * v116++) = v118;
      }
      free(v123);
      if ((unint64_t)++v117 >= *(_QWORD *)(v8 + 1224))
        goto LABEL_108;
    }
    result = sub_10001EC4C(v8, 22, 0, 464, 0, "Invalid environment[%zd]: %s", v120, v121, v117);
    if ((_DWORD)result)
      return result;
  }
  else
  {
    v116 = 0;
LABEL_108:
    xpc_release(v115);
    *(_QWORD *)(v8 + 1224) = v116;
    *(_QWORD *)(*(_QWORD *)(v8 + 1232) + 8 * v116) = 0;
  }
  v124 = *(_DWORD *)(a2 + 64);
  if (v124)
  {
    v127 = _xpc_spawnattr_unpack_string(a2, a3, v124);
    if (!v127)
    {
      v128 = "Unable to unpack cwd";
      v129 = v8;
      v130 = 224;
LABEL_144:
      result = sub_10001EC4C(v129, 22, 0, v130, 0, v128, v125, v126, v156);
LABEL_145:
      if ((_DWORD)result)
        return result;
      goto LABEL_146;
    }
  }
  else
  {
    v127 = "/";
  }
  v131 = *(_DWORD *)(a2 + 68);
  if (v131)
  {
    v132 = _xpc_spawnattr_unpack_string(a2, a3, v131);
    if (!v132)
    {
      v128 = "Unable to unpack stdin";
      v129 = v8;
      v130 = 241;
      goto LABEL_144;
    }
    v133 = (char *)v132;
    bzero(__str, 0x400uLL);
    if (*v133 != 47)
    {
      v157 = v133;
      v133 = __str;
      snprintf(__str, 0x400uLL, "%s/%s", v127, v157);
    }
    v134 = sub_100013840(v133);
    if ((_DWORD)v134)
    {
      result = sub_10001EC4C(v8, v134, 0, 253, 0, "Unable to create stdin directory (%s)", v135, v136, (char)v133);
      goto LABEL_145;
    }
    v138 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 0, v133, 131584, 0x1B6u);
    if (v138)
      sub_10004D764(v138);
  }
  else
  {
    v137 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 0, "/dev/null", 0x20000, 0x1B6u);
    if (v137)
      sub_10004D764(v137);
  }
  v139 = *(_DWORD *)(a2 + 72);
  if (v139)
  {
    v140 = _xpc_spawnattr_unpack_string(a2, a3, v139);
    if (!v140)
    {
      v128 = "Unable to unpack stdout";
      v129 = v8;
      v130 = 268;
      goto LABEL_144;
    }
    v141 = (char *)v140;
    bzero(__str, 0x400uLL);
    if (*v141 != 47)
    {
      v158 = v141;
      v141 = __str;
      snprintf(__str, 0x400uLL, "%s/%s", v127, v158);
    }
    v142 = sub_100013840(v141);
    if ((_DWORD)v142)
    {
      result = sub_10001EC4C(v8, v142, 0, 280, 0, "Unable to create stdout directory (%s)", v143, v144, (char)v141);
      goto LABEL_145;
    }
    v146 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 1, v141, 131594, 0x1B6u);
    if (v146)
      sub_10004D764(v146);
  }
  else
  {
    v145 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 1, "/dev/null", 131074, 0x1B6u);
    if (v145)
      sub_10004D764(v145);
  }
  v147 = *(_DWORD *)(a2 + 76);
  if (v147)
  {
    v148 = _xpc_spawnattr_unpack_string(a2, a3, v147);
    if (!v148)
    {
      v128 = "Unable to unpack stderr";
      v129 = v8;
      v130 = 295;
      goto LABEL_144;
    }
    v149 = (char *)v148;
    bzero(__str, 0x400uLL);
    if (*v149 != 47)
    {
      v159 = v149;
      v149 = __str;
      snprintf(__str, 0x400uLL, "%s/%s", v127, v159);
    }
    v150 = sub_100013840(v149);
    if ((_DWORD)v150)
    {
      result = sub_10001EC4C(v8, v150, 0, 307, 0, "Unable to create stderr directory (%s)", v151, v152, (char)v149);
      goto LABEL_145;
    }
    v155 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 2, v149, 131594, 0x1B6u);
    if (v155)
      sub_10004D764(v155);
  }
  else
  {
    v153 = posix_spawn_file_actions_addopen((posix_spawn_file_actions_t *)(v8 + 8), 2, "/dev/null", 131074, 0x1B6u);
    if (v153)
      sub_10004D764(v153);
  }
LABEL_146:
  if ((*(_BYTE *)(a2 + 238) & 1) != 0)
  {
    v154 = *(_DWORD *)(v8 + 1128);
    if (!v154 || v154 == -101)
    {
      v25 = "extensions cannot run as root";
      a1 = v8;
      v26 = 1;
      v27 = 769;
      return sub_10001EC4C(a1, v26, 0, v27, 0, v25, a7, a8, v156);
    }
  }
  return 0;
}

uint64_t sub_100013388(posix_spawnattr_t *a1, uint64_t a2, uint64_t a3, xpc_object_t xarray, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  unint64_t v12;
  char v15;
  size_t v16;
  uint64_t v17;
  xpc_object_t value;
  mach_port_t right;
  uint64_t v20;
  uint64_t v21;
  mach_port_t v22;
  int v23;
  int v24;
  int v25;
  const char *v26;
  uint64_t v27;
  int v28;
  char v29;
  uint64_t v30;
  int v31;

  v8 = *(unsigned int *)(a2 + 220);
  if (!(_DWORD)v8)
    return 0;
  v11 = *(unsigned int *)(a2 + 216);
  v12 = 4 * v8;
  if (v12 > a3 - v11)
    return sub_10001EC4C((uint64_t)a1, 22, 0, 797, 0, "No space for special ports: %zu > (%zu - %d)", a7, a8, v12);
  v15 = 0;
  v16 = 0;
  v17 = a2 + v11 + 240;
  while (1)
  {
    value = xpc_array_get_value(xarray, v16);
    right = xpc_mach_send_get_right(value);
    v22 = right;
    if (right - 1 >= 0xFFFFFFFE)
    {
      v29 = v16;
      v26 = "Invalid special port[%zd]: %d";
      v27 = (uint64_t)a1;
      v28 = 806;
      return sub_10001EC4C(v27, 22, 0, v28, 0, v26, v20, v21, v29);
    }
    v23 = *(_DWORD *)(v17 + 4 * v16);
    if ((v23 - 128) > 2)
    {
      if (v23 == 4)
      {
        if ((*(_BYTE *)(a2 + 239) & 4) != 0)
          v22 = 0;
        else
          v22 = right;
      }
      v25 = posix_spawnattr_setspecialport_np(a1, v22, v23);
      if (v25)
        sub_10004D764(v25);
      goto LABEL_16;
    }
    v31 = 0;
    v30 = 0;
    if ((v23 - 129) <= 1)
      break;
LABEL_16:
    if (++v16 >= *(unsigned int *)(a2 + 220))
      return 0;
  }
  if ((v15 & 1) == 0)
  {
    LODWORD(v30) = right;
    v15 = 1;
    v24 = posix_spawnattr_set_registered_ports_np(a1, &v30, 1);
    if (v24)
      sub_10004D764(v24);
    goto LABEL_16;
  }
  v26 = "Already registered ports";
  v27 = (uint64_t)a1;
  v28 = 820;
  return sub_10001EC4C(v27, 22, 0, v28, 0, v26, v20, v21, v29);
}

size_t sub_100013528(uint64_t a1, xpc_object_t xarray)
{
  size_t result;
  size_t v5;
  xpc_object_t value;
  uint64_t v7;
  uint64_t v8;
  int64_t v9;
  xpc_object_t v10;
  uint64_t port;
  int v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  int v17;
  char v18;

  result = xpc_array_get_count(xarray);
  if (result)
  {
    v5 = 0;
    while (1)
    {
      value = xpc_array_get_value(xarray, v5 + 1);
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
      {
        v15 = "setup_fds bad int type";
        v16 = a1;
        v17 = 864;
        return sub_10001EC4C(v16, 9, 0, v17, 0, v15, v7, v8, v18);
      }
      v9 = xpc_int64_get_value(value);
      if ((v9 & 0x80000000) != 0 || getdtablesize() <= (int)v9)
      {
        getdtablesize();
        return sub_10001EC4C(a1, 9, 0, 868, 0, "setup_fds bad dest: %d table: %d", v13, v14, v9);
      }
      v10 = xpc_array_get_value(xarray, v5);
      if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_fd)
        break;
      port = _xpc_fd_get_port(v10);
      v12 = posix_spawn_file_actions_add_fileportdup2_np(a1 + 8, port, v9);
      if (v12)
        sub_10004D764(v12);
      v5 += 2;
      if (v5 >= xpc_array_get_count(xarray))
        return 0;
    }
    v15 = "setup_fds bad fd type";
    v16 = a1;
    v17 = 873;
    return sub_10001EC4C(v16, 9, 0, v17, 0, v15, v7, v8, v18);
  }
  return result;
}

uint64_t sub_10001367C(uint64_t a1, uint64_t a2, unint64_t a3, const void *a4, size_t a5)
{
  size_t v8;
  const void *v9;
  BOOL v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  size_t length;
  void *v17;
  size_t bytes;
  uint64_t v19;
  void *v20;
  uint64_t result;
  const char *v22;
  uint64_t v23;
  int v24;
  char v25;

  v8 = *(unsigned int *)(a2 + 12);
  if ((_DWORD)v8)
    v9 = (const void *)_xpc_spawnattr_unpack_bytes(a2, a3, *(_DWORD *)(a2 + 8), v8);
  else
    v9 = 0;
  if ((_DWORD)v8)
    v10 = v9 == 0;
  else
    v10 = 1;
  v11 = !v10;
  if (!a4 || !a5)
  {
    if (!v11)
      return 0;
    v20 = sub_10001541C(v9, v8);
    *(_QWORD *)(a1 + 1240) = v20;
    *(_QWORD *)(a1 + 1248) = v8;
    a5 = v8;
    goto LABEL_19;
  }
  if (v11)
  {
    v12 = (void *)sub_10001197C((unint64_t)a4, a5, (unint64_t)v9, v8);
    if (v12)
    {
      v15 = v12;
      length = xpc_data_get_length(v12);
      *(_QWORD *)(a1 + 1248) = length;
      v17 = sub_10001389C(length);
      *(_QWORD *)(a1 + 1240) = v17;
      bytes = xpc_data_get_bytes(v15, v17, 0, *(_QWORD *)(a1 + 1248));
      v19 = *(_QWORD *)(a1 + 1248);
      xpc_release(v15);
      if (bytes == v19)
      {
        v20 = *(void **)(a1 + 1240);
        a5 = *(_QWORD *)(a1 + 1248);
        goto LABEL_19;
      }
      v22 = "Unable to copy merged spawn constraints";
      v23 = a1;
      v24 = 938;
    }
    else
    {
      v22 = "Unable to merge spawn constraints";
      v23 = a1;
      v24 = 933;
    }
    return sub_10001EC4C(v23, 22, 0, v24, 0, v22, v13, v14, v25);
  }
  v20 = sub_10001541C(a4, a5);
  *(_QWORD *)(a1 + 1240) = v20;
  *(_QWORD *)(a1 + 1248) = a5;
LABEL_19:
  result = amfi_launch_constraint_set_spawnattr(a1, v20, a5);
  if ((_DWORD)result)
    sub_10004D764(result);
  return result;
}

char *sub_1000137DC(_QWORD *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v10;
  char *result;
  uint64_t v12;
  uint64_t v13;
  char *v14[2];

  v14[0] = 0;
  v14[1] = &a9;
  vasprintf(v14, a2, &a9);
  v10 = v14[0];
  *(_QWORD *)v14[0] = a1[228];
  a1[228] = v10;
  result = v10 + 8;
  v12 = a1[154];
  v13 = a1[153];
  a1[153] = v13 + 1;
  *(_QWORD *)(v12 + 8 * v13) = result;
  return result;
}

uint64_t sub_100013840(char *a1)
{
  char *v2;
  char *v3;
  char v4;
  uint64_t result;

  v2 = strrchr(a1, 47);
  if (!v2)
    return 22;
  v3 = v2;
  v4 = *v2;
  *v2 = 0;
  LODWORD(result) = mkpath_np(a1, 0x1F6u);
  if ((_DWORD)result == 17)
    result = 0;
  else
    result = result;
  *v3 = v4;
  return result;
}

void *sub_10001389C(size_t size)
{
  void *v2;
  int v3;

  do
  {
    v2 = malloc_type_calloc(1uLL, size, 0x5C63E6C5uLL);
    if (v2)
      break;
    if (*__error() != 12)
    {
      v3 = *__error();
      if (v3)
        sub_10004D778(v3);
    }
  }
  while (sub_100015400());
  return v2;
}

void *sub_100013900(void *ptr, int a2, size_t size)
{
  void *v5;
  int v6;

  do
  {
    v5 = malloc_type_realloc(ptr, size, 0x662826DDuLL);
    if (v5)
      break;
    if (*__error() != 12)
    {
      v6 = *__error();
      if (v6)
        sub_10004D778(v6);
    }
  }
  while (sub_100015400());
  return v5;
}

void sub_100013970(uint64_t a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if ((_UNKNOWN *)sub_10002E360(a1) == &unk_1000715B8)
    sub_1000139B0(a2, v3, v4, v5, v6, v7, v8, v9);
}

void sub_1000139B0(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1 != 18)
  {
    switch(dword_100071CB8)
    {
      case 0:
        if (a1 != 1)
          goto LABEL_38;
        break;
      case 1:
        if ((a1 - 1) >= 2)
          goto LABEL_38;
        break;
      case 2:
        if (a1 != 3)
          goto LABEL_38;
        break;
      case 3:
        if (a1 != 4)
          goto LABEL_38;
        break;
      case 4:
        if (a1 != 5)
          goto LABEL_38;
        break;
      case 5:
        if (a1 != 6)
          goto LABEL_38;
        break;
      case 6:
        if (a1 != 7)
          goto LABEL_38;
        break;
      case 7:
        if (a1 != 8)
          goto LABEL_38;
        break;
      case 8:
        if (a1 != 9)
          goto LABEL_38;
        break;
      case 9:
        if (a1 != 10)
          goto LABEL_38;
        break;
      case 10:
        if (a1 != 11)
          goto LABEL_38;
        break;
      case 11:
        if (a1 != 12)
          goto LABEL_38;
        break;
      case 12:
        if (a1 != 13)
          goto LABEL_38;
        break;
      case 13:
        if (a1 != 14)
          goto LABEL_38;
        break;
      case 14:
        if (a1 != 15)
          goto LABEL_38;
        break;
      case 15:
      case 18:
        if (a1 != 16)
          goto LABEL_38;
        break;
      case 16:
        if (a1 != 17)
          goto LABEL_38;
        goto LABEL_3;
      default:
LABEL_38:
        sub_10003E208("Unexpected shutdown transition %s -> %s", off_10006BE80[dword_100071CB8], off_10006BE80[a1]);
    }
  }
  sub_100041468("shutdown", 196613, "shutdown %s -> %s", a4, a5, a6, a7, a8, (char)off_10006BE80[dword_100071CB8]);
LABEL_3:
  dword_100071CB8 = a1;
}

void sub_100013B28()
{
  dword_100071CB8 = 0;
  dword_100071CBC = 0;
  dword_100071CC0 = 0;
  byte_100071CC4 = 0;
  sub_1000185F8();
}

void sub_100013B4C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (dword_100071CB8 >= 2)
    sub_10004D738();
  sub_1000184B0(&stru_10006BE20);
  sub_10000E410(&stru_10006BE60);
  sub_100013C60();
  sub_1000139B0(2, v0, v1, v2, v3, v4, v5, v6);
}

void sub_100013B90(id a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_100013B9C((uint64_t)a1, v1, v2, v3, v4, v5, v6, v7);
}

void sub_100013B9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  sub_100041468("shutdown timeout", 196611, "%s", a4, a5, a6, a7, a8, (char)"Shutting the system down has taken too long. launchd is rebooting\n(or halting) the system now. Any processes that are still running\nwill be abandoned to the mercy of the kernel.\n");
  v8 = sub_100014390();
  sub_1000139B0(18, v9, v10, v11, v12, v13, v14, v15);
  sub_100013DD4(v8);
  free(v8);
  v16 = sub_10002E190();
  sub_1000141F4(v16);
}

void sub_100013BF8(id a1, unsigned int a2)
{
  if (a2 == 2)
  {
    if ((byte_100071CC4 & 1) == 0)
      sub_10004D738();
    byte_100071CC4 = 0;
    if (dword_100071CB8 == 14)
      sub_1000141D8();
  }
  else if (a2 == 1)
  {
    if (byte_100071CC4 == 1)
      sub_10004D738();
    byte_100071CC4 = 1;
  }
}

void sub_100013C60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;

  if (dword_100071CB8 == 1)
  {
    sub_100040F68(5, "shutdown already committed");
  }
  else
  {
    if (dword_100071CB8)
      sub_10003E208("Attempting to commit shutdown unexpectedly: %s", off_10006BE80[dword_100071CB8]);
    sub_100040F68(5, "committing to system shutdown");
    v0 = dispatch_queue_create("com.apple.xpc.launchd.system-override", 0);
    dispatch_async_f(v0, 0, (dispatch_function_t)sub_10001435C);
    dispatch_release(v0);
    if (dword_100071CBC == 1)
    {
      v8 = "kern.willuserspacereboot";
      goto LABEL_8;
    }
    if (!dword_100071CBC)
    {
      sub_10003FF3C("kern.willshutdown", 1);
      v8 = "security.mac.asp.willshutdown";
LABEL_8:
      sub_10003FF3C(v8, 1);
    }
  }
  sub_1000139B0(1, v1, v2, v3, v4, v5, v6, v7);
}

uint64_t sub_100013D48(int a1, uint64_t a2, int a3)
{
  if (dword_100071CB8)
  {
    sub_100040F68(3, "Shutdown already started: %s", off_10006BE80[dword_100071CB8]);
    return 37;
  }
  else
  {
    dword_100071CBC = a1;
    if (a2)
      sub_10004D738();
    dword_100071CC0 = a3;
    sub_100013C60();
    return 0;
  }
}

BOOL sub_100013DB4(int a1)
{
  return dword_100071CB8 > 0 && dword_100071CBC == a1;
}

void sub_100013DD4(char *a1, ...)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  char v9;
  char *v10[2];
  va_list va;

  va_start(va, a1);
  if (dword_100071CB8 != 18 && (dword_100071CB8 - 2) >= 0xA)
    sub_10004D738();
  dword_100071CBC = 0;
  v10[0] = 0;
  va_copy((va_list)&v10[1], va);
  vasprintf(v10, a1, va);
  v8 = v10[0];
  v9 = (char)v10[0];
  if (!v10[0])
  {
    _os_assumes_log(0);
    v10[0] = a1;
    v9 = (char)a1;
  }
  sub_100041468("hard reboot", 196612, "Could not cleanly tear down userspace. Will force a full hardware reboot. (%s)", v3, v4, v5, v6, v7, v9);
  free(v8);
}

uint64_t sub_100013E7C(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t result;
  NSObject *v24;
  char v25;
  _QWORD block[5];

  if (dword_100071CB8 != 11)
    sub_10004D738();
  sub_100028C34((uint64_t)a1, 5, "cleaning up", a4, a5, a6, a7, a8, v25);
  sub_1000139B0(12, v9, v10, v11, v12, v13, v14, v15);
  sub_1000480C8();
  sub_1000139B0(13, v16, v17, v18, v19, v20, v21, v22);
  sub_10001CDB4();
  result = sub_100013F48();
  if ((result & 1) == 0)
  {
    sub_100013FD4((uint64_t)a1);
    v24 = sub_1000146E4();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_1000140BC;
    block[3] = &unk_10006BF18;
    block[4] = a1;
    dispatch_async(v24, block);
    result = (uint64_t)sub_100019580(a1);
    if (a1[47])
      sub_10004D738();
  }
  return result;
}

uint64_t sub_100013F48()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100014714();
  if (dword_100071CB8 != 13)
    sub_10004D738();
  if (dword_100071CBC)
  {
    if (byte_100072A81)
    {
      sub_100040F68(65540, "Abandoning lingering coalitions");
    }
    else if (sub_10001C7F4(0))
    {
      return 0;
    }
  }
  sub_1000139B0(14, v0, v1, v2, v3, v4, v5, v6);
  if ((byte_100071CC4 & 1) == 0)
    sub_1000141D8();
  return 1;
}

uint64_t sub_100013FD4(uint64_t a1)
{
  int data_np;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v11;
  void *v12;

  if (dword_100071CB8 != 13)
    sub_10004D738();
  v11 = 0;
  v12 = 0;
  data_np = sysctlbyname_get_data_np("kern.proc.all", &v12, &v11);
  if (data_np)
  {
    if (data_np == -1)
      sub_10004D870();
  }
  else
  {
    if (v11 >= 0x288)
    {
      v8 = 0;
      v9 = v11 / 0x288;
      do
      {
        if (*(int *)((char *)v12 + v8 + 40) >= 2)
          sub_100028C34(a1, 65540, "Found lingering process: %d (%s)", v3, v4, v5, v6, v7, *(_DWORD *)((char *)v12 + v8 + 40));
        v8 += 648;
        --v9;
      }
      while (v9);
    }
    free(v12);
  }
  return sub_100040848();
}

void sub_1000140BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_1000140C4(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8, a9);
}

void sub_1000140C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  dispatch_time_t v10;
  NSObject *v11;
  _QWORD v12[5];
  _QWORD v13[5];

  if (dword_100071CB8 == 13)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_100014548;
    v13[3] = &unk_10006BF60;
    v13[4] = a1;
    if (sub_10001C7F4((uint64_t)v13))
    {
      sub_100013FD4(a1);
      v10 = dispatch_time(0, 1000000000);
      v11 = sub_1000146E4();
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 0x40000000;
      v12[2] = sub_1000145A8;
      v12[3] = &unk_10006BF80;
      v12[4] = a1;
      dispatch_after(v10, v11, v12);
    }
  }
  else
  {
    sub_100028C34(a1, 65541, "Polling for lingering coalitions stopped", a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_1000141C0()
{
  uint64_t result;

  if (dword_100071CB8 == 13)
    return sub_100013F48();
  return result;
}

void sub_1000141D8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_1000185F8();
  sub_1000139B0(15, v0, v1, v2, v3, v4, v5, v6);
  v7 = sub_10002E190();
  sub_1000141F4(v7);
}

void sub_1000141F4(uint64_t a1)
{
  uint64_t v1;
  void **p_vtable;
  task_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;

  if (dword_100071CB8 == 15 || dword_100071CB8 == 18)
  {
    v1 = a1;
    v4 = mach_host_self();
    sub_100042AAC(v4, 0);
    p_vtable = OS_launch_service_stub.vtable;
    v5 = dword_100071CC0;
    sub_10000D6D0(*(_QWORD *)(v1 + 272));
    sub_100028C34(v1, 5, "shutting down system: flags = 0x%x, time = %llu ms", v6, v7, v8, v9, v10, v5);
    v11 = sub_10000D6D0(*(_QWORD *)(v1 + 272));
    sub_100028C34(v1, 196613, "Userspace teardown took: %llu ms", v12, v13, v14, v15, v16, v11 / 0xF4240);
    if (dword_100071CBC)
    {
      if (dword_100071CBC == 1)
      {
        sub_100028C34(v1, 196613, "Will be re-execing for a userspace reboot", v22, v23, v24, v25, v26, v41);
        v17 = 4;
        goto LABEL_11;
      }
LABEL_10:
      v17 = 1;
LABEL_11:
      sub_100040F68(196613, "Quiescing queues");
      sub_1000139B0(16, v27, v28, v29, v30, v31, v32, v33);
      sub_100010384();
      sub_100040FA0();
      sub_10000FC98("launchd quiesce complete\n");
      sub_1000139B0(17, v34, v35, v36, v37, v38, v39, v40);
      sub_100014344(v17);
    }
  }
  else
  {
    v18 = _os_assert_log(dword_100071CB8 == 18);
    _os_crash(v18, v19, v20, v21);
    __break(1u);
  }
  sub_100028C34(v1, 196613, "Will be calling reboot(2) with flags: 0x%x", v22, v23, v24, v25, v26, *((_DWORD *)p_vtable + 816));
  goto LABEL_10;
}

void sub_100014344(int a1)
{
  sub_1000404A8(a1, dword_100071CC0);
}

uint64_t sub_10001435C()
{
  uint64_t result;

  pthread_setname_np("system shutdown has begun");
  result = system_override(-1, 3);
  if ((_DWORD)result == -1)
    sub_10004D83C();
  return result;
}

char *sub_100014390()
{
  const char **v0;
  char *v1;
  char *v2;
  _QWORD v4[6];
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  int v8;

  if (dword_100071CB8 != 13)
    return sub_100015630("userspace shutdown timed out: %s", off_10006BE80[dword_100071CB8]);
  v5 = 0;
  v6 = &v5;
  v7 = 0x2000000000;
  v8 = 0;
  v0 = (const char **)sub_1000106C8(0x40uLL);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_1000144D8;
  v4[3] = &unk_10006BF40;
  v4[4] = &v5;
  v4[5] = v0;
  sub_10001C7F4((uint64_t)v4);
  if (*((int *)v6 + 6) < 1)
  {
    v2 = sub_100015630("userspace shutdown timed out: %s. Unable to identify lingering coalitions.", off_10006BE80[dword_100071CB8]);
  }
  else
  {
    v1 = sub_100010710(v0);
    v2 = sub_100015630("userspace shutdown timed out: %s (%d).%s", off_10006BE80[dword_100071CB8], *((_DWORD *)v6 + 6), v1);
    free(v1);
  }
  sub_100010718((void **)v0);
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_1000144D8(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(_QWORD *)(a1 + 40);
  v5 = sub_100011400(a2);
  sub_1000124E4(a2);
  sub_100010740(v4, " %llu (%s),", v6, v7, v8, v9, v10, v11, v5);
  ++*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

void sub_100014548(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  char v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v3 = *(_QWORD *)(a1 + 32);
  v4 = sub_100011400(a2);
  sub_1000124E4(a2);
  sub_100028C34(v3, 65540, "Lingering coalition: %llu (%s)", v5, v6, v7, v8, v9, v4);
}

uint64_t sub_1000145A8(uint64_t a1)
{
  return sub_1000140C4(*(_QWORD *)(a1 + 32));
}

uint64_t sub_1000145B0(uint32_t a1)
{
  uint64_t result;
  int v3;
  int *v4;

  *__error() = 0;
  result = usrctl(a1);
  if ((_DWORD)result)
  {
    v3 = result;
    v4 = __error();
    sub_10003E208("usrctl(0x%x) returned %d (errno %d)", a1, v3, *v4);
  }
  return result;
}

dispatch_queue_t sub_100014608()
{
  NSObject *initially_inactive;
  qos_class_t v1;
  NSObject *v2;
  qos_class_t v3;
  NSObject *v4;
  NSObject *v5;
  dispatch_queue_t result;

  initially_inactive = dispatch_queue_attr_make_initially_inactive(0);
  v1 = qos_class_main();
  v2 = dispatch_queue_attr_make_with_qos_class(initially_inactive, v1, 0);
  qword_100071CC8 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.eventq", v2);
  v3 = qos_class_main();
  v4 = dispatch_queue_attr_make_with_qos_class(0, v3, 0);
  qword_100071CD0 = (uint64_t)dispatch_queue_create_with_target_V2("com.apple.xpc.launchd.spawn", v4, 0);
  qword_100072978 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.ioq", 0);
  v5 = dispatch_queue_attr_make_with_qos_class(0, (dispatch_qos_class_t)5u, 0);
  qword_100071CD8 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.bgioq", v5);
  result = dispatch_queue_create("com.apple.xpc.launchd.bglogq", v5);
  qword_100071CE0 = (uint64_t)result;
  return result;
}

uint64_t sub_1000146E4()
{
  return qword_100071CC8;
}

uint64_t sub_1000146F0()
{
  return qword_100072978;
}

uint64_t sub_1000146FC()
{
  return qword_100071CD8;
}

uint64_t sub_100014708()
{
  return qword_100071CE0;
}

void sub_100014714()
{
  dispatch_assert_queue_V2((dispatch_queue_t)qword_100071CC8);
}

uint64_t sub_100014720()
{
  return qword_100071CD0;
}

void sub_10001472C()
{
  dispatch_assert_queue_not_V2((dispatch_queue_t)qword_100071CD0);
}

_QWORD *sub_100014738(uint64_t a1, const char *a2)
{
  char *v3;
  char *v4;
  _QWORD *v5;
  _QWORD v7[5];

  v3 = sub_100028C98(a1, 1);
  v4 = sub_100015630("%s/%s", v3, a2);
  free(v3);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_1000147D0;
  v7[3] = &unk_10006BFA0;
  v7[4] = v4;
  v5 = sub_10001389C(0x18uLL);
  *v5 = sub_1000156A0(v7);
  v5[1] = v4;
  return v5;
}

void sub_1000147D0(uint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100041468(*(const char **)(a1 + 32), a2, "(lint): %s", a4, a5, a6, a7, a8, a3);
}

void sub_1000147FC(uint64_t a1)
{
  free(*(void **)(a1 + 8));
  *(_QWORD *)(a1 + 8) = 0;
  _Block_release(*(const void **)a1);
  free((void *)a1);
}

void sub_100014830(_BYTE *a1, uint64_t a2, char *a3, ...)
{
  void *v4[2];
  va_list va;

  va_start(va, a3);
  a1[16] = 1;
  v4[0] = 0;
  va_copy((va_list)&v4[1], va);
  if (vasprintf((char **)v4, a3, va) != -1)
  {
    (*(void (**)(void))(*(_QWORD *)a1 + 16))();
    free(v4[0]);
  }
}

void sub_1000148A4(uint64_t a1)
{
  int v2;
  NSObject *global_queue;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD block[5];
  _QWORD v8[5];
  _QWORD v9[5];

  v2 = *(unsigned __int8 *)(a1 + 56);
  if ((v2 - 1) < 2)
  {
    v5 = *(_QWORD *)(a1 + 64);
    if (v2 == 2)
      v6 = 2;
    else
      v6 = 1;
    *(_QWORD *)(a1 + 80) = xpc_bundle_create(v5, v6);
    sub_100019580((void *)a1);
    global_queue = dispatch_get_global_queue(0, 0);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = sub_100014F2C;
    v9[3] = &unk_10006C040;
    v9[4] = a1;
    v4 = v9;
  }
  else if (v2 == 3)
  {
    sub_100019580((void *)a1);
    global_queue = sub_1000146F0();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100014B80;
    block[3] = &unk_10006BFE0;
    block[4] = a1;
    v4 = block;
  }
  else
  {
    if (*(_BYTE *)(a1 + 56))
      sub_10003E208("unsupported IO type %d", *(unsigned __int8 *)(a1 + 56));
    sub_100019580((void *)a1);
    global_queue = sub_1000146F0();
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = sub_100014A10;
    v8[3] = &unk_10006BFC0;
    v8[4] = a1;
    v4 = v8;
  }
  dispatch_async(global_queue, v4);
}

void sub_100014A10(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned __int16 v7;
  unsigned int v8;
  char *v9;
  char *v10;
  size_t v11;
  void *v12;
  ssize_t v13;
  dispatch_data_t v14;
  uint64_t v15;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_1000146F0();
  dispatch_assert_queue_V2(v3);
  v15 = v2;
  v4 = guarded_open_np(*(_QWORD *)(v2 + 64), &v15, 31, 0x1000000);
  if ((v4 & 0x80000000) != 0)
  {
    v6 = *__error();
    goto LABEL_7;
  }
  v5 = v4;
  if (fstat(v4, (stat *)(v2 + 96)))
  {
LABEL_3:
    v6 = *__error();
    goto LABEL_4;
  }
  v7 = (*(_WORD *)(v2 + 100) & 0xF000) + 0x4000;
  if ((v7 & 0xF000u) >= 0xB000 || (v8 = v7 >> 12, ((0x561u >> v8) & 1) == 0))
  {
    v9 = sub_10003B954(v5);
    if (v9)
    {
      v10 = v9;
      free(*(void **)(v2 + 64));
      *(_QWORD *)(v2 + 64) = v10;
      v11 = *(_QWORD *)(v2 + 192);
      v12 = sub_10001389C(v11);
      v13 = read(v5, v12, v11);
      if (v13 < 0 || v13 == v11)
      {
        v14 = dispatch_data_create(v12, v11, 0, _dispatch_data_destructor_free);
        v6 = 0;
        *(_QWORD *)(v2 + 72) = v14;
      }
      else
      {
        free(v12);
        v6 = 5;
      }
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  v6 = dword_10004FD24[v8];
LABEL_4:
  if (guarded_close_np(v5, &v15) == -1)
    sub_10004D914();
LABEL_7:
  sub_100014E2C(v2, 0, v6);
  sub_10001962C(*(void **)(a1 + 32));
}

void sub_100014B80(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  char *v7;
  int v8;
  int *v9;
  FTS *v10;
  FTS *v11;
  FTSENT *v12;
  FTSENT *v13;
  uint64_t v14;
  unsigned int fts_info;
  uint64_t fts_path;
  int v17;
  int fts_errno;
  _BYTE *v19;
  const char *v20;
  int v21;
  int *v22;
  const char *v23;
  uint64_t v24;
  char *v25[2];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = sub_1000146F0();
  dispatch_assert_queue_V2(v3);
  v24 = v2;
  v4 = guarded_open_np(*(_QWORD *)(v2 + 64), &v24, 31, 16809984);
  if ((v4 & 0x80000000) != 0)
  {
    v9 = __error();
    sub_100014E2C(v2, 0, *v9);
    goto LABEL_37;
  }
  v5 = v4;
  if (!fstat(v4, (stat *)(v2 + 96)))
  {
    if ((*(_WORD *)(v2 + 100) & 0xF000) != 0x4000)
    {
      v7 = 0;
      v8 = 20;
      goto LABEL_34;
    }
    v7 = sub_10003B954(v5);
    if (!v7)
    {
      v6 = __error();
      goto LABEL_4;
    }
    free(*(void **)(v2 + 64));
    *(_QWORD *)(v2 + 64) = v7;
    v25[0] = v7;
    v25[1] = 0;
    v7 = (char *)sub_10001123C();
    v10 = fts_open(v25, 92, 0);
    if (v10)
    {
      v11 = v10;
      v12 = fts_read(v10);
      if (v12)
      {
        v13 = v12;
        v14 = 0;
        while (1)
        {
          fts_info = v13->fts_info;
          if (fts_info > 6)
            break;
          if (fts_info == 1)
          {
            if (v14)
            {
              ++v14;
              fts_set(v11, v13, 4);
              fts_path = (uint64_t)v13->fts_path;
              v17 = 3;
LABEL_20:
              fts_errno = 0;
              goto LABEL_23;
            }
            v14 = 1;
          }
          else
          {
            if (fts_info != 6)
              goto LABEL_22;
            --v14;
          }
LABEL_25:
          v13 = fts_read(v11);
          if (!v13)
            goto LABEL_29;
        }
        if (fts_info == 7)
        {
          fts_path = (uint64_t)v13->fts_path;
          fts_errno = v13->fts_errno;
          v17 = 4;
        }
        else
        {
          if (fts_info == 11)
          {
            fts_path = (uint64_t)v13->fts_path;
            v17 = 0;
            goto LABEL_20;
          }
LABEL_22:
          fts_path = (uint64_t)v13->fts_path;
          v17 = 4;
          fts_errno = 108;
        }
LABEL_23:
        v19 = sub_1000104A0(v17, fts_path, fts_errno);
        if (v19)
        {
          sub_1000112C0(v7, v19);
          sub_10001962C(v19);
        }
        goto LABEL_25;
      }
LABEL_29:
      if (fts_close(v11) == -1)
        sub_10004D914();
    }
    else
    {
      v20 = *(const char **)(v2 + 64);
      v21 = *__error();
      v22 = __error();
      v23 = (const char *)xpc_strerror(*v22);
      sub_100040F68(4, "failed to fts_open(%s, 0x%x): %d: %s", v20, 92, v21, v23);
    }
    v8 = 0;
    goto LABEL_34;
  }
  v6 = __error();
  v7 = 0;
LABEL_4:
  v8 = *v6;
LABEL_34:
  if (guarded_close_np(v5, &v24) == -1)
    sub_10004D914();
  sub_100014E2C(v2, v7, v8);
  if (v7)
    sub_10001962C(v7);
LABEL_37:
  sub_10001962C(*(void **)(a1 + 32));
}

void sub_100014E2C(uint64_t a1, void *a2, int a3)
{
  NSObject *v6;
  NSObject *v7;
  _QWORD v8[6];

  v6 = sub_1000146F0();
  dispatch_assert_queue_V2(v6);
  *(_DWORD *)(a1 + 240) = a3;
  sub_100019580((void *)a1);
  if (a2)
    sub_100019580(a2);
  v7 = *(NSObject **)(a1 + 248);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_100014ED4;
  v8[3] = &unk_10006C000;
  v8[4] = a1;
  v8[5] = a2;
  dispatch_async(v7, v8);
}

void sub_100014ED4(uint64_t a1)
{
  void *v2;

  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 256) + 16))();
  v2 = *(void **)(a1 + 40);
  if (v2)
    sub_10001962C(v2);
  sub_10001962C(*(void **)(a1 + 32));
}

void sub_100014F2C(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD block[5];

  v2 = sub_100010428();
  dispatch_semaphore_wait(v2, 0xFFFFFFFFFFFFFFFFLL);
  xpc_bundle_resolve_sync(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 80));
  dispatch_semaphore_signal(v2);
  v3 = *(_QWORD *)(a1 + 32);
  v4 = *(NSObject **)(v3 + 248);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100014FB4;
  block[3] = &unk_10006C020;
  block[4] = v3;
  dispatch_async(v4, block);
}

void sub_100014FB4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int error;
  _OWORD *property;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  v2 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v2 + 248));
  v3 = *(_QWORD *)(v2 + 80);
  error = xpc_bundle_get_error(v3);
  if (!error)
  {
    property = (_OWORD *)xpc_bundle_get_property(v3, 4);
    *(_OWORD *)(v2 + 96) = *property;
    v6 = property[4];
    v8 = property[1];
    v7 = property[2];
    *(_OWORD *)(v2 + 144) = property[3];
    *(_OWORD *)(v2 + 160) = v6;
    *(_OWORD *)(v2 + 112) = v8;
    *(_OWORD *)(v2 + 128) = v7;
    v9 = property[8];
    v11 = property[5];
    v10 = property[6];
    *(_OWORD *)(v2 + 208) = property[7];
    *(_OWORD *)(v2 + 224) = v9;
    *(_OWORD *)(v2 + 176) = v11;
    *(_OWORD *)(v2 + 192) = v10;
  }
  *(_DWORD *)(v2 + 240) = error;
  (*(void (**)(void))(*(_QWORD *)(v2 + 256) + 16))();
  sub_10001962C(*(void **)(a1 + 32));
}

uint64_t sub_100015054(int *a1)
{
  return _os_assert_log(*a1);
}

size_t _xpc_spawnattr_pack_string_fragment(uint64_t a1, _DWORD *a2, _QWORD *a3, char *__src)
{
  size_t result;

  strcpy((char *)(a1 + *a2 + 240), __src);
  result = strlen(__src);
  *a2 += result;
  *a3 -= result;
  return result;
}

size_t _xpc_spawnattr_pack_string(uint64_t a1, _DWORD *a2, _QWORD *a3, char *__src)
{
  size_t result;

  strcpy((char *)(a1 + *a2 + 240), __src);
  result = strlen(__src);
  *a2 += result + 1;
  *a3 -= result + 1;
  return result;
}

const char *_xpc_spawnattr_unpack_string(uint64_t a1, unint64_t a2, unsigned int a3)
{
  const char *v3;

  if (a2 <= a3)
    return 0;
  v3 = (const char *)(a1 + a3 + 240);
  if (strnlen(v3, a2 - a3) + 1 <= a2 - a3)
    return v3;
  else
    return 0;
}

void *_xpc_spawnattr_pack_bytes(uint64_t a1, _DWORD *a2, _QWORD *a3, void *__src, size_t __n)
{
  unsigned int v5;
  void *result;

  v5 = __n;
  result = memcpy((void *)(a1 + *a2 + 240), __src, __n);
  *a2 += v5;
  *a3 -= v5;
  return result;
}

uint64_t _xpc_spawnattr_unpack_bytes(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4)
{
  uint64_t v4;

  if (a2 - a3 >= a4)
    v4 = a1 + a3 + 240;
  else
    v4 = 0;
  if (a2 <= a3)
    return 0;
  else
    return v4;
}

const char *_xpc_spawnattr_unpack_strings(uint64_t a1, unint64_t a2, unsigned int a3, const char **a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v7;
  uint64_t v9;
  const char **i;
  const char *v11;
  size_t v12;

  if (a3 >= a2)
    return 0;
  v5 = a5;
  if (!a5)
    return *a4;
  v7 = a3;
  v9 = a1 + 240;
  for (i = a4; ; ++i)
  {
    v11 = (const char *)(v9 + v7);
    v12 = strnlen(v11, a2 - v7);
    if (v12 + 1 > a2 - v7)
      break;
    v7 += v12 + 1;
    *i = v11;
    if (!--v5)
      return *a4;
  }
  return 0;
}

uint64_t _xpc_spawnattr_binprefs_size(uint64_t a1)
{
  return 8 * xpc_binprefs_count(a1);
}

uint64_t _xpc_spawnattr_binprefs_pack(uint64_t a1, uint64_t a2, _DWORD *a3, _QWORD *a4)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t result;

  v8 = xpc_binprefs_count(a2);
  *(_DWORD *)(a1 + 32) = v8;
  v9 = 0;
  if (v8)
  {
    *(_DWORD *)(a1 + 36) = *a3;
    v10 = 8 * (v8 - 1);
    v11 = v8;
    v12 = (_DWORD *)(*a3 + a1 + 244);
    do
    {
      *(v12 - 1) = xpc_binprefs_cpu_type(a2, v9);
      *v12 = xpc_binprefs_cpu_subtype(a2, v9);
      v12 += 2;
      ++v9;
    }
    while (v11 != v9);
    v9 = v10 + 8;
  }
  else
  {
    *(_DWORD *)(a1 + 36) = 0;
  }
  result = xpc_binprefs_count(a2);
  if (v9 != 8 * result)
    sub_10004D74C();
  *a3 += v9;
  *a4 -= v9;
  return result;
}

uint64_t _xpc_spawnattr_binprefs_unpack(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int *v7;

  v2 = *(unsigned int *)(a1 + 32);
  if (!(_DWORD)v2 || a2 - (unint64_t)*(unsigned int *)(a1 + 36) < 8 * v2)
    return 0;
  xpc_binprefs_alloc();
  v4 = v5;
  if (*(_DWORD *)(a1 + 32))
  {
    v6 = 0;
    v7 = (int *)(*(unsigned int *)(a1 + 36) + a1 + 244);
    do
    {
      xpc_binprefs_add(v4, *(v7 - 1), *v7);
      ++v6;
      v7 += 2;
    }
    while (v6 < *(unsigned int *)(a1 + 32));
  }
  return v4;
}

uint64_t sub_100015400()
{
  sleep(1u);
  return 1;
}

void *sub_10001541C(const void *a1, size_t size)
{
  void *v4;

  v4 = sub_10001389C(size);
  return memcpy(v4, a1, size);
}

char *sub_10001544C(const char *a1)
{
  const char *i;
  char *result;
  int v3;

  for (i = a1; ; a1 = i)
  {
    result = strdup(a1);
    if (result)
      break;
    if (*__error() != 12)
    {
      v3 = *__error();
      if (v3)
        sub_10004D764(v3);
    }
    sub_100015400();
  }
  return result;
}

char *sub_1000154A0(const char *a1, size_t a2)
{
  size_t v2;
  const char *v3;
  char *result;
  int v5;

  v2 = a2;
  v3 = a1;
  while (1)
  {
    result = strndup(a1, a2);
    if (result)
      break;
    if (*__error() != 12)
    {
      v5 = *__error();
      if (v5)
        sub_10004D764(v5);
    }
    sub_100015400();
    a1 = v3;
    a2 = v2;
  }
  return result;
}

uint64_t sub_1000154F8(const char *a1, const char *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  _QWORD v7[3];
  _QWORD v8[3];

  memset(v8, 0, sizeof(v8));
  sub_1000155B4(a1, (uint64_t)v8);
  memset(v7, 0, sizeof(v7));
  sub_1000155B4(a2, (uint64_t)v7);
  v3 = 0;
  while (1)
  {
    v4 = v8[v3];
    v5 = v7[v3];
    if (v4 > v5)
      break;
    if (v4 < v5)
      return 0xFFFFFFFFLL;
    if (++v3 == 3)
      return 0;
  }
  return 1;
}

void sub_1000155B4(const char *a1, uint64_t a2)
{
  char *v3;
  uint64_t v4;
  char *v5;
  char *v6;
  char *__stringp;

  v3 = strdup(a1);
  v4 = 0;
  __stringp = v3;
  do
  {
    v5 = strsep(&__stringp, ".");
    if (!v5)
      break;
    v6 = 0;
    *(_QWORD *)(a2 + v4) = strtoull(v5, &v6, 10);
    v4 += 8;
  }
  while (v4 != 24);
  free(v3);
}

char *sub_100015630(char *a1, ...)
{
  char *result;
  int v3;
  char *v4;
  va_list va;

  va_start(va, a1);
  v4 = 0;
  while (1)
  {
    vasprintf(&v4, a1, va);
    result = v4;
    if (v4)
      break;
    if (*__error() != 12)
    {
      v3 = *__error();
      if (v3)
        sub_10004D764(v3);
    }
    sub_100015400();
  }
  return result;
}

void *sub_1000156A0(const void *a1)
{
  const void *i;
  void *result;
  int v3;

  for (i = a1; ; a1 = i)
  {
    result = _Block_copy(a1);
    if (result)
      break;
    if (*__error() != 12)
    {
      v3 = *__error();
      if (v3)
        sub_10004D764(v3);
    }
    sub_100015400();
  }
  return result;
}

BOOL sub_1000156F0(const char *a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return strncmp(a1, __s, v4) == 0;
}

BOOL sub_100015730(const char *a1, const char *a2)
{
  const char *v4;
  const char *v5;

  v4 = &a1[strlen(a1)];
  v5 = &v4[-strlen(a2)];
  return v5 >= a1 && strcmp(v5, a2) == 0;
}

BOOL sub_10001578C(char *a1, const char *a2)
{
  return strstr(a1, a2) != 0;
}

BOOL sub_1000157A8(char *__s1, const char *a2)
{
  _BOOL8 result;

  result = ((unint64_t)__s1 | (unint64_t)a2) == 0;
  if (__s1)
  {
    if (a2)
      return strcmp(__s1, a2) == 0;
  }
  return result;
}

BOOL sub_1000157E0(char *a1, const char *a2)
{
  _BOOL8 result;

  result = ((unint64_t)a1 | (unint64_t)a2) == 0;
  if (a1)
  {
    if (a2)
      return strcasecmp(a1, a2) == 0;
  }
  return result;
}

size_t sub_100015818(xpc_object_t xarray, const char *a2)
{
  size_t result;
  size_t v5;
  size_t v6;
  const char *string;

  result = 0;
  if (xarray)
  {
    if (a2)
    {
      result = xpc_array_get_count(xarray);
      if (result)
      {
        v5 = result;
        v6 = 0;
        while (1)
        {
          string = xpc_array_get_string(xarray, v6);
          if (string)
          {
            if (!strcmp(string, a2))
              break;
          }
          if (v5 == ++v6)
            return 0;
        }
        return 1;
      }
    }
  }
  return result;
}

BOOL sub_100015894(void *a1)
{
  return xpc_array_apply(a1, &stru_10006C080);
}

BOOL sub_1000158A0(id a1, unint64_t a2, void *a3)
{
  return xpc_get_type(a3) == (xpc_type_t)&_xpc_type_string;
}

uint64_t sub_1000158C8(_BYTE *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;

  if (!a2)
    return 5381;
  result = 5381;
  do
  {
    v4 = *a1;
    if (!*a1)
      break;
    ++a1;
    result = 33 * result + v4;
    --a2;
  }
  while (a2);
  return result;
}

uint64_t sub_1000158FC(_BYTE *a1)
{
  char v1;
  uint64_t result;
  unsigned __int8 *v4;
  int v5;

  v1 = *a1;
  if (!*a1)
    return 0;
  result = 0;
  v4 = a1 + 1;
  do
  {
    result = 33 * result + v1;
    v5 = *v4++;
    v1 = v5;
  }
  while (v5);
  return result;
}

uint64_t sub_10001592C(int a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;

  if (!a3)
    return 0;
  for (i = a2 + 8; *(_DWORD *)(i - 8) != a1; i += 16)
  {
    if (!--a3)
      return 0;
  }
  return *(_QWORD *)i;
}

xpc_type_t sub_10001595C(FILE *a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  xpc_type_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t info_dictionary;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char *v34;
  char *v35;
  const char *v36;
  FILE *v37;
  uint64_t v38;
  size_t v39;
  xpc_object_t v40;
  double value;
  tm v42;
  time_t v43;
  char v44[8];
  uint64_t v45;
  _WORD v46[7];

  if ((_DWORD)a3)
    sub_100043840((uint64_t)a1, a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  result = xpc_get_type(a4);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    value = COERCE_DOUBLE(xpc_string_get_string_ptr(a4));
    v35 = "\"%s\"";
LABEL_22:
    v37 = a1;
    v38 = 0;
    return (xpc_type_t)sub_10004391C(v37, v38, v35, v12, v13, v14, v15, v16, *(_QWORD *)&value);
  }
  if (result == (xpc_type_t)&_xpc_type_int64)
  {
    value = COERCE_DOUBLE(xpc_int64_get_value(a4));
    v35 = "%lld";
    goto LABEL_22;
  }
  if (result == (xpc_type_t)&_xpc_type_uint64)
  {
    value = COERCE_DOUBLE(xpc_uint64_get_value(a4));
    v35 = "%llu";
    goto LABEL_22;
  }
  if (result == (xpc_type_t)&_xpc_type_double)
  {
    value = xpc_double_get_value(a4);
    v35 = "%f";
    goto LABEL_22;
  }
  if (result == (xpc_type_t)&_xpc_type_BOOL)
  {
    if (a4 == &_xpc_BOOL_true)
      v36 = "true";
    else
      v36 = "false";
    value = *(double *)&v36;
    v35 = "%s";
    goto LABEL_22;
  }
  if (result == (xpc_type_t)&_xpc_type_date)
  {
    v43 = (uint64_t)(xpc_date_get_value_absolute(a4) + 978307200.0);
    memset(&v42, 0, sizeof(v42));
    gmtime_r(&v43, &v42);
    *(_QWORD *)v44 = 0;
    v45 = 0;
    memset(v46, 0, sizeof(v46));
    strftime(v44, 0x1EuLL, "%a %b %d %T %Y %Z", &v42);
    value = COERCE_DOUBLE(v44);
    v35 = "%s (approx)";
    goto LABEL_22;
  }
  if (result == (xpc_type_t)&_xpc_type_array)
  {
    sub_10004391C(a1, 0, "[", v12, v13, v14, v15, v16);
    if (xpc_array_get_count(a4))
    {
      v39 = 0;
      do
      {
        sub_1000438B0(a1, a2 + 1, "%lu = ", v29, v30, v31, v32, v33, v39);
        v40 = xpc_array_get_value(a4, v39);
        sub_10001595C(a1, a2 + 1, 0, v40);
        ++v39;
      }
      while (v39 < xpc_array_get_count(a4));
    }
    v34 = "]";
    return (xpc_type_t)sub_10004391C(a1, a2, v34, v29, v30, v31, v32, v33);
  }
  if (result == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_10004391C(a1, 0, "{", v12, v13, v14, v15, v16);
    *(_QWORD *)&v42.tm_sec = 0;
    *(_QWORD *)&v42.tm_hour = a1;
    *(_QWORD *)&v42.tm_mon = a2 + 1;
    xpc_dictionary_apply_f(a4);
    v35 = "}";
    v37 = a1;
    v38 = a2;
    return (xpc_type_t)sub_10004391C(v37, v38, v35, v12, v13, v14, v15, v16, *(_QWORD *)&value);
  }
  if (result == (xpc_type_t)&_xpc_type_bundle)
  {
    sub_10004391C(a1, 0, "@bundle {", v12, v13, v14, v15, v16);
    info_dictionary = xpc_bundle_get_info_dictionary(a4);
    sub_1000438B0(a1, a2 + 1, "info plist = ", v18, v19, v20, v21, v22);
    sub_10001595C(a1, a2 + 1, 0, info_dictionary);
    v23 = (void *)xpc_bundle_copy_services(a4);
    sub_1000438B0(a1, a2 + 1, "service bundles => ", v24, v25, v26, v27, v28);
    sub_10001595C(a1, a2 + 1, 0, v23);
    xpc_release(v23);
    v34 = "}";
    return (xpc_type_t)sub_10004391C(a1, a2, v34, v29, v30, v31, v32, v33);
  }
  return result;
}

uint64_t sub_100015D20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  FILE *v9;
  uint64_t v10;

  v9 = *(FILE **)(a3 + 8);
  v10 = *(_QWORD *)(a3 + 16);
  sub_1000438B0(v9, v10, "\"%s\" => ", a4, a5, a6, a7, a8, a1);
  return sub_10001595C(v9, v10, 0, a2);
}

uint64_t sub_100015D78(uint64_t a1, mach_port_context_t a2)
{
  mach_port_options_t v4;
  _BYTE v5[255];
  char v6;

  v4.reserved[1] = 0;
  memset(v5, 0, sizeof(v5));
  v6 = 7;
  __strlcpy_chk(v5, a1, 255, 255);
  *(_QWORD *)&v4.flags = 0x8000000433;
  v4.reserved[0] = (uint64_t)v5;
  return sub_10000D850(&v4, a2);
}

void os_crash_function(const char *a1)
{
  sub_10003E208("%s", a1);
}

void start()
{
  int v0;
  int v1;
  FILE *v2;
  const char *v3;
  const char *v4;
  pid_t v5;
  pid_t v6;
  FILE *v7;
  const char *v8;
  const char *v9;
  mach_port_t v10;
  char *v11;
  uint64_t v12;
  mach_header_64 *v13;
  uint64_t v14;
  int v15;
  int v16;
  int *v17;
  char *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int *v24;
  kern_return_t v25;
  uint64_t v26;
  pid_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  NSObject *v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  mach_port_t init_port_set[4];
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  unint64_t v65;
  char *v66;
  char out[48];

  if (!getenv("LAUNCH_DID_REEXEC") && !getenv("XPC_USERSPACE_REBOOTED"))
    sub_10003FF3C("kern.initproc_spawned", 1);
  _os_crash_callback = os_crash_function;
  v0 = isatty(1);
  if (v0 && !byte_100072A61)
  {
    v1 = v0;
    v2 = __stdoutp;
    v3 = getprogname();
    fprintf(v2, "%s cannot be run directly.\n", v3);
    v4 = getprogname();
    sub_10003E208("%s cannot be run directly (stdout: %d)", v4, v1);
  }
  v5 = getpid();
  if (v5 != 1 && !byte_100072A61)
  {
    v6 = v5;
    v7 = __stdoutp;
    v8 = getprogname();
    fprintf(v7, "%s cannot be run directly.\n", v8);
    v9 = getprogname();
    sub_10003E208("%s cannot be run directly (pid = %d)", v9, v6);
  }
  v10 = mach_host_self();
  panic_init(v10);
  sub_100014608();
  if (!byte_100072A61)
  {
    sub_1000164D0(0, 0);
    sub_1000164D0(1, 1);
    sub_1000164D0(2, 2);
  }
  sub_10001140C(570425408);
  sub_100010EF8();
  v11 = sub_100046FC8();
  nullsub_23(v11, v12);
  sub_100003EBC();
  memset(out, 0, 37);
  memset(init_port_set, 0, sizeof(init_port_set));
  v13 = _NSGetMachExecuteHeader();
  if (_dyld_get_image_uuid(v13, init_port_set))
    goto LABEL_58;
  _os_assumes_log(0);
  while (1)
  {
    sub_100040F68(5, "hello, launchd UUID: %s", out);
    sub_10003EE0C();
    if (byte_100072A7B)
      dword_100071AB4 = -1;
    if (byte_100072A47)
    {
      sub_100040F68(65543, "Memory limit override file is present, disabling memory limits.");
      dword_100071AB4 = -1;
      *(_QWORD *)init_port_set = 0;
    }
    else
    {
      *(_QWORD *)init_port_set = 0;
      if (dword_100071AB4 != -1 && sub_100003F84((unint64_t *)init_port_set))
        dword_100071AB4 += 2;
    }
    v14 = getpid();
    if (memorystatus_control(6, v14, dword_100071AB4, 0, 0) == -1)
    {
      v15 = dword_100071AB4;
      v16 = *__error();
      v17 = __error();
      v18 = strerror(*v17);
      sub_100040F68(65539, "Could not opt into %d MB Jetsam high watermark: %d: %s", v15, v16, v18);
    }
    sub_100040F68(65541, "%s", off_100071AC8[0]);
    v66 = 0;
    if (sub_10003FCE8("kern.bootargs", &v66))
      sub_100040F68(65541, "boot-args = %s", v66);
    free(v66);
    v19 = getpid();
    if (proc_disable_wakemon(v19) == -1)
    {
      v34 = __error();
      v35 = _os_assert_log(*v34);
      _os_crash(v35, v36, v37, v38);
      __break(1u);
    }
    else
    {
      if (byte_100072A61)
      {
        byte_100072ABA = 1;
        sub_100040F68(65541, "Lean Testing Environment starting.");
      }
      v20 = byte_100072A65;
      if (byte_100072A63 && !byte_100072A65)
      {
        byte_100072ABA = 1;
        sub_100040F68(65541, "Restore environment starting.");
        v20 = byte_100072A65;
      }
      if (v20)
      {
        byte_100072ABA = 1;
        sub_100040F68(65541, "BaseSystem environment starting.");
      }
      v65 = 0;
      if (sub_100003F84(&v65))
        sub_100040F68(65541, "Running with Probabilistic Guard Malloc envvar (Sample Rate = %zu)", v65);
      if (setsid() == -1 && !byte_100072A61 && (!byte_100072A80 || *__error() != 1))
      {
        v21 = *__error();
        if ((_DWORD)v21)
          goto LABEL_57;
      }
      if (chdir("/") != -1)
      {
        if (setlogin("root") != -1)
        {
          v22 = 0;
          while (1)
          {
            v23 = dword_10004FD70[v22];
            dword_100071CE8 |= 1 << (v23 - 1);
            if (signal(v23, (void (__cdecl *)(int))1) == (void (__cdecl *)(int))-1)
            {
              v24 = __error();
              _os_assumes_log(*v24);
            }
            if (++v22 == 21)
            {
              v25 = task_set_special_port(mach_task_self_, 4, 0);
              if (!v25)
              {
                bootstrap_port = 0;
                v26 = sub_100015D78((uint64_t)off_100071630, 0x70507uLL);
                init_port_set[0] = v26;
                if (!mach_ports_register(mach_task_self_, init_port_set, 1u))
                {
                  dword_100072A00 = v26;
                  qword_100072A08 = xpc_mach_send_create_with_disposition(v26, 17);
                  qword_100072980 = mach_absolute_time();
                  uuid_generate(byte_100072990);
                  LODWORD(qword_1000729A0) = getuid();
                  HIDWORD(qword_1000729A0) = geteuid();
                  dword_1000729A8 = getegid();
                  dword_1000729AC = geteuid();
                  LODWORD(qword_1000729B0) = getegid();
                  HIDWORD(qword_1000729B0) = getpid();
                  dword_1000729B8 = sub_10001F090();
                  unk_1000729BC = 0;
                  v63 = 0u;
                  v64 = 0u;
                  v61 = 0u;
                  v62 = 0u;
                  v59 = 0u;
                  v60 = 0u;
                  v57 = 0u;
                  v58 = 0u;
                  v55 = 0u;
                  v56 = 0u;
                  *(_OWORD *)init_port_set = 0u;
                  v54 = 0u;
                  v27 = getpid();
                  v28 = sub_10003FB84(v27, init_port_set);
                  if (v28)
                  {
                    if (v28 != 45)
                      sub_10003E208("could not get unique pid");
                  }
                  qword_100072988 = *((_QWORD *)&v62 + 1);
                  sub_100044508();
                  sub_1000102D8();
                  sub_100039B08();
                  sub_10001F344();
                  sub_10002CDB8();
                  sub_10003B488();
                  sub_10003C5B0();
                  sub_1000393DC();
                  sub_100038E38();
                  nullsub_23(v29, v30);
                  sub_100013B28();
                  sub_100003880();
                  sub_10001C7C8();
                  v31 = sub_10000ECE8();
                  nullsub_23(v31, v32);
                  sub_10000FEB0();
                  sub_100012524();
                  sub_10001CE34();
                  sub_100042808();
                  v33 = sub_1000146E4();
                  dispatch_activate(v33);
                  dispatch_main();
                }
                sub_10003E208("could not set up inheritance port");
              }
              sub_100040F68(3, "Could not neuter bootstrap port: 0x%x", v25);
              exit(1);
            }
          }
        }
        goto LABEL_56;
      }
    }
    v39 = __error();
    v40 = _os_assert_log(*v39);
    _os_crash(v40, v41, v42, v43);
    __break(1u);
LABEL_56:
    v44 = __error();
    v45 = _os_assert_log(*v44);
    v21 = _os_crash(v45, v46, v47, v48);
    __break(1u);
LABEL_57:
    v49 = _os_assert_log(v21);
    _os_crash(v49, v50, v51, v52);
    __break(1u);
LABEL_58:
    uuid_unparse((const unsigned __int8 *)init_port_set, out);
  }
}

int *sub_1000164D0(int a1, int a2)
{
  int *result;
  int *v4;
  int v5;

  result = (int *)open("/dev/null", a1 | 0x20000, 438);
  if ((_DWORD)result != -1)
  {
    v4 = (int *)dup2((int)result, a2);
    if ((_DWORD)v4 == -1)
    {
      v5 = *__error();
      if (v5)
        sub_10004D778(v5);
    }
    return sub_10003BAF4(v4);
  }
  return result;
}

size_t sub_10001654C(const char *a1)
{
  if ((sub_1000165A8(a1, "Frameworks") & 1) != 0 || (sub_1000165A8(a1, "PrivateFrameworks") & 1) != 0)
    return 1;
  else
    return sub_1000165A8(a1, "AppRemovalServices");
}

size_t sub_1000165A8(const char *a1, const char *a2)
{
  size_t result;
  void *v5;
  size_t v6;
  const char *string;
  const char *v8;
  char __str[1024];

  bzero(__str, 0x400uLL);
  snprintf(__str, 0x400uLL, "%s/%s", "/System/Library", a2);
  if (sub_1000156F0(a1, __str))
    return 1;
  result = (size_t)sub_1000479B8("SystemRoots");
  if (result)
  {
    v5 = (void *)result;
    if (xpc_get_type((xpc_object_t)result) == (xpc_type_t)&_xpc_type_array)
    {
      result = xpc_array_get_count(v5);
      if (result)
      {
        v6 = 0;
        while (1)
        {
          string = xpc_array_get_string(v5, v6);
          if (string)
          {
            v8 = string;
            bzero(__str, 0x400uLL);
            snprintf(__str, 0x400uLL, "%s/%s", v8, a2);
            if (sub_1000156F0(a1, __str))
              break;
          }
          if (++v6 >= xpc_array_get_count(v5))
            return 0;
        }
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

char *sub_1000166F8(char a1, const char *a2, _OWORD *a3, uint64_t a4, NSObject *a5)
{
  char *v10;
  __int128 v11;

  v10 = (char *)sub_100019B1C(0);
  v10[100] = a1;
  *((_QWORD *)v10 + 2) = sub_10001544C(a2);
  v11 = a3[1];
  *(_OWORD *)(v10 + 24) = *a3;
  *(_OWORD *)(v10 + 40) = v11;
  *((_QWORD *)v10 + 7) = a4;
  *((_QWORD *)v10 + 8) = a5;
  dispatch_retain(a5);
  return v10;
}

void sub_10001676C(uint64_t a1)
{
  const void *v2;
  const void *v3;
  void *v4;

  if ((*(_BYTE *)(a1 + 101) & 1) != 0)
    sub_10004D738();
  free(*(void **)(a1 + 16));
  dispatch_release(*(dispatch_object_t *)(a1 + 64));
  v2 = *(const void **)(a1 + 72);
  if (v2)
    _Block_release(v2);
  v3 = *(const void **)(a1 + 80);
  if (v3)
    _Block_release(v3);
  v4 = *(void **)(a1 + 88);
  if (v4)
  {
    sub_10001962C(v4);
    *(_QWORD *)(a1 + 88) = 0;
  }
}

void *sub_1000167D8(uint64_t a1, void *aBlock)
{
  void *result;

  if ((*(_BYTE *)(a1 + 101) & 1) != 0)
    sub_10004D738();
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 72) = result;
  return result;
}

void *sub_10001680C(uint64_t a1, void *aBlock)
{
  void *result;

  if ((*(_BYTE *)(a1 + 101) & 1) != 0)
    sub_10004D738();
  result = _Block_copy(aBlock);
  *(_QWORD *)(a1 + 80) = result;
  return result;
}

void sub_100016840(uint64_t a1)
{
  const char *v2;
  _BOOL8 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  _BYTE *v9;
  __int128 v10;
  NSObject *v11;
  void *v12;
  void *v13;
  int v14;
  __int128 v15;
  void **v16;
  uint64_t v17;
  void *v18;
  void *v19;
  uint64_t v20;
  _BYTE *v21;

  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 64));
  if ((*(_BYTE *)(a1 + 101) & 1) != 0)
    sub_10004D738();
  *(_BYTE *)(a1 + 101) |= 1u;
  sub_100019580((void *)a1);
  if (!*(_QWORD *)(a1 + 72))
    sub_10004D738();
  if (!*(_QWORD *)(a1 + 80))
    sub_10004D738();
  v2 = *(const char **)(a1 + 16);
  if (*v2 != 47 || sub_1000156F0(*(const char **)(a1 + 16), "/usr/lib") || (v3 = sub_1000156F0(v2, "/usr/local/lib")))
  {
    sub_100016A4C(a1);
  }
  else
  {
    v7 = *(unsigned __int8 *)(a1 + 100);
    switch(*(_BYTE *)(a1 + 100))
    {
      case 1:
        sub_100016AB8(a1);
        return;
      case 2:
        sub_100016B74(a1);
        return;
      case 3:
        sub_100016C28(a1);
        return;
      case 4:
      case 5:
        if (!qword_100071CF0)
          goto LABEL_20;
        if (xpc_dictionary_get_BOOL((xpc_object_t)qword_100071CF0, *(const char **)(a1 + 16)))
        {
          sub_100017680(a1);
        }
        else
        {
          v7 = *(unsigned __int8 *)(a1 + 100);
LABEL_20:
          if (v7 == 5)
            v14 = 1;
          else
            v14 = 2;
          v9 = sub_1000104A0(v14, *(_QWORD *)(a1 + 16), 0);
          v15 = *(_OWORD *)(a1 + 40);
          *((_OWORD *)v9 + 1) = *(_OWORD *)(a1 + 24);
          *((_OWORD *)v9 + 2) = v15;
          v11 = *(NSObject **)(a1 + 64);
          *((_QWORD *)v9 + 6) = *(_QWORD *)(a1 + 56);
          v16 = _NSConcreteStackBlock;
          v17 = 0x40000000;
          v12 = sub_100017974;
          v13 = &unk_10006C1C8;
LABEL_24:
          v18 = v12;
          v19 = v13;
          v20 = a1;
          v21 = v9;
          sub_1000104D0((uint64_t)v9, v11, &v16);
        }
        break;
      case 6:
      case 7:
        if (v7 == 7)
          v8 = 1;
        else
          v8 = 2;
        v9 = sub_1000104A0(v8, *(_QWORD *)(a1 + 16), 0);
        v10 = *(_OWORD *)(a1 + 40);
        *((_OWORD *)v9 + 1) = *(_OWORD *)(a1 + 24);
        *((_OWORD *)v9 + 2) = v10;
        v11 = *(NSObject **)(a1 + 64);
        *((_QWORD *)v9 + 6) = *(_QWORD *)(a1 + 56);
        v16 = _NSConcreteStackBlock;
        v17 = 0x40000000;
        v12 = sub_100017B54;
        v13 = &unk_10006C1E8;
        goto LABEL_24;
      default:
        sub_10004D92C(v3, v4, v5, v6);
    }
  }
}

void sub_100016A4C(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 64));
  (*(void (**)(void))(*(_QWORD *)(a1 + 72) + 16))();
  if ((*(_BYTE *)(a1 + 101) & 1) == 0)
    sub_10004D738();
  *(_BYTE *)(a1 + 101) &= ~1u;
  sub_10001962C((void *)a1);
}

void sub_100016AB8(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  char v4;
  char *v5;

  v2 = *(_QWORD *)(a1 + 56);
  v3 = *(const char **)(a1 + 16);
  if (sub_100015730(v3, ".plist"))
  {
    v4 = 2;
  }
  else if (sub_100015730(v3, ".xpc") || sub_100015730(v3, ".pluginkit"))
  {
    v2 |= 0x1000uLL;
    v4 = 7;
  }
  else
  {
    v4 = 3;
  }
  v5 = sub_1000166F8(v4, v3, (_OWORD *)(a1 + 24), v2, *(NSObject **)(a1 + 64));
  sub_1000175BC(a1, v5);
  sub_10001962C(v5);
  sub_100017680(a1);
}

void sub_100016B74(uint64_t a1)
{
  const char *v2;
  _BYTE *v3;
  __int128 v4;
  NSObject *v5;
  _QWORD v6[6];

  v2 = *(const char **)(a1 + 16);
  if (sub_100015730(v2, ".plist"))
  {
    v3 = sub_1000104A0(0, (uint64_t)v2, 0);
    v4 = *(_OWORD *)(a1 + 40);
    *((_OWORD *)v3 + 1) = *(_OWORD *)(a1 + 24);
    *((_OWORD *)v3 + 2) = v4;
    v5 = *(NSObject **)(a1 + 64);
    *((_QWORD *)v3 + 6) = *(_QWORD *)(a1 + 56);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_1000177E8;
    v6[3] = &unk_10006C188;
    v6[4] = a1;
    v6[5] = v3;
    sub_1000104D0((uint64_t)v3, v5, v6);
  }
  else
  {
    sub_100016A4C(a1);
  }
}

void sub_100016C28(uint64_t a1)
{
  _BYTE *v2;
  __int128 v3;
  NSObject *v4;
  _QWORD v5[6];

  v2 = sub_1000104A0(3, *(_QWORD *)(a1 + 16), 0);
  v3 = *(_OWORD *)(a1 + 40);
  *((_OWORD *)v2 + 1) = *(_OWORD *)(a1 + 24);
  *((_OWORD *)v2 + 2) = v3;
  v4 = *(NSObject **)(a1 + 64);
  *((_QWORD *)v2 + 6) = *(_QWORD *)(a1 + 56);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100017828;
  v5[3] = &unk_10006C1A8;
  v5[4] = a1;
  v5[5] = v2;
  sub_1000104D0((uint64_t)v2, v4, v5);
}

void sub_100016CA8(uint64_t a1)
{
  void *v2;
  NSObject *v3;

  if ((*(_BYTE *)(a1 + 140) & 1) != 0)
    sub_10004D738();
  sub_10001962C(*(void **)(a1 + 48));
  v2 = *(void **)(a1 + 72);
  if (v2)
    xpc_release(v2);
  dispatch_release(*(dispatch_object_t *)(a1 + 16));
  _Block_release(*(const void **)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 80));
  v3 = *(NSObject **)(a1 + 56);
  if (v3)
    dispatch_release(v3);
  sub_10001962C(*(void **)(a1 + 64));
  sub_10001962C(*(void **)(a1 + 32));
}

void sub_100016D38(_QWORD *a1, int a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  NSObject *v14;
  char *v15;
  NSObject *v16;
  BOOL v17;
  BOOL v18;
  BOOL v19;
  char v20;
  __int128 v21;
  xpc_type_t type;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  size_t v26;
  const char *string;
  const char *v28;
  char v29;
  char v30;
  char v31;
  NSObject *v32;
  char *v33;
  char v34;
  char v35;
  char v36;
  char v37;
  const char *string_ptr;
  NSObject *v39;
  char *v40;
  NSObject *v41;
  char v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  _QWORD v49[5];
  _QWORD aBlock[5];
  _QWORD applier[7];

  if ((a2 - 1) >= 2)
    sub_10004D738();
  v8 = a6;
  if (!a1[32])
    a1[32] = mach_absolute_time();
  if (a2 == 1)
    sub_1000296E0((uint64_t)a1, 8, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, v48);
  v14 = sub_1000146E4();
  v15 = (char *)sub_100019AF0(0);
  *((_QWORD *)v15 + 6) = sub_100019580(a1);
  v15[96] = a2;
  *((_QWORD *)v15 + 11) = v8;
  if (a3)
    *((_QWORD *)v15 + 9) = xpc_retain(a3);
  *((_QWORD *)v15 + 2) = v14;
  dispatch_retain(v14);
  *((_QWORD *)v15 + 10) = xpc_dictionary_create(0, 0, 0);
  *((_QWORD *)v15 + 4) = sub_10001123C();
  if (a2 == 2 && a3)
  {
    v16 = dispatch_group_create();
    *((_QWORD *)v15 + 7) = v16;
    dispatch_group_enter(v16);
  }
  *((_QWORD *)v15 + 8) = sub_1000431D8();
  if ((uint64_t *)a5 == &qword_1000729A0
    || (*(_QWORD *)a5 == qword_1000729A0 ? (v17 = *(_QWORD *)(a5 + 8) == *(_QWORD *)&dword_1000729A8) : (v17 = 0),
        v17 ? (v18 = *(_QWORD *)(a5 + 16) == qword_1000729B0) : (v18 = 0),
        v18 ? (v19 = *(_QWORD *)(a5 + 24) == *(_QWORD *)&dword_1000729B8) : (v19 = 0),
        v19))
  {
    v20 = 2;
  }
  else if (sub_1000186F4((_OWORD *)a5, 0, 2))
  {
    v20 = 2;
  }
  else
  {
    v20 = 1;
  }
  v15[104] = v20;
  v21 = *(_OWORD *)(a5 + 16);
  *(_OWORD *)(v15 + 108) = *(_OWORD *)a5;
  *(_OWORD *)(v15 + 124) = v21;
  if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_array)
  {
    if (xpc_array_get_count(a4))
    {
      v26 = 0;
      do
      {
        string = xpc_array_get_string(a4, v26);
        if (string)
        {
          v28 = string;
          if ((v8 & 0x1000) != 0)
            v29 = 6;
          else
            v29 = 4;
          if ((v8 & 0x1000) != 0)
            v30 = 7;
          else
            v30 = 5;
          if (v8 != 1)
            v30 = 1;
          if (v8 == 2)
            v31 = v29;
          else
            v31 = v30;
          v8 = v8 & 0xFFFFFF00;
          v32 = sub_1000146E4();
          v33 = sub_1000166F8(v31, v28, v15 + 108, v8, v32);
          sub_100017B94((uint64_t)v15, v33);
          sub_10001962C(v33);
        }
        ++v26;
      }
      while (v26 < xpc_array_get_count(a4));
    }
  }
  else if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string)
  {
    if ((v8 & 0x1000) != 0)
      v34 = 6;
    else
      v34 = 4;
    if ((v8 & 0x1000) != 0)
      v35 = 7;
    else
      v35 = 5;
    if (v8 == 1)
      v36 = v35;
    else
      v36 = 1;
    if (v8 == 2)
      v37 = v34;
    else
      v37 = v36;
    string_ptr = xpc_string_get_string_ptr(a4);
    v39 = sub_1000146E4();
    v40 = sub_1000166F8(v37, string_ptr, v15 + 108, v8 & 0xFFFFFF00, v39);
    sub_100017B94((uint64_t)v15, v40);
    sub_10001962C(v40);
  }
  else
  {
    type = xpc_get_type(a4);
    if (type != (xpc_type_t)&_xpc_type_dictionary)
      sub_10004D944((uint64_t)type, v23, v24, v25);
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_100017C4C;
    applier[3] = &unk_10006C208;
    applier[4] = v8;
    applier[5] = v15;
    xpc_dictionary_apply(a4, applier);
  }
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_10001712C;
  aBlock[3] = &unk_10006C0A0;
  aBlock[4] = v15;
  if ((v15[140] & 1) != 0)
    sub_10004D738();
  *((_QWORD *)v15 + 3) = _Block_copy(aBlock);
  v41 = sub_1000146E4();
  v49[0] = _NSConcreteStackBlock;
  v49[1] = 0x40000000;
  v49[2] = sub_10001731C;
  v49[3] = &unk_10006C0C0;
  v49[4] = v15;
  v42 = sub_100038EFC((uint64_t)a3, v41, v49);
  if (a3)
  {
    if ((v42 & 1) == 0)
      sub_100028C34((uint64_t)a1, 5, "couldn't handoff domain IO, asynced away", v43, v44, v45, v46, v47, v48);
  }
}

void sub_10001712C(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  rb_tree_t **v4;
  void *v5;
  const char *v6;
  NSObject *v7;
  NSObject *v8;
  void *v9;
  void **v10;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t *v15;
  _QWORD v16[6];

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(uint64_t **)(v2 + 48);
  if ((*(_BYTE *)(v2 + 89) & 4) != 0)
  {
    if (*(_BYTE *)(v2 + 96) != 1)
      sub_10004D738();
    v4 = *(rb_tree_t ***)(v2 + 64);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = sub_100018310;
    v16[3] = &unk_10006C288;
    v16[4] = v3;
    v16[5] = v2;
    sub_100043140(v4, (uint64_t)v16);
  }
  v5 = *(void **)(v2 + 72);
  if (v5)
  {
    if (*(_BYTE *)(v2 + 96) == 1)
      v6 = "bootstrap-error";
    else
      v6 = "bootout-error";
    xpc_dictionary_set_int64(*(xpc_object_t *)(v2 + 72), v6, *(int *)(v2 + 100));
    xpc_dictionary_set_value(v5, "errors", *(xpc_object_t *)(v2 + 80));
    if (*(_QWORD *)(v2 + 56))
    {
      xpc_retain(v5);
      sub_100019580(v3);
      dispatch_group_leave(*(dispatch_group_t *)(v2 + 56));
      v7 = *(NSObject **)(v2 + 56);
      v8 = *(NSObject **)(v2 + 16);
      v10 = _NSConcreteStackBlock;
      v11 = 0x40000000;
      v12 = sub_100018390;
      v13 = &unk_10006C2A8;
      v14 = v5;
      v15 = v3;
      dispatch_group_notify(v7, v8, &v10);
    }
    else if ((xpc_pipe_routine_reply(v5) | 0x20) != 0x20)
    {
      _os_assumes_log_ctx(sub_100028C00, v3);
    }
  }
  else
  {
    v9 = *(void **)(v2 + 80);
    v10 = _NSConcreteStackBlock;
    v11 = 0x40000000;
    v12 = sub_1000183F4;
    v13 = &unk_10006C2C8;
    v14 = (void *)v2;
    xpc_dictionary_apply(v9, &v10);
  }
  if ((*(_BYTE *)(v2 + 89) & 0x20) != 0)
  {
    v3[33] = sub_10000D6D0(v3[32]);
    sub_100029A24((uint64_t)v3);
  }
  if (*(_BYTE *)(v2 + 96) == 1)
    sub_10002976C((uint64_t)v3, 8);
  sub_10001962C(*(void **)(a1 + 32));
}

void sub_10001731C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t i;
  uint64_t v5;

  v1 = *(_QWORD *)(a1 + 32);
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(v1 + 16));
  if ((*(_BYTE *)(v1 + 140) & 1) != 0)
    sub_10004D738();
  *(_BYTE *)(v1 + 140) |= 1u;
  sub_100019580((void *)v1);
  if (sub_100011400(*(_QWORD *)(v1 + 32)))
  {
    v2 = sub_100011400(*(_QWORD *)(v1 + 32));
    if ((*(_BYTE *)(v1 + 90) & 1) != 0)
      v3 = 1;
    else
      v3 = v2;
    if (v3)
    {
      for (i = 0; i != v3; ++i)
      {
        v5 = sub_1000113D8(*(_QWORD *)(v1 + 32), i);
        sub_100016840(v5);
      }
    }
  }
  else
  {
    sub_100018238(v1);
  }
}

void sub_1000173C8(_QWORD *a1, int a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100016D38(a1, a2, a3, a4, a5, a6 | 0x10000, a7, a8);
}

void sub_1000173D0(void *a1, const char *a2, void *a3, _OWORD *a4, uint64_t a5)
{
  NSObject *v10;
  char *v11;
  _QWORD v12[8];

  v10 = sub_1000146E4();
  v11 = sub_1000166F8(6, a2, a4, 20480, v10);
  if (a3)
    xpc_retain(a3);
  sub_100019580(a1);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  v12[2] = sub_1000174AC;
  v12[3] = &unk_10006C0E8;
  v12[4] = a5;
  v12[5] = a3;
  v12[6] = a1;
  v12[7] = v11;
  sub_1000167D8((uint64_t)v11, v12);
  sub_10001680C((uint64_t)v11, &stru_10006C128);
  sub_100016840((uint64_t)v11);
}

void sub_1000174AC(uint64_t a1, uint64_t a2, int a3)
{
  void *v5;
  uint64_t v6;
  uint64_t info_dictionary;
  void *v8;
  int v9;
  _QWORD applier[5];

  v9 = a3;
  if (!a3)
  {
    v5 = *(void **)(a1 + 40);
    if (v5)
    {
      v6 = sub_1000105FC(a2);
      if (!v6)
        sub_10004D738();
      info_dictionary = xpc_bundle_get_info_dictionary(v6);
      if (info_dictionary)
      {
        applier[0] = _NSConcreteStackBlock;
        applier[1] = 0x40000000;
        applier[2] = sub_100018494;
        applier[3] = &unk_10006C2E8;
        applier[4] = info_dictionary;
        xpc_dictionary_apply(v5, applier);
      }
    }
    sub_10002C76C(*(_QWORD *)(a1 + 48), a2, *(void **)(a1 + 40), &v9);
    v8 = *(void **)(a1 + 40);
    if (v8)
      xpc_release(v8);
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  sub_10001962C(*(void **)(a1 + 48));
  sub_10001962C(*(void **)(a1 + 56));
}

void sub_1000175A4(id a1, _launch_domain_io_s *a2, _launch_io_s *a3, int a4)
{
  _os_crash("unexpected subdio for an app extension bundle", a2, a3, *(_QWORD *)&a4);
  __break(1u);
}

_QWORD *sub_1000175BC(uint64_t a1, void *a2)
{
  _QWORD *v4;
  _QWORD v6[5];
  _QWORD aBlock[6];

  if (*(_DWORD *)(a1 + 96))
    sub_10004D738();
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100017728;
  aBlock[3] = &unk_10006C148;
  aBlock[4] = a1;
  aBlock[5] = a2;
  sub_1000167D8((uint64_t)a2, aBlock);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_1000177E0;
  v6[3] = &unk_10006C168;
  v6[4] = a1;
  sub_10001680C((uint64_t)a2, v6);
  v4 = *(_QWORD **)(a1 + 88);
  if (!v4)
  {
    v4 = sub_10001123C();
    *(_QWORD *)(a1 + 88) = v4;
  }
  return sub_1000112C0(v4, a2);
}

void sub_100017680(uint64_t a1)
{
  int v2;
  unint64_t v3;
  uint64_t v4;

  if (*(_QWORD *)(a1 + 88))
  {
    sub_100019580((void *)a1);
    v2 = sub_100011400(*(_QWORD *)(a1 + 88));
    *(_DWORD *)(a1 + 96) = v2;
    if (!v2)
      sub_10004D738();
    if (sub_100011400(*(_QWORD *)(a1 + 88)))
    {
      v3 = 0;
      do
      {
        v4 = sub_1000113D8(*(_QWORD *)(a1 + 88), v3);
        sub_100016840(v4);
        ++v3;
      }
      while (v3 < sub_100011400(*(_QWORD *)(a1 + 88)));
    }
    sub_10001962C((void *)a1);
  }
  else
  {
    sub_100016A4C(a1);
  }
}

void sub_100017728(uint64_t a1)
{
  uint64_t v2;
  int v3;
  int v4;

  sub_100017788(*(_QWORD *)(a1 + 32));
  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(_DWORD *)(v2 + 96);
  if (!v3)
    sub_10004D738();
  v4 = v3 - 1;
  *(_DWORD *)(v2 + 96) = v4;
  if (!v4)
    sub_100016A4C(v2);
}

uint64_t sub_100017788(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 101) & 1) == 0)
    sub_10004D738();
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 64));
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 80) + 16))();
}

uint64_t sub_1000177E0(uint64_t a1)
{
  return sub_100017788(*(_QWORD *)(a1 + 32));
}

void sub_1000177E8(uint64_t a1, uint64_t a2)
{
  if (a2)
    sub_10004D738();
  sub_100016A4C(*(_QWORD *)(a1 + 32));
  sub_10001962C(*(void **)(a1 + 40));
}

void sub_100017828(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  int v9;
  const char *v10;
  char v11;
  char *v12;

  if (a3)
  {
    sub_100016A4C(*(_QWORD *)(a1 + 32));
  }
  else
  {
    if (!a2)
      sub_10004D738();
    if (!sub_100011400(a2) && (*(_BYTE *)(*(_QWORD *)(a1 + 32) + 57) & 0x20) == 0)
      sub_100040F68(4, "Activated a directory (%s) and found no files", "<private>");
    if (sub_100011400(a2))
    {
      v5 = 0;
      do
      {
        v6 = sub_1000113D8(a2, v5);
        v7 = *(_QWORD *)(a1 + 32);
        v8 = *(_OWORD *)(v7 + 40);
        *(_OWORD *)(v6 + 16) = *(_OWORD *)(v7 + 24);
        *(_OWORD *)(v6 + 32) = v8;
        *(_QWORD *)(v6 + 48) = *(_QWORD *)(v7 + 56);
        v9 = sub_1000105B4(v6);
        v10 = (const char *)sub_1000105F4(v6);
        if (v9 == 3)
          v11 = 5;
        else
          v11 = 2;
        v12 = sub_1000166F8(v11, v10, (_OWORD *)(*(_QWORD *)(a1 + 32) + 24), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56), *(NSObject **)(*(_QWORD *)(a1 + 32) + 64));
        sub_1000175BC(*(_QWORD *)(a1 + 32), v12);
        sub_10001962C(v12);
        ++v5;
      }
      while (v5 < sub_100011400(a2));
    }
    sub_100017680(*(_QWORD *)(a1 + 32));
  }
  sub_10001962C(*(void **)(a1 + 40));
}

void sub_100017974(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v4;
  uint64_t v5;
  void *v6;
  size_t v7;
  xpc_object_t value;
  _BYTE *v9;
  int v10;
  uint64_t v11;
  const char *v12;
  char v13;
  char *v14;
  __int128 v15;
  const char *path;
  uint64_t v17;
  xpc_object_t v18;

  if (a2)
    sub_10004D738();
  if (a3)
  {
    sub_100016A4C(*(_QWORD *)(a1 + 32));
    v4 = (uint64_t *)(a1 + 40);
  }
  else
  {
    v4 = (uint64_t *)(a1 + 40);
    v5 = sub_1000105FC(*(_QWORD *)(a1 + 40));
    v6 = (void *)xpc_bundle_copy_services(v5);
    if (xpc_array_get_count(v6))
    {
      v7 = 0;
      do
      {
        value = xpc_array_get_value(v6, v7);
        if (sub_1000105C4(*v4))
        {
          v9 = sub_1000187CC(value);
          v10 = sub_1000105B4((uint64_t)v9);
          v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56) | 0x1000;
          v12 = (const char *)sub_1000105F4((uint64_t)v9);
          if (v10 == 1)
            v13 = 7;
          else
            v13 = 6;
          v14 = sub_1000166F8(v13, v12, (_OWORD *)(*(_QWORD *)(a1 + 32) + 24), v11, *(NSObject **)(*(_QWORD *)(a1 + 32) + 64));
          v15 = *(_OWORD *)(v14 + 40);
          *((_OWORD *)v9 + 1) = *(_OWORD *)(v14 + 24);
          *((_OWORD *)v9 + 2) = v15;
          *((_QWORD *)v9 + 6) = *((_QWORD *)v14 + 7);
          sub_100017788(*(_QWORD *)(a1 + 32));
          sub_10001962C(v14);
        }
        else
        {
          path = (const char *)xpc_bundle_get_path(value);
          v9 = sub_1000166F8(7, path, (_OWORD *)(*(_QWORD *)(a1 + 32) + 24), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56) | 0x1000, *(NSObject **)(*(_QWORD *)(a1 + 32) + 64));
          sub_1000175BC(*(_QWORD *)(a1 + 32), v9);
        }
        sub_10001962C(v9);
        ++v7;
      }
      while (v7 < xpc_array_get_count(v6));
    }
    if ((sub_1000105C4(*v4) & 1) == 0 && !xpc_array_get_count(v6))
    {
      v17 = *(_QWORD *)(a1 + 32);
      v18 = (xpc_object_t)qword_100071CF0;
      if (!qword_100071CF0)
      {
        v18 = xpc_dictionary_create(0, 0, 0);
        qword_100071CF0 = (uint64_t)v18;
      }
      xpc_dictionary_set_BOOL(v18, *(const char **)(v17 + 16), 1);
    }
    xpc_release(v6);
    sub_100017680(*(_QWORD *)(a1 + 32));
  }
  sub_10001962C((void *)*v4);
}

void sub_100017B54(uint64_t a1, uint64_t a2)
{
  if (a2)
    sub_10004D738();
  sub_100016A4C(*(_QWORD *)(a1 + 32));
  sub_10001962C(*(void **)(a1 + 40));
}

_QWORD *sub_100017B94(uint64_t a1, void *a2)
{
  _QWORD v5[5];
  _QWORD aBlock[6];

  if (*(_QWORD *)(a1 + 40))
    sub_10004D738();
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_100017D30;
  aBlock[3] = &unk_10006C248;
  aBlock[4] = a1;
  aBlock[5] = a2;
  sub_1000167D8((uint64_t)a2, aBlock);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_1000182A8;
  v5[3] = &unk_10006C268;
  v5[4] = a1;
  sub_10001680C((uint64_t)a2, v5);
  return sub_1000112C0(*(_QWORD **)(a1 + 32), a2);
}

uint64_t sub_100017C4C(uint64_t a1, const char *a2, xpc_object_t object)
{
  uint64_t value;
  uint64_t v7;
  int v8;
  char v9;
  char v10;
  char v11;
  uint64_t v12;
  _OWORD *v13;
  NSObject *v14;
  char *v15;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_uint64)
    value = xpc_uint64_get_value(object);
  else
    value = 0;
  v7 = *(_QWORD *)(a1 + 32) | value;
  v8 = (*(_BYTE *)(a1 + 32) | value);
  if ((v7 & 0x1000) != 0)
    v9 = 6;
  else
    v9 = 4;
  if ((v7 & 0x1000) != 0)
    v10 = 7;
  else
    v10 = 5;
  if (v8 != 1)
    v10 = 1;
  if (v8 == 2)
    v11 = v9;
  else
    v11 = v10;
  v12 = v7 & 0xFFFFFF00;
  v13 = (_OWORD *)(*(_QWORD *)(a1 + 40) + 108);
  v14 = sub_1000146E4();
  v15 = sub_1000166F8(v11, a2, v13, v12, v14);
  sub_100017B94(*(_QWORD *)(a1 + 40), v15);
  sub_10001962C(v15);
  return 1;
}

void sub_100017D30(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  _QWORD block[5];

  sub_100017DFC(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), a2, a3);
  v4 = *(_QWORD *)(a1 + 32);
  v5 = *(_QWORD *)(v4 + 32);
  v6 = *(_QWORD *)(v4 + 40) + 1;
  *(_QWORD *)(v4 + 40) = v6;
  if (v6 > sub_100011400(v5))
    sub_10004D738();
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(_QWORD *)(v7 + 40);
  v9 = sub_100011400(*(_QWORD *)(v7 + 32));
  v10 = *(_QWORD *)(a1 + 32);
  if (v8 == v9)
  {
    sub_100018238(v10);
  }
  else if ((*(_BYTE *)(v10 + 90) & 1) != 0)
  {
    v11 = sub_1000146E4();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_10001828C;
    block[3] = &unk_10006C228;
    block[4] = *(_QWORD *)(a1 + 32);
    dispatch_async(v11, block);
  }
}

void sub_100017DFC(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  uint64_t v4;
  int v7;
  size_t v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  rb_tree_t **v14;
  void *info_dictionary;
  void *v16;
  const char *string;
  const char *v18;
  rb_tree_t **v19;
  uint64_t v20;
  uint64_t v21;
  const char *property;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  const char *v30;
  void *v31;
  const char *v32;
  const char *v33;
  int v34;
  int v35;
  const char *v36;
  int v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;

  v4 = a4;
  if (!(_DWORD)a4)
  {
    v7 = *(unsigned __int8 *)(a1 + 96);
    if ((v7 - 1) >= 2)
      sub_10004D738();
    v9 = *(_QWORD *)(a1 + 48);
    if (sub_1000291BC(v9))
    {
      v4 = 124;
      goto LABEL_47;
    }
    v10 = *(unsigned __int8 *)(a2 + 100);
    if ((v10 - 6) >= 2)
    {
      if (v10 != 2)
      {
LABEL_46:
        v4 = 0;
        goto LABEL_47;
      }
      if (v7 == 1)
      {
        v11 = sub_10002BB18(v9, (uint64_t)a3);
LABEL_13:
        v4 = v11;
        goto LABEL_47;
      }
      v12 = sub_10002C2C4(v9, (uint64_t)a3, *(NSObject **)(a1 + 56));
      if (((v12 == 36) & (*(unsigned __int8 *)(a1 + 90) >> 1)) != 0)
        v4 = 0;
      else
        v4 = v12;
    }
    else
    {
      if (v7 == 2)
      {
        v4 = 116;
        goto LABEL_47;
      }
      if ((*(_BYTE *)(a1 + 89) & 4) == 0)
      {
        v11 = sub_10002C734(v9, (uint64_t)a3);
        goto LABEL_13;
      }
      v13 = sub_1000105FC((uint64_t)a3);
      v14 = *(rb_tree_t ***)(a1 + 64);
      info_dictionary = (void *)xpc_bundle_get_info_dictionary(v13);
      if (!info_dictionary
        || (v16 = info_dictionary, (string = xpc_dictionary_get_string(info_dictionary, "CFBundleIdentifier")) == 0))
      {
        v4 = 107;
        goto LABEL_47;
      }
      v18 = string;
      v19 = sub_10004310C(v14, string);
      if (!v19)
        goto LABEL_45;
      v20 = (uint64_t)v19;
      v21 = sub_1000105FC((uint64_t)v19);
      property = (const char *)xpc_bundle_get_property(v13, 2);
      v23 = (const char *)xpc_bundle_get_property(v21, 2);
      if (sub_10001654C(v23) && !sub_10001654C(property))
      {
        v4 = 127;
        goto LABEL_47;
      }
      if ((sub_10001654C(v23) & 1) == 0 && (sub_10001654C(property) & 1) != 0)
      {
        LODWORD(v4) = 127;
LABEL_44:
        v36 = (const char *)sub_1000105F4(v20);
        sub_1000182B0(a1, v36, v4);
LABEL_45:
        a3[6] &= ~0x400uLL;
        sub_100043048((uint64_t)v14, v18, a3);
        goto LABEL_46;
      }
      if ((sub_10001654C(v23) & 1) != 0 || (sub_10001654C(property) & 1) != 0)
      {
        if (!strcmp(v23, property))
        {
          v4 = 121;
        }
        else
        {
          sub_100028C34(*(_QWORD *)(a1 + 48), 4, "Conflicts exist in System services. Randomly deciding: path1 = %s, path2 = %s", v24, v25, v26, v27, v28, (char)property);
          v4 = 130;
        }
      }
      else
      {
        v29 = xpc_dictionary_get_string(v16, "CFBundleVersion");
        if (v29)
          v30 = v29;
        else
          v30 = "0";
        v31 = (void *)xpc_bundle_get_info_dictionary(v21);
        v32 = xpc_dictionary_get_string(v31, "CFBundleVersion");
        if (v32)
          v33 = v32;
        else
          v33 = "0";
        v34 = sub_1000154F8(v30, v33);
        if ((v34 + 1) >= 2)
          v35 = 0;
        else
          v35 = 3;
        if (v34 == 1)
          v35 = 2;
        v4 = 129;
        if ((v35 | 2) == 2)
          goto LABEL_44;
      }
    }
  }
LABEL_47:
  v37 = *(unsigned __int8 *)(a2 + 100);
  if (v37 == 2)
  {
    if ((*(_BYTE *)(a1 + 89) & 0x20) != 0)
      goto LABEL_62;
    if (*(_BYTE *)(a1 + 96) == 1)
      v38 = "Bootstrap";
    else
      v38 = "Bootout";
    if ((_DWORD)v4)
    {
      xpc_strerror(v4);
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      sub_10003FBC0(a1 + 108, (char *)&v44);
      if ((_DWORD)v4 != 36)
      {
        sub_100028C34(*(_QWORD *)(a1 + 48), 5, "%s by %s[%d] for %s failed (%d: %s)", v39, v40, v41, v42, v43, (char)v38);
LABEL_57:
        LOBYTE(v37) = *(_BYTE *)(a2 + 100);
        goto LABEL_58;
      }
    }
    else
    {
      v46 = 0u;
      v47 = 0u;
      v44 = 0u;
      v45 = 0u;
      sub_10003FBC0(a1 + 108, (char *)&v44);
    }
    sub_100028C34(*(_QWORD *)(a1 + 48), 5, "%s by %s[%d] for %s succeeded (%d: %s)", v39, v40, v41, v42, v43, (char)v38);
    goto LABEL_57;
  }
LABEL_58:
  if ((v37 & 0xFE) != 4 || (v4 - 107) > 0x15 || ((1 << (v4 - 107)) & 0x200005) == 0)
  {
LABEL_62:
    if (!(_DWORD)v4)
      return;
    goto LABEL_63;
  }
  LODWORD(v4) = 121;
LABEL_63:
  sub_1000182B0(a1, *(const char **)(a2 + 16), v4);
}

void sub_100018238(uint64_t a1)
{
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 16));
  (*(void (**)(void))(*(_QWORD *)(a1 + 24) + 16))();
  if ((*(_BYTE *)(a1 + 140) & 1) == 0)
    sub_10004D738();
  *(_BYTE *)(a1 + 140) &= ~1u;
  sub_10001962C((void *)a1);
}

void sub_10001828C(uint64_t a1)
{
  uint64_t v1;

  v1 = sub_1000113D8(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40));
  sub_100016840(v1);
}

void sub_1000182A8(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  sub_100017DFC(*(_QWORD *)(a1 + 32), a2, a3, a4);
}

void sub_1000182B0(uint64_t a1, const char *a2, int a3)
{
  int v5;

  if (!a3)
    sub_10004D738();
  if (*(_BYTE *)(a1 + 104) != 2)
  {
    v5 = 5;
    goto LABEL_6;
  }
  xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 80), a2, a3);
  if (*(_DWORD *)(a1 + 100))
  {
    v5 = 133;
LABEL_6:
    *(_DWORD *)(a1 + 100) = v5;
    return;
  }
  *(_DWORD *)(a1 + 100) = a3;
}

void sub_100018310(uint64_t a1, int a2, id a3)
{
  Class Class;
  int v6;
  int v7;
  uint64_t v8;
  const char *v9;

  Class = j__object_getClass(a3);
  if (Class != (Class)sub_100019C90())
    sub_10004D738();
  v6 = sub_10002C734(*(_QWORD *)(a1 + 32), (uint64_t)a3);
  if (v6)
  {
    v7 = v6;
    v8 = *(_QWORD *)(a1 + 40);
    v9 = (const char *)sub_1000105F4((uint64_t)a3);
    sub_1000182B0(v8, v9, v7);
  }
}

void sub_100018390(uint64_t a1)
{
  int v2;

  v2 = xpc_pipe_routine_reply(*(_QWORD *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  if ((v2 | 0x20) != 0x20)
    _os_assumes_log_ctx(sub_100028C00, *(_QWORD *)(a1 + 40));
  sub_10001962C(*(void **)(a1 + 40));
}

uint64_t sub_1000183F4(uint64_t a1, char a2, xpc_object_t xint)
{
  uint64_t v4;
  int64_t value;
  BOOL v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 32);
  value = xpc_int64_get_value(xint);
  v6 = (value - 119) > 0x21 || ((1 << (value - 119)) & 0x220008025) == 0;
  if (v6 || byte_100072A78)
  {
    v7 = *(_QWORD *)(v4 + 48);
    xpc_strerror(value);
    sub_100028C34(v7, 3, "Failed to bootstrap path: path = %s, error = %d: %s", v8, v9, v10, v11, v12, a2);
  }
  return 1;
}

uint64_t sub_100018494(uint64_t a1, const char *a2, void *a3)
{
  xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), a2, a3);
  return 1;
}

void sub_1000184B0(const void *a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  dispatch_time_t v5;
  NSObject *v6;
  void *v7;

  if (dword_100071A9C)
  {
    v2 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
    v3 = dispatch_queue_create("com.apple.xpc.launchd.timeout", v2);
    v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v3);
    qword_100071CF8 = (uint64_t)v4;
    v5 = dispatch_time(0, 1000000000 * dword_100071A9C);
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0);
    v6 = qword_100071CF8;
    v7 = _Block_copy(a1);
    dispatch_set_context(v6, v7);
    dispatch_source_set_event_handler_f((dispatch_source_t)qword_100071CF8, (dispatch_function_t)sub_100018590);
    dispatch_activate((dispatch_object_t)qword_100071CF8);
  }
}

void sub_100018590(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  _QWORD v4[6];

  v2 = sub_10002E190();
  v3 = sub_1000146E4();
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_1000186C0;
  v4[3] = &unk_10006C310;
  v4[4] = a1;
  v4[5] = v2;
  dispatch_async_and_wait(v3, v4);
}

void sub_1000185F8()
{
  if (qword_100071CF8)
  {
    dispatch_source_cancel((dispatch_source_t)qword_100071CF8);
    dispatch_release((dispatch_object_t)qword_100071CF8);
    qword_100071CF8 = 0;
  }
}

void sub_10001862C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  NSObject *v6;
  dispatch_time_t v7;

  if (qword_100071CF8)
  {
    v2 = sub_10002E190();
    v3 = mach_absolute_time();
    v4 = sub_10000D768(v3 - *(_QWORD *)(v2 + 272));
    v5 = a1 + 1000000000 * dword_100071A9C;
    if (v5 > v4)
    {
      v6 = qword_100071CF8;
      v7 = dispatch_time(0, v5 - v4);
      dispatch_source_set_timer(v6, v7, 0xFFFFFFFFFFFFFFFFLL, 0);
    }
  }
}

uint64_t sub_1000186C0(uint64_t a1)
{
  nullsub_23(*(_QWORD *)(a1 + 40), "shutdowntimeout");
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

BOOL sub_1000186F4(_OWORD *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  __int128 v4;
  _OWORD v6[2];

  if (a3 == 2)
    v3 = SANDBOX_CHECK_NO_REPORT;
  else
    v3 = 0;
  v4 = a1[1];
  v6[0] = *a1;
  v6[1] = v4;
  return sandbox_check_by_audit_token(v6, a2, v3) == 0;
}

BOOL sub_100018738(_OWORD *a1, uint64_t a2, int a3)
{
  unsigned int v3;
  __int128 v4;
  uint64_t v5;
  _OWORD v7[2];

  if (a3 == 2)
    v3 = 3;
  else
    v3 = 2;
  v4 = a1[1];
  if (a3 == 3)
    v5 = 12;
  else
    v5 = v3;
  v7[0] = *a1;
  v7[1] = v4;
  return sandbox_check_by_audit_token(v7, a2, v5) == 0;
}

BOOL sub_100018784(_OWORD *a1, _OWORD *a2, uint64_t a3)
{
  __int128 v3;
  __int128 v4;
  _OWORD v6[2];
  _OWORD v7[2];

  v3 = a1[1];
  v7[0] = *a1;
  v7[1] = v3;
  v4 = a2[1];
  v6[0] = *a2;
  v6[1] = v4;
  return sandbox_check_process_signal_target(v7, a3, v6, 0) == 0;
}

_BYTE *sub_1000187CC(void *a1)
{
  int property;
  uint64_t v3;
  char v4;
  uint64_t v5;
  _BYTE *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;

  property = xpc_bundle_get_property(a1, 0);
  if (property == 1)
    v3 = 3;
  else
    v3 = 2;
  if (property == 1)
    v4 = 2;
  else
    v4 = 1;
  v5 = xpc_bundle_get_property(a1, v3);
  v6 = sub_100010434(v4, v5);
  *((_QWORD *)v6 + 10) = xpc_retain(a1);
  v7 = unk_100071480;
  *((_OWORD *)v6 + 8) = xmmword_100071470;
  *((_OWORD *)v6 + 9) = v7;
  v8 = unk_100071460;
  *((_OWORD *)v6 + 6) = xmmword_100071450;
  *((_OWORD *)v6 + 7) = v8;
  v9 = unk_1000714A0;
  *((_OWORD *)v6 + 10) = xmmword_100071490;
  *((_OWORD *)v6 + 11) = v9;
  v10 = unk_1000714C0;
  *((_OWORD *)v6 + 12) = xmmword_1000714B0;
  *((_OWORD *)v6 + 13) = v10;
  *((_OWORD *)v6 + 14) = xmmword_1000714D0;
  v6[264] |= 1u;
  return v6;
}

BOOL sub_10001886C(const char *a1)
{
  uint64_t v2;
  _BOOL8 result;

  v2 = 0;
  do
  {
    result = sub_1000156F0(a1, off_10006C330[v2]);
    if (result)
      break;
  }
  while (v2++ != 1);
  return result;
}

uint64_t sub_1000188BC(uint64_t a1)
{
  int v2;
  const char *v3;
  size_t v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  _QWORD *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  char *v14;
  char *v15;
  uint64_t v16;
  rb_tree_t **v17;
  uint64_t v18;
  char *v20;
  uint64_t v21;
  uint64_t *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  char __str[8];
  uint64_t v28;
  void (*v29)(uint64_t, const char *);
  void *v30;
  char *v31;
  _QWORD *v32;

  v2 = *(unsigned __int8 *)(a1 + 56);
  if (v2 == 1)
  {
    if (sub_100015730(*(const char **)(a1 + 64), ".appex"))
    {
      v14 = *(char **)(a1 + 64);
LABEL_16:
      v16 = (uint64_t)sub_10001911C(v14);
      goto LABEL_25;
    }
LABEL_17:
    v2 = *(unsigned __int8 *)(a1 + 56);
LABEL_18:
    if (v2 == 2)
    {
      v16 = sub_100019148(*(char **)(a1 + 64));
    }
    else
    {
      if (v2 == 1)
      {
        v20 = *(char **)(a1 + 64);
        v18 = (uint64_t)sub_10001911C(v20);
        if (!v18)
        {
          v21 = sub_100019148(v20);
          if (!v21)
            return 148;
          v18 = v21;
          sub_100040F68(5, "Found XPCService bundle by executable: %s", v20);
        }
LABEL_30:
        LODWORD(v7) = *(unsigned __int8 *)(a1 + 56);
        if ((v7 - 1) >= 2)
        {
          if (*(_BYTE *)(a1 + 56))
            goto LABEL_38;
          v22 = (uint64_t *)(a1 + 88);
        }
        else
        {
          v22 = (uint64_t *)(a1 + 80);
        }
        *v22 = v18;
        *(_BYTE *)(a1 + 264) |= 1u;
        *(_DWORD *)(a1 + 240) = 0;
        v23 = unk_100071480;
        *(_OWORD *)(a1 + 128) = xmmword_100071470;
        *(_OWORD *)(a1 + 144) = v23;
        v24 = unk_100071460;
        *(_OWORD *)(a1 + 96) = xmmword_100071450;
        *(_OWORD *)(a1 + 112) = v24;
        v25 = unk_1000714A0;
        *(_OWORD *)(a1 + 160) = xmmword_100071490;
        *(_OWORD *)(a1 + 176) = v25;
        v26 = unk_1000714C0;
        *(_OWORD *)(a1 + 192) = xmmword_1000714B0;
        *(_OWORD *)(a1 + 208) = v26;
        *(_OWORD *)(a1 + 224) = xmmword_1000714D0;
        dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 248));
        (*(void (**)(void))(*(_QWORD *)(a1 + 256) + 16))();
        return 0;
      }
      if (v2)
        return 148;
      if (!qword_1000729C0)
        return 148;
      v17 = sub_10004310C((rb_tree_t **)qword_1000729C0, *(const void **)(a1 + 64));
      if (!v17)
        return 148;
      v16 = sub_100043334((uint64_t)v17);
    }
LABEL_25:
    v18 = v16;
    if (!v16)
      return 148;
    goto LABEL_30;
  }
  if (v2 == 2)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s", *(const char **)(a1 + 64));
    v15 = strrchr(__str, 47);
    if (v15)
      *v15 = 0;
    if (sub_100015730(__str, ".appex"))
    {
      v14 = __str;
      goto LABEL_16;
    }
    goto LABEL_17;
  }
  if (v2 != 3)
    goto LABEL_18;
  v3 = *(const char **)(a1 + 64);
  if ((sub_100015818((xpc_object_t)qword_100072A30, v3) & 1) == 0
    && (!qword_100072A38 || !sub_100015818((xpc_object_t)qword_100072A38, v3)))
  {
    return 148;
  }
  v4 = strlen(*(const char **)(a1 + 64));
  v5 = v4 + 2;
  v6 = v4 >= 0xFFFFFFFFFFFFFFFELL;
  v7 = v6 << 63 >> 63;
  if (v7 != v6 || v7 < 0)
  {
    __break(1u);
LABEL_38:
    sub_10003E208("unsupported cached entry type %d", v7);
  }
  v8 = (char *)sub_10001389C(v4 + 2);
  strlcpy(v8, *(const char **)(a1 + 64), v5);
  *(_WORD *)&v8[v5 - 2] = 47;
  v9 = sub_10001123C();
  *(_QWORD *)__str = _NSConcreteStackBlock;
  v28 = 0x40000000;
  v29 = sub_1000190B0;
  v30 = &unk_10006C348;
  v31 = v8;
  v32 = v9;
  sub_100043140((rb_tree_t **)qword_1000729C0, (uint64_t)__str);
  v10 = unk_100071550;
  *(_OWORD *)(a1 + 192) = xmmword_100071540;
  *(_OWORD *)(a1 + 208) = v10;
  *(_OWORD *)(a1 + 224) = xmmword_100071560;
  v11 = unk_100071510;
  *(_OWORD *)(a1 + 128) = xmmword_100071500;
  *(_OWORD *)(a1 + 144) = v11;
  v12 = unk_100071530;
  *(_OWORD *)(a1 + 160) = xmmword_100071520;
  *(_OWORD *)(a1 + 176) = v12;
  v13 = *(_OWORD *)algn_1000714F0;
  *(_OWORD *)(a1 + 96) = xmmword_1000714E0;
  *(_OWORD *)(a1 + 112) = v13;
  dispatch_assert_queue_V2(*(dispatch_queue_t *)(a1 + 248));
  (*(void (**)(void))(*(_QWORD *)(a1 + 256) + 16))();
  sub_10001962C(v9);
  free(v8);
  return 0;
}

xpc_object_t sub_100018BF8()
{
  int *v0;
  int *v1;
  int v2;
  int *v3;
  char *v4;
  xpc_object_t v5;
  int v6;
  int *v7;
  char *v8;
  size_t st_size;
  const void *v10;
  NSObject *v11;
  stat v13;

  v0 = (int *)open("/System/Library/xpc/launchd.plist", 0);
  if ((v0 & 0x80000000) != 0)
  {
    v6 = *__error();
    v7 = __error();
    v8 = strerror(*v7);
    sub_100040F68(65539, "Unable to open %s [%d:%s]", "/System/Library/xpc/launchd.plist", v6, v8);
    return 0;
  }
  else
  {
    v1 = v0;
    memset(&v13, 0, sizeof(v13));
    if (fstat((int)v0, &v13))
    {
      v2 = *__error();
      v3 = __error();
      v4 = strerror(*v3);
      sub_100040F68(65539, "Unable to stat %s [%d:%s]", "/System/Library/xpc/launchd.plist", v2, v4);
      v5 = 0;
    }
    else
    {
      st_size = v13.st_size;
      v10 = (const void *)sub_100040420((v13.st_size + vm_page_size - 1) & -(uint64_t)vm_page_size);
      v11 = dispatch_data_create(v10, st_size, 0, _dispatch_data_destructor_vm_deallocate);
      v5 = xpc_data_create_with_dispatch_data(v11);
      dispatch_release(v11);
    }
    sub_10003BAF4(v1);
  }
  return v5;
}

void sub_100018D2C(xpc_object_t xdata)
{
  xpc_object_t v1;
  const void *bytes_ptr;
  size_t length;
  void *v4;
  xpc_object_t value;
  xpc_object_t v6;
  char v7;
  BOOL v8;
  xpc_object_t v9;
  xpc_object_t v10;
  xpc_object_t v11;
  xpc_object_t v12;
  xpc_object_t v13;
  xpc_object_t v14;
  void *v15;
  xpc_object_t v16;
  void *v17;
  xpc_object_t v18;
  void *v19;
  void **applier;
  uint64_t v21;
  uint64_t (*v22)(uint64_t, const char *, xpc_object_t);
  void *v23;
  xpc_object_t v24;

  v1 = xdata;
  if (!xdata)
  {
    sub_100040F68(65539, "No MRM cache found");
LABEL_7:
    v7 = 1;
    goto LABEL_8;
  }
  bytes_ptr = xpc_data_get_bytes_ptr(xdata);
  length = xpc_data_get_length(v1);
  v4 = (void *)xpc_create_from_plist(bytes_ptr, length);
  v1 = v4;
  if (!v4)
  {
    sub_100040F68(65541, "Unable to parse MRM cache");
    goto LABEL_7;
  }
  value = xpc_dictionary_get_value(v4, "SystemLibraryTreeState");
  v6 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_value(v6, "_imagePathToInfo", value);
  xpc_dictionary_set_value(v1, "SystemLibraryTreeState", v6);
  xpc_release(v6);
  if (xpc_get_type(v1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v9 = xpc_dictionary_get_value(v1, "LaunchDaemons");
    v10 = v9;
    if (v9)
    {
      if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_dictionary)
        v10 = xpc_retain(v10);
      else
        v10 = 0;
    }
    v11 = xpc_dictionary_get_value(v1, "SystemLibraryTreeState");
    v12 = v11;
    if (v11)
    {
      if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_dictionary
        && (v18 = xpc_dictionary_get_value(v12, "_imagePathToInfo")) != 0
        && (v19 = v18, xpc_get_type(v18) == (xpc_type_t)&_xpc_type_dictionary))
      {
        v12 = xpc_dictionary_create(0, 0, 0);
        applier = _NSConcreteStackBlock;
        v21 = 0x40000000;
        v22 = sub_1000192FC;
        v23 = &unk_10006C3A8;
        v24 = v12;
        xpc_dictionary_apply(v19, &applier);
      }
      else
      {
        v12 = 0;
      }
    }
    v13 = xpc_dictionary_create(0, 0, 0);
    applier = _NSConcreteStackBlock;
    v21 = 0x40000000;
    v22 = sub_1000194D8;
    v23 = &unk_10006C3C8;
    v24 = v13;
    v14 = xpc_dictionary_get_value(v1, "AppExtensions");
    if (v14)
    {
      v15 = v14;
      if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary)
        xpc_dictionary_apply(v15, &applier);
    }
    v16 = xpc_dictionary_get_value(v1, "AppRemovalServices");
    if (v16)
    {
      v17 = v16;
      if (xpc_get_type(v16) == (xpc_type_t)&_xpc_type_dictionary)
        xpc_dictionary_apply(v17, &applier);
    }
    sub_1000191A4(v10, v12, v13);
    if (v10)
      xpc_release(v10);
    if (v12)
      xpc_release(v12);
    if (v13)
      xpc_release(v13);
    goto LABEL_35;
  }
  v7 = 0;
LABEL_8:
  if (byte_100072A63)
    v8 = byte_100072A65 == 0;
  else
    v8 = 0;
  if (!v8)
    sub_10003E208("No service cache");
  sub_1000191A4(0, 0, 0);
  if ((v7 & 1) == 0)
  {
LABEL_35:
    xpc_release(v1);
    return;
  }
  if (!dword_100072A40)
    sub_100040F68(65540, "Unable to load cache");
}

BOOL sub_100019088()
{
  BOOL v0;

  if (byte_100072A63)
    v0 = byte_100072A65 == 0;
  else
    v0 = 0;
  return !v0;
}

void sub_1000190B0(uint64_t a1, const char *a2)
{
  _BYTE *v4;

  if (sub_1000156F0(a2, *(char **)(a1 + 32)))
  {
    v4 = sub_1000104A0(0, (uint64_t)a2, 0);
    sub_1000112C0(*(_QWORD **)(a1 + 40), v4);
    sub_10001962C(v4);
  }
}

xpc_object_t sub_10001911C(char *key)
{
  xpc_object_t result;

  result = xpc_dictionary_get_value((xpc_object_t)qword_1000729D0, key);
  if (result)
    return xpc_retain(result);
  return result;
}

uint64_t sub_100019148(char *key)
{
  xpc_object_t value;
  xpc_object_t v3;
  uint64_t v4;

  value = xpc_dictionary_get_value((xpc_object_t)qword_1000729C8, key);
  if (!value)
    return 0;
  v3 = value;
  v4 = xpc_bundle_create_from_origin(1, key);
  xpc_bundle_populate(v4, 0, v3);
  return v4;
}

xpc_object_t sub_1000191A4(void *a1, void *a2, void *a3)
{
  xpc_object_t v6;
  xpc_object_t result;

  if (qword_1000729C0)
    sub_10001962C((void *)qword_1000729C0);
  qword_1000729C0 = (uint64_t)sub_1000431D8();
  if (a1 && xpc_get_type(a1) == (xpc_type_t)&_xpc_type_dictionary)
    xpc_dictionary_apply(a1, &stru_10006C388);
  if (qword_1000729C8)
    xpc_release((xpc_object_t)qword_1000729C8);
  if (a2 && xpc_get_type(a2) == (xpc_type_t)&_xpc_type_dictionary)
    v6 = xpc_retain(a2);
  else
    v6 = xpc_dictionary_create(0, 0, 0);
  qword_1000729C8 = (uint64_t)v6;
  if (qword_1000729D0)
    xpc_release((xpc_object_t)qword_1000729D0);
  if (a3 && xpc_get_type(a3) == (xpc_type_t)&_xpc_type_dictionary)
    result = xpc_retain(a3);
  else
    result = xpc_dictionary_create(0, 0, 0);
  qword_1000729D0 = (uint64_t)result;
  return result;
}

BOOL sub_1000192A8(id a1, const char *a2, void *a3)
{
  _QWORD *v4;

  v4 = sub_1000432C8((uint64_t)a3);
  sub_100043048(qword_1000729C0, a2, v4);
  sub_10001962C(v4);
  return 1;
}

uint64_t sub_1000192FC(uint64_t a1, const char *a2, xpc_object_t object)
{
  xpc_object_t v6;
  size_t count;
  xpc_object_t v8;
  xpc_object_t v10;
  void *v11;
  size_t v12;
  xpc_object_t value;
  void *v14;
  void *v15;
  void *v16;

  if (object
    && xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary
    && (v10 = xpc_dictionary_get_value(object, "_serviceBundles")) != 0
    && (v11 = v10, xpc_get_type(v10) == (xpc_type_t)&_xpc_type_array)
    && xpc_array_get_count(v11))
  {
    v8 = xpc_array_create(0, 0);
    if (xpc_array_get_count(v11))
    {
      v12 = 0;
      do
      {
        value = xpc_array_get_value(v11, v12);
        if (value)
        {
          v14 = value;
          if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary)
          {
            v15 = (void *)sub_100019458(v14);
            if (v15)
            {
              v16 = v15;
              xpc_array_append_value(v8, v15);
              xpc_release(v16);
            }
          }
        }
        ++v12;
      }
      while (v12 < xpc_array_get_count(v11));
    }
  }
  else
  {
    v6 = (xpc_object_t)qword_100071D00;
    if (!qword_100071D00)
    {
      v6 = xpc_array_create(0, 0);
      qword_100071D00 = (uint64_t)v6;
    }
    count = xpc_array_get_count(v6);
    if (count)
      sub_10004D95C(count);
    v8 = xpc_retain((xpc_object_t)qword_100071D00);
  }
  if (v8)
  {
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), a2, v8);
    xpc_release(v8);
  }
  return 1;
}

uint64_t sub_100019458(void *a1)
{
  xpc_object_t value;
  xpc_object_t v3;
  uint64_t v4;
  const char *string;

  value = xpc_dictionary_get_value(a1, "_infoPlist");
  if (!value)
    return 0;
  v3 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    return 0;
  string = xpc_dictionary_get_string(a1, "_executablePath");
  if (!string)
    return 0;
  v4 = xpc_bundle_create_from_origin(1, string);
  xpc_bundle_populate(v4, v3, 0);
  return v4;
}

uint64_t sub_1000194D8(uint64_t a1, const char *a2, void *a3)
{
  void *v5;
  void *v6;

  v5 = (void *)sub_100019458(a3);
  if (v5)
  {
    v6 = v5;
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 32), a2, v5);
    xpc_release(v6);
  }
  return 1;
}

_QWORD *sub_10001952C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  id v8;

  v7 = sub_10001389C(0x18uLL);
  *v7 = a1;
  v7[1] = a3;
  v7[2] = a4;
  if (a1)
  {
    sub_100019A04((uint64_t)a1);
    v8 = a1;
  }
  return v7;
}

void *sub_100019580(void *a1)
{
  id v2;

  sub_100019A04((uint64_t)a1);
  v2 = a1;
  return a1;
}

_QWORD *sub_1000195A8(void *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;

  v6 = sub_10001389C(0x18uLL);
  *v6 = a1;
  v6[1] = a2;
  v6[2] = a3;
  if (a1)
    xpc_retain(a1);
  return v6;
}

void sub_1000195F8(uint64_t *a1)
{
  void *v2;

  v2 = (void *)*a1;
  if (*a1)
  {
    sub_100019A04(*a1);

  }
  free(a1);
}

void sub_10001962C(void *a1)
{
  sub_100019A04((uint64_t)a1);

}

void sub_100019650(void **a1)
{
  void *v2;

  v2 = *a1;
  if (v2)
    xpc_release(v2);
  free(a1);
}

char *sub_10001967C(char *__s, const char *a2, uint64_t a3, size_t *a4, char a5)
{
  uint64_t v9;
  size_t v10;
  size_t v11;
  BOOL v12;
  char *result;
  char *v14;
  BOOL v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  void *v20;

  if ((a5 & 1) == 0)
  {
    v9 = 0;
    while (strcmp(__s, off_10006C3E8[v9]))
    {
      if (++v9 == 2)
        goto LABEL_5;
    }
    return 0;
  }
LABEL_5:
  v10 = strlen(__s);
  v11 = v10 + 1;
  v12 = v10 == -1;
  result = (char *)strlen(a2);
  v14 = &result[v11];
  v15 = __CFADD__(result, v11);
  v16 = (size_t)(v14 + 1);
  v17 = v14 == (char *)-1;
  v18 = v17 << 63 >> 63;
  v19 = v18 != v17;
  if (!v12 && !v15 && !v19 && (v18 & 0x8000000000000000) == 0)
  {
    result = (char *)(v16 + 32);
    if (v16 < 0xFFFFFFFFFFFFFFE0)
    {
      v20 = sub_10001389C((size_t)result);
      *((_QWORD *)v20 + 3) = a3;
      snprintf((char *)v20 + 32, v16, "%s=%s", __s, a2);
      *a4 = v16;
      return (char *)v20;
    }
  }
  __break(1u);
  return result;
}

size_t sub_100019770(uint64_t a1, size_t *a2)
{
  const char *v3;
  size_t v4;
  size_t v5;
  BOOL v6;
  size_t result;
  char *v8;

  v3 = (const char *)(a1 + 32);
  v4 = strlen((const char *)(a1 + 32));
  v5 = v4 + 1;
  v6 = __CFADD__(v4 + 1, 32);
  result = v4 + 33;
  if (v6)
  {
    __break(1u);
  }
  else
  {
    v8 = (char *)sub_10001389C(result);
    snprintf(v8 + 32, v5, "%s", v3);
    *a2 = v5;
    return (size_t)v8;
  }
  return result;
}

uint64_t sub_1000197E0(uint64_t a1, uint64_t a2, FILE *a3)
{
  uint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;

  v5 = a1 + 32;
  v6 = strrchr((char *)(a1 + 32), 61);
  *v6 = 0;
  result = sub_10004391C(a3, a2, "%s => %s", v7, v8, v9, v10, v11, v5, v6 + 1);
  *v6 = 61;
  return result;
}

char *sub_100019854(uint64_t a1, const char *a2)
{
  const char *v3;
  char *result;
  _BYTE *v5;

  v3 = (const char *)(a1 + 32);
  result = strchr((char *)(a1 + 32), 61);
  if (result)
  {
    v5 = result;
    *result = 0;
    result = (char *)(strcmp(v3, a2) == 0);
    *v5 = 61;
  }
  return result;
}

char *sub_1000198B0(uint64_t a1)
{
  char *v1;

  v1 = strchr((char *)(a1 + 32), 61);
  if (v1)
    return v1 + 1;
  else
    return 0;
}

BOOL sub_1000198D8(const char *a1)
{
  _BOOL8 result;
  uint64_t v3;
  int v4;

  if (!strcmp(a1, "LD_LIBRARY_PATH"))
    return 1;
  result = sub_1000156F0(a1, "DYLD_");
  if (!result)
    return result;
  if (!sub_1000156F0(a1, "DYLD_PRINT_"))
    return 1;
  v3 = 0;
  do
  {
    v4 = strcmp(a1, (&off_10006C400)[v3]);
    result = v4 != 0;
    if (!v4)
      break;
  }
  while (v3++ != 10);
  return result;
}

_DWORD *sub_100019974(mach_port_name_t a1, int a2)
{
  _DWORD *v4;
  int v5;

  v4 = sub_10001389C(0x18uLL);
  v5 = sub_10000D964(a1);
  if (v5)
    _os_assumes_log(v5);
  v4[4] = a1;
  v4[5] = a2;
  return v4;
}

void sub_1000199C8(mach_port_name_t *a1)
{
  int v2;

  v2 = sub_10000D980(a1[4]);
  if (v2)
    _os_assumes_log(v2);
  free(a1);
}

uint64_t sub_100019A04(uint64_t result)
{
  if (*(_BYTE *)(result + 8))
    sub_10004D74C();
  return result;
}

uint64_t sub_100019A20(uint64_t a1)
{
  sub_100019A04(a1);
  return a1;
}

uint64_t sub_100019A48(uint64_t result)
{
  if (*(_BYTE *)(result + 8))
    sub_10004D74C();
  *(_BYTE *)(result + 8) = 1;
  return result;
}

id sub_100019A6C(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 32;
  v2 = (objc_class *)objc_opt_class(OS_launch_array);
  return class_createInstance(v2, v1);
}

id sub_100019A98(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 24;
  v2 = (objc_class *)objc_opt_class(OS_launch_dictionary);
  return class_createInstance(v2, v1);
}

id sub_100019AC4(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 1016;
  v2 = (objc_class *)objc_opt_class(OS_launch_domain);
  return class_createInstance(v2, v1);
}

id sub_100019AF0(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 136;
  v2 = (objc_class *)objc_opt_class(OS_launch_domain_aggregate_io);
  return class_createInstance(v2, v1);
}

id sub_100019B1C(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 96;
  v2 = (objc_class *)objc_opt_class(OS_launch_domain_io);
  return class_createInstance(v2, v1);
}

char *sub_100019B48(const char *a1)
{
  size_t v2;
  objc_class *v3;
  char *Instance;

  v2 = strlen(a1) + 161;
  v3 = (objc_class *)objc_opt_class(OS_launch_endpoint);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 168, a1);
  return Instance;
}

id sub_100019B94(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 56;
  v2 = (objc_class *)objc_opt_class(OS_launch_event_provider);
  return class_createInstance(v2, v1);
}

id sub_100019BC0(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 80;
  v2 = (objc_class *)objc_opt_class(OS_launch_event_realm);
  return class_createInstance(v2, v1);
}

char *sub_100019BEC(const char *a1)
{
  size_t v2;
  objc_class *v3;
  char *Instance;

  v2 = strlen(a1) + 25;
  v3 = (objc_class *)objc_opt_class(OS_launch_event_stream);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 32, a1);
  return Instance;
}

id sub_100019C38(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 80;
  v2 = (objc_class *)objc_opt_class(OS_launch_event_subscription);
  return class_createInstance(v2, v1);
}

id sub_100019C64(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 264;
  v2 = (objc_class *)objc_opt_class(OS_launch_io);
  return class_createInstance(v2, v1);
}

uint64_t sub_100019C90()
{
  return objc_opt_class(OS_launch_io);
}

id sub_100019C9C(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 80;
  v2 = (objc_class *)objc_opt_class(OS_launch_log);
  return class_createInstance(v2, v1);
}

char *sub_100019CC8(const char *a1)
{
  size_t v2;
  objc_class *v3;
  char *Instance;

  v2 = strlen(a1) + 1385;
  v3 = (objc_class *)objc_opt_class(OS_launch_service);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 1392, a1);
  return Instance;
}

id sub_100019D14(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 56;
  v2 = (objc_class *)objc_opt_class(OS_launch_service_stub);
  return class_createInstance(v2, v1);
}

char *sub_100019D40(const char *a1)
{
  size_t v2;
  objc_class *v3;
  char *Instance;

  v2 = strlen(a1) + 201;
  v3 = (objc_class *)objc_opt_class(OS_launch_socket);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 208, a1);
  return Instance;
}

id sub_100019D8C(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 40;
  v2 = (objc_class *)objc_opt_class(OS_launch_cache);
  return class_createInstance(v2, v1);
}

id sub_100019DB8(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 24;
  v2 = (objc_class *)objc_opt_class(OS_launch_uint64_dictionary);
  return class_createInstance(v2, v1);
}

id sub_100019DE4(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 64;
  v2 = (objc_class *)objc_opt_class(OS_launch_coalition);
  return class_createInstance(v2, v1);
}

id sub_100019E10(uint64_t a1)
{
  size_t v1;
  objc_class *v2;

  v1 = a1 + 16;
  v2 = (objc_class *)objc_opt_class(OS_launch_plist);
  return class_createInstance(v2, v1);
}

char *sub_100019E3C(const char *a1)
{
  size_t v2;
  objc_class *v3;
  char *Instance;

  v2 = strlen(a1) + 33;
  v3 = (objc_class *)objc_opt_class(OS_launch_service_stub_static);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 40, a1);
  return Instance;
}

char *sub_100019E88(const char *a1)
{
  size_t v2;
  objc_class *v3;
  char *Instance;

  v2 = strlen(a1) + 25;
  v3 = (objc_class *)objc_opt_class(OS_launch_service_static);
  Instance = (char *)class_createInstance(v3, v2);
  strcpy(Instance + 32, a1);
  return Instance;
}

uint64_t sub_100019EE0()
{
  uint64_t v0;

  return sub_100019A48(v0);
}

id sub_100019EE8(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  return objc_msgSendSuper2(&a9, a2);
}

uint64_t sub_100019EF0(uid_t a1, _DWORD *a2)
{
  int v4;
  uint64_t v5;

  v4 = sub_100038FB8();
  if (!v4 || v4 != a1)
    return sub_100019F50(a1, (uint64_t)a2);
  v5 = sub_100019F50(0x1F5u, (uint64_t)a2);
  sub_100019FB0(a2);
  return v5;
}

uint64_t sub_100019F50(uid_t a1, uint64_t a2)
{
  uint64_t result;
  passwd *v4;

  v4 = 0;
  result = getpwuid_r(a1, (passwd *)a2, (char *)(a2 + 72), 0x1000uLL, &v4);
  if (!(_DWORD)result)
  {
    if (v4)
    {
      sub_10001A160(*(const char **)a2, *(_DWORD *)(a2 + 20), a2);
      return 0;
    }
    else
    {
      return 114;
    }
  }
  return result;
}

uint64_t sub_100019FB0(_DWORD *a1)
{
  uint64_t result;
  int v3;
  uint64_t v4;
  _DWORD *v5;

  result = sub_100038FB8();
  if ((_DWORD)result)
  {
    if (a1[4] == 501)
      a1[4] = result;
    if (a1[5] == 501)
      a1[5] = result;
    v3 = a1[1058];
    if (v3 >= 1)
    {
      v4 = 0;
      v5 = a1 + 1042;
      do
      {
        if (v5[v4] == 501)
        {
          v5[v4] = result;
          v3 = a1[1058];
        }
        ++v4;
      }
      while (v4 < v3);
    }
  }
  return result;
}

uint64_t sub_10001A02C(const char *a1, const char *a2, uint64_t a3)
{
  uint64_t result;
  gid_t gr_gid;
  const char *v8;
  group *v9;
  group v10;
  passwd *v11[512];

  if (a1)
  {
    v11[0] = 0;
    result = getpwnam_r(a1, (passwd *)a3, (char *)(a3 + 72), 0x1000uLL, v11);
    if ((_DWORD)result)
      return result;
    if (!v11[0])
      return 114;
    gr_gid = *(_DWORD *)(a3 + 20);
    if (!a2)
      goto LABEL_10;
  }
  else
  {
    gr_gid = -101;
    if (!a2)
      goto LABEL_10;
  }
  bzero(v11, 0x1000uLL);
  memset(&v10, 0, sizeof(v10));
  v9 = 0;
  result = getgrnam_r(a2, &v10, (char *)v11, 0x1000uLL, &v9);
  if ((_DWORD)result)
    return result;
  if (!v9)
    return 115;
  gr_gid = v10.gr_gid;
LABEL_10:
  if (gr_gid != -101)
  {
    if (a1)
      v8 = a1;
    else
      v8 = "root";
    sub_10001A160(v8, gr_gid, a3);
  }
  sub_100019FB0((_DWORD *)a3);
  return 0;
}

uint64_t sub_10001A160(const char *a1, int a2, uint64_t a3)
{
  uint64_t result;

  *(_DWORD *)(a3 + 4232) = 16;
  result = getgrouplist(a1, a2, (int *)(a3 + 4168), (int *)(a3 + 4232));
  if ((_DWORD)result == -1)
    return sub_10004D870();
  return result;
}

uint64_t sub_10001A19C(uint64_t a1, const char *a2, int a3, uint64_t a4)
{
  _DWORD *v9;
  char *v10;

  if (os_map_str_find(a1, a2))
    return 17;
  v9 = sub_10001389C(0x18uLL);
  v10 = sub_10001544C(a2);
  *(_QWORD *)v9 = v10;
  v9[2] = a3;
  *((_QWORD *)v9 + 2) = a4;
  os_map_str_insert(a1, v10, v9);
  return 0;
}

uint64_t sub_10001A218(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v4;
  void *v5;
  uint64_t v6;

  v4 = os_map_str_delete();
  if (!v4)
    return 0;
  v5 = (void *)v4;
  v6 = *(unsigned int *)(v4 + 8);
  *a3 = *(_QWORD *)(v4 + 16);
  free(*(void **)v4);
  free(v5);
  return v6;
}

void sub_10001A270(void *a1)
{
  os_map_str_clear(a1, &stru_10006C478);
  os_map_str_destroy(a1);
  free(a1);
}

BOOL sub_10001A2A4(id a1, const char *a2, void *a3)
{
  int v4;

  v4 = sub_10000D994(*((_DWORD *)a3 + 2), 0, *((_QWORD *)a3 + 2));
  if (v4)
    sub_10004D778(v4);
  free(*(void **)a3);
  free(a3);
  return 1;
}

uint64_t sub_10001A2EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  _BOOL4 v6;

  v3 = *(_QWORD *)(a2 + 24);
  v4 = *(_QWORD *)(a3 + 24);
  v5 = v3 >= v4;
  v6 = v3 > v4;
  if (v5)
    return v6;
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_10001A304(uint64_t a1, uint64_t a2, unint64_t *a3)
{
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;

  v3 = *(_QWORD *)(a2 + 24);
  v4 = v3 >= *a3;
  v5 = v3 > *a3;
  if (v4)
    return v5;
  else
    return 0xFFFFFFFFLL;
}

void sub_10001A31C(uint64_t a1, uint64_t a2, void *a3)
{
  void **node;
  void **v6;
  _QWORD *v7;
  uint64_t v8;

  v8 = a2;
  if (*(_DWORD *)(a1 + 24) == 4982)
  {
    node = (void **)rb_tree_find_node(*(rb_tree_t **)(a1 + 16), &v8);
    if (node)
    {
      v6 = node;
      rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), node);
      os_release(v6[4]);
      free(v6);
    }
    if (a3)
    {
      v7 = malloc_type_malloc(0x28uLL, 0x108004034BCA2CCuLL);
      v7[3] = v8;
      v7[4] = os_retain(a3);
      if (rb_tree_insert_node(*(rb_tree_t **)(a1 + 16), v7) != v7)
        sub_10004D74C();
    }
  }
  else
  {
    __break(1u);
  }
}

rb_tree_t **sub_10001A3E0(rb_tree_t **result, uint64_t a2)
{
  uint64_t v2;

  v2 = a2;
  if (*((_DWORD *)result + 6) == 4982)
  {
    result = (rb_tree_t **)rb_tree_find_node(result[2], &v2);
    if (result)
      return (rb_tree_t **)result[4];
  }
  else
  {
    __break(1u);
  }
  return result;
}

rb_tree_t **sub_10001A424(rb_tree_t **result, uint64_t a2)
{
  rb_tree_t **v3;
  rb_tree_t **v4;

  if (*((_DWORD *)result + 6) == 4982)
  {
    v3 = result;
    result = (rb_tree_t **)rb_tree_iterate(result[2], 0, 1u);
    if (result)
    {
      v4 = result;
      do
      {
        (*(void (**)(uint64_t, rb_tree_t *, rb_tree_t *))(a2 + 16))(a2, v4[3], v4[4]);
        result = (rb_tree_t **)rb_tree_iterate(v3[2], v4, 1u);
        v4 = result;
      }
      while (result);
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

size_t sub_10001A4A0(size_t result)
{
  if (*(_DWORD *)(result + 24) == 4982)
    return rb_tree_count(*(rb_tree_t **)(result + 16));
  __break(1u);
  return result;
}

_QWORD *sub_10001A4BC()
{
  _QWORD *v0;
  rb_tree_t *v1;

  v0 = sub_100019DB8(0);
  v1 = (rb_tree_t *)malloc_type_malloc(0x40uLL, 0x80040A284212CuLL);
  v0[2] = v1;
  rb_tree_init(v1, (const rb_tree_ops_t *)off_100071570);
  *((_DWORD *)v0 + 6) = 4982;
  return v0;
}

void sub_10001A514(uint64_t a1)
{
  void **v2;
  void **v3;
  void **v4;

  if (*(_DWORD *)(a1 + 24) == 4982)
  {
    *(_DWORD *)(a1 + 24) = 0;
    v2 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), 0, 1u);
    if (v2)
    {
      v3 = v2;
      do
      {
        v4 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), v3, 1u);
        rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), v3);
        os_release(v3[4]);
        free(v3);
        v3 = v4;
      }
      while (v4);
    }
    free(*(void **)(a1 + 16));
  }
  else
  {
    __break(1u);
  }
}

void sub_10001A5A4(uint64_t a1)
{
  unint64_t v2;
  unint64_t v3;
  int v4;
  int *v5;

  if (qword_100071D08 == a1)
    qword_100071D08 = 0;
  v2 = *(_QWORD *)(a1 + 88);
  if (v2)
  {
    v3 = 0;
    v4 = dword_100071A30;
    do
    {
      v5 = (int *)*(unsigned int *)(*(_QWORD *)(a1 + 64) + 4 * v3);
      if ((v5 & 0x80000000) == 0 && (_DWORD)v5 != v4)
      {
        sub_10003BAF4(v5);
        v4 = dword_100071A30;
        v2 = *(_QWORD *)(a1 + 88);
      }
      ++v3;
    }
    while (v3 < v2);
  }
  if (*(_QWORD *)(a1 + 32) != -1 || *(_QWORD *)(a1 + 40) != -1)
    sub_10003E208("socket deallocated while still in domain list");
  if (*(_QWORD *)(a1 + 16) != -1 || *(_QWORD *)(a1 + 24) != -1)
    sub_10003E208("socket deallocated while still in service list");
  if ((*(_WORD *)(a1 + 204) & 0x84) == 4)
    sub_10003E208("socket deallocated while still active");
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 72));
  free(*(void **)(a1 + 136));
  free(*(void **)(a1 + 144));
  free(*(void **)(a1 + 160));
  free(*(void **)(a1 + 168));
  free(*(void **)(a1 + 176));
  xpc_release(*(xpc_object_t *)(a1 + 192));
}

uint64_t sub_10001A6C4(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10001A6F8(a2, 3, "%s", a4, a5, a6, a7, a8, a3);
  return 1;
}

void sub_10001A6F8(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  char *v12;

  v12 = sub_10001A758(a1);
  sub_1000412EC(v12, a2, a3, &a9, v9);
  free(v12);
}

char *sub_10001A758(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char **v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;

  v8 = (const char **)sub_1000106C8(0x40uLL);
  v9 = *(_QWORD *)(a1 + 56);
  if (v9)
  {
    v10 = sub_10001F264(v9, 1);
    sub_100010740((uint64_t)v8, "%s - ", v11, v12, v13, v14, v15, v16, (char)v10);
    free(v10);
  }
  sub_100010740((uint64_t)v8, "%s", v2, v3, v4, v5, v6, v7, a1 - 48);
  v17 = sub_100010710(v8);
  sub_100010718((void **)v8);
  return v17;
}

char *sub_10001A7F0(uint64_t a1, const char *a2, int a3, void *a4, NSObject *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v15;
  __int128 v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  const char *string;
  uint64_t *v22;

  v15 = sub_100019D40(a2);
  *((_QWORD *)v15 + 7) = a1;
  *((_DWORD *)v15 + 24) = -1;
  *((_DWORD *)v15 + 26) = a3;
  dispatch_retain(a5);
  *((_QWORD *)v15 + 14) = a5;
  *((_QWORD *)v15 + 15) = a6;
  *((_QWORD *)v15 + 16) = a7;
  *((_QWORD *)v15 + 24) = xpc_retain(a4);
  *((_WORD *)v15 + 102) |= 2u;
  *(_QWORD *)&v16 = -1;
  *((_QWORD *)&v16 + 1) = -1;
  *((_OWORD *)v15 + 1) = v16;
  *((_OWORD *)v15 + 2) = v16;
  v17 = sub_100020D40(a1);
  v18 = *(_DWORD *)(v17 + 20);
  if (v18)
  {
    v19 = v17;
    if (v18 != getpid())
    {
      v20 = *(_DWORD *)(v19 + 8);
      if (v20)
        *((_DWORD *)v15 + 27) = v20;
    }
  }
  string = xpc_dictionary_get_string(a4, "SockPathName");
  if (string && !strcmp(string, "/var/run/syslog"))
    xpc_dictionary_set_BOOL(a4, "SystemLoggingSocket", 1);
  *((_DWORD *)v15 + 25) = 1;
  v22 = sub_10001952C(v15, 1, a8, 0);
  xpc_dictionary_apply_f(a4);
  sub_1000195F8(v22);
  return v15;
}

void sub_10001A92C(const char *a1, xpc_object_t object, uint64_t *a3)
{
  _BYTE *v5;
  uint64_t v6;
  xpc_type_t type;
  const char *string_ptr;
  __int16 v9;
  __int16 v10;
  __int16 v11;
  int v12;
  const char *v13;
  const char *v14;
  int v15;
  const char *v16;
  const char *v17;
  int64_t value;
  char *v19;
  const char *v20;
  int v21;
  const char *v22;
  const char *v23;
  int v24;

  v6 = *a3;
  v5 = (_BYTE *)a3[1];
  type = xpc_get_type(object);
  if (!strcasecmp(a1, "SockType"))
  {
    if (type != (xpc_type_t)&_xpc_type_string)
      goto LABEL_64;
    string_ptr = xpc_string_get_string_ptr(object);
    if (!strcasecmp(string_ptr, "stream"))
    {
      v12 = 1;
    }
    else if (!strcasecmp(string_ptr, "dgram"))
    {
      v12 = 2;
    }
    else
    {
      if (strcasecmp(string_ptr, "seqpacket"))
      {
        sub_100014830(v5, 3, "Unrecognized %s");
        goto LABEL_65;
      }
      v12 = 5;
    }
    *(_DWORD *)(v6 + 100) = v12;
    return;
  }
  if (!strcasecmp(a1, "SockPassive"))
  {
    if (type == (xpc_type_t)&_xpc_type_BOOL)
    {
      if (xpc_BOOL_get_value(object))
        v9 = 2;
      else
        v9 = 0;
      v10 = *(_WORD *)(v6 + 204) & 0xFFFD;
LABEL_27:
      v11 = v10 | v9;
LABEL_28:
      *(_WORD *)(v6 + 204) = v11;
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SecureSocketWithKey"))
  {
    if (type != (xpc_type_t)&_xpc_type_string)
      goto LABEL_64;
    if (!*(_QWORD *)(v6 + 144))
    {
      v13 = xpc_string_get_string_ptr(object);
      *(_QWORD *)(v6 + 136) = sub_10001544C(v13);
      return;
    }
    goto LABEL_34;
  }
  if (!strcasecmp(a1, "SockPathName"))
  {
    if (type != (xpc_type_t)&_xpc_type_string)
      goto LABEL_64;
    if (*(_QWORD *)(v6 + 136))
    {
LABEL_34:
      sub_100014830(v5, 3, "Can't have both %s and %s");
      goto LABEL_65;
    }
    if (xpc_string_get_length(object) >= 0x68)
    {
      sub_100014830(v5, 3, "%s value is too long.", a1);
      v15 = 34;
LABEL_66:
      *(_DWORD *)(v6 + 200) = v15;
      return;
    }
    v17 = xpc_string_get_string_ptr(object);
    if (v17)
    {
      *(_QWORD *)(v6 + 144) = sub_10001544C(v17);
      return;
    }
LABEL_65:
    v15 = 22;
    goto LABEL_66;
  }
  if (!strcasecmp(a1, "SockPathOwner"))
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      *(_DWORD *)(v6 + 104) = xpc_int64_get_value(object);
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SockPathGroup"))
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      *(_DWORD *)(v6 + 108) = xpc_int64_get_value(object);
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SockPathMode"))
  {
    if (type == (xpc_type_t)&_xpc_type_int64)
    {
      *(_WORD *)(v6 + 152) = xpc_int64_get_value(object);
      v11 = *(_WORD *)(v6 + 204) | 8;
      goto LABEL_28;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SockNodeName"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      v14 = xpc_string_get_string_ptr(object);
      *(_QWORD *)(v6 + 160) = sub_10001544C(v14);
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "MulticastGroup"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      v16 = xpc_string_get_string_ptr(object);
      *(_QWORD *)(v6 + 168) = sub_10001544C(v16);
      return;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(a1, "SockServiceName"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      v22 = xpc_string_get_string_ptr(object);
      v19 = sub_10001544C(v22);
    }
    else
    {
      if (type != (xpc_type_t)&_xpc_type_int64)
        goto LABEL_64;
      value = xpc_int64_get_value(object);
      v19 = sub_100015630("%lld", value);
    }
    *(_QWORD *)(v6 + 176) = v19;
    return;
  }
  if (!strcasecmp(a1, "SockFamily"))
  {
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      v20 = xpc_string_get_string_ptr(object);
      if (!strcasecmp(v20, "IPv4"))
      {
        v21 = 2;
      }
      else if (!strcasecmp(v20, "IPv6"))
      {
        v21 = 30;
      }
      else
      {
        if (!strcasecmp(v20, "IPv4v6"))
        {
          *(_DWORD *)(v6 + 184) = 30;
          v11 = *(_WORD *)(v6 + 204) | 0x20;
          goto LABEL_28;
        }
        if (strcasecmp(v20, "Unix"))
          goto LABEL_79;
        v21 = 1;
      }
      *(_DWORD *)(v6 + 184) = v21;
      return;
    }
LABEL_64:
    xpc_type_get_name(type);
    sub_100014830(v5, 3, "Invalid type for socket dictionary (key/type): %s/%s");
    goto LABEL_65;
  }
  if (!strcasecmp(a1, "SockProtocol"))
  {
    if (type != (xpc_type_t)&_xpc_type_string)
      goto LABEL_64;
    v23 = xpc_string_get_string_ptr(object);
    if (!strcasecmp(v23, "TCP"))
    {
      v24 = 6;
    }
    else
    {
      if (strcasecmp(v23, "UDP"))
      {
LABEL_79:
        sub_100014830(v5, 4, "Unrecognized %s");
        return;
      }
      v24 = 17;
    }
    *(_DWORD *)(v6 + 188) = v24;
    return;
  }
  if (strcasecmp(a1, "Bonjour"))
  {
    if (!strcasecmp(a1, "SystemLoggingSocket"))
    {
      if (xpc_BOOL_get_value(object))
        v9 = 64;
      else
        v9 = 0;
      v10 = *(_WORD *)(v6 + 204) & 0xFFBF;
    }
    else
    {
      if (strcasecmp(a1, "ReceivePacketInfo"))
      {
        sub_100014830(v5, 4, "Unknown socket key %s");
        return;
      }
      if (xpc_BOOL_get_value(object))
        v9 = 512;
      else
        v9 = 0;
      v10 = *(_WORD *)(v6 + 204) & 0xFDFF;
    }
    goto LABEL_27;
  }
  if (type != (xpc_type_t)&_xpc_type_BOOL || xpc_BOOL_get_value(object))
  {
    v11 = *(_WORD *)(v6 + 204) | 0x10;
    goto LABEL_28;
  }
}

void sub_10001AEBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v9;
  dispatch_queue_t *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  char v18;

  if ((*(_WORD *)(a1 + 204) & 0x40) != 0)
  {
    if (qword_100071D08)
    {
      sub_10001A6F8(a1, 3, "System logger socket is already claimed by: %s", a4, a5, a6, a7, a8, qword_100071D08 - 48);
      *(_DWORD *)(a1 + 200) = 37;
      v10 = (dispatch_queue_t *)a1;
      v11 = 1;
    }
    else
    {
      qword_100071D08 = a1;
      *(_QWORD *)(a1 + 64) = sub_10001389C(4uLL);
      *(_QWORD *)(a1 + 72) = sub_10001389C(1uLL);
      *(_QWORD *)(a1 + 88) = 1;
      v17 = *(_DWORD **)(a1 + 64);
      *v17 = dword_100071A30;
      *(_DWORD *)(a1 + 100) = 2;
      *(_WORD *)(a1 + 204) |= 4u;
      if (*v17 == -1)
        sub_10001A6F8(a1, 4, "System logger socket was not opened during early boot. (Proceeding anyway)", v12, v13, v14, v15, v16, v18);
      v10 = (dispatch_queue_t *)a1;
      v11 = 0;
    }
    sub_10001AFCC(v10, v11);
  }
  else
  {
    sub_100019580((void *)a1);
    v9 = sub_1000146F0();
    dispatch_async_f(v9, (void *)a1, (dispatch_function_t)sub_10001B02C);
  }
}

void sub_10001AFCC(dispatch_queue_t *a1, int a2)
{
  _DWORD *v4;

  v4 = sub_10001389C(0x10uLL);
  *(_QWORD *)v4 = sub_100019580(a1);
  v4[2] = a2;
  dispatch_async_f(a1[14], v4, (dispatch_function_t)sub_10001C604);
}

void sub_10001B02C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  char *v10;
  int v11;
  int v12;
  int v13;
  const char *v14;
  int *v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int *v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int *v29;
  int *v30;
  uid_t v31;
  gid_t v32;
  char *v33;
  int *v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  addrinfo *v44;
  unint64_t v45;
  addrinfo *v46;
  uint64_t v47;
  int v48;
  uint64_t v49;
  __int16 v50;
  int v51;
  int ai_family;
  int v53;
  int v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  int v65;
  int v66;
  const char *v67;
  int v68;
  int v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  socklen_t v86;
  int v87;
  int v88;
  const char *v89;
  char *v90;
  int v91;
  char *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  addrinfo *v113;
  char *v114;
  NSObject *v115;
  int *v116;
  char v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  int *v123;
  char v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uid_t v130;
  mode_t v131;
  int *v132;
  char v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  char v145;
  char v146;
  const char *ai_socktype;
  uint64_t ai_protocol;
  uint64_t v149;
  int v150;
  int v151;
  addrinfo *v152;
  addrinfo v153;
  char *__stringp;
  char v155[16];
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  stat v167;
  addrinfo v168;

  v9 = *(_QWORD *)(a1 + 136);
  if (v9 || *(_QWORD *)(a1 + 144))
  {
    if (!byte_1000729D8)
    {
      sub_100041468("fixup-mobile-tmp", 196611, "launchd has not fixed mobile/tmp (socket)", a4, a5, a6, a7, a8, v145);
      v9 = *(_QWORD *)(a1 + 136);
    }
    bzero(v155, 0x400uLL);
    if (v9)
    {
      __strlcpy_chk(v155, "/private/var/tmp/com.apple.launchd.XXXXXXXXXX", 1024, 1024);
      if (!mkdtemp(v155) && *__error())
        _os_assumes_log_ctx(sub_10001A6C4, a1);
      v10 = sub_100015630("%s/%s", v155, (const char *)(a1 + 208));
      *(_QWORD *)(a1 + 144) = v10;
    }
    else
    {
      v10 = *(char **)(a1 + 144);
    }
    memset(&v167, 0, 106);
    BYTE1(v167.st_dev) = 1;
    strncpy((char *)&v167.st_dev + 2, v10, 0x67uLL);
    *(_QWORD *)(a1 + 64) = sub_10001389C(4uLL);
    *(_QWORD *)(a1 + 72) = sub_10001389C(1uLL);
    *(_QWORD *)(a1 + 88) = 1;
    v11 = socket(1, *(_DWORD *)(a1 + 100), 0);
    **(_DWORD **)(a1 + 64) = v11;
    if (v11 == -1)
      goto LABEL_124;
    if ((*(_WORD *)(a1 + 204) & 2) == 0)
    {
      v12 = connect(v11, (const sockaddr *)&v167, 0x6Au);
      goto LABEL_14;
    }
    v14 = *(const char **)(a1 + 144);
    if (!v14)
      sub_10004D738();
    if (unlink(v14))
    {
      if (*__error() != 2)
      {
        v15 = __error();
        v16 = xpc_strerror(*v15);
        __error();
        sub_10001A6F8(a1, 3, "Failed to remove old socket: error=%s (%d)", v17, v18, v19, v20, v21, v16);
        v13 = *__error();
        if (v13)
          goto LABEL_134;
      }
    }
    if (bind(**(_DWORD **)(a1 + 64), (const sockaddr *)&v167, 0x6Au))
    {
      v22 = __error();
      v23 = xpc_strerror(*v22);
      __error();
      sub_10001A6F8(a1, 3, "Failed to bind() a socket: error=%s (%d)", v24, v25, v26, v27, v28, v23);
      v13 = *__error();
      if (v13)
        goto LABEL_134;
    }
    bzero(&v168, 0x400uLL);
    if (dirname_r(*(const char **)(a1 + 144), (char *)&v168))
    {
      v29 = (int *)open((const char *)&v168, 0x100000);
      if ((v29 & 0x80000000) == 0)
      {
        v30 = v29;
        bzero(&v168, 0x400uLL);
        if (basename_r(*(const char **)(a1 + 144), (char *)&v168))
        {
          v31 = *(_DWORD *)(a1 + 104);
          if (*(_DWORD *)(a1 + 108))
            v32 = *(_DWORD *)(a1 + 108);
          else
            v32 = v31 == 0;
          if (fchownat((int)v30, (const char *)&v168, v31, v32, 32))
          {
            v33 = "Failed to fchown() a socket: error=%s (%d)";
          }
          else
          {
            if (!*(_QWORD *)(a1 + 136) || (v130 = *(_DWORD *)(a1 + 104)) == 0 || !chown(v155, v130, 0))
            {
LABEL_141:
              if ((*(_WORD *)(a1 + 204) & 8) != 0)
                v131 = *(_WORD *)(a1 + 152);
              else
                v131 = 438;
              if (fchmodat((int)v30, (const char *)&v168, v131, 32))
              {
                v132 = __error();
                v133 = xpc_strerror(*v132);
                __error();
                sub_10001A6F8(a1, 3, "Failed to fchmodat() a socket: error=%s (%d)", v134, v135, v136, v137, v138, v133);
                v13 = *__error();
                sub_10003BAF4(v30);
                if (v13)
                  goto LABEL_134;
              }
              else
              {
                sub_10003BAF4(v30);
              }
              if ((*(_DWORD *)(a1 + 100) | 4) != 5)
                goto LABEL_15;
              v12 = listen(**(_DWORD **)(a1 + 64), -1);
LABEL_14:
              if (v12 != -1)
              {
LABEL_15:
                v13 = 0;
LABEL_134:
                *(_DWORD *)(a1 + 200) = v13;
LABEL_135:
                *(_WORD *)(a1 + 204) |= 4u;
                sub_10001AFCC((dispatch_queue_t *)a1, v13 != 0);
                sub_10001962C((void *)a1);
                return;
              }
LABEL_124:
              __error();
              _os_assumes_log_ctx(sub_10001A6C4, a1);
              v13 = *__error();
              goto LABEL_134;
            }
            v33 = "Failed to chown() secure socket directory: error=%s (%d)";
          }
          v34 = __error();
          v35 = xpc_strerror(*v34);
          __error();
          sub_10001A6F8(a1, 3, v33, v36, v37, v38, v39, v40, v35);
          v13 = *__error();
          if (v13)
          {
            sub_10003BAF4(v30);
            goto LABEL_134;
          }
          goto LABEL_141;
        }
        v123 = __error();
        v124 = xpc_strerror(*v123);
        __error();
        sub_10001A6F8(a1, 3, "Failed to basename_r() a socket path: error=%s (%d)", v125, v126, v127, v128, v129, v124);
LABEL_133:
        v13 = 108;
        goto LABEL_134;
      }
      v114 = "Failed to open() socket directory: error=%s (%d)";
    }
    else
    {
      v114 = "Failed to dirname_r() a socket path: error=%s (%d)";
    }
    v116 = __error();
    v117 = xpc_strerror(*v116);
    __error();
    sub_10001A6F8(a1, 3, v114, v118, v119, v120, v121, v122, v117);
    goto LABEL_133;
  }
  memset(&v153, 0, sizeof(v153));
  v41 = *(_DWORD *)(a1 + 100);
  v42 = *(_DWORD *)(a1 + 188);
  v153.ai_family = *(_DWORD *)(a1 + 184);
  v153.ai_socktype = v41;
  v153.ai_protocol = v42;
  if ((*(_BYTE *)(a1 + 204) & 2) != 0)
    v153.ai_flags = 1;
  v152 = 0;
  v43 = getaddrinfo(*(const char **)(a1 + 160), *(const char **)(a1 + 176), &v153, &v152);
  if (v43)
  {
    v139 = v43;
    _os_assumes_log_ctx(sub_10001A6C4, a1);
    gai_strerror(v139);
    sub_10001A6F8(a1, 3, "getaddrinfo(3): %d: %s", v140, v141, v142, v143, v144, v139);
    v13 = sub_10001C698(v139);
    *(_DWORD *)(a1 + 200) = v13;
    if (v13)
      goto LABEL_135;
LABEL_128:
    if ((*(_WORD *)(a1 + 204) & 0x10) != 0)
    {
      sub_100019580((void *)a1);
      v115 = sub_1000146E4();
      dispatch_async_f(v115, (void *)a1, (dispatch_function_t)sub_10001C64C);
      v13 = *(_DWORD *)(a1 + 200);
    }
    else
    {
      v13 = 0;
    }
    goto LABEL_135;
  }
  v44 = v152;
  v45 = *(_QWORD *)(a1 + 88);
  if (v152)
  {
    do
    {
      ++v45;
      v44 = v44->ai_next;
    }
    while (v44);
    *(_QWORD *)(a1 + 88) = v45;
  }
  if (!(v45 >> 62))
  {
    *(_QWORD *)(a1 + 64) = sub_10001389C(4 * v45);
    *(_QWORD *)(a1 + 72) = sub_10001389C(*(_QWORD *)(a1 + 88));
    v46 = v152;
    if (!v152)
    {
      v113 = 0;
      goto LABEL_127;
    }
    v47 = 0;
    while (1)
    {
      v48 = socket(v46->ai_family, v46->ai_socktype, v46->ai_protocol);
      v49 = *(_QWORD *)(a1 + 64);
      *(_DWORD *)(v49 + 4 * v47) = v48;
      if (v48 == -1)
      {
        __error();
        _os_assumes_log_ctx(sub_10001A6C4, a1);
        ai_protocol = v46->ai_protocol;
        v149 = v47;
        ai_socktype = (const char *)v46->ai_socktype;
        sub_10001A6F8(a1, 3, "Could not create socket for resolved listener (family = %d, type = %d, protocol = %d, idx = %lu: ", v55, v56, v57, v58, v59, v46->ai_family);
        goto LABEL_113;
      }
      v151 = 1;
      v50 = *(_WORD *)(a1 + 204);
      if ((v50 & 2) == 0)
      {
        v51 = connect(*(_DWORD *)(v49 + 4 * v47), v46->ai_addr, v46->ai_addrlen);
        if (!v51)
          goto LABEL_97;
        if (v51 == -1)
          goto LABEL_96;
        goto LABEL_113;
      }
      ai_family = v46->ai_family;
      if (ai_family == 2)
      {
        if ((v50 & 0x20) != 0)
        {
          sub_10003BAF4((int *)*(unsigned int *)(v49 + 4 * v47));
          *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v47) = -1;
          goto LABEL_113;
        }
        if ((*(_WORD *)(a1 + 204) & 0x200) != 0)
        {
          v54 = setsockopt(*(_DWORD *)(v49 + 4 * v47), 0, 20, &v151, 4u);
          if (v54)
          {
            if (v54 == -1)
              goto LABEL_96;
            goto LABEL_113;
          }
          v61 = setsockopt(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v47), 0, 7, &v151, 4u);
          if (v61)
          {
            if (v61 == -1)
              goto LABEL_96;
            goto LABEL_113;
          }
        }
      }
      else if (ai_family == 30)
      {
        if ((v50 & 0x20) == 0)
        {
          v53 = setsockopt(*(_DWORD *)(v49 + 4 * v47), 41, 27, &v151, 4u);
          if (v53)
          {
            if (v53 == -1)
              goto LABEL_96;
            goto LABEL_113;
          }
          v49 = *(_QWORD *)(a1 + 64);
          *(_DWORD *)(a1 + 96) = *(_DWORD *)(v49 + 4 * v47);
          v50 = *(_WORD *)(a1 + 204);
        }
        if ((v50 & 0x200) != 0)
        {
          v60 = setsockopt(*(_DWORD *)(v49 + 4 * v47), 41, 61, &v151, 4u);
          if (v60)
          {
            if (v60 == -1)
              goto LABEL_96;
            goto LABEL_113;
          }
        }
      }
      v62 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v47);
      if (*(_QWORD *)(a1 + 168))
      {
        v63 = setsockopt(v62, 0xFFFF, 512, &v151, 4u);
        if (v63)
        {
          if (v63 == -1)
            goto LABEL_96;
          goto LABEL_113;
        }
      }
      else
      {
        v64 = setsockopt(v62, 0xFFFF, 4, &v151, 4u);
        if (v64)
        {
          if (v64 == -1)
            goto LABEL_96;
          goto LABEL_113;
        }
      }
      v65 = bind(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v47), v46->ai_addr, v46->ai_addrlen);
      if (v65)
      {
        if (v65 == -1)
          goto LABEL_96;
        goto LABEL_113;
      }
      v66 = getsockname(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v47), v46->ai_addr, &v46->ai_addrlen);
      if (v66)
      {
        if (v66 == -1)
          goto LABEL_96;
        goto LABEL_113;
      }
      v67 = *(const char **)(a1 + 168);
      if (v67)
      {
        v68 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v47);
        v69 = v46->ai_protocol;
        v70 = *(_QWORD *)&v46->ai_family;
        memset(&v168.ai_addrlen, 0, 32);
        v150 = v70;
        *(_QWORD *)&v168.ai_family = v70;
        v168.ai_flags = 1;
        v168.ai_protocol = v69;
        *(_QWORD *)&v167.st_dev = 0;
        v71 = getaddrinfo(v67, 0, &v168, (addrinfo **)&v167);
        if (!v71)
        {
          v83 = *(_QWORD *)&v167.st_dev;
          if (!*(_QWORD *)&v167.st_dev)
          {
LABEL_92:
            freeaddrinfo(*(addrinfo **)&v167.st_dev);
            goto LABEL_93;
          }
          while (2)
          {
            if (v150 == 30)
            {
              LODWORD(v156) = 0;
              memset(v155, 0, sizeof(v155));
              *(_OWORD *)v155 = *(_OWORD *)(*(_QWORD *)(v83 + 32) + 8);
              v84 = v68;
              v85 = 41;
              v86 = 20;
LABEL_88:
              if (setsockopt(v84, v85, 12, v155, v86) != -1)
                goto LABEL_92;
              __error();
              _os_assumes_log_ctx(sub_10001A6C4, a1);
            }
            else
            {
              if (v150 == 2)
              {
                *(_QWORD *)v155 = 0;
                *(_DWORD *)v155 = *(_DWORD *)(*(_QWORD *)(v83 + 32) + 4);
                v84 = v68;
                v85 = 0;
                v86 = 8;
                goto LABEL_88;
              }
              sub_10001A6F8(a1, 3, "Unknown family encountered during multicast group bind: %d", v72, v73, v74, v75, v76, v150);
            }
            v83 = *(_QWORD *)(v83 + 40);
            if (!v83)
              goto LABEL_92;
            continue;
          }
        }
        v77 = v71;
        ai_socktype = gai_strerror(v71);
        sub_10001A6F8(a1, 3, "getaddrinfo(3): %d: %s", v78, v79, v80, v81, v82, v77);
        sub_10001C698(v77);
      }
LABEL_93:
      if ((v46->ai_socktype | 4) != 5 || (v87 = listen(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v47), -1)) == 0)
      {
LABEL_97:
        v88 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v47);
        v89 = (const char *)sub_1000213BC(*(_QWORD *)(a1 + 56));
        if (*v89 == 47)
        {
          v90 = 0;
        }
        else
        {
          v92 = getenv("PATH");
          if (!v92)
          {
            sub_10001A6F8(a1, 3, "No PATH environment variable set. The application firewall will not work with this service.", v93, v94, v95, v96, v97, v145);
LABEL_111:
            if (fcntl(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v47), 4, 4, ai_socktype, ai_protocol, v149) == -1)
              sub_10004DE84();
            goto LABEL_113;
          }
          v90 = sub_10001544C(v92);
          __stringp = v90;
          v165 = 0u;
          v166 = 0u;
          v163 = 0u;
          v164 = 0u;
          v161 = 0u;
          v162 = 0u;
          v159 = 0u;
          v160 = 0u;
          v157 = 0u;
          v158 = 0u;
          *(_OWORD *)v155 = 0u;
          v156 = 0u;
          v98 = strsep(&__stringp, ":");
          if (v98)
          {
            v104 = 0;
            while (v104 != 24)
            {
              v105 = v104 + 1;
              *(_QWORD *)&v155[8 * v104] = v98;
              v98 = strsep(&__stringp, ":");
              v104 = v105;
              if (!v98)
                goto LABEL_117;
            }
            sub_10001A6F8(a1, 4, "PATH contains lots of paths. Some will be skipped.", v99, v100, v101, v102, v103, v145);
            v105 = 24;
LABEL_117:
            v106 = 0;
            v107 = 8 * v105;
            while (1)
            {
              bzero(&v168, 0x400uLL);
              snprintf((char *)&v168, 0x400uLL, "%s/%s", *(const char **)&v155[v106], v89);
              memset(&v167, 0, sizeof(v167));
              if (!stat((const char *)&v168, &v167))
                break;
              v106 += 8;
              if (v107 == v106)
                goto LABEL_122;
            }
            free(v90);
            v89 = sub_10001544C((const char *)&v168);
            v90 = (char *)v89;
LABEL_122:
            if (!v89)
            {
              sub_10001A6F8(a1, 3, "Socket's service points to a non-existent executable. The application firewall will not work with this service.", v108, v109, v110, v111, v112, v146);
LABEL_110:
              free(v90);
              goto LABEL_111;
            }
          }
        }
        v91 = strlen(v89);
        if (setsockopt(v88, 0xFFFF, 4229, v89, v91 + 1) == -1 && *__error() != 42 && *__error())
          _os_assumes_log_ctx(sub_10001A6C4, a1);
        goto LABEL_110;
      }
      if (v87 == -1)
LABEL_96:
        sub_10004DE5C();
LABEL_113:
      ++v47;
      v46 = v46->ai_next;
      if (!v46)
      {
        v113 = v152;
LABEL_127:
        freeaddrinfo(v113);
        *(_DWORD *)(a1 + 200) = 0;
        goto LABEL_128;
      }
    }
  }
  __break(1u);
}

uint64_t sub_10001BC30(uint64_t a1, _QWORD *a2)
{
  uint64_t v2;
  uint64_t result;

  v2 = *(_QWORD *)(a1 + 136);
  if (!v2)
    return 0;
  result = *(_QWORD *)(a1 + 144);
  *a2 = v2;
  return result;
}

void sub_10001BC4C(uint64_t a1)
{
  __int16 v1;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uintptr_t v13;
  NSObject *v14;
  NSObject *v15;
  _QWORD v16[5];
  _QWORD handler[5];
  int v18;

  v1 = *(_WORD *)(a1 + 204);
  if ((v1 & 0x100) != 0)
    sub_10003E208("attempt to watch socket that is already watched");
  if ((v1 & 0x80) != 0)
    sub_10003E208("attempt to watch canceled socket");
  if (*(_QWORD *)(a1 + 80))
    sub_10004D738();
  v3 = *(_QWORD *)(a1 + 88);
  if (v3 >> 61)
  {
    __break(1u);
  }
  else
  {
    *(_QWORD *)(a1 + 80) = sub_10001389C(8 * v3);
    v4 = *(_QWORD *)(a1 + 88);
    if (v4)
    {
      v5 = 0;
      while (1)
      {
        v6 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v5);
        if (v6 != -1)
          break;
LABEL_15:
        if (++v5 >= v4)
          goto LABEL_16;
      }
      v7 = dup(*(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v5));
      if (v7 == -1)
      {
        sub_10004DE84();
      }
      else
      {
        v13 = v7;
        if ((v7 & 0x80000000) == 0)
        {
          v14 = sub_1000146E4();
          v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v13, 0, v14);
          dispatch_set_context(v15, (void *)a1);
          handler[0] = _NSConcreteStackBlock;
          handler[1] = 0x40000000;
          handler[2] = sub_10001C714;
          handler[3] = &unk_10006C498;
          handler[4] = v15;
          v18 = v6;
          dispatch_source_set_event_handler(v15, handler);
          v16[0] = _NSConcreteStackBlock;
          v16[1] = 0x40000000;
          v16[2] = sub_10001C77C;
          v16[3] = &unk_10006C4B8;
          v16[4] = v15;
          dispatch_source_set_mandatory_cancel_handler(v15, v16);
          dispatch_activate(v15);
          if (v15)
            goto LABEL_14;
        }
      }
      sub_10001A6F8(a1, 4, "Unable to monitor socket #%zu", v8, v9, v10, v11, v12, v5);
      v15 = 0;
LABEL_14:
      *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * v5) = v15;
      v4 = *(_QWORD *)(a1 + 88);
      goto LABEL_15;
    }
LABEL_16:
    *(_WORD *)(a1 + 204) |= 0x100u;
  }
}

void sub_10001BE04(uint64_t a1)
{
  __int16 v1;
  void *v3;
  unint64_t v4;
  unint64_t i;
  NSObject *v6;

  v1 = *(_WORD *)(a1 + 204);
  if ((v1 & 0x100) == 0)
    sub_10003E208("attempt to ignore socket that is already ignored");
  if ((v1 & 0x80) != 0)
    sub_10003E208("attempt to ignore canceled socket");
  v3 = *(void **)(a1 + 80);
  if (!v3)
    sub_10004D738();
  v4 = *(_QWORD *)(a1 + 88);
  if (v4)
  {
    for (i = 0; i < v4; ++i)
    {
      v6 = *(NSObject **)(*(_QWORD *)(a1 + 80) + 8 * i);
      if (*(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * i) == -1)
      {
        if (v6)
          sub_10004D738();
      }
      else if (v6)
      {
        dispatch_source_cancel(v6);
        v4 = *(_QWORD *)(a1 + 88);
        *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8 * i) = 0;
      }
    }
    v3 = *(void **)(a1 + 80);
  }
  free(v3);
  *(_QWORD *)(a1 + 80) = 0;
  *(_WORD *)(a1 + 204) &= ~0x100u;
}

uint64_t sub_10001BEB4(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  unint64_t v5;
  int v6;
  uint64_t result;

  if ((*(_WORD *)(a1 + 204) & 1) != 0)
    return 37;
  *a2 = *(_QWORD *)(a1 + 64);
  *a4 = *(_QWORD *)(a1 + 88);
  if (a3)
    *a3 = *(_QWORD *)(a1 + 72);
  if (*(_QWORD *)(a1 + 88))
  {
    v5 = 0;
    do
    {
      v6 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 4 * v5);
      if (v6 != -1 && fcntl(v6, 4, 0) == -1)
        sub_10004DE84();
      ++v5;
    }
    while (v5 < *(_QWORD *)(a1 + 88));
  }
  result = 0;
  *(_WORD *)(a1 + 204) |= 1u;
  return result;
}

uint64_t sub_10001BF60(uint64_t result, _QWORD *a2, _QWORD *a3)
{
  *a2 = *(_QWORD *)(result + 64);
  *a3 = *(_QWORD *)(result + 88);
  return result;
}

uint64_t sub_10001BF74(uint64_t a1)
{
  return *(unsigned int *)(a1 + 200);
}

uint64_t sub_10001BF7C(uint64_t result)
{
  unint64_t v1;
  _QWORD *v2;
  unint64_t i;

  *(_WORD *)(result + 204) &= ~1u;
  v1 = *(_QWORD *)(result + 88);
  if (v1)
  {
    v2 = (_QWORD *)result;
    for (i = 0; i < v1; ++i)
    {
      result = *(unsigned int *)(v2[8] + 4 * i);
      if ((_DWORD)result != -1)
      {
        result = fcntl(result, 4, 4);
        if ((_DWORD)result == -1)
          result = sub_10004DE84();
        *(_BYTE *)(v2[9] + i) = 0;
        v1 = v2[11];
      }
    }
  }
  return result;
}

void sub_10001C00C(uint64_t a1)
{
  __int16 v2;

  v2 = *(_WORD *)(a1 + 204);
  if ((v2 & 0x100) != 0)
  {
    sub_10001BE04(a1);
    v2 = *(_WORD *)(a1 + 204);
  }
  *(_WORD *)(a1 + 204) = v2 | 0x80;
}

uint64_t sub_10001C044(_QWORD *a1, unsigned int **a2, _QWORD *a3)
{
  unint64_t v3;
  unsigned int *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v22;
  unsigned int v23;
  socklen_t v24;
  sockaddr v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  v3 = a1[11];
  if (v3 >> 62)
    __break(1u);
  v7 = (unsigned int *)sub_10001389C(4 * v3);
  v8 = a1[11];
  if (v8)
  {
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v11 = a1[8];
      if (*(_DWORD *)(v11 + 4 * v9) != -1)
      {
        v31 = 0u;
        v32 = 0u;
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        v25 = (sockaddr)0;
        v26 = 0u;
        v24 = 128;
        v12 = accept(*(_DWORD *)(v11 + 4 * v9), &v25, &v24);
        if (v12 == -1)
        {
          v14 = __error();
          v15 = *v14;
          if (*(_BYTE *)(a1[9] + v9))
          {
            xpc_strerror(*v14);
            sub_10001A6F8((uint64_t)a1, 3, "Got a socket event but accept() failed with errno %d - %s", v16, v17, v18, v19, v20, v15);
          }
          if ((_DWORD)v15 != 35)
          {
            if (v10)
            {
              v22 = v7;
              do
              {
                v23 = *v22++;
                sub_10003BAF4((int *)v23);
                --v10;
              }
              while (v10);
            }
            free(v7);
            return v15;
          }
        }
        else
        {
          v13 = v12;
          if (fcntl(v12, 4, 0) == -1)
            sub_10004DE84();
          v7[v10++] = v13;
        }
        *(_BYTE *)(a1[9] + v9) = 0;
        v8 = a1[11];
      }
      if (++v9 >= v8)
        goto LABEL_16;
    }
  }
  v10 = 0;
LABEL_16:
  v15 = 0;
  *a2 = v7;
  *a3 = v10;
  return v15;
}

uint64_t sub_10001C1EC(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;
  char *v18;
  FILE *v19;
  unsigned int v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  const char *v30;
  int v31;
  const char *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  const char *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const char *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  const char *v76;
  const char *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  const char *v84;
  uint64_t v85;
  char v86;

  sub_10004391C(a2, a3, "\"%s\" = {", a4, a5, a6, a7, a8, a1 + 208);
  v16 = *(_WORD *)(a1 + 204);
  if ((v16 & 4) != 0)
  {
    if ((v16 & 0x40) != 0)
    {
      v18 = "(system logger socket)";
LABEL_63:
      v19 = a2;
      v17 = a3 + 1;
      goto LABEL_64;
    }
    v20 = *(_DWORD *)(a1 + 100) - 1;
    v21 = "(unknown)";
    if (v20 <= 4)
      v21 = off_10006C4D8[v20];
    sub_10004391C(a2, a3 + 1, "type = %s", v11, v12, v13, v14, v15, v21);
    if (*(_QWORD *)(a1 + 144) || *(_QWORD *)(a1 + 136))
    {
      sub_10004391C(a2, a3 + 1, "path = %s", v24, v25, v26, v27, v28, *(_QWORD *)(a1 + 144));
      if ((*(_WORD *)(a1 + 204) & 8) != 0)
      {
        LOWORD(v85) = *(_WORD *)(a1 + 152);
        sub_10004391C(a2, a3 + 1, "mode = %o", v24, v25, v26, v27, v28);
      }
      if (*(_QWORD *)(a1 + 136))
      {
        v85 = *(_QWORD *)(a1 + 136);
        sub_10004391C(a2, a3 + 1, "secure key = %s", v24, v25, v26, v27, v28);
      }
      if (*(_DWORD *)(a1 + 104))
      {
        LODWORD(v85) = *(_DWORD *)(a1 + 104);
        sub_10004391C(a2, a3 + 1, "owner uid = %u", v24, v25, v26, v27, v28);
        if (*(_DWORD *)(a1 + 104))
          sub_10004391C(a2, a3 + 1, "group id = %u", v24, v25, v26, v27, v28, *(unsigned int *)(a1 + 108));
      }
LABEL_39:
      if (*(_DWORD *)(a1 + 200))
      {
        LODWORD(v85) = *(_DWORD *)(a1 + 200);
        sub_10004391C(a2, a3 + 1, "error = %d", v24, v25, v26, v27, v28);
      }
      sub_100043998(a2, v22, v23, v24, v25, v26, v27, v28, v85);
      sub_10004391C(a2, a3 + 1, "sockets = {", v34, v35, v36, v37, v38);
      if (*(_QWORD *)(a1 + 88))
      {
        v44 = 0;
        do
        {
          if (*(_BYTE *)(*(_QWORD *)(a1 + 72) + v44))
            v45 = (const char *)&unk_100056F87;
          else
            v45 = "no ";
          sub_10004391C(a2, a3 + 2, "%d (%sbytes to read)", v39, v40, v41, v42, v43, *(unsigned int *)(*(_QWORD *)(a1 + 64) + 4 * v44++), v45);
        }
        while (v44 < *(_QWORD *)(a1 + 88));
      }
      sub_10004391C(a2, a3 + 1, "}", v39, v40, v41, v42, v43);
      sub_100043998(a2, v46, v47, v48, v49, v50, v51, v52, v86);
      if ((*(_WORD *)(a1 + 204) & 1) != 0)
        v58 = "1";
      else
        v58 = "0";
      sub_10004391C(a2, a3 + 1, "active = %s", v53, v54, v55, v56, v57, v58);
      if ((*(_WORD *)(a1 + 204) & 2) != 0)
        v64 = "1";
      else
        v64 = "0";
      sub_10004391C(a2, a3 + 1, "passive = %s", v59, v60, v61, v62, v63, v64);
      if ((*(_WORD *)(a1 + 204) & 0x10) != 0)
        v70 = "1";
      else
        v70 = "0";
      sub_10004391C(a2, a3 + 1, "bonjour = %s", v65, v66, v67, v68, v69, v70);
      if ((*(_WORD *)(a1 + 204) & 0x20) != 0)
        v76 = "1";
      else
        v76 = "0";
      sub_10004391C(a2, a3 + 1, "ipv4v6 = %s", v71, v72, v73, v74, v75, v76);
      if ((*(_WORD *)(a1 + 204) & 0x200) != 0)
        v77 = "1";
      else
        v77 = "0";
      v84 = v77;
      v18 = "receive_packet_info = %s";
      goto LABEL_63;
    }
    if (*(_QWORD *)(a1 + 160))
    {
      v85 = *(_QWORD *)(a1 + 160);
      sub_10004391C(a2, a3 + 1, "node name = %s", v24, v25, v26, v27, v28);
    }
    if (*(_QWORD *)(a1 + 168))
    {
      v85 = *(_QWORD *)(a1 + 168);
      sub_10004391C(a2, a3 + 1, "multicast group = %s", v24, v25, v26, v27, v28);
    }
    if (*(_QWORD *)(a1 + 176))
    {
      v85 = *(_QWORD *)(a1 + 176);
      sub_10004391C(a2, a3 + 1, "service name = %s", v24, v25, v26, v27, v28);
    }
    v29 = *(_DWORD *)(a1 + 184);
    if (v29 > 1)
    {
      if (v29 == 2)
      {
        v30 = "ipv4";
        goto LABEL_31;
      }
      if (v29 == 30)
      {
        v30 = "ipv6";
        goto LABEL_31;
      }
    }
    else
    {
      if (!v29)
        goto LABEL_32;
      if (v29 == 1)
      {
        v30 = "unix";
LABEL_31:
        sub_10004391C(a2, a3 + 1, "family = %s", v24, v25, v26, v27, v28, v30);
LABEL_32:
        v31 = *(_DWORD *)(a1 + 188);
        if (v31)
        {
          v32 = "udp";
          if (v31 != 17)
            v32 = "(unknown)";
          if (v31 == 6)
            v33 = "tcp";
          else
            v33 = v32;
          sub_10004391C(a2, a3 + 1, "protocol = %s", v24, v25, v26, v27, v28, v33);
        }
        goto LABEL_39;
      }
    }
    v30 = "(unknown)";
    goto LABEL_31;
  }
  v17 = a3 + 1;
  v18 = "(animating)";
  v19 = a2;
LABEL_64:
  sub_10004391C(v19, v17, v18, v11, v12, v13, v14, v15, v84);
  return sub_10004391C(a2, a3, "}", v78, v79, v80, v81, v82);
}

void sub_10001C604(unsigned int *a1)
{
  void *v2;

  v2 = *(void **)a1;
  (*(void (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)a1 + 120))(*(_QWORD *)a1, a1[2], *(_QWORD *)(*(_QWORD *)a1 + 128));
  sub_10001962C(v2);
  free(a1);
}

void sub_10001C64C(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 204) & 0x80) == 0)
    sub_10003AAC4(*(_QWORD **)(a1 + 56), "com.apple.bonjour.registration", (const char *)(a1 + 208), *(void **)(a1 + 192));
  sub_10001962C((void *)a1);
}

uint64_t sub_10001C698(int a1)
{
  uint64_t result;

  switch(a1)
  {
    case 1:
    case 5:
    case 9:
    case 10:
      result = 45;
      break;
    case 2:
      result = 35;
      break;
    case 3:
    case 12:
    case 13:
      result = 22;
      break;
    case 4:
      result = 153;
      break;
    case 6:
      result = 12;
      break;
    case 7:
    case 8:
      result = 3;
      break;
    case 11:
      result = *__error();
      break;
    case 14:
      result = 34;
      break;
    default:
      result = 0xFFFFFFFFLL;
      break;
  }
  return result;
}

uint64_t sub_10001C714(uint64_t a1)
{
  _QWORD *context;
  uint64_t v3;
  uint64_t v4;

  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  v3 = context[11];
  if (v3)
  {
    v4 = 0;
    while (*(_DWORD *)(context[8] + 4 * v4) != *(_DWORD *)(a1 + 40))
    {
      if (v3 == ++v4)
        return ((uint64_t (*)(_QWORD *, uint64_t, _QWORD))context[15])(context, 2, context[16]);
    }
    *(_BYTE *)(context[9] + v4) = 1;
  }
  return ((uint64_t (*)(_QWORD *, uint64_t, _QWORD))context[15])(context, 2, context[16]);
}

void sub_10001C77C(uint64_t a1)
{
  int *handle;

  handle = (int *)dispatch_source_get_handle(*(dispatch_source_t *)(a1 + 32));
  sub_10003BAF4(handle);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t sub_10001C7A8(uint64_t a1)
{
  uint64_t v1;

  return _os_assumes_log_ctx(a1, v1);
}

int *sub_10001C7B0()
{
  return __error();
}

uint64_t sub_10001C7C0(int *a1)
{
  return _os_assumes_log(*a1);
}

void sub_10001C7C8()
{
  qword_100071D10 = 0;
  byte_100071D18 = 0;
  qword_100071D20 = 0;
  qword_100071D28 = 0;
  qword_100071D30 = 0;
}

BOOL sub_10001C7F4(uint64_t a1)
{
  rb_tree_t **v2;
  _QWORD *v3;
  _QWORD v5[5];

  if (a1)
  {
    v2 = (rb_tree_t **)sub_10001C868();
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_10001C898;
    v5[3] = &unk_10006C508;
    v5[4] = a1;
    sub_10001A424(v2, (uint64_t)v5);
  }
  v3 = sub_10001C868();
  return sub_10001A4A0((size_t)v3) != 0;
}

_QWORD *sub_10001C868()
{
  _QWORD *result;

  sub_100014714();
  result = (_QWORD *)qword_100071D28;
  if (!qword_100071D28)
  {
    result = sub_10001A4BC();
    qword_100071D28 = (uint64_t)result;
  }
  return result;
}

uint64_t sub_10001C898(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_10001C8A8(void *a1, _QWORD *a2)
{
  uint64_t uint64;
  uint64_t v5;
  rb_tree_t **v6;
  rb_tree_t **v7;
  uint64_t v8;
  xpc_object_t reply;
  xpc_object_t v10;
  uint64_t result;

  uint64 = xpc_dictionary_get_uint64(a1, "cid");
  if (!uint64)
    return 22;
  v5 = uint64;
  v6 = (rb_tree_t **)sub_10001C868();
  v7 = sub_10001A3E0(v6, v5);
  if (v7)
  {
    v8 = (uint64_t)v7;
    reply = xpc_dictionary_create_reply(a1);
    if (reply)
    {
      v10 = reply;
      sub_10001C928(reply, v8);
      result = 0;
      *a2 = v10;
      return result;
    }
    return 22;
  }
  return 3;
}

void sub_10001C928(void *a1, uint64_t a2)
{
  uint64_t v4;
  const char *v5;
  const char *v6;
  const void *v7;

  v4 = sub_100011400(a2);
  xpc_dictionary_set_uint64(a1, "cid", v4);
  v5 = (const char *)sub_1000124E4(a2);
  v6 = (const char *)sub_1000124EC(a2);
  if (v5)
    xpc_dictionary_set_string(a1, "name", v5);
  if (v6)
    xpc_dictionary_set_string(a1, "bundle_identifier", v6);
  v7 = (const void *)sub_1000124F4(a2);
  if (v7)
    xpc_dictionary_set_data(a1, "resource-usage-blob", v7, 0x160uLL);
}

uint64_t sub_10001C9E4(void *a1, _QWORD *a2)
{
  _QWORD *v4;
  xpc_object_t reply;
  void *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t result;
  xpc_object_t v11;

  byte_100071D18 = 1;
  v4 = (_QWORD *)qword_100071D30;
  if (!qword_100071D30)
  {
    v4 = sub_10001123C();
    qword_100071D30 = (uint64_t)v4;
  }
  if (sub_100011400((uint64_t)v4))
  {
    reply = xpc_dictionary_create_reply(a1);
    if (reply)
    {
      v6 = reply;
      v7 = (_QWORD *)qword_100071D30;
      if (!qword_100071D30)
      {
        v7 = sub_10001123C();
        qword_100071D30 = (uint64_t)v7;
      }
      v8 = sub_1000113D8((uint64_t)v7, 0);
      sub_100012504(v8, 2);
      sub_10001C928(v6, v8);
      v9 = (_QWORD *)qword_100071D30;
      if (!qword_100071D30)
      {
        v9 = sub_10001123C();
        qword_100071D30 = (uint64_t)v9;
      }
      sub_100011368((uint64_t)v9, 0);
      result = 0;
      *a2 = v6;
    }
    else
    {
      return 22;
    }
  }
  else if (qword_100071D10)
  {
    return 37;
  }
  else
  {
    v11 = xpc_dictionary_create_reply(a1);
    result = 0;
    qword_100071D10 = (uint64_t)v11;
  }
  return result;
}

uint64_t sub_10001CAC8(uint64_t a1)
{
  rb_tree_t **v2;
  rb_tree_t **v3;
  rb_tree_t **v4;
  void *v6;
  int v7;
  const char *v8;
  _QWORD *v9;
  uint64_t v10;
  _OWORD v11[22];

  v2 = (rb_tree_t **)sub_10001C868();
  v3 = sub_10001A3E0(v2, a1);
  if (!v3)
    return 5;
  v4 = v3;
  sub_100012504((uint64_t)v3, 1);
  if (!sub_1000124FC((uint64_t)v4))
  {
    memset(v11, 0, sizeof(v11));
    if (coalition_info_resource_usage(a1, v11, 352) == -1)
      sub_10004D870();
    sub_100012490(v4, v11);
    v6 = (void *)qword_100071D10;
    if (qword_100071D10)
    {
      qword_100071D10 = 0;
      sub_10001C928(v6, (uint64_t)v4);
      v7 = xpc_pipe_routine_reply(v6);
      xpc_release(v6);
      if (!v7)
        goto LABEL_11;
      if (v7 != 32)
      {
        _os_assumes_log(v7);
        goto LABEL_11;
      }
    }
    sub_10001CDDC(v4);
    goto LABEL_11;
  }
  sub_100012490(v4, 0);
LABEL_11:
  if (byte_100072A82)
  {
    v8 = (const char *)sub_1000124E4((uint64_t)v4);
    sub_100040F68(65541, "coalition_reap(%llu) [%s]", a1, v8);
  }
  sub_10001020C(a1);
  v9 = sub_10001C868();
  v10 = sub_100011400((uint64_t)v4);
  sub_10001A31C((uint64_t)v9, v10, 0);
  return 0;
}

_BYTE *sub_10001CC44(uint64_t a1)
{
  uint64_t v2;
  _BYTE *v3;
  _QWORD *v4;
  uint64_t v5;

  v2 = sub_1000100EC((unsigned int *)a1);
  v3 = sub_10001232C(v2, *(const char **)(a1 + 8), *(const char **)(a1 + 16), *(_DWORD *)a1, (uint64_t)sub_1000101E4);
  v4 = sub_10001C868();
  v5 = sub_100011400((uint64_t)v3);
  sub_10001A31C((uint64_t)v4, v5, v3);
  return v3;
}

uint64_t sub_10001CCA0(const void *a1, _DWORD *a2)
{
  _QWORD *v4;
  rb_tree_t **v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE *v9;
  uint64_t v10;
  void *v11;

  if (*a2)
    sub_10004D74C();
  if (!a1)
    sub_10004D74C();
  v4 = (_QWORD *)qword_100071D20;
  if (!qword_100071D20)
  {
    v4 = sub_100043588(32, (uint64_t)sub_10001CD6C);
    qword_100071D20 = (uint64_t)v4;
  }
  v5 = sub_100043528((uint64_t)v4, a1);
  if (v5)
  {
    v6 = (uint64_t)v5;
    v7 = sub_100011400((uint64_t)v5);
    sub_100040F68(5, "Coalition Cache Hit: %s [%llu]", (const char *)a1, v7);
    return sub_100012408(v6);
  }
  else
  {
    v9 = sub_10001CC44((uint64_t)a2);
    v10 = qword_100071D20;
    v11 = (void *)sub_100012408((uint64_t)v9);
    sub_10004335C(v10, a1, v11);
    return (uint64_t)v9;
  }
}

uint64_t sub_10001CD6C(const char *a1, uint64_t a2)
{
  uint64_t v4;

  v4 = sub_100011400(a2);
  sub_100040F68(5, "Coalition Cache Evicted: %s [%llu]", a1, v4);
  return sub_100012438(a2);
}

void sub_10001CDB4()
{
  os_release((void *)qword_100071D20);
  qword_100071D20 = 0;
}

_QWORD *sub_10001CDDC(void *a1)
{
  _QWORD *result;
  _QWORD *v3;

  result = (_QWORD *)sub_100012504((uint64_t)a1, 2);
  if (byte_100071D18 == 1)
  {
    v3 = (_QWORD *)qword_100071D30;
    if (!qword_100071D30)
    {
      v3 = sub_10001123C();
      qword_100071D30 = (uint64_t)v3;
    }
    return sub_1000112C0(v3, a1);
  }
  return result;
}

uint64_t sub_10001CE34()
{
  return os_map_str_init(&unk_100071D38, 0, 1);
}

void sub_10001CE48(uint64_t a1)
{
  void *v2;

  os_map_str_delete(&unk_100071D38, a1 + 32);
  free(*(void **)(a1 + 16));
  v2 = *(void **)(a1 + 24);
  if (v2)
    sub_10001962C(v2);
}

char *sub_10001CE9C(uint64_t a1, const char *a2, const char *a3)
{
  char *v4;

  v4 = sub_100019E88(a3);
  *((_QWORD *)v4 + 2) = sub_10001544C(a2);
  return v4;
}

_QWORD *sub_10001CED4(uint64_t a1, char *a2, const char *a3, void *a4)
{
  uint64_t v7;
  const char **v8;
  _QWORD *v9;

  v7 = os_map_str_find(&unk_100071D38, a3);
  if (!v7)
    goto LABEL_6;
  v8 = (const char **)v7;
  if (!sub_1000157A8(a2, *(const char **)(v7 + 16)))
  {
    sub_100040F68(65539, "CACHE INVARIANT VIOLATED: %s | %s != %s", a3, a2, v8[2]);
LABEL_6:
    v9 = sub_100019E88(a3);
    v9[2] = sub_10001544C(a2);
    v9[3] = sub_100019580(a4);
    os_map_str_insert(&unk_100071D38, v9 + 4, v9);
    return v9;
  }
  v9 = sub_100019580(v8);
  if (!v9)
    goto LABEL_6;
  return v9;
}

uint64_t sub_10001CFB8(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 16);
}

uint64_t sub_10001CFC4(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16) + 32;
}

uint64_t sub_10001CFD0(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 16) + 24);
}

void *sub_10001CFDC()
{
  return sub_10001389C(0x50uLL);
}

uint64_t sub_10001CFE4(uint64_t result, int a2)
{
  int v2;
  unsigned int v3;

  if (*(_QWORD *)result)
  {
    v2 = *(_DWORD *)(result + 72);
    v3 = *(_DWORD *)(result + 76);
    *(_DWORD *)(result + 4 * (((_BYTE)v3 + (_BYTE)v2) & 0xF) + 8) = a2 - *(_QWORD *)result;
    if (v3 > 0xF)
      *(_DWORD *)(result + 72) = ((_BYTE)v2 + 1) & 0xF;
    else
      *(_DWORD *)(result + 76) = v3 + 1;
  }
  *(_QWORD *)result = 0;
  return result;
}

_QWORD *sub_10001D02C(_QWORD *result, uint64_t a2)
{
  *result = a2;
  return result;
}

uint64_t sub_10001D034(uint64_t a1)
{
  return *(unsigned int *)(a1 + 76);
}

uint64_t sub_10001D03C(uint64_t a1, char a2)
{
  return *(unsigned int *)(a1 + 4 * ((*(_DWORD *)(a1 + 72) + a2) & 0xF) + 8);
}

uint64_t sub_10001D054(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  const char *v4;
  _BYTE *v5;
  char *v6;

  result = sub_10001D0CC(a1);
  if (result)
  {
    v3 = result;
    result = os_map_str_find(result, *(_QWORD *)(a1 + 576));
    if (!result)
    {
      v4 = *(const char **)(a1 + 576);
      v5 = sub_10001389C(0x58uLL);
      v5[1] = 1;
      v6 = sub_10001544C(v4);
      return os_map_str_insert(v3, v6, v5);
    }
  }
  return result;
}

uint64_t sub_10001D0CC(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 248);
  if (!v2 || (_UNKNOWN *)sub_10002E360(v2) != &unk_100071750)
    return 0;
  if ((*(_BYTE *)(a1 + 1382) & 0x10) == 0)
  {
    if (!sub_1000157A8(*(char **)(a1 + 576), "com.apple.IDSBlastDoorService"))
      return 0;
    *(_QWORD *)(a1 + 1376) |= 0x10000000000000uLL;
  }
  return sub_10002E370(*(_QWORD *)(*(_QWORD *)(a1 + 248) + 232));
}

uint64_t sub_10001D144(uint64_t a1)
{
  uint64_t v2;
  unsigned __int8 *v3;

  v2 = sub_100023BE0(a1);
  v3 = (unsigned __int8 *)(a1 + 1040);
  if (v2)
    v3 = (unsigned __int8 *)v2;
  return *v3;
}

uint64_t sub_10001D174(uint64_t a1, uint64_t a2)
{
  if (byte_100072A79 || (*(_BYTE *)(a1 + 1378) & 0x80) != 0)
    return 0;
  if (*(unsigned __int8 *)(a2 + 32) == sub_10004419C(a1 + 1200))
    return 6;
  return 0;
}

uint64_t sub_10001D1C8(uint64_t a1, uint64_t a2)
{
  int v4;

  if (byte_100072A79 || (*(_BYTE *)(a1 + 1378) & 0x80) != 0)
    return 0;
  if (sub_100044284(a1 + 1200))
  {
    v4 = 1;
  }
  else if (sub_100044038(a1 + 1200))
  {
    v4 = sub_100044064((_DWORD *)(a1 + 1200)) == 0;
  }
  else if (*(_DWORD *)(a1 + 1024))
  {
    v4 = 0;
  }
  else
  {
    v4 = *(_BYTE *)(a2 + 32) != 0;
  }
  if (*(unsigned __int8 *)(a2 + 32) == v4)
    return 6;
  else
    return 0;
}

uint64_t sub_10001D274(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  int v4;

  v3 = *(_QWORD *)(a1 + 144);
  if (v3)
  {
    v4 = 0;
    do
    {
      v4 |= sub_10003A77C(v3);
      v3 = *(_QWORD *)(v3 + 16);
    }
    while (v3);
  }
  else
  {
    LOBYTE(v4) = 0;
  }
  if (*(_BYTE *)(a2 + 32) == (v4 & 1))
    return 14;
  else
    return 0;
}

void sub_10001D2D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *v7;
  NSObject *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v6 = *(_QWORD **)(a1 + 512);
  if (v6)
  {
    do
    {
      v7 = (_QWORD *)*v6;
      if ((_DWORD)a2 == 9 || *((_DWORD *)v6 + 8) == (_DWORD)a2)
      {
        v6[5] = sub_100019580((void *)a1);
        v8 = sub_1000146E4();
        dispatch_async_f(v8, v6, (dispatch_function_t)sub_100023C14);
        v9 = (_QWORD *)*v6;
        if (*v6)
          v9[1] = v6[1];
        *(_QWORD *)v6[1] = v9;
        *v6 = -1;
        v6[1] = -1;
      }
      v6 = v7;
    }
    while (v7);
  }
  sub_100019580((void *)a1);
  if ((a2 - 1) > 8)
    v15 = "WILL_SPAWN";
  else
    v15 = off_10006C8E8[(int)a2 - 1];
  sub_10001D418(a1, 5, "internal event: %s, code = %ld", v10, v11, v12, v13, v14, (char)v15);
  sub_10003D248(a1, a2, a3, v16, v17, v18, v19, v20);
  (*(void (**)(uint64_t, uint64_t, uint64_t, _QWORD))(a1 + 520))(a1, a2, a3, *(_QWORD *)(a1 + 568));
  sub_10001962C((void *)a1);
}

void sub_10001D418(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  char *v12;

  v12 = sub_10001F264(a1, 2);
  sub_1000412EC(v12, a2, a3, &a9, v9);
  free(v12);
}

uint64_t sub_10001D47C(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  char v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  uint64_t v45;
  uint64_t v46;
  _DWORD *v47;
  const char *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  char v63;

  v2 = a2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(a1 + 528))(a1, a2, *(_QWORD *)(a1 + 568));
  if ((_DWORD)result == 124)
    return 0;
  if (!(_DWORD)result)
  {
    if ((*(_QWORD *)(a1 + 1384) & 1) != 0)
    {
      v23 = "cannot spawn: service is configured as retain only";
    }
    else
    {
      if ((*(_QWORD *)(a1 + 1376) & 0x40000) == 0)
      {
        v10 = *(_QWORD *)(a1 + 248);
        if ((_UNKNOWN *)sub_10002E360(v10) == &unk_100071750)
        {
          v25 = qword_100071D50;
          if (qword_100071D50)
          {
            do
            {
              v26 = *(_QWORD *)v25;
              v27 = *(_QWORD *)(a1 + 256);
              v28 = *(char **)(v25 + 16);
              if (v27)
              {
                if (sub_1000157A8(v28, (const char *)(v27 + 1392)))
                  goto LABEL_29;
              }
              else if (sub_1000157A8(v28, (const char *)(a1 + 1392)))
              {
LABEL_29:
                sub_10001D418(a1, 5, "matched global attach request before spawn", v11, v12, v13, v14, v15, v63);
                v33 = sub_10002E368(v10);
                xpc_dictionary_set_uint64(*(xpc_object_t *)(v25 + 24), "handle", v33);
                if ((*(_BYTE *)(a1 + 1381) & 2) != 0)
                  xpc_dictionary_set_uuid(*(xpc_object_t *)(v25 + 24), "_instance", (const unsigned __int8 *)(a1 + 408));
                sub_100044BF8(dword_100072A00, *(void **)(v25 + 24));
                xpc_release(*(xpc_object_t *)(v25 + 24));
                v34 = *(_QWORD *)v25;
                if (*(_QWORD *)v25)
                  *(_QWORD *)(v34 + 8) = *(_QWORD *)(v25 + 8);
                **(_QWORD **)(v25 + 8) = v34;
                free((void *)v25);
                *(_DWORD *)(a1 + 820) = v2;
                *(_BYTE *)(a1 + 1322) |= 8u;
                v35 = sub_100023994(v2);
                sub_10001D418(a1, 5, "service spawn reason '%s' pended until controller attaches", v36, v37, v38, v39, v40, v35);
                sub_100023D28(a1, 1);
                v63 = sub_100023994(v2);
                v24 = "pended spawn reason '%s': redriving controller attach request";
LABEL_34:
                sub_10001D418(a1, 5, v24, v11, v12, v13, v14, v15, v63);
                return 36;
              }
              v25 = v26;
            }
            while (v26);
          }
        }
        v16 = *(_DWORD *)(a1 + 1128);
        if (v16 && v16 != v2)
        {
          v17 = sub_100023994(v2);
          sub_10001D418(a1, 5, "ignoring spawn reason '%s' due to filter", v18, v19, v20, v21, v22, v17);
          return 102;
        }
        if (*(_QWORD *)(a1 + 824))
        {
          v24 = "cannot spawn: service is throttled";
          goto LABEL_34;
        }
        v29 = sub_100023BE0(a1);
        v30 = a1 + 1040;
        if (v29)
          v31 = v29;
        else
          v31 = a1 + 1040;
        if (*(_BYTE *)(v31 + 1) || (v2 & 0xFFFFFFF7) == 3 || (*(_QWORD *)(a1 + 1376) & 0x4000) != 0)
          goto LABEL_27;
        v41 = sub_100023BE0(a1);
        v42 = sub_100023BE0(a1);
        if (v42)
          v43 = v42;
        else
          v43 = a1 + 1040;
        if (v41)
        {
          if (v43 == v30)
            v44 = (_DWORD *)(a1 + 1200);
          else
            v44 = (_DWORD *)(v43 + 32);
          if (!*v44)
            goto LABEL_27;
          v45 = sub_100023BE0(a1);
          if (v45)
            v46 = v45;
          else
            v46 = a1 + 1040;
          if (v46 == v30)
            v47 = (_DWORD *)(a1 + 1200);
          else
            v47 = (_DWORD *)(v46 + 32);
          if (*v47 != 3)
          {
            if (!*v47)
            {
              sub_10001D950(a1);
LABEL_27:
              v32 = *(unsigned __int8 *)(a1 + 424);
              if (v32 >= 2)
              {
                if (v32 != 2)
                {
                  v48 = sub_100023DAC(a1);
                  sub_10003E208("Spawning a service in state %s", v48);
                }
                return 36;
              }
              sub_100023D28(a1, 1);
              sub_100023E54(a1, v2);
              return sub_100023F34(a1);
            }
            v50 = 0;
LABEL_61:
            v56 = sub_10001D950(a1);
            v57 = v56 - v50;
            if (v56 > v50)
            {
              sub_10001D418(a1, 5, "Service only ran for %llu seconds. Pushing respawn out by %llu seconds.", v51, v52, v53, v54, v55, v50);
              if (v56 > *(_DWORD *)(a1 + 836))
                sub_10001D418(a1, 4, "Exponential throttling is in effect for %llu seconds.", v58, v59, v60, v61, v62, v57);
              if (v56 != v50)
              {
                sub_1000248C8(a1, v57, v2);
                return 36;
              }
            }
            goto LABEL_27;
          }
          v49 = sub_1000440A8((uint64_t)v47);
        }
        else
        {
          v49 = *(_QWORD *)(v43 + 8);
        }
        v50 = sub_10000D6D0(v49) / 0x3B9ACA00uLL;
        goto LABEL_61;
      }
      v23 = "cannot spawn: service is in penalty box";
    }
    sub_10001D418(a1, 5, v23, v5, v6, v7, v8, v9, v63);
    return 139;
  }
  return result;
}

uint64_t sub_10001D840()
{
  return 1;
}

uint64_t sub_10001D848(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = *(unsigned int *)(a1 + 700);
  if (!(_DWORD)result)
  {
    v3 = *(_QWORD *)(a1 + 256);
    if (v3)
      return *(unsigned int *)(v3 + 700);
    else
      return 0;
  }
  return result;
}

size_t sub_10001D870(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  sub_10001D8CC(a1);
  v2 = sub_100023BE0(a1);
  if (v2)
    v3 = v2;
  else
    v3 = a1 + 1040;
  if (!*(_QWORD *)(v3 + 16))
    return 0;
  v4 = sub_100023BE0(a1);
  if (v4)
    v5 = v4;
  else
    v5 = a1 + 1040;
  return xpc_array_get_count(*(xpc_object_t *)(v5 + 16));
}

uint64_t sub_10001D8CC(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  xpc_object_t v7;
  uint64_t v8;

  result = sub_100023BE0(a1);
  if (result)
    v3 = result;
  else
    v3 = a1 + 1040;
  if (*(_QWORD *)(v3 + 16))
  {
    v4 = sub_100023BE0(a1);
    if (v4)
      v5 = v4;
    else
      v5 = a1 + 1040;
    v6 = *(void **)(v5 + 16);
    v7 = sub_100023C6C(v6, qword_100071AA0);
    xpc_release(v6);
    result = sub_100023BE0(a1);
    if (result)
      v8 = result;
    else
      v8 = a1 + 1040;
    *(_QWORD *)(v8 + 16) = v7;
  }
  return result;
}

uint64_t sub_10001D950(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v8;
  unint64_t v9;

  sub_10001D8CC(a1);
  if ((*(_BYTE *)(a1 + 1382) & 8) == 0)
    return *(unsigned int *)(a1 + 836);
  v2 = sub_100023BE0(a1);
  v3 = a1 + 1040;
  if (v2)
    v3 = v2;
  if (!*(_QWORD *)(v3 + 16))
    return *(unsigned int *)(a1 + 836);
  v4 = *(unsigned __int16 *)(a1 + 1028);
  v5 = sub_10001D870(a1);
  v6 = v5 - v4;
  if (v5 <= v4)
    return *(unsigned int *)(a1 + 836);
  if (v6 > 0xB)
    return 1200;
  v8 = *(unsigned int *)(a1 + 836);
  if (!(_DWORD)v8)
    sub_10004D738();
  v9 = v8 << v6;
  if (v9 >= 0x4B0)
    return 1200;
  else
    return v9;
}

void sub_10001D9DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  BOOL v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  xpc_object_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v24;

  *(_BYTE *)(a2 + 176) = 0;
  *(_QWORD *)(a2 + 180) = 0;
  if (*(_BYTE *)(a1 + 1030) || (*(_BYTE *)(a1 + 1383) & 8) != 0)
  {
    v11 = *(_QWORD *)(a1 + 1376);
    if (byte_100072A66)
      v12 = 0;
    else
      v12 = (v11 & 0x10000000000) == 0;
    if (v12)
    {
      sub_10001D418(a1, 4, "Disallowing panic-on-crash behavior for non-system service", a4, a5, a6, a7, a8, a9);
    }
    else if ((v11 & 0x800000000000000) != 0)
    {
      v14 = sub_100023BE0(a1);
      if (v14)
        v15 = v14;
      else
        v15 = a1 + 1040;
      v16 = *(void **)(v15 + 24);
      if (v16)
      {
        v17 = sub_100023C6C(*(void **)(v15 + 24), *(_QWORD *)(a1 + 1032));
        xpc_release(v16);
        *(_QWORD *)(v15 + 24) = v17;
        if (xpc_array_get_count(v17) >= 2)
        {
          v18 = sub_10001DAF8(*(_QWORD *)(a1 + 1032));
          sub_10001D418(a1, 4, "Enabling panic-on-crash due to consecutive crashes", v19, v20, v21, v22, v23, v24);
          *(_QWORD *)(a2 + 180) = v18;
          *(_BYTE *)(a2 + 176) = 1;
        }
      }
    }
    else
    {
      *(_BYTE *)(a2 + 176) = *(_BYTE *)(a1 + 1030);
      v13 = *(_QWORD *)(a1 + 1032);
      if (v13)
        *(_QWORD *)(a2 + 180) = sub_10001DAF8(v13);
    }
  }
}

uint64_t sub_10001DAF8(unint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = mach_continuous_time();
  sub_10000D76C(a1);
  if (__CFADD__(v2, v3))
    sub_10003E208("Overflow calculating deadline: %lld + %lld", v2, v3);
  return v2 + v3;
}

uint64_t sub_10001DB48(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char v38;

  if ((*(_QWORD *)(a1 + 1384) & 1) != 0)
    return 0;
  v2 = *(_QWORD *)(a1 + 1376);
  if ((v2 & 0x220000) != 0 || (v2 & 0x400000) != 0 && !*(_DWORD *)(a1 + 1024))
  {
    v3 = 7;
    goto LABEL_4;
  }
  if ((v2 & 4) != 0)
  {
    if (*(_DWORD *)(a1 + 1024))
      v3 = 5;
    else
      v3 = 4;
    goto LABEL_4;
  }
  if ((v2 & 0x10) != 0 && !*(_DWORD *)(a1 + 1024))
  {
    if ((~v2 & 0x40000001000) != 0)
      v3 = 4;
    else
      v3 = 9;
    goto LABEL_4;
  }
  v6 = sub_100023BE0(a1);
  v7 = a1 + 1040;
  if (v6)
    v8 = v6;
  else
    v8 = a1 + 1040;
  if (v8 == v7)
    v9 = a1 + 1200;
  else
    v9 = v8 + 32;
  if ((*(_BYTE *)(v9 + 48) & 2) != 0)
  {
    v10 = sub_100023BE0(a1);
    if (v10)
      v11 = v10;
    else
      v11 = a1 + 1040;
    if (v11 == v7)
      v12 = a1 + 1200;
    else
      v12 = v11 + 32;
    v13 = sub_100044284(v12);
    v14 = sub_100023BE0(a1);
    if (v14)
      v15 = v14;
    else
      v15 = a1 + 1040;
    if (!v13)
    {
      if (v15 == v7)
        v23 = (_DWORD *)(a1 + 1200);
      else
        v23 = (_DWORD *)(v15 + 32);
      if (sub_10004423C(v23))
      {
        if (sub_10001DDE4(a1))
          goto LABEL_30;
        if (*(int *)(a1 + 920) >= 31)
        {
          v24 = sub_100023BE0(a1);
          if (v24)
            v25 = v24;
          else
            v25 = a1 + 1040;
          *(_BYTE *)(v25 + 1) = 1;
        }
        if ((*(_BYTE *)(a1 + 1380) & 4) != 0)
          goto LABEL_30;
      }
      else
      {
        if (!sub_10001DE20(a1))
          goto LABEL_30;
        v26 = sub_100023BE0(a1);
        v27 = v26 ? v26 : a1 + 1040;
        v28 = v27 == v7 ? a1 + 1200 : v27 + 32;
        if ((*(_BYTE *)(v28 + 48) & 1) == 0)
          goto LABEL_30;
        v29 = sub_100023BE0(a1);
        if (v29)
          v35 = v29;
        else
          v35 = a1 + 1040;
        if (*(_DWORD *)(v35 + 4) > 2u)
        {
          sub_10001D418(a1, 5, "service exceeded successive crash limit. launch will be throttled", v30, v31, v32, v33, v34, v38);
          goto LABEL_30;
        }
        v36 = sub_100023BE0(a1);
        if (v36)
          v37 = v36;
        else
          v37 = a1 + 1040;
        *(_BYTE *)(v37 + 1) = 1;
      }
      v3 = 3;
      goto LABEL_4;
    }
    *(_BYTE *)(v15 + 1) = 1;
  }
LABEL_30:
  v16 = *(_QWORD *)(a1 + 136);
  if (!v16)
  {
LABEL_33:
    v17 = a1 + 672;
    while (1)
    {
      v17 = *(_QWORD *)v17;
      if (!v17)
        break;
      v18 = (*(uint64_t (**)(uint64_t, uint64_t))(v17 + 16))(a1, v17);
      if ((_DWORD)v18)
      {
        v3 = v18;
        goto LABEL_4;
      }
    }
LABEL_41:
    v3 = 0;
    goto LABEL_42;
  }
  while ((sub_10003AC90(v16) & 1) == 0)
  {
    v16 = *(_QWORD *)(v16 + 16);
    if (!v16)
      goto LABEL_33;
  }
  v3 = 8;
LABEL_4:
  if (byte_1000729D9)
  {
    v4 = &dword_1000715B0;
    v5 = 2;
    goto LABEL_39;
  }
  if (byte_100072A79)
  {
    v4 = &dword_100071590;
    v5 = 8;
LABEL_39:
    while (1)
    {
      v19 = *v4++;
      if (v19 == (_DWORD)v3)
        break;
      if (!--v5)
        goto LABEL_41;
    }
  }
LABEL_42:
  if ((*(_BYTE *)(a1 + 1380) & 4) != 0)
  {
    v20 = sub_100023BE0(a1);
    v21 = a1 + 1040;
    if (v20)
      v21 = v20;
    *(_BYTE *)(v21 + 1) = 1;
  }
  return v3;
}

BOOL sub_10001DDE4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_100023BE0(a1);
  if (v2)
    v3 = v2;
  else
    v3 = a1 + 1040;
  if (v3 == a1 + 1040)
    v4 = a1 + 1200;
  else
    v4 = v3 + 32;
  return sub_100044254(v4);
}

uint64_t sub_10001DE20(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = sub_100023BE0(a1);
  if (v2)
    v3 = v2;
  else
    v3 = a1 + 1040;
  if (v3 == a1 + 1040)
    v4 = a1 + 1200;
  else
    v4 = v3 + 32;
  return sub_10004419C(v4);
}

uint64_t sub_10001DE5C(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int *v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int *v17;
  char v19;

  v8 = a5;
  if (a2)
    sub_10001D418((uint64_t)a1, 4, "Overriding specified stdin path for inetd-compatible service.", a4, a5, a6, a7, a8, v19);
  v12 = (int *)dup(v8);
  if ((_DWORD)v12 != -1)
  {
    v13 = v12;
    if (a3)
    {
      v14 = 0xFFFFFFFFLL;
    }
    else
    {
      v14 = dup(v8);
      if ((_DWORD)v14 == -1)
      {
        v15 = *__error();
        v17 = v13;
        goto LABEL_15;
      }
    }
    if (a4)
    {
      v16 = -1;
LABEL_11:
      v15 = 0;
      a1[172] = (_DWORD)v13;
      a1[173] = v14;
      a1[174] = v16;
      return v15;
    }
    v16 = dup(v8);
    if (v16 != -1)
      goto LABEL_11;
    v15 = *__error();
    sub_10003BAF4(v13);
    if ((_DWORD)v14 == -1)
      return v15;
    v17 = (int *)v14;
LABEL_15:
    sub_10003BAF4(v17);
    return v15;
  }
  return *__error();
}

_QWORD *sub_10001DF50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v9;

  v8 = (_QWORD *)a1;
  if (*(_DWORD *)(a1 + 1152))
  {
    sub_10001D418(a1, 5, "Abandoning PID %d and its process group", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 1152));
    sub_100019580(v8);
    *(_QWORD *)((char *)v8 + 1188) |= 0x2000000000uLL;
    sub_10001DFE8((uint64_t)v8, 1);
    v9 = v8[172];
    sub_10001962C(v8);
    if ((v9 & 0x10000000) != 0)
      return 0;
  }
  return v8;
}

void sub_10001DFE8(uint64_t a1, char a2)
{
  uint64_t v4;
  uint64_t v5;
  __int16 v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  int *v15;
  __int128 *v16;
  char *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int v30;
  uint64_t *v31;
  char *v32;
  uint64_t v33;
  int v34;
  int v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void **v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  const char *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  _QWORD *v87;
  _QWORD *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _BYTE *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  _BYTE *v121;
  uint64_t i;
  int *v123;
  __uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  int v129;
  __int16 v130;
  int v131;
  const char *v132;
  uint64_t v133;
  uint64_t v134;
  __uint64_t v135;
  uint64_t v136;
  NSObject *v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  char v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char v148;
  char v149;
  char v150;
  char v151;
  char v152;
  unsigned int v153;
  unsigned int v154;
  unint64_t *v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  __int128 v175;
  __int128 v176;
  __int128 v177;
  __int128 v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;
  __int128 v183;
  __int128 v184;

  v4 = *(unsigned int *)(a1 + 1152);
  v156 = 0uLL;
  *(_QWORD *)&v157 = 0;
  v5 = sub_100040A84(v4, (uint64_t)&v156);
  if ((_DWORD)v5)
    v6 = -1;
  else
    v6 = WORD2(v156);
  if ((_DWORD)v5)
  {
    v7 = *(_DWORD *)(a1 + 1152);
    xpc_strerror(v5);
    sub_10001D418(a1, 4, "failed to query memory status priority for PID %d: %s (%d)", v8, v9, v10, v11, v12, v7);
  }
  if ((a2 & 1) == 0 && (*(_QWORD *)(a1 + 1376) & 0x10000) == 0)
  {
    v13 = killpg(*(_DWORD *)(a1 + 1152), 15);
    if (v13)
    {
      v14 = v13;
      if (*__error() != 3)
      {
        v15 = __error();
        if (v14 == -1 && *v15 != 1)
          sub_10004DE9C(a1);
      }
    }
  }
  if ((*(_BYTE *)(a1 + 1192) & 0x20) != 0)
  {
    sub_1000440B0(a1 + 1200);
    LODWORD(v19) = 0;
    LODWORD(v18) = 0;
    v17 = 0;
  }
  else
  {
    v183 = 0u;
    v184 = 0u;
    v181 = 0u;
    v182 = 0u;
    v179 = 0u;
    v180 = 0u;
    v177 = 0u;
    v178 = 0u;
    v175 = 0u;
    v176 = 0u;
    v173 = 0u;
    v174 = 0u;
    v171 = 0u;
    v172 = 0u;
    v169 = 0u;
    v170 = 0u;
    v167 = 0u;
    v168 = 0u;
    v165 = 0u;
    v166 = 0u;
    v163 = 0u;
    v164 = 0u;
    v161 = 0u;
    v162 = 0u;
    v159 = 0u;
    v160 = 0u;
    v157 = 0u;
    v158 = 0u;
    v156 = 0u;
    v16 = (__int128 *)(a1 + 1200);
    v17 = sub_1000439A4(a1 + 1200, *(_DWORD *)(a1 + 1152), (uint64_t)&v156);
    v18 = *((_QWORD *)&v173 + 1) >> 10;
    v19 = (unint64_t)v171 >> 10;
    if ((sub_100025080(a1) & 1) == 0)
    {
      v25 = sub_100023BE0(a1);
      v26 = v25 ? v25 : a1 + 1040;
      if (v26 != a1 + 1040 && (__int128 *)(v26 + 32) != v16 && *(_QWORD *)(a1 + 1232) > *(_QWORD *)(v26 + 64))
      {
        v27 = *v16;
        v28 = *(_OWORD *)(a1 + 1216);
        v29 = *(_OWORD *)(a1 + 1232);
        *(_QWORD *)(v26 + 80) = *(_QWORD *)(a1 + 1248);
        *(_OWORD *)(v26 + 48) = v28;
        *(_OWORD *)(v26 + 64) = v29;
        *(_OWORD *)(v26 + 32) = v27;
      }
    }
  }
  v30 = *(_DWORD *)(a1 + 1200);
  if (v30 == 2)
  {
    sub_10001D418(a1, 3, "wait4() failed", v20, v21, v22, v23, v24, v148);
  }
  else if (!v30)
  {
    sub_10004D738();
  }
  v31 = (uint64_t *)(a1 + 1188);
  if ((*(_BYTE *)(a1 + 1192) & 2) == 0)
  {
    if (*(_DWORD *)(a1 + 1200) == 1)
    {
      v32 = "abandoned xpcproxy before exec";
      v33 = a1;
      v34 = 4;
    }
    else
    {
      if (sub_100044038(a1 + 1200))
      {
        v35 = sub_100044064((_DWORD *)(a1 + 1200));
        v36 = v35;
        if (v35 != 78)
          sub_10001D418(a1, 4, "xpcproxy could not exec: %d: %s", v20, v21, v22, v23, v24, v35);
        v148 = v36;
        v32 = "xpcproxy exited due to exit(%d)";
      }
      else
      {
        v148 = (char)v17;
        v32 = "xpcproxy exited due to %s";
      }
      v33 = a1;
      v34 = 5;
    }
    sub_10001D418(v33, v34, v32, v20, v21, v22, v23, v24, v148);
  }
  if (sub_1000440CC(a1 + 1200))
    sub_10001D418(a1, 4, "removing service since it exited with consistent failure - %s", v37, v38, v39, v40, v41, (char)v17);
  sub_100011420(570425428, *(int *)(a1 + 1152));
  v42 = (void **)sub_1000106C8(0x80uLL);
  if (sub_100044038(a1 + 1200))
  {
    v149 = sub_100044064((_DWORD *)(a1 + 1200));
    sub_100010740((uint64_t)v42, "exited due to exit(%d)", v43, v44, v45, v46, v47, v48, v149);
  }
  else if (sub_10004410C((_DWORD *)(a1 + 1200)))
  {
    sub_100010740((uint64_t)v42, "exited due to %s", v49, v50, v51, v52, v53, v54, (char)v17);
  }
  else
  {
    v55 = *(_DWORD *)(a1 + 1204);
    if (v55)
      sub_100010740((uint64_t)v42, "exited with exit reason (namespace: %d code: 0x%llx) - %s", v49, v50, v51, v52, v53, v54, v55);
  }
  v56 = sub_10002EB24(*(_QWORD *)(a1 + 248));
  if (v56)
    sub_100010740((uint64_t)v42, " during %s", v57, v58, v59, v60, v61, v62, (char)v56);
  v63 = sub_10004409C(a1 + 1200);
  sub_100010740((uint64_t)v42, ", ran for %qums", v64, v65, v66, v67, v68, v69, v63 / 0xF4240);
  sub_10001D418(a1, 5, "%s", v70, v71, v72, v73, v74, (char)*v42);
  sub_100010718(v42);
  if ((~*(unsigned __int8 *)(a1 + 1248) & 3) == 0)
    sub_10001D418(a1, 5, "process exited in a dirty state", v75, v76, v77, v78, v79, v150);
  free(v17);
  if (*(_QWORD *)(a1 + 848))
  {
    sub_100019A44(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 848));
    dispatch_release(*(dispatch_object_t *)(a1 + 848));
    *(_QWORD *)(a1 + 848) = 0;
  }
  if (*(_QWORD *)(a1 + 856))
  {
    sub_100019A44(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 856));
    dispatch_release(*(dispatch_object_t *)(a1 + 856));
    *(_QWORD *)(a1 + 856) = 0;
  }
  if ((*(_BYTE *)(a1 + 1380) & 4) != 0)
  {
    if (sub_10004423C((_DWORD *)(a1 + 1200)))
      sub_100020AB4(a1, v80, v86, v81, v82, v83, v84, v85);
    v87 = *(_QWORD **)(a1 + 136);
    if (v87)
    {
      do
      {
        v88 = (_QWORD *)v87[2];
        sub_10003ACA8(v87);
        sub_10001962C(v87);
        v87 = v88;
      }
      while (v88);
    }
  }
  v89 = *v31;
  if ((*v31 & 0x200000000) == 0)
  {
    if (byte_100072A7A)
    {
      nullsub_23("xpcproxy exited before exec", v80);
      LOBYTE(v89) = *(_BYTE *)v31;
    }
    if ((_BYTE)v89)
    {
      v90 = 89;
    }
    else if (sub_1000442B0(a1 + 1200))
    {
      v90 = 80;
    }
    else if (sub_1000442DC((_DWORD *)(a1 + 1200)))
    {
      v90 = 162;
    }
    else
    {
      v90 = 153;
    }
    sub_1000250B4(a1, v90, 0, v81, v82, v83, v84, v85, v150);
  }
  if ((*(_BYTE *)(a1 + 1378) & 0x10) != 0)
  {
    sub_10001D418(a1, 5, "service only configured to run once, removing", v81, v82, v83, v84, v85, v150);
    *(_DWORD *)(a1 + 368) |= 0x10u;
  }
  else
  {
    sub_1000440CC(a1 + 1200);
  }
  if (sub_10004419C(a1 + 1200))
  {
    v91 = sub_100023BE0(a1);
    if (v91)
      v92 = v91;
    else
      v92 = a1 + 1040;
    ++*(_DWORD *)(v92 + 4);
    v93 = sub_100023BE0(a1);
    if (v93)
      v94 = v93;
    else
      v94 = a1 + 1040;
    v95 = *(_DWORD *)(v94 + 4);
    sub_100023BE0(a1);
    sub_10001D418(a1, 5, "service has crashed %u times in a row (last was%s dirty)", v96, v97, v98, v99, v100, v95);
    if (!sub_100044230(a1 + 1200))
      goto LABEL_97;
    sub_10001D418(a1, 5, "service has crashed into the shared cache area", v101, v102, v103, v104, v105, v151);
    v106 = (_BYTE *)sub_100023BE0(a1);
    v112 = *(_QWORD *)(a1 + 256);
    if (v106)
    {
      if (!v112)
      {
LABEL_92:
        v120 = sub_100023BE0(a1);
        if ((*(_BYTE *)(a1 + 1382) & 0x20) == 0)
        {
          if (v120)
            v121 = (_BYTE *)v120;
          else
            v121 = (_BYTE *)(a1 + 1040);
          *v121 = 1;
        }
        goto LABEL_97;
      }
    }
    else
    {
      if (!v112)
        goto LABEL_92;
      v106 = (_BYTE *)(v112 + 1040);
    }
    if ((*(_BYTE *)(v112 + 1382) & 0x20) == 0)
    {
      *v106 = 1;
      sub_10001D418(a1, 5, "recorded reslide request for this instance in the original service", v107, v108, v109, v110, v111, v152);
    }
    goto LABEL_92;
  }
  if (sub_100025080(a1))
  {
    sub_10001D418(a1, 5, "skipping successive crash reset", v113, v114, v115, v116, v117, v150);
  }
  else
  {
    v118 = sub_100023BE0(a1);
    v119 = a1 + 1040;
    if (v118)
      v119 = v118;
    *(_DWORD *)(v119 + 4) = 0;
  }
LABEL_97:
  for (i = 688; i != 700; i += 4)
  {
    v123 = (int *)*(unsigned int *)(a1 + i);
    if ((_DWORD)v123 != -1)
    {
      sub_10003BAF4(v123);
      *(_DWORD *)(a1 + i) = -1;
    }
  }
  sub_100023D28(a1, 8);
  if (*(_BYTE *)(a1 + 424) != 8)
    sub_10004D738();
  if (sub_10004423C((_DWORD *)(a1 + 1200)) && !sub_100044254(a1 + 1200))
  {
    if (!*(_QWORD *)(a1 + 976))
      *(_QWORD *)(a1 + 976) = sub_10001CFDC();
    v124 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
    sub_10001D02C(*(_QWORD **)(a1 + 976), v124 / 0xF4240);
  }
  if (*(_BYTE *)(a1 + 424) != 8)
    sub_10004D738();
  v153 = v19;
  v154 = v18;
  v125 = *(unsigned int *)(a1 + 1152);
  v126 = *v31;
  if (*(_QWORD *)(a1 + 256))
    v127 = *(_QWORD *)(a1 + 256);
  else
    v127 = a1;
  v128 = *(_QWORD *)(a1 + 976);
  v155 = (unint64_t *)(a1 + 1188);
  if (v128 && (v129 = sub_10001D034(v128)) != 0)
  {
    v130 = v6;
    v131 = sub_10001D03C(*(_QWORD *)(a1 + 976), v129 - 1);
  }
  else
  {
    v130 = v6;
    v131 = -1;
  }
  v132 = (const char *)(v127 + 1392);
  if (sub_100044038(a1 + 1200))
  {
    v133 = 0;
    v134 = (int)sub_100044064((_DWORD *)(a1 + 1200));
  }
  else
  {
    v133 = *(unsigned int *)(a1 + 1204);
    v134 = *(_QWORD *)(a1 + 1208);
  }
  v135 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
  v136 = sub_100003B4C(v125);
  if (!v136)
    sub_100040F68(4, "No spawn timestamp found; service=%s, pid=%d", v132, v125);
  *(_QWORD *)&v156 = _NSConcreteStackBlock;
  *(_QWORD *)&v157 = sub_1000251B0;
  *((_QWORD *)&v157 + 1) = &unk_10006C6A8;
  *((_QWORD *)&v156 + 1) = 0x40000000;
  *((_QWORD *)&v160 + 1) = __PAIR64__(v131, v125);
  *(_QWORD *)&v158 = v132;
  *((_QWORD *)&v158 + 1) = v136;
  *(_QWORD *)&v159 = v135 / 0xF4240;
  *((_QWORD *)&v159 + 1) = v133;
  *(_QWORD *)&v160 = v134;
  *(_QWORD *)&v161 = __PAIR64__(v154, v153);
  DWORD2(v161) = v126 >> 8;
  WORD6(v161) = v130;
  sub_100003D10((uint64_t)&v156);
  sub_100019580((void *)a1);
  sub_10001D2D4(a1, 5, 0);
  free(*(void **)(a1 + 1136));
  *(_QWORD *)(a1 + 1136) = 0;
  sub_100023D28(a1, 0);
  *(_DWORD *)(a1 + 1152) = 0;
  *(_DWORD *)(a1 + 1160) = 16;
  v137 = *(NSObject **)(a1 + 1168);
  if (v137)
  {
    dispatch_source_cancel(v137);
    dispatch_release(*(dispatch_object_t *)(a1 + 1168));
    *(_QWORD *)(a1 + 1168) = 0;
  }
  if (*(_QWORD *)(a1 + 1176))
  {
    sub_100019A44(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 1176));
    dispatch_release(*(dispatch_object_t *)(a1 + 1176));
    *(_QWORD *)(a1 + 1176) = 0;
  }
  v138 = *v155;
  v139 = *(_QWORD *)(a1 + 24);
  *(_DWORD *)(a1 + 1184) = 0;
  *v155 = v138 & 0xFFFFFE0000000000;
  if (v139)
    *(_QWORD *)(v139 + 32) = *(_QWORD *)(a1 + 32);
  **(_QWORD **)(a1 + 32) = v139;
  *(_QWORD *)(a1 + 24) = -1;
  *(_QWORD *)(a1 + 32) = -1;
  if ((*(_BYTE *)(a1 + 368) & 0x10) == 0 && (*(_BYTE *)(a1 + 1378) & 4) == 0)
  {
    v140 = sub_10001DB48(a1);
    if ((_DWORD)v140)
    {
      v141 = sub_10001D47C(a1, v140);
      if ((_DWORD)v141)
      {
        v142 = v141;
        if ((_DWORD)v141 != 36 && (_DWORD)v141 != 124)
        {
          xpc_strerror(v141);
          sub_10001D418(a1, 4, "Failed to respawn: %d: %s", v143, v144, v145, v146, v147, v142);
        }
      }
    }
  }
  if ((*(_BYTE *)(a1 + 368) & 0x10) == 0 && (*(_BYTE *)(a1 + 1378) & 4) != 0)
    sub_100023D28(a1, 1);
  sub_10001962C((void *)a1);
}

void sub_10001E9BC(uint64_t *a1)
{
  uint64_t v1;
  int data;
  int v3;

  v1 = *a1;
  data = dispatch_source_get_data(*(dispatch_source_t *)(*a1 + 1168));
  v3 = data;
  if ((data & 0x40000000) != 0)
  {
    ++*(_WORD *)(v1 + 1184);
    if ((data & 0x20000000) == 0)
    {
LABEL_3:
      if ((data & 0x80000000) == 0)
        return;
LABEL_7:
      sub_10001DFE8(v1, 0);
      return;
    }
  }
  else if ((data & 0x20000000) == 0)
  {
    goto LABEL_3;
  }
  sub_10001EA20(v1);
  if (v3 < 0)
    goto LABEL_7;
}

void sub_10001EA20(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  dispatch_time_t v8;
  NSObject *v9;
  char v10;
  char *v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  _OWORD buffer[3];
  _OWORD v20[6];
  __int128 v21;
  __int128 v22;
  __int128 v23;

  v22 = 0u;
  v23 = 0u;
  v21 = 0u;
  memset(v20, 0, sizeof(v20));
  memset(buffer, 0, sizeof(buffer));
  if (sub_10003FB84(*(_DWORD *)(a1 + 1152), buffer))
  {
    _os_assumes_log_ctx(sub_10001F174, a1);
    if ((*(_BYTE *)(a1 + 1192) & 2) != 0)
      goto LABEL_15;
LABEL_3:
    if (*(unsigned __int8 *)(a1 + 424) > 4u)
      return;
    sub_100023D28(a1, 4);
    *(_QWORD *)(a1 + 1188) |= 0x200000000uLL;
    if ((*(_BYTE *)(a1 + 1380) & 4) == 0)
      goto LABEL_14;
    if (byte_100072AC8)
    {
      v7 = *(_DWORD *)(a1 + 868);
      if (v7)
      {
        v8 = dispatch_time(0, 1000000000 * v7);
LABEL_13:
        v9 = sub_1000146E4();
        *(_QWORD *)(a1 + 856) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v9);
        sub_100019A20(a1);
        dispatch_set_context(*(dispatch_object_t *)(a1 + 856), (void *)a1);
        dispatch_source_set_timer(*(dispatch_source_t *)(a1 + 856), v8, 0xFFFFFFFFFFFFFFFFLL, 0);
        dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 856), (dispatch_function_t)sub_1000251FC);
        dispatch_activate(*(dispatch_object_t *)(a1 + 856));
LABEL_14:
        sub_10001D2D4(a1, 4, 0);
        sub_100024C88(a1);
        v10 = sub_1000213F0(a1);
        v11 = sub_100023994(*(_DWORD *)(a1 + 1160));
        v12 = sub_100015630("%s", v11);
        sub_10001D418(a1, 5, "Successfully spawned %s[%d] because %s", v13, v14, v15, v16, v17, v10);
        free(v12);
        goto LABEL_15;
      }
      sub_10001D418(a1, 4, "Skipping extension launch watchdog", v2, v3, v4, v5, v6, v18);
    }
    v8 = -1;
    goto LABEL_13;
  }
  *(_QWORD *)(a1 + 1144) = *((_QWORD *)&v21 + 1);
  if ((*(_BYTE *)(a1 + 1192) & 2) == 0)
    goto LABEL_3;
  free(*(void **)(a1 + 1136));
  *(_QWORD *)(a1 + 1136) = sub_10001544C((const char *)v20);
LABEL_15:
  ++*(_WORD *)(a1 + 1186);
}

uint64_t sub_10001EC4C(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, const char *a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v16;
  int v17;
  char *v19[2];
  uuid_t uu;

  memset(uu, 0, sizeof(uu));
  v16 = dyld_image_header_containing_address(v9);
  v17 = v16;
  if (!v16)
  {
    uuid_clear(uu);
    if (!a5)
      goto LABEL_3;
LABEL_5:
    sub_10003E208("Cannot setup an event for proxyless spawns!");
  }
  _dyld_get_image_uuid(v16, uu);
  if (a5)
    goto LABEL_5;
LABEL_3:
  v19[0] = 0;
  v19[1] = &a9;
  vasprintf(v19, a6, &a9);
  sub_10001ED58(*(_QWORD *)(a1 + 1256), v9 - v17, a4, uu, (int)a2, a3, (char)v19[0]);
  free(v19[0]);
  return a2;
}

void sub_10001ED58(uint64_t a1, int a2, int a3, unsigned __int8 *uu, uint64_t a5, uint64_t a6, char a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  char *v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  char *v21;
  size_t v22;
  int v23;
  const char *v24;
  char **v25;
  size_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  _OWORD *v41;
  _OWORD v42[8];
  char out[48];

  memset(out, 0, 37);
  uuid_unparse(uu, out);
  if (a5 <= 85)
  {
    if (a5 > 79)
    {
      if (a5 == 80)
      {
        v17 = "FairPlay decryption failed on binary.";
      }
      else
      {
        if (a5 != 85)
          goto LABEL_46;
        v17 = "Program specified by service is malformed.";
      }
    }
    else
    {
      if (a5 != 8)
      {
        if (a5 == 32)
        {
          v16 = *(_DWORD *)(a1 + 700);
          if ((v16 || (v27 = *(_QWORD *)(a1 + 256)) != 0 && (v16 = *(_DWORD *)(v27 + 700)) != 0) && v16 != -1)
          {
            v17 = "Service could not notify controller.";
LABEL_44:
            v28 = a1;
            v29 = 4;
            goto LABEL_45;
          }
        }
        goto LABEL_46;
      }
      v17 = "Program specified by service is not a Mach-O executable file.";
    }
LABEL_42:
    v28 = a1;
    v29 = 3;
LABEL_45:
    sub_10001D418(v28, v29, v17, v11, v12, v13, v14, v15, (char)v41);
    goto LABEL_46;
  }
  if ((unint64_t)(a5 - 114) < 2)
  {
    v18 = *(_DWORD *)(*(_QWORD *)(a1 + 248) + 56);
    xpc_strerror(a6);
    LOBYTE(v41) = a6;
    if (v18)
      v17 = "Could not find uid associated with service: %d: %s %u";
    else
      v17 = "Could not find user/group associated with service: %d: %s %s/%s";
    goto LABEL_44;
  }
  if (a5 == 86)
  {
    v19 = *(_QWORD *)(a1 + 904);
    if (v19)
    {
      memset(v42, 0, sizeof(v42));
      if (xpc_binprefs_count(v19))
      {
        v20 = 0;
        v21 = (char *)v42;
        v22 = 128;
        do
        {
          v23 = xpc_binprefs_cpu_type(v19, v20);
          if (v22 < 2)
          {
            v26 = 0;
          }
          else
          {
            v24 = "(invalid)";
            if ((v23 & 0xFEFFFFFF) - 1 <= 0x11)
            {
              v25 = &off_10006C6C8[v23 & 0xFEFFFFFF];
              if ((v23 & 0x1000000) == 0)
                v25 = &off_10006C760[v23];
              v24 = *v25;
            }
            v26 = snprintf(v21, v22, "%u:%s ", v23, v24);
            if (v22 <= v26)
              v26 = v22 - 1;
          }
          v21 += v26;
          v22 -= v26;
          ++v20;
        }
        while (v20 < xpc_binprefs_count(v19));
      }
      v41 = v42;
      v17 = "Program specified by service does not contain one of the requested architectures: %s";
    }
    else
    {
      v17 = "Program specified by service does not contain any valid architectures for this system.";
    }
    goto LABEL_42;
  }
  if (a5 == 111)
  {
    if ((int)a6 >= 1)
    {
      if ((_DWORD)a6 == 75)
      {
        v17 = "LaunchServices returned a bundle URL that does not match with the LoginItem's known association.";
      }
      else
      {
        xpc_strerror(a6);
        sub_10001CFB8(a1);
        LOBYTE(v41) = a6;
        v17 = "Could not find and/or execute program specified by service: %d: %s: %s";
      }
      goto LABEL_44;
    }
    if ((a6 & 0x80000000) != 0)
    {
      LOBYTE(v41) = a6;
      sub_10001CFB8(a1);
      v17 = "Could not resolve CFBundleIdentifier specified by service: %d: %s";
      goto LABEL_44;
    }
  }
LABEL_46:
  xpc_strerror(a5);
  sub_10001D418(a1, 3, "Service could not initialize: %s, error 0x%llx - %s", v30, v31, v32, v33, v34, a7);
  v35 = sub_100011030();
  sub_10001D418(a1, 3, "initialization failure: %s: %s + %llu [%llu][%s]: 0x%llx", v36, v37, v38, v39, v40, v35);
}

uint64_t sub_10001F090()
{
  return 0;
}

void sub_10001F098(uint64_t a1, xpc_object_t object)
{
  xpc_object_t v4;
  void *v5;
  size_t length;
  void *v7;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v4 = sub_100011648(1, 0, object);
    v5 = (void *)sub_1000116F4(v4);
    length = xpc_data_get_length(v5);
    v7 = sub_10001389C(length);
    if (xpc_data_get_bytes(v5, v7, 0, length) != length)
      _os_assumes_log_ctx(sub_10001F174, a1);
    *(_QWORD *)(a1 + 616) = v7;
    *(_DWORD *)(a1 + 624) = length;
    *(_QWORD *)(a1 + 592) += length;
    xpc_release(v4);
    xpc_release(v5);
  }
}

uint64_t sub_10001F174(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10001D418(a2, 3, "%s", a4, a5, a6, a7, a8, a3);
  return 1;
}

_QWORD *sub_10001F1A8(_QWORD *result, xpc_object_t object)
{
  _QWORD *v3;
  void *v4;
  size_t length;
  void *v6;

  if (object)
  {
    v3 = result;
    result = xpc_get_type(object);
    if (result == (_QWORD *)&_xpc_type_data)
    {
      v4 = (void *)v3[75];
      if (v4)
      {
        free(v4);
        v3[74] -= *((unsigned int *)v3 + 152);
      }
      length = xpc_data_get_length(object);
      v6 = sub_10001389C(length);
      result = (_QWORD *)xpc_data_get_bytes(object, v6, 0, length);
      if (result != (_QWORD *)length)
        result = (_QWORD *)_os_assumes_log_ctx(sub_10001F174, v3);
      v3[75] = v6;
      *((_DWORD *)v3 + 152) = length;
      v3[74] += length;
    }
  }
  return result;
}

char *sub_10001F264(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char **v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  char *v26;

  if ((a2 - 1) >= 2)
    sub_10004D738();
  v10 = (const char **)sub_1000106C8(0x40uLL);
  v11 = *(_QWORD *)(a1 + 248);
  if (v11)
  {
    v12 = sub_100028C98(v11, 1);
    sub_100010740((uint64_t)v10, "%s/", v13, v14, v15, v16, v17, v18, (char)v12);
    free(v12);
  }
  sub_100010740((uint64_t)v10, "%s", v4, v5, v6, v7, v8, v9, a1 + 112);
  if (a2 == 2)
  {
    v25 = *(_DWORD *)(a1 + 296);
    if (v25 > 0 || (v25 = *(_DWORD *)(a1 + 1152), v25 >= 1))
      sub_100010740((uint64_t)v10, " [%d]", v19, v20, v21, v22, v23, v24, v25);
  }
  v26 = sub_100010710(v10);
  sub_100010718((void **)v10);
  return v26;
}

_DWORD *sub_10001F344()
{
  sub_10004454C(2, (uint64_t)sub_10001F370);
  return sub_10004454C(6, (uint64_t)sub_10001F638);
}

uint64_t sub_10001F370(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  __int128 *v16;
  char v17;
  unsigned int v18;

  v18 = -1;
  v7 = sub_10002530C(a3, (int *)&v18);
  if (v18 == 36)
  {
    sub_100044D8C(a3, "domain deferral", v8, v9, v10, v11, v12, v13, v17);
    return 0;
  }
  v14 = v7;
  if (v7)
  {
    if (*(_BYTE *)(v7 + 424) == 2)
    {
      sub_10001D418(v7, 5, "Deferring IPC (%d) while service is spawning", v9, v10, v11, v12, v13, a2);
      sub_10002555C(v14, a3, 1);
      return 0;
    }
    v16 = sub_100044524();
    result = 45;
    switch(a2)
    {
      case 700:
        result = sub_1000255C0(v14, (uint64_t)v16, a3, a4);
        break;
      case 701:
        result = sub_100025878(v14, (uint64_t)v16, a3, a4);
        break;
      case 702:
        result = sub_100025A40(v14, (uint64_t)v16, a3, a4);
        break;
      case 703:
        result = sub_100025C48(v14, (uint64_t)v16, a3, a4);
        break;
      case 704:
        return sub_100025E90(v14, (uint64_t)v16, a3, a4);
      case 705:
        result = sub_100026358(v14, (uint64_t)v16, a3, a4);
        break;
      case 706:
        result = sub_100026630(v14, (uint64_t)v16, (uint64_t)a3);
        break;
      case 707:
        result = sub_10002669C(v14, (uint64_t)v16, a3, a4);
        break;
      case 708:
        result = sub_100026770(v14, (uint64_t)v16, a3, a4);
        break;
      case 710:
        result = sub_100026830(v14, (uint64_t)v16, a3, a4);
        break;
      case 711:
        result = sub_100026904(v14, (uint64_t)v16, a3, a4);
        break;
      case 712:
        result = sub_1000269FC(v14, (uint64_t)v16, a3, a4);
        break;
      case 713:
        result = sub_100026ABC(v14, (uint64_t)v16, a3, a4);
        break;
      case 715:
        result = sub_100026CE4(v14, (uint64_t)v16, a3, a4);
        break;
      case 716:
        result = sub_100026EC8(v14, (uint64_t)v16, a3, a4);
        break;
      case 717:
      case 724:
        return result;
      case 718:
        result = sub_100026FA0(v14, (uint64_t)v16, a3, a4);
        break;
      case 719:
        result = sub_100026B94(v14, (uint64_t)v16, a3, a4);
        break;
      case 720:
        result = sub_100027068(v14, a3, a4);
        break;
      case 721:
        result = sub_1000270D8(v14, v16, a3, a4);
        break;
      case 722:
        result = sub_1000271C0(v14, (uint64_t)v16, a3, a4);
        break;
      case 723:
        result = sub_1000272D0(v14, (uint64_t)v16, a3, a4);
        break;
      case 725:
        result = sub_100027380(v14, (uint64_t)v16, a3, a4);
        break;
      default:
        result = 33;
        break;
    }
  }
  else
  {
    sub_100044D8C(a3, "no service, code = %d", v8, v9, v10, v11, v12, v13, v18);
    result = v18;
    if (a2 == 704 && (v18 & 0xFFFFFFFE) == 0x70)
    {
      v16 = sub_100044524();
      return sub_100025E90(v14, (uint64_t)v16, a3, a4);
    }
  }
  return result;
}

uint64_t sub_10001F638(uint64_t a1, int a2, void *a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  xpc_object_t v11;
  int v12;
  int64_t v13;
  xpc_object_t v14;
  char *i;
  char *v16;
  uint64_t uint64;
  uint64_t v18;
  xpc_object_t value;
  void *v20;
  unint64_t v21;
  xpc_object_t reply;
  xpc_object_t v23;
  unsigned int v25;

  dword_100071E88 = *((_DWORD *)sub_100044524() + 5);
  qword_100071E58 = sub_10002E190();
  v25 = -1;
  v7 = sub_10002530C(a3, (int *)&v25);
  v8 = v25;
  if (v25 == 36)
    return 0;
  v9 = (_QWORD *)v7;
  if (a2 == 301 && v25 == 135)
  {
    v9 = &unk_100071D60;
  }
  else
  {
    if (!v7)
      return v8;
    v8 = 45;
    if ((a2 - 302) < 8 || a2 == 300)
      return v8;
    if (a2 != 301)
      return 33;
  }
  v10 = v9[31];
  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  v8 = 45;
  v11 = 0;
  switch(xpc_dictionary_get_uint64(a3, "outgsk"))
  {
    case 0uLL:
      goto LABEL_55;
    case 1uLL:
      if (*((_DWORD *)v9 + 74))
        goto LABEL_43;
      v12 = *((_DWORD *)v9 + 300);
      if (v12 == 2)
      {
        v13 = 11;
      }
      else if (v12)
      {
        v13 = *((int *)v9 + 307);
      }
      else
      {
LABEL_18:
        v13 = 0;
      }
      goto LABEL_53;
    case 3uLL:
      v13 = getuid();
      goto LABEL_53;
    case 4uLL:
      v13 = getpid();
      goto LABEL_53;
    case 6uLL:
      if ((_UNKNOWN *)sub_10002E360(v10) == &unk_1000715B8 || sub_10003E3D8(v10))
      {
        v14 = xpc_string_create("System");
        goto LABEL_54;
      }
      v8 = 125;
      goto LABEL_44;
    case 7uLL:
      if (*((_DWORD *)v9 + 74))
        goto LABEL_43;
      v13 = (v9[172] >> 2) & 1;
      goto LABEL_53;
    case 8uLL:
      if (*((_DWORD *)v9 + 74))
        goto LABEL_43;
      v13 = *((unsigned int *)v9 + 220);
      goto LABEL_53;
    case 9uLL:
      goto LABEL_18;
    case 0xAuLL:
      if (*((_DWORD *)v9 + 74))
        goto LABEL_43;
      v13 = *((unsigned int *)v9 + 208);
      goto LABEL_53;
    case 0xBuLL:
      if (*((_DWORD *)v9 + 74))
        goto LABEL_43;
      v11 = xpc_dictionary_create(0, 0, 0);
      for (i = (char *)v9[126]; i; i = *(char **)i)
      {
        v16 = strrchr(i + 32, 61);
        *v16 = 0;
        xpc_dictionary_set_string(v11, i + 32, v16 + 1);
        *v16 = 61;
      }
      goto LABEL_55;
    case 0xCuLL:
    case 0x18uLL:
    case 0x1AuLL:
      v8 = 126;
      goto LABEL_44;
    case 0xDuLL:
      v13 = 32;
      goto LABEL_53;
    case 0xEuLL:
      if (*((_DWORD *)v9 + 74))
        goto LABEL_43;
      if ((*((_BYTE *)v9 + 1380) & 1) == 0)
      {
        v8 = 3;
        goto LABEL_44;
      }
      v13 = *((unsigned __int16 *)v9 + 408);
      goto LABEL_53;
    case 0xFuLL:
      if (*((_DWORD *)v9 + 74))
        goto LABEL_43;
      v13 = (v9[172] >> 16) & 1;
      goto LABEL_53;
    case 0x10uLL:
      if (*((_DWORD *)v9 + 74))
        goto LABEL_43;
      v13 = (v9[172] >> 8) & 1;
      goto LABEL_53;
    case 0x12uLL:
      if (!*((_DWORD *)v9 + 74))
      {
        v13 = (v9[172] >> 11) & 1;
LABEL_53:
        v14 = xpc_int64_create(v13);
LABEL_54:
        v11 = v14;
LABEL_55:
        uint64 = xpc_dictionary_get_uint64(a3, "ingsk");
        if (uint64)
        {
          if (*((_DWORD *)v9 + 74))
          {
            v8 = 135;
LABEL_58:
            if (v11)
              xpc_release(v11);
            return v8;
          }
          v18 = uint64;
          value = xpc_dictionary_get_value(a3, "in");
          if (value)
          {
            v8 = 45;
            v20 = value;
            switch(v18)
            {
              case 2uLL:
              case 0xDuLL:
                break;
              case 7uLL:
                if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
                  goto LABEL_76;
                v21 = v9[172] & 0xFFFFFFFFFFFFFFFBLL | (4 * (xpc_int64_get_value(v20) != 0));
                goto LABEL_75;
              case 8uLL:
                if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
                  goto LABEL_76;
                if (*((_DWORD *)v9 + 288))
                {
                  if (v9[109])
                    sub_10004D738();
                  *((_DWORD *)v9 + 220) = xpc_int64_get_value(v20);
                }
                break;
              case 0xAuLL:
                if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
                  goto LABEL_76;
                *((_DWORD *)v9 + 208) = xpc_int64_get_value(v20);
                break;
              case 0xEuLL:
                if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
                  goto LABEL_76;
                v9[172] |= (unint64_t)&_mh_execute_header;
                *((_WORD *)v9 + 408) = xpc_int64_get_value(v20);
                break;
              case 0xFuLL:
                if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
                {
LABEL_76:
                  v8 = 22;
                  goto LABEL_58;
                }
                v21 = v9[172] & 0xFFFFFFFFFFFEFFFFLL | ((unint64_t)(xpc_int64_get_value(v20) != 0) << 16);
LABEL_75:
                v9[172] = v21;
                break;
              case 0x10uLL:
                if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64 && xpc_int64_get_value(v20))
                  v9[172] |= 0x100uLL;
                break;
              case 0x11uLL:
              case 0x12uLL:
              case 0x16uLL:
              case 0x17uLL:
                v8 = 126;
                goto LABEL_58;
              default:
                goto LABEL_58;
            }
          }
        }
        reply = xpc_dictionary_create_reply(a3);
        v23 = reply;
        if (v11)
        {
          xpc_dictionary_set_value(reply, "out", v11);
          xpc_release(v11);
        }
        v8 = 0;
        *a4 = v23;
        return v8;
      }
LABEL_43:
      v8 = 135;
LABEL_44:
      if (xpc_dictionary_get_uint64(a3, "ingsk"))
      {
        if (*((_DWORD *)v9 + 74))
          return 135;
        else
          return v8;
      }
      return v8;
    default:
      goto LABEL_44;
  }
}

uint64_t sub_10001FAFC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return (*(unsigned __int8 *)(a1 + 1381) >> 1) & 1;
}

uint64_t sub_10001FB38(int a1)
{
  uint64_t result;

  result = sub_10001FB78(a1);
  if (!result)
  {
    result = sub_10001FBF0(a1);
    if (result)
      return sub_10001FB78(a1);
  }
  return result;
}

uint64_t sub_10001FB78(int a1)
{
  uint64_t result;
  int v2;

  v2 = a1;
  for (result = qword_1000722D0[sub_1000158C8(&v2, 4) % 0x35uLL]; result; result = *(_QWORD *)(result + 24))
  {
    if (*(_DWORD *)(result + 1152) == v2)
      break;
  }
  return result;
}

uint64_t sub_10001FBF0(int a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  sub_10001472C();
  if (!a1)
    return 0;
  __dmb(9u);
  v7 = qword_100071D58;
  if (!qword_100071D58)
    return 0;
  while (*(_DWORD *)(v7 + 1156) != a1)
  {
    v7 = *(_QWORD *)(v7 + 24);
    if (!v7)
      return 0;
  }
  if (*(_BYTE *)(v7 + 424) != 2)
    sub_10004D738();
  sub_10001D418(v7, 5, "speculatively converting service to spawned, pid=%d", v2, v3, v4, v5, v6, a1);
  return sub_10001FC8C(v7, a1, 0, 1, v9, v10, v11, v12);
}

uint64_t sub_10001FC8C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  char v21;
  const char *v22;
  int v23;
  uint64_t *v24;
  uint64_t v25;
  uintptr_t v26;
  NSObject *v27;
  dispatch_source_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int v73;
  char *v74;
  unsigned int *v75;
  uint64_t v76;
  uint64_t v77;
  unsigned __int8 *v78;
  int v80;
  uint64_t v81;
  __uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  char v96;
  char v97;
  char v98;
  uint64_t v99;
  unsigned __int8 *v100;
  unsigned int *v101;

  v8 = a4;
  v11 = a1;
  if ((*(_BYTE *)(a1 + 1192) & 0x80) != 0)
    v12 = "xpcproxy";
  else
    v12 = "service";
  if (*(_BYTE *)(a1 + 424) != 2)
  {
    sub_10001D418(a1, 5, "spawn completed after a speculative conversion", a4, a5, a6, a7, a8, v96);
    if ((_DWORD)a3)
      sub_10003E208("speculatively converted service to spawned, but spawn failed with error %d", a3);
    if (*(_DWORD *)(v11 + 1156) != a2)
      sub_10004D738();
    v23 = *(_DWORD *)(v11 + 1152);
    if (v23 && v23 != a2)
      sub_10003E208("speculatively converted service to spawned with PID %d, but the PID is %d", *(_DWORD *)(v11 + 1152), a2);
    if (v8)
      sub_10004D738();
    sub_10001D2D4(v11, 8, 0);
    return v11;
  }
  v13 = *(int *)(a1 + 1160);
  sub_100014714();
  v20 = (_QWORD *)(v11 + 24);
  v19 = *(_QWORD *)(v11 + 24);
  if (v19)
    *(_QWORD *)(v19 + 32) = *(_QWORD *)(v11 + 32);
  **(_QWORD **)(v11 + 32) = v19;
  *v20 = -1;
  *(_QWORD *)(v11 + 32) = -1;
  if ((_DWORD)a3)
  {
    if ((*(_BYTE *)(v11 + 1192) & 0x80) != 0)
    {
      v21 = (char)off_100071A80[0];
      v22 = "trampoline";
    }
    else
    {
      v21 = sub_10001CFB8(v11);
      v22 = "service";
    }
    v46 = *(_DWORD *)(v11 + 1160);
    if (a3 <= 0xD && ((1 << a3) & 0x2104) != 0)
    {
      v47 = *(_QWORD *)(v11 + 1376);
      if ((v47 & 0x2000000000000) == 0)
      {
        *(_QWORD *)(v11 + 1384) = *(_QWORD *)(v11 + 1384);
        *(_QWORD *)(v11 + 1376) = v47 | 0x2000000000000;
        strerror(a3);
        sub_10001D418(v11, 5, "Remove ability to use bypass the proxy: spawn failed: %d: %s", v48, v49, v50, v51, v52, a3);
      }
    }
    strerror(a3);
    sub_10001D418(v11, 5, "%s spawn failed: %d: %s", v53, v54, v55, v56, v57, (char)v22);
    sub_100019580((void *)v11);
    sub_10001D2D4(v11, 1, (int)a3);
    strerror(a3);
    sub_10001D418(v11, 3, "Could not spawn process %s: %d: %s", v58, v59, v60, v61, v62, v21);
    if ((*(_BYTE *)(v11 + 1379) & 0x10) == 0)
    {
      sub_10001962C((void *)v11);
      sub_100023D28(v11, 0);
      if ((*(_BYTE *)(v11 + 1192) & 0x80) != 0)
      {
        if ((*(_DWORD *)(v11 + 368) & 0x10) != 0)
          sub_10004DED0(*(_DWORD *)(v11 + 368) & 0x10);
        v73 = sub_10001D950(v11);
        sub_1000248C8(v11, v73, v46);
      }
      sub_1000250B4(v11, a3, 0, v68, v69, v70, v71, v72, v98);
      goto LABEL_51;
    }
    sub_10001D418(v11, 3, "Removed service on spawn failure", v63, v64, v65, v66, v67, v98);
    sub_100023D28(v11, 0);
    sub_10001962C((void *)v11);
    return 0;
  }
  *(_DWORD *)(v11 + 1152) = a2;
  sub_10001D418(v11, 5, "%s spawned with pid %d", v14, v15, v16, v17, v18, (char)v12);
  sub_100011420(570425348, *(int *)(v11 + 1152));
  j__kdebug_trace(570425416, *(int *)(v11 + 1152), v13, 0, 0);
  v24 = &qword_1000722D0[sub_1000158C8((_BYTE *)(v11 + 1152), 4) % 0x35uLL];
  v25 = *v24;
  *(_QWORD *)(v11 + 24) = *v24;
  if (v25)
    *(_QWORD *)(v25 + 32) = v20;
  *v24 = v11;
  *(_QWORD *)(v11 + 32) = v24;
  v26 = *(int *)(v11 + 1152);
  v27 = sub_1000146E4();
  v28 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v26, 0xE0000000uLL, v27);
  *(_QWORD *)(v11 + 1168) = v28;
  v29 = sub_10001952C((void *)v11, 26, (uint64_t)v28, 0);
  dispatch_set_context(*(dispatch_object_t *)(v11 + 1168), v29);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(v11 + 1168), (dispatch_function_t)sub_10001E9BC);
  dispatch_source_set_registration_handler_f(*(dispatch_source_t *)(v11 + 1168), (dispatch_function_t)sub_100027748);
  dispatch_source_set_mandatory_cancel_handler_f(*(_QWORD *)(v11 + 1168), sub_100027784);
  dispatch_activate(*(dispatch_object_t *)(v11 + 1168));
  if ((*(_BYTE *)(v11 + 1377) & 0x80) != 0)
  {
    v35 = *(_QWORD *)(v11 + 192);
    if (!v35)
    {
      v74 = "inetd-compatible service with no sockets.";
LABEL_42:
      sub_10001D418(v11, 3, v74, v30, v31, v32, v33, v34, v97);
      goto LABEL_43;
    }
    v100 = 0;
    v101 = 0;
    v99 = 0;
    v36 = sub_10001BEB4(v35, &v101, &v100, &v99);
    if ((_DWORD)v36)
    {
      v40 = v36;
      xpc_strerror(v36);
      sub_10001D418(v11, 3, "Could not activate inetd socket: %d: %s", v41, v42, v43, v44, v45, v40);
      goto LABEL_43;
    }
    v75 = v101;
    v76 = *v101;
    v77 = v99;
    if (v99)
    {
      v78 = v100;
      while (!*v78++)
      {
        ++v75;
        if (!--v77)
          goto LABEL_40;
      }
      v76 = *v75;
    }
LABEL_40:
    v80 = sub_10001DE5C((_DWORD *)v11, *(_QWORD *)(v11 + 448), *(_QWORD *)(v11 + 456), *(_QWORD *)(v11 + 464), v76, v37, v38, v39);
    if (v80)
    {
      v97 = v80;
      strerror(v80);
      v74 = "Could not setup inetd descriptors: %d: %s";
      goto LABEL_42;
    }
  }
LABEL_43:
  sub_10001D2D4(v11, 1, 0);
  if (*(_BYTE *)(v11 + 424) != 2)
    sub_10004D738();
  sub_100023D28(v11, 3);
  if (*(_BYTE *)(v11 + 424) != 3)
    sub_10004D738();
  v81 = *(unsigned int *)(v11 + 1152);
  v82 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
  sub_100003A4C(v81, v82 / 0xF4240);
  if ((*(_BYTE *)(v11 + 1192) & 0x80) == 0)
    sub_10001EA20(v11);
  if (v8)
    sub_10001D2D4(v11, 7, 0);
  if ((*(_BYTE *)(v11 + 1193) & 1) != 0)
  {
    sub_10001D418(v11, 5, "redriving pending stop", v83, v84, v85, v86, v87, v97);
    v88 = sub_10000DA1C();
    sub_1000204AC(v11, v88, v89, v90, v91, v92, v93, v94);
LABEL_51:
    *(_QWORD *)(v11 + 1188) &= ~0x10000000000uLL;
  }
  return v11;
}

uint64_t sub_1000201F0(uint64_t result)
{
  uint64_t v1;

  v1 = result;
  if (*(_DWORD *)(result + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(result + 296), (const char *)(result + 1392));
  if (!*(_DWORD *)(result + 1152) && (*(_BYTE *)(result + 368) & 0x10) == 0)
  {
    result = sub_10001DB48(result);
    if ((_DWORD)result)
      return sub_10001D47C(v1, result);
  }
  return result;
}

uint64_t sub_100020264(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*(_BYTE *)(a1 + 424) == 1)
    sub_1000202C0(a1, 1);
  v4 = sub_100023BE0(a1);
  v11 = a1 + 1040;
  if (v4)
    v11 = v4;
  *(_BYTE *)(v11 + 1) = 1;
  return sub_1000203B0(a1, a2, v5, v6, v7, v8, v9, v10);
}

void sub_1000202C0(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  dispatch_semaphore_t *v16;
  char *v17;
  _QWORD *v18;
  _QWORD *v19;
  char v20;

  if (*(_BYTE *)(a1 + 424) != 1)
    sub_10004D738();
  sub_100023D28(a1, 0);
  if ((*(_BYTE *)(a1 + 1378) & 4) != 0)
  {
    v18 = *(_QWORD **)(a1 + 136);
    if (v18)
    {
      do
      {
        v19 = (_QWORD *)v18[2];
        if (sub_10003AC9C((uint64_t)v18))
        {
          sub_10003ACA8(v18);
          sub_10001962C(v18);
        }
        v18 = v19;
      }
      while (v19);
    }
    if (a2)
      *(_QWORD *)(a1 + 1376) &= ~0x40000uLL;
    v17 = "canceling penalty-box spawn";
    goto LABEL_14;
  }
  v9 = *(NSObject **)(a1 + 824);
  if (v9)
  {
    dispatch_source_cancel(v9);
    *(_QWORD *)(a1 + 824) = 0;
    *(_DWORD *)(a1 + 820) = 0;
    v16 = *(dispatch_semaphore_t **)(a1 + 840);
    if (v16)
    {
      sub_100004478(v16);
      *(_QWORD *)(a1 + 840) = 0;
    }
    sub_100024BA0(a1, 0, v10, v11, v12, v13, v14, v15);
    v17 = "canceling throttled spawn";
LABEL_14:
    sub_10001D418(a1, 5, v17, v4, v5, v6, v7, v8, v20);
  }
  sub_10001D2D4(a1, 1, 89);
}

uint64_t sub_1000203B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char v12;

  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  if ((_DWORD)a2 == 11)
  {
    v10 = *(_QWORD *)(a1 + 1376);
    if ((v10 & 0x40000) == 0)
      sub_10003E208("retry launch on service that was not deferred");
    *(_QWORD *)(a1 + 1384) = *(_QWORD *)(a1 + 1384);
    *(_QWORD *)(a1 + 1376) = v10 & 0xFFFFFFFFFFFBFFFFLL;
    sub_10001D418(a1, 5, "retry launch", a4, a5, a6, a7, a8, v12);
  }
  else if (*(unsigned __int8 *)(a1 + 424) - 1 <= 1)
  {
    sub_10001D418(a1, 5, "launch already in progress", a4, a5, a6, a7, a8, v12);
    return 36;
  }
  if ((*(_BYTE *)(a1 + 1378) & 4) != 0)
  {
    sub_10001D418(a1, 5, "attempt to launch while in penalty box", a4, a5, a6, a7, a8, v12);
    return 139;
  }
  else if (*(_DWORD *)(a1 + 1152))
  {
    return 37;
  }
  else
  {
    return sub_10001D47C(a1, a2);
  }
}

uint64_t sub_1000204AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;

  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  if ((*(_BYTE *)(a1 + 368) & 0x10) != 0)
  {
    v10 = *(_QWORD **)(a1 + 144);
    if (v10)
    {
      do
      {
        v11 = (_QWORD *)v10[2];
        sub_10003A788((uint64_t)v10);
        sub_10001962C(v10);
        v10 = v11;
      }
      while (v11);
    }
  }
  v12 = *(unsigned __int8 *)(a1 + 424);
  if (v12 == 1)
  {
    sub_1000202C0(a1, 0);
    return 89;
  }
  if (!*(_DWORD *)(a1 + 1152))
  {
    if (v12 == 2)
    {
      sub_10001D418(a1, 5, "service spawning, defer stopping", a4, a5, a6, a7, a8, v34);
      if (*(_DWORD *)(a1 + 1152))
        sub_10004D738();
      v26 = *(_QWORD *)(a1 + 1188);
      *(_QWORD *)(a1 + 1188) = v26 | 0x10000000000;
      if ((v26 & 0x10000000000) != 0)
        return 37;
      else
        return 36;
    }
    else
    {
      sub_10001D418(a1, 5, "service not running, not stopping", a4, a5, a6, a7, a8, v34);
      return 37;
    }
  }
  if (v12 == 7)
  {
    v15 = (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 536))(a1, *(_QWORD *)(a1 + 568));
    v13 = v15;
    if ((_DWORD)v15)
    {
      sub_10001D418(a1, 5, "cannot abandon languishing service: %d", v16, v17, v18, v19, v20, v15);
      xpc_strerror(v13);
      sub_10001D418(a1, 4, "Cannot abandon languishing service: %d: %s", v21, v22, v23, v24, v25, v13);
    }
    else
    {
      sub_10001D418(a1, 5, "abandoning languishing service", v16, v17, v18, v19, v20, v34);
      sub_10001DF50(a1, v27, v28, v29, v30, v31, v32, v33);
    }
    return v13;
  }
  return sub_100020658(a1, 0, a2, a4, a5, a6, a7, a8);
}

uint64_t sub_100020658(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  mach_error_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  int v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  const char *v28;
  int v29;
  char v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  void (__cdecl *v44)(void *);
  char v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  NSObject *v56;
  NSObject *v57;
  dispatch_time_t v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char v65;
  _OWORD v66[2];

  if (*(unsigned __int8 *)(a1 + 424) - 3 >= 2)
  {
    sub_10001D418(a1, 5, "service already stopped", a4, a5, a6, a7, a8, v65);
    return 37;
  }
  memset(v66, 0, sizeof(v66));
  v9 = *(_DWORD *)(a1 + 1152);
  if (!v9)
    sub_10004D738();
  v12 = sub_100040A08(v9, (integer_t *)v66);
  if (v12)
  {
    v13 = *(_DWORD *)(a1 + 1152);
    mach_error_string(v12);
    sub_10001D418(a1, 5, "could not get audit token for service (PID %d): %d: %s", v14, v15, v16, v17, v18, v13);
    v19 = dword_100071A94;
    v20 = 3;
LABEL_24:
    strerror(v20);
    sub_10001D418(a1, 5, "could not terminate service: %d: %s", v33, v34, v35, v36, v37, v20);
    strerror(v20);
    sub_10001D418(a1, 3, "could not terminate service: %d: %s", v38, v39, v40, v41, v42, v20);
    if (v19 <= 1)
      v19 = 1;
    v43 = *(_QWORD *)(a1 + 1188) & 0xFFFFFFFFFFFFFF00 | 9;
    *(_QWORD *)(a1 + 1188) = v43;
    goto LABEL_27;
  }
  if (sub_10000DA1C() != a3 && sub_10002CD78(*(_QWORD *)(a1 + 248), a3) && !sub_100018784((_OWORD *)a3, v66, 9))
  {
    sub_10001D418(a1, 5, "caller (PID %d) is not allowed to signal target process: %s", v22, v23, v24, v25, v26, *(_DWORD *)(a3 + 20));
    return 1;
  }
  v27 = (char *)(a1 + 1188);
  if ((*(_BYTE *)(a1 + 1192) & 2) == 0 || byte_100072A45)
  {
    v29 = sub_1000408B0(v66);
    if (v29 && v29 != 3)
      _os_assumes_log(v29);
    if ((*(_BYTE *)(a1 + 1192) & 2) != 0)
    {
      if (!byte_100072A45)
        sub_10004D738();
      v28 = "sudden shutdown";
    }
    else
    {
      v28 = "aborting trampoline";
    }
    goto LABEL_21;
  }
  if (a2 == 2)
  {
    v20 = sub_1000407FC(*(unsigned int *)(a1 + 1152), 3u, (uint64_t)"extension check-in timeout", 2);
    *v27 = 9;
  }
  else
  {
    if (a2 == 1)
    {
      v28 = "force-kill";
LABEL_21:
      v30 = 9;
      v31 = a1;
      v32 = 9;
LABEL_22:
      v20 = sub_100027788(v31, v66, v32, (char)v28);
      *v27 = v30;
      goto LABEL_23;
    }
    if ((*(_BYTE *)(a1 + 1381) & 0x20) != 0)
    {
      if (a2)
        sub_10004D738();
      v28 = "requested SIGTERM";
      v30 = 15;
      v31 = a1;
      v32 = 15;
      goto LABEL_22;
    }
    if (a2)
      sub_10004D738();
    v20 = sub_1000408B0(v66);
    *v27 = 0;
    if (!v20)
    {
      sub_100011430(570425424, *(int *)(a1 + 1152), 0);
      v59 = strsignal(*v27);
      sub_10001D418(a1, 5, "signaled service: %s", v60, v61, v62, v63, v64, v59);
    }
  }
LABEL_23:
  v19 = 0;
  if (v20)
    goto LABEL_24;
  v43 = *(_QWORD *)v27;
LABEL_27:
  if (v43 == 15)
  {
    sub_100023D28(a1, 5);
    if (!v19)
      v19 = *(unsigned int *)(a1 + 832);
    v44 = (void (__cdecl *)(void *))sub_1000279F4;
  }
  else if (v43 == 9)
  {
    sub_100023D28(a1, 6);
    if (!v19)
      v19 = dword_100071A94;
    v44 = (void (__cdecl *)(void *))sub_10002781C;
  }
  else
  {
    v45 = strsignal(v43);
    sub_10001D418(a1, 4, "Service was sent unexpected signal: %s", v46, v47, v48, v49, v50, v45);
    v44 = (void (__cdecl *)(void *))sub_10002781C;
    v19 = 1;
  }
  if (a2 == 2)
    v19 = 10;
  strsignal(*(unsigned __int8 *)(a1 + 1188));
  sub_10001D418(a1, 5, "scheduling cleanup in %llu sec after sending %s", v51, v52, v53, v54, v55, v19);
  if (*(_QWORD *)(a1 + 1176))
    sub_10003E208("tried to overwrite service timeout_source");
  v56 = sub_1000146E4();
  *(_QWORD *)(a1 + 1176) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v56);
  sub_100019A20(a1);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 1176), (void *)a1);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 1176), v44);
  v57 = *(NSObject **)(a1 + 1176);
  v58 = dispatch_time(0, 1000000000 * v19);
  dispatch_source_set_timer(v57, v58, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_activate(*(dispatch_object_t *)(a1 + 1176));
  return 0;
}

uint64_t sub_100020A8C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v2 = sub_10000DA1C();
  return sub_1000204AC(a1, v2, v3, v4, v5, v6, v7, v8);
}

void sub_100020AB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  if ((*(_BYTE *)(a1 + 1380) & 0x10) != 0)
    sub_100020AFC(a1, a2, a3, a4, a5, a6, a7, a8);
}

void sub_100020AFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t j;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  for (i = *(_QWORD *)(a1 + 152); i; i = *(_QWORD *)(i + 16))
  {
    if ((*(_BYTE *)(i + 88) & 0x40) == 0)
    {
      sub_10001D418(a1, 5, "draining messages from %s", a4, a5, a6, a7, a8, i - 88);
      sub_100046B74(i, v10, v11, v12, v13, v14, v15, v16);
    }
  }
  for (j = *(_QWORD *)(a1 + 184); j; j = *(_QWORD *)(j + 16))
  {
    if ((*(_BYTE *)(j + 88) & 0x40) == 0)
    {
      sub_10001D418(a1, 5, "draining messages from %s", a4, a5, a6, a7, a8, j - 88);
      sub_100046B74(j, v18, v19, v20, v21, v22, v23, v24);
    }
  }
}

void sub_100020BA8(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  dispatch_time_t v5;

  if (*(_DWORD *)(a1 + 880))
  {
    if (*(_QWORD *)(a1 + 872))
      sub_10004D738();
    v2 = sub_1000146E4();
    v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v2);
    *(_QWORD *)(a1 + 872) = v3;
    dispatch_set_context(v3, (void *)a1);
    v4 = *(NSObject **)(a1 + 872);
    v5 = dispatch_time(0, 1000000000 * *(unsigned int *)(a1 + 880));
    dispatch_source_set_timer(v4, v5, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 872), (dispatch_function_t)sub_100020C50);
    dispatch_activate(*(dispatch_object_t *)(a1 + 872));
  }
}

void sub_100020C50(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = sub_10001D47C(a1, 12);
  sub_10001D418(a1, 5, "interval event: domain response: %d", v3, v4, v5, v6, v7, v2);
  if ((_DWORD)v2 && (_DWORD)v2 != 36 && (_DWORD)v2 != 124)
  {
    xpc_strerror(v2);
    sub_10001D418(a1, 3, "Interval spawn of service failed: %d: %s", v8, v9, v10, v11, v12, v2);
  }
}

void sub_100020CCC(uint64_t a1)
{
  NSObject *v2;

  if (*(_DWORD *)(a1 + 880))
  {
    v2 = *(NSObject **)(a1 + 872);
    if (!v2)
      sub_10004D738();
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 872));
    *(_QWORD *)(a1 + 872) = 0;
  }
}

void sub_100020D0C(uint64_t a1)
{
  NSObject *v2;

  v2 = *(NSObject **)(a1 + 872);
  if (v2)
  {
    dispatch_source_cancel(v2);
    dispatch_release(*(dispatch_object_t *)(a1 + 872));
    *(_QWORD *)(a1 + 872) = 0;
  }
}

uint64_t sub_100020D40(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return a1 + 376;
}

uint64_t sub_100020D78(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return *(unsigned int *)(a1 + 1152);
}

xpc_object_t sub_100020DB0(uint64_t a1)
{
  xpc_object_t v2;
  _QWORD *v3;
  const char *v4;
  int64_t v5;
  int64_t v6;
  const char *v7;
  const char *v8;
  const char *v9;
  uint64_t v10;
  void *v11;
  const char *v12;
  xpc_object_t v13;
  unint64_t v14;

  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  v2 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v2, "Label", (const char *)(a1 + 1392));
  xpc_dictionary_set_BOOL(v2, "OnDemand", (*(_QWORD *)(a1 + 1376) & 4) == 0);
  v3 = (_QWORD *)sub_10002E360(*(_QWORD *)(a1 + 248));
  if (v3 == (_QWORD *)&unk_1000715B8)
  {
    v4 = "System";
  }
  else if (v3 == qword_100071640)
  {
    v4 = "Background";
  }
  else
  {
    if (v3 != (_QWORD *)&unk_1000716C8)
      goto LABEL_9;
    v4 = "Aqua";
  }
  xpc_dictionary_set_string(v2, "LimitLoadToSessionType", v4);
LABEL_9:
  if (sub_1000442B0(a1 + 1200))
  {
    v5 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else if (sub_1000440E8((_DWORD *)(a1 + 1200)))
  {
    v5 = *(int *)(a1 + 1228);
  }
  else
  {
    v5 = 0;
  }
  xpc_dictionary_set_int64(v2, "LastExitStatus", v5);
  v6 = *(int *)(a1 + 1152);
  if ((_DWORD)v6)
    xpc_dictionary_set_int64(v2, "PID", v6);
  v7 = *(const char **)(a1 + 448);
  if (v7)
    xpc_dictionary_set_string(v2, "StandardInPath", v7);
  v8 = *(const char **)(a1 + 456);
  if (v8)
    xpc_dictionary_set_string(v2, "StandardOutPath", v8);
  v9 = *(const char **)(a1 + 464);
  if (v9)
    xpc_dictionary_set_string(v2, "StandardErrorPath", v9);
  v10 = *(_QWORD *)(a1 + 1376);
  if ((v10 & 0x100) != 0)
  {
    xpc_dictionary_set_BOOL(v2, "EnableTransactions", 1);
    v10 = *(_QWORD *)(a1 + 1376);
  }
  if ((v10 & 0x4000) != 0)
  {
    xpc_dictionary_set_BOOL(v2, "inetdCompatibility", 1);
    xpc_dictionary_set_BOOL(v2, "Wait", (*(_QWORD *)(a1 + 1376) & 0x8000) != 0);
  }
  v11 = *(void **)(a1 + 640);
  if (v11)
    xpc_dictionary_set_value(v2, "_AdditionalProperties", v11);
  v12 = (const char *)sub_10001CFB8(a1);
  xpc_dictionary_set_string(v2, "Program", v12);
  if (*(_DWORD *)(a1 + 428))
  {
    v13 = xpc_array_create(0, 0);
    if (*(_DWORD *)(a1 + 428))
    {
      v14 = 0;
      do
        xpc_array_set_string(v13, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(*(_QWORD *)(a1 + 432) + 8 * v14++));
      while (v14 < *(unsigned int *)(a1 + 428));
    }
    xpc_dictionary_set_value(v2, "ProgramArguments", v13);
    xpc_release(v13);
  }
  return v2;
}

xpc_object_t sub_10002102C(uint64_t a1, char a2)
{
  xpc_object_t v4;
  const char *v5;
  const char *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  void *v12;
  xpc_object_t v13;
  uint64_t i;
  int v15;
  xpc_object_t v16;
  uint64_t j;
  xpc_object_t v18;
  uint64_t k;
  int v20;
  xpc_object_t v21;
  uint64_t v22;
  const char *v23;

  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_BOOL(v4, "extension", (*(_QWORD *)(a1 + 1376) & 0x400000000) != 0);
  xpc_dictionary_set_BOOL(v4, launch_extension_property_xpc_bundle, (*(_QWORD *)(a1 + 1376) & 2) != 0);
  v5 = *(const char **)(a1 + 576);
  if (v5)
    xpc_dictionary_set_string(v4, "bundle-id", v5);
  xpc_dictionary_set_int64(v4, launch_extension_property_pid, *(int *)(a1 + 1152));
  if (*(_BYTE *)sub_10001CFC4(a1) == 47)
  {
    v6 = (const char *)sub_10001CFC4(a1);
    xpc_dictionary_set_string(v4, "path", v6);
  }
  v7 = *(_QWORD *)(a1 + 248);
  if ((_QWORD *)sub_10002E360(v7) == qword_100071750)
  {
    v8 = sub_10002E368(v7);
    v9 = sub_10001FB38(v8);
    if (v9)
    {
      v10 = *(const char **)(v9 + 576);
      if (v10)
        xpc_dictionary_set_string(v4, launch_extension_property_host_bundle_id, v10);
    }
    xpc_dictionary_set_int64(v4, launch_extension_property_host_pid, v8);
    if ((a2 & 1) == 0)
      goto LABEL_15;
  }
  else if ((a2 & 1) == 0)
  {
    goto LABEL_15;
  }
  v11 = *(_QWORD *)(a1 + 344);
  if (v11)
  {
    v12 = *(void **)(v11 + 56);
    goto LABEL_16;
  }
LABEL_15:
  v12 = 0;
LABEL_16:
  v13 = xpc_array_create(0, 0);
  for (i = *(_QWORD *)(a1 + 152); i; i = *(_QWORD *)(i + 16))
  {
    if ((*(_BYTE *)(i + 88) & 0x40) == 0)
    {
      v15 = sub_100015818(v12, (const char *)(i + 168));
      v16 = sub_100046058(i, v15);
      xpc_array_append_value(v13, v16);
      xpc_release(v16);
    }
  }
  for (j = *(_QWORD *)(a1 + 176); j; j = *(_QWORD *)(j + 16))
  {
    if ((*(_BYTE *)(j + 88) & 0x40) == 0)
    {
      v18 = sub_100046058(j, 0);
      xpc_array_append_value(v13, v18);
      xpc_release(v18);
    }
  }
  for (k = *(_QWORD *)(a1 + 184); k; k = *(_QWORD *)(k + 16))
  {
    if ((*(_BYTE *)(k + 88) & 0x40) == 0)
    {
      v20 = sub_100015818(v12, (const char *)(k + 168));
      v21 = sub_100046058(k, v20);
      xpc_array_append_value(v13, v21);
      xpc_release(v21);
    }
  }
  if (xpc_array_get_count(v13))
    xpc_dictionary_set_value(v4, launch_perfcheck_property_endpoints, v13);
  xpc_release(v13);
  v22 = *(_QWORD *)(a1 + 256);
  if (!v22)
    v22 = a1;
  xpc_dictionary_set_string(v4, "label", (const char *)(v22 + 1392));
  if ((*(_BYTE *)(a1 + 1381) & 2) != 0)
    xpc_dictionary_set_uuid(v4, "instance", (const unsigned __int8 *)(a1 + 408));
  xpc_dictionary_set_int64(v4, "jp-priority", *(int *)(a1 + 920));
  xpc_dictionary_set_value(v4, "additional-properties", *(xpc_object_t *)(a1 + 640));
  v23 = (const char *)sub_10001CFB8(a1);
  xpc_dictionary_set_string(v4, "program", v23);
  xpc_dictionary_set_uint64(v4, "process-type", *(unsigned int *)(a1 + 896));
  xpc_dictionary_set_BOOL(v4, "keep-alive", (*(_QWORD *)(a1 + 1376) & 0xCLL) != 0);
  xpc_dictionary_set_BOOL(v4, "run-at-load", (*(_QWORD *)(a1 + 1376) & 0x10) != 0);
  xpc_dictionary_set_BOOL(v4, "enable-transactions", *(_QWORD *)(a1 + 1376) & 0x100);
  xpc_dictionary_set_uint64(v4, "service-type", *(unsigned __int8 *)(a1 + 356));
  xpc_dictionary_set_value(v4, "persist-to-boot-mode", *(xpc_object_t *)(a1 + 648));
  return v4;
}

uint64_t sub_1000213BC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return sub_10001CFB8(a1);
}

char *sub_1000213F0(uint64_t a1)
{
  char *result;
  char *v3;
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;

  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  result = *(char **)(a1 + 1136);
  if (!result || *(unsigned __int16 *)(a1 + 1186) <= 1u)
  {
    v3 = (char *)sub_10001CFB8(a1);
    v4 = *(_QWORD *)(a1 + 1376);
    v5 = strrchr(v3, 47);
    v6 = v5;
    if ((v4 & 2) != 0)
    {
      if (v5)
      {
        v7 = strrchr(v5, 46);
        if (v7)
          v3 = v7;
        else
          v3 = v6;
      }
    }
    else if (v5)
    {
      v3 = v5;
    }
    return v3 + 1;
  }
  return result;
}

uint64_t sub_100021494(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return *(_QWORD *)(a1 + 584);
}

uint64_t sub_1000214CC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return *(_QWORD *)(a1 + 576);
}

uint64_t sub_100021504(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return a1 + 408;
}

uint64_t sub_10002153C(uint64_t a1)
{
  return a1 + 1200;
}

uint64_t sub_100021544(uint64_t a1, BOOL *a2)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  *a2 = (*(_DWORD *)(a1 + 1376) & 0x8000) != 0;
  return (*(unsigned __int8 *)(a1 + 1377) >> 6) & 1;
}

uint64_t sub_10002158C(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return (*(unsigned __int8 *)(a1 + 1192) >> 1) & 1;
}

uint64_t sub_1000215C8(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return *(_BYTE *)(a1 + 1381) & 1;
}

uint64_t sub_100021604(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 1381) >> 3) & 1;
}

FILE *sub_100021610(FILE *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  FILE *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;

  if (qword_100071D50)
  {
    v9 = result;
    v10 = a2 + 1;
    sub_10004391C(result, a2 + 1, "pending global attachments = {", a4, a5, a6, a7, a8);
    v16 = (_QWORD *)qword_100071D50;
    if (qword_100071D50)
    {
      v17 = a2 + 2;
      do
      {
        sub_10004391C(v9, v17, "%s", v11, v12, v13, v14, v15, v16[2]);
        v16 = (_QWORD *)*v16;
      }
      while (v16);
    }
    return (FILE *)sub_10004391C(v9, v10, "}", v11, v12, v13, v14, v15);
  }
  return result;
}

uint64_t sub_1000216C4(uint64_t a1, FILE *a2, uint64_t a3)
{
  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  return sub_1000216F8(a1, a2, a3);
}

uint64_t sub_1000216F8(uint64_t a1, FILE *a2, uint64_t a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  const char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  xpc_type_t type;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  size_t v113;
  const char *string;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  const char *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  _QWORD *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  _QWORD *i;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  _QWORD *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  _QWORD *j;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  char *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  char *v234;
  char *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  _QWORD *v256;
  char *v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  char *v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  char *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  char *v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  char *v281;
  const char *v282;
  unsigned int v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  unsigned int v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  unsigned int v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  int v301;
  char *v302;
  int v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  const char *v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  const char *v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t **k;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t m;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t n;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t ii;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t jj;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t kk;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t mm;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t nn;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t i1;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  void *v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  const char *v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  mach_port_name_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  unint64_t v460;
  unint64_t v461;
  void *v462;
  uint64_t v463;
  void *v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  unsigned int v471;
  int v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  const char *v478;
  char **v479;
  uint64_t v480;
  unsigned int v481;
  int v482;
  uint64_t v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  const char *v488;
  char **v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  int v502;
  const char *v503;
  char *v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  uint64_t v508;
  uint64_t v509;
  int v510;
  char *v511;
  int v512;
  const char *v513;
  char *v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  int v520;
  char *v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  char *v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t *v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  uint64_t v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  uint64_t v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  char *v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  uint64_t v568;
  uint64_t v569;
  uint64_t v570;
  uint64_t v571;
  uint64_t v572;
  uint64_t v573;
  uint64_t v574;
  uint64_t v575;
  uint64_t v576;
  uint64_t v577;
  uint64_t v578;
  uint64_t v579;
  uint64_t v580;
  uint64_t v581;
  void *count;
  uint64_t v583;
  uint64_t v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  uint64_t v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  uint64_t v596;
  uint64_t v597;
  uint64_t v598;
  uint64_t v599;
  uint64_t v600;
  uint64_t v601;
  uint64_t v602;
  int v603;
  const char *v604;
  const char *v605;
  void **v606;
  uint64_t v607;
  uint64_t v608;
  uint64_t v609;
  uint64_t v610;
  uint64_t v611;
  uint64_t v612;
  uint64_t v613;
  uint64_t v614;
  uint64_t v615;
  uint64_t v616;
  uint64_t v617;
  uint64_t v618;
  uint64_t v619;
  uint64_t v620;
  uint64_t v621;
  uint64_t v622;
  uint64_t v623;
  uint64_t v624;
  uint64_t v625;
  uint64_t v626;
  uint64_t v627;
  uint64_t v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  uint64_t v647;
  uint64_t v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  uint64_t v655;
  uint64_t v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t v659;
  uint64_t v660;
  uint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  uint64_t v673;
  uint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  uint64_t v689;
  uint64_t v690;
  uint64_t v691;
  uint64_t v692;
  uint64_t v693;
  uint64_t v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  uint64_t v709;
  uint64_t v710;
  uint64_t v711;
  uint64_t v712;
  uint64_t v713;
  uint64_t v714;
  uint64_t v715;
  uint64_t v716;
  uint64_t v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  uint64_t v722;
  uint64_t v723;
  uint64_t v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t v732;
  uint64_t v733;
  uint64_t v734;
  uint64_t v735;
  uint64_t v736;
  uint64_t v737;
  uint64_t v738;
  uint64_t v739;
  uint64_t v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  uint64_t v753;
  uint64_t v754;
  uint64_t v755;
  uint64_t v756;
  uint64_t v757;
  unsigned __int8 *v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  uint64_t v762;
  uint64_t v763;
  uint64_t v764;
  uint64_t v765;
  uint64_t v766;
  uint64_t v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  uint64_t v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t v776;
  uint64_t v777;
  uint64_t v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  uint64_t v788;
  uint64_t v789;
  uint64_t v790;
  uint64_t v791;
  uint64_t v792;
  uint64_t v793;
  uint64_t v794;
  uint64_t v795;
  uint64_t v796;
  uint64_t v797;
  uint64_t v798;
  uint64_t v799;
  uint64_t v800;
  uint64_t v801;
  uint64_t v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  uint64_t v806;
  uint64_t v807;
  uint64_t v808;
  uint64_t v809;
  uint64_t v810;
  uint64_t v811;
  uint64_t v812;
  uint64_t v813;
  uint64_t v814;
  uint64_t v815;
  uint64_t v816;
  uint64_t v817;
  uint64_t v818;
  uint64_t v819;
  uint64_t v820;
  uint64_t v821;
  uint64_t v822;
  uint64_t v823;
  uint64_t v824;
  uint64_t v825;
  uint64_t v826;
  uint64_t v827;
  uint64_t v828;
  uint64_t v829;
  uint64_t v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  uint64_t v834;
  uint64_t v835;
  uint64_t v836;
  uint64_t v837;
  uint64_t v838;
  uint64_t v839;
  uint64_t v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  uint64_t v844;
  uint64_t v845;
  uint64_t v846;
  uint64_t v847;
  uint64_t v848;
  uint64_t v849;
  uint64_t v850;
  uint64_t v851;
  uint64_t v852;
  uint64_t v853;
  uint64_t v854;
  uint64_t v855;
  uint64_t v856;
  uint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t v860;
  uint64_t v861;
  uint64_t v862;
  uint64_t v863;
  uint64_t v864;
  uint64_t v865;
  uint64_t v866;
  uint64_t v867;
  uint64_t v868;
  uint64_t v869;
  uint64_t v870;
  const char *v872;
  const char *v873;
  const char *v874;
  uint64_t v875;
  uint64_t v876;
  uint64_t v877;
  uint64_t v878;
  uint64_t v879;
  const char *v880;
  uint64_t v881;
  const char *string_ptr;
  uint64_t v883;
  uint64_t v884;
  uint64_t v885;
  uint64_t v886;
  uint64_t v887;
  char *v888;
  char v889;
  char v890;
  char v891;
  char v892;
  const char *v893;
  const char *v894;
  uint64_t v895;
  const char *v896;
  char v897;
  uint64_t v898;
  uint64_t v899;
  uint64_t v900;
  uint64_t v901;
  uint64_t v902;
  uint64_t v903;
  uint64_t v904;
  _QWORD v905[6];
  unsigned int object_addr[4];
  __int128 v907;
  _QWORD v908[6];
  _QWORD applier[6];
  unsigned int object_type[4];
  __int128 v911;
  __int128 v912;
  __int128 v913;
  __int128 v914;
  __int128 v915;
  __int128 v916;
  __int128 v917;
  __int128 v918;
  __int128 v919;
  __int128 v920;
  __int128 v921;
  __int128 v922;
  __int128 v923;
  __int128 v924;
  __int128 v925;

  v6 = sub_10001F264(a1, 1);
  sub_10004391C(a2, a3, "%s = {", v7, v8, v9, v10, v11, v6);
  free(v6);
  v17 = a3 + 1;
  if ((*(_BYTE *)(a1 + 1381) & 2) != 0)
    sub_10004391C(a2, a3 + 1, "original = %s", v12, v13, v14, v15, v16, *(_QWORD *)(a1 + 256) + 1392);
  sub_10004391C(a2, a3 + 1, "active count = %d", v12, v13, v14, v15, v16, *(__int16 *)(a1 + 300));
  if (*(_DWORD *)(a1 + 264))
    sub_10004391C(a2, a3 + 1, "copy count = %d", v18, v19, v20, v21, v22, *(unsigned int *)(a1 + 264));
  if (sub_10001CFC4(a1))
  {
    v28 = sub_10001CFC4(a1);
    sub_10004391C(a2, a3 + 1, "path = %s", v29, v30, v31, v32, v33, v28);
  }
  v34 = *(unsigned __int8 *)(a1 + 356) - 1;
  if (v34 > 6)
    v35 = "Unknown";
  else
    v35 = off_10006C930[(char)v34];
  sub_10004391C(a2, a3 + 1, "type = %s", v23, v24, v25, v26, v27, v35);
  v41 = *(_QWORD *)(a1 + 344);
  if (v41)
  {
    v42 = *(void **)(v41 + 48);
    if (v42)
    {
      type = xpc_get_type(v42);
      if (type == (xpc_type_t)&_xpc_type_array)
      {
        sub_10004391C(a2, a3 + 1, "managed_by = {", v36, v37, v38, v39, v40);
        v49 = *(void **)(*(_QWORD *)(a1 + 344) + 48);
        applier[0] = _NSConcreteStackBlock;
        applier[1] = 0x40000000;
        applier[2] = sub_100027BF0;
        applier[3] = &unk_10006C818;
        applier[4] = a2;
        applier[5] = a3;
        xpc_array_apply(v49, applier);
        sub_10004391C(a2, a3 + 1, "}", v50, v51, v52, v53, v54, v881);
      }
      else if (type == (xpc_type_t)&_xpc_type_string)
      {
        string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(*(_QWORD *)(a1 + 344) + 48));
        sub_10004391C(a2, a3 + 1, "managed_by = %s", v44, v45, v46, v47, v48, string_ptr);
      }
    }
    v55 = *(_QWORD *)(a1 + 344);
    if (v55 && *(_QWORD *)(v55 + 56))
    {
      sub_10004391C(a2, a3 + 1, "managedby_services = {", v36, v37, v38, v39, v40);
      v56 = *(void **)(*(_QWORD *)(a1 + 344) + 56);
      v908[0] = _NSConcreteStackBlock;
      v908[1] = 0x40000000;
      v908[2] = sub_100027C3C;
      v908[3] = &unk_10006C838;
      v908[4] = a2;
      v908[5] = a3;
      xpc_array_apply(v56, v908);
      sub_10004391C(a2, a3 + 1, "}", v57, v58, v59, v60, v61);
    }
  }
  LOBYTE(v883) = sub_100023DAC(a1);
  sub_10004391C(a2, a3 + 1, "state = %s", v62, v63, v64, v65, v66);
  if (*(_QWORD *)(a1 + 576))
  {
    v883 = *(_QWORD *)(a1 + 576);
    sub_10004391C(a2, a3 + 1, "bundle id = %s", v69, v70, v71, v72, v73);
  }
  if ((*(_BYTE *)(a1 + 1380) & 4) != 0)
  {
    v883 = *(_QWORD *)(a1 + 584);
    sub_10004391C(a2, a3 + 1, "extension point = %s", v69, v70, v71, v72, v73);
  }
  v74 = *(_DWORD *)(a1 + 704);
  if (v74)
  {
    *(_OWORD *)object_addr = 0u;
    v907 = 0u;
    DWORD1(v907) = v74;
    v912 = 0u;
    v913 = 0u;
    *(_OWORD *)object_type = 0u;
    v911 = 0u;
    LOBYTE(v883) = sub_10003FBC0((uint64_t)object_addr, (char *)object_type);
    v899 = *(unsigned int *)(a1 + 704);
    sub_10004391C(a2, a3 + 1, "controller = %s.%d", v75, v76, v77, v78, v79);
  }
  sub_100043998(a2, v67, v68, v69, v70, v71, v72, v73, v883);
  LOBYTE(v884) = sub_10001CFB8(a1);
  sub_10004391C(a2, a3 + 1, "program = %s", v80, v81, v82, v83, v84);
  if (*(_QWORD *)(a1 + 1256))
  {
    v884 = *(_QWORD *)(a1 + 1256);
    sub_10004391C(a2, a3 + 2, "+ %s", v85, v86, v87, v88, v89);
  }
  if (*(_DWORD *)(a1 + 428) || *(_QWORD *)(a1 + 1264))
  {
    sub_10004391C(a2, a3 + 1, "arguments = {", v85, v86, v87, v88, v89);
    if (*(_DWORD *)(a1 + 428))
    {
      v95 = 0;
      do
        sub_10004391C(a2, a3 + 2, "%s", v90, v91, v92, v93, v94, *(_QWORD *)(*(_QWORD *)(a1 + 432) + 8 * v95++));
      while (v95 < *(unsigned int *)(a1 + 428));
    }
    sub_10004391C(a2, a3 + 1, "}", v90, v91, v92, v93, v94);
    if (*(_QWORD *)(a1 + 1264))
    {
      sub_100043998(a2, v96, v97, v98, v99, v100, v101, v102, v884);
      sub_10004391C(a2, a3 + 1, "controller-supplied arguments = {", v103, v104, v105, v106, v107);
      if (xpc_array_get_count(*(xpc_object_t *)(a1 + 1264)))
      {
        v113 = 0;
        do
        {
          string = xpc_array_get_string(*(xpc_object_t *)(a1 + 1264), v113);
          if (string)
          {
            LOBYTE(v884) = (_BYTE)string;
            sub_10004391C(a2, a3 + 2, "%s", v115, v116, v117, v118, v119);
          }
          ++v113;
        }
        while (v113 < xpc_array_get_count(*(xpc_object_t *)(a1 + 1264)));
      }
      sub_10004391C(a2, a3 + 1, "}", v108, v109, v110, v111, v112);
    }
    sub_100043998(a2, v96, v97, v98, v99, v100, v101, v102, v884);
  }
  v120 = *(const char **)(a1 + 440);
  if (!v120)
  {
    if (!*(_QWORD *)(a1 + 1272))
      goto LABEL_46;
    v120 = "(unspecified)";
  }
  sub_10004391C(a2, a3 + 1, "working directory = %s", v85, v86, v87, v88, v89, v120);
  if (*(_QWORD *)(a1 + 1272))
  {
    v885 = *(_QWORD *)(a1 + 1272);
    sub_10004391C(a2, a3 + 2, "+ %s", v123, v124, v125, v126, v127);
  }
  sub_100043998(a2, v121, v122, v123, v124, v125, v126, v127, v885);
LABEL_46:
  if (*(_QWORD *)(a1 + 448))
  {
    v884 = *(_QWORD *)(a1 + 448);
    sub_10004391C(a2, a3 + 1, "stdin path = %s", v85, v86, v87, v88, v89);
  }
  if (*(_QWORD *)(a1 + 456))
  {
    v884 = *(_QWORD *)(a1 + 456);
    sub_10004391C(a2, a3 + 1, "stdout path = %s", v85, v86, v87, v88, v89);
  }
  if (*(_QWORD *)(a1 + 464))
  {
    v884 = *(_QWORD *)(a1 + 464);
    sub_10004391C(a2, a3 + 1, "stderr path = %s", v85, v86, v87, v88, v89);
  }
  if (*(_QWORD *)(a1 + 472))
  {
    v884 = *(_QWORD *)(a1 + 472);
    sub_10004391C(a2, a3 + 1, "container id = %s", v85, v86, v87, v88, v89);
  }
  if (*(_QWORD *)(a1 + 480))
  {
    v884 = *(_QWORD *)(a1 + 480);
    sub_10004391C(a2, a3 + 1, "sandbox profile = %s", v85, v86, v87, v88, v89);
  }
  if (*(_QWORD *)(a1 + 488))
  {
    v884 = *(_QWORD *)(a1 + 488);
    sub_10004391C(a2, a3 + 1, "subsystem root = %s", v85, v86, v87, v88, v89);
  }
  if (*(_QWORD *)(a1 + 1280))
  {
    sub_10004391C(a2, a3 + 1, "controller-supplied environment = {", v85, v86, v87, v88, v89);
    *(_QWORD *)object_type = a2;
    *(_QWORD *)&object_type[2] = 0;
    *(_QWORD *)&v911 = a3 + 2;
    xpc_dictionary_apply_f(*(_QWORD *)(a1 + 1280));
    sub_10004391C(a2, a3 + 1, "}", v128, v129, v130, v131, v132);
    sub_100043998(a2, v133, v134, v135, v136, v137, v138, v139, v884);
  }
  if (qword_100072AD0)
  {
    sub_10004391C(a2, a3 + 1, "global environment = {", v85, v86, v87, v88, v89);
    v145 = (_QWORD *)qword_100072AD0;
    if (qword_100072AD0)
    {
      do
      {
        sub_1000197E0((uint64_t)v145, a3 + 2, a2);
        v145 = (_QWORD *)*v145;
      }
      while (v145);
    }
    sub_10004391C(a2, a3 + 1, "}", v140, v141, v142, v143, v144);
    sub_100043998(a2, v146, v147, v148, v149, v150, v151, v152, v884);
  }
  if (*(_QWORD *)(*(_QWORD *)(a1 + 248) + 96))
  {
    sub_10004391C(a2, a3 + 1, "inherited environment = {", v85, v86, v87, v88, v89);
    for (i = *(_QWORD **)(*(_QWORD *)(a1 + 248) + 96); i; i = (_QWORD *)*i)
      sub_1000197E0((uint64_t)i, a3 + 2, a2);
    sub_10004391C(a2, a3 + 1, "}", v153, v154, v155, v156, v157);
    sub_100043998(a2, v159, v160, v161, v162, v163, v164, v165, v884);
  }
  if (qword_100072AD8)
  {
    sub_10004391C(a2, a3 + 1, "default environment = {", v85, v86, v87, v88, v89);
    v171 = (_QWORD *)qword_100072AD8;
    if (qword_100072AD8)
    {
      do
      {
        sub_1000197E0((uint64_t)v171, a3 + 2, a2);
        v171 = (_QWORD *)*v171;
      }
      while (v171);
    }
    sub_10004391C(a2, a3 + 1, "}", v166, v167, v168, v169, v170);
    sub_100043998(a2, v172, v173, v174, v175, v176, v177, v178, v884);
  }
  if (*(_WORD *)(a1 + 1016))
  {
    sub_10004391C(a2, a3 + 1, "environment = {", v85, v86, v87, v88, v89);
    for (j = *(_QWORD **)(a1 + 1008); j; j = (_QWORD *)*j)
      sub_1000197E0((uint64_t)j, a3 + 2, a2);
    sub_10004391C(a2, a3 + 1, "}", v179, v180, v181, v182, v183);
    sub_100043998(a2, v185, v186, v187, v188, v189, v190, v191, v884);
  }
  v192 = sub_100028C98(*(_QWORD *)(a1 + 248), 2);
  sub_10004391C(a2, a3 + 1, "domain = %s", v193, v194, v195, v196, v197, v192);
  free(v192);
  if (*(_QWORD *)(a1 + 800))
  {
    v886 = *(_QWORD *)(a1 + 800);
    sub_10004391C(a2, a3 + 1, "username = %s", v198, v199, v200, v201, v202);
    v205 = *(_QWORD *)(a1 + 808);
    if (!v205)
      goto LABEL_81;
  }
  else
  {
    v205 = *(_QWORD *)(a1 + 808);
    if (!v205)
      goto LABEL_82;
  }
  sub_10004391C(a2, a3 + 1, "group = %s", v198, v199, v200, v201, v202, v205);
LABEL_81:
  sub_100043998(a2, v203, v204, v198, v199, v200, v201, v202, v886);
LABEL_82:
  if ((*(_BYTE *)(a1 + 1380) & 1) != 0)
    sub_10004391C(a2, a3 + 1, "umask = %o", v198, v199, v200, v201, v202, *(unsigned __int16 *)(a1 + 816));
  v206 = sub_10001D950(a1);
  sub_10004391C(a2, a3 + 1, "minimum runtime = %u", v207, v208, v209, v210, v211, v206);
  if ((*(_BYTE *)(a1 + 1382) & 8) != 0)
    sub_10004391C(a2, a3 + 1, "base minimum runtime = %u", v212, v213, v214, v215, v216, *(unsigned int *)(a1 + 836));
  sub_10004391C(a2, a3 + 1, "exit timeout = %u", v212, v213, v214, v215, v216, *(unsigned int *)(a1 + 832));
  if ((*(_BYTE *)(a1 + 1380) & 4) != 0)
  {
    sub_10004391C(a2, a3 + 1, "voluntary exit timeout = %u", v217, v218, v219, v220, v221, *(unsigned int *)(a1 + 864));
    if (byte_100072AC8)
      sub_10004391C(a2, a3 + 1, "launch watchdog timeout = %u", v222, v223, v224, v225, v226, *(unsigned int *)(a1 + 868));
    else
      sub_10004391C(a2, a3 + 1, "launch watchdog timeout = (globally disabled)", v222, v223, v224, v225, v226, v887);
  }
  if (*(_QWORD *)(a1 + 888))
    sub_10004391C(a2, a3 + 1, "exception handler endpoint = %s", v217, v218, v219, v220, v221, *(_QWORD *)(a1 + 888));
  sub_10004391C(a2, a3 + 1, "runs = %u", v217, v218, v219, v220, v221, *(unsigned int *)(a1 + 1024));
  v227 = sub_100023BE0(a1);
  v233 = a1 + 1040;
  if (v227)
    v233 = v227;
  v234 = (char *)*(unsigned int *)(v233 + 4);
  if ((_DWORD)v234)
  {
    v888 = v234;
    sub_10004391C(a2, a3 + 1, "successive crashes = %u", v228, v229, v230, v231, v232);
  }
  if (*(_DWORD *)(a1 + 1152))
  {
    sub_10004391C(a2, a3 + 1, "pid = %d", v228, v229, v230, v231, v232, *(unsigned int *)(a1 + 1152));
    v235 = sub_100023994(*(_DWORD *)(a1 + 1160));
    sub_10004391C(a2, a3 + 1, "immediate reason = %s", v236, v237, v238, v239, v240, v235);
    sub_10004391C(a2, a3 + 1, "forks = %hu", v241, v242, v243, v244, v245, *(unsigned __int16 *)(a1 + 1184));
    sub_10004391C(a2, a3 + 1, "execs = %hu", v246, v247, v248, v249, v250, *(unsigned __int16 *)(a1 + 1186));
    v256 = (_QWORD *)(a1 + 1188);
    v257 = (*(_QWORD *)(a1 + 1188) & (unint64_t)&_mh_execute_header) != 0 ? "1" : "0";
    sub_10004391C(a2, a3 + 1, "initialized = %s", v251, v252, v253, v254, v255, v257);
    v263 = (*v256 & 0x200000000) != 0 ? "1" : "0";
    sub_10004391C(a2, a3 + 1, "trampolined = %s", v258, v259, v260, v261, v262, v263);
    v269 = (*v256 & 0x400000000) != 0 ? "1" : "0";
    sub_10004391C(a2, a3 + 1, "started suspended = %s", v264, v265, v266, v267, v268, v269);
    v275 = (*v256 & 0x800000000) != 0 ? "1" : "0";
    sub_10004391C(a2, a3 + 1, "proxy started suspended = %s", v270, v271, v272, v273, v274, v275);
    v281 = (*v256 & 0x8000000000) != 0 ? "1" : "0";
    sub_10004391C(a2, a3 + 1, "uses proxy = %s", v276, v277, v278, v279, v280, v281);
    if ((*(_BYTE *)(a1 + 1380) & 4) != 0)
    {
      if ((*v256 & 0x4000000000) != 0)
        v282 = "1";
      else
        v282 = "0";
      sub_10004391C(a2, a3 + 1, "extension alive = %s", v228, v229, v230, v231, v232, v282);
    }
  }
  v283 = *(_DWORD *)(a1 + 288);
  if (v283)
  {
    v888 = sub_100023994(v283);
    sub_10004391C(a2, a3 + 1, "pended spawn = %s", v284, v285, v286, v287, v288);
  }
  v289 = *(_DWORD *)(a1 + 292);
  if (v289)
  {
    v888 = sub_100023994(v289);
    sub_10004391C(a2, a3 + 1, "pended nondemand spawn = %s", v290, v291, v292, v293, v294);
  }
  v295 = *(_DWORD *)(a1 + 1128);
  if (v295)
  {
    v888 = sub_100023994(v295);
    sub_10004391C(a2, a3 + 1, "spawn reason filter = %s", v296, v297, v298, v299, v300);
  }
  v301 = *(_DWORD *)(a1 + 1200);
  switch(v301)
  {
    case 2:
      v302 = "last exit code = (failed reap)";
      goto LABEL_131;
    case 1:
      v302 = "last exit code = (abandoned)";
      goto LABEL_131;
    case 0:
      v302 = "last exit code = (never exited)";
LABEL_131:
      sub_10004391C(a2, a3 + 1, v302, v228, v229, v230, v231, v232, v888, v899);
      goto LABEL_132;
  }
  if (sub_10004410C((_DWORD *)(a1 + 1200)))
  {
    v303 = sub_100044154((_DWORD *)(a1 + 1200));
    v888 = strsignal(v303);
    v302 = "last terminating signal = %s";
    goto LABEL_131;
  }
  if (sub_100044038(a1 + 1200))
  {
    v454 = sub_100044064((_DWORD *)(a1 + 1200));
    if ((v454 - 64) > 0xE)
      sub_10004391C(a2, a3 + 1, "last exit code = %d", v455, v456, v457, v458, v459, v454, v899);
    else
      sub_10004391C(a2, a3 + 1, "last exit code = %d: %s", v455, v456, v457, v458, v459, v454, off_10006C630[(v454 - 64)]);
  }
  else
  {
    if (sub_1000442F4(a1 + 1200))
    {
      v302 = "last exit code = (extension watchdogged)";
      goto LABEL_131;
    }
    v874 = sub_100043F58(a1 + 1200);
    v880 = "(unknown)";
    if (v874)
      v880 = v874;
    sub_10004391C(a2, a3 + 1, "last exit reason = %s", v875, v876, v877, v878, v879, v880, v899);
  }
LABEL_132:
  if (sub_10004423C((_DWORD *)(a1 + 1200)))
  {
    v311 = sub_100043F58(a1 + 1200);
    v317 = "(unknown)";
    if (v311)
      v317 = v311;
    sub_10004391C(a2, a3 + 1, "last jetsam exit details = %s", v312, v313, v314, v315, v316, v317);
  }
  if (*(_QWORD *)(a1 + 672))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "semaphores = {", v318, v319, v320, v321, v322);
    for (k = *(uint64_t ***)(a1 + 672); k; k = (uint64_t **)*k)
    {
      v924 = 0u;
      v925 = 0u;
      v922 = 0u;
      v923 = 0u;
      v920 = 0u;
      v921 = 0u;
      v918 = 0u;
      v919 = 0u;
      v916 = 0u;
      v917 = 0u;
      v914 = 0u;
      v915 = 0u;
      v912 = 0u;
      v913 = 0u;
      *(_OWORD *)object_type = 0u;
      v911 = 0u;
      sub_10004391C(a2, a3 + 2, "%s%s => %u", v323, v324, v325, v326, v327, k[3], object_type, *((unsigned __int8 *)k + 32));
    }
    sub_10004391C(a2, a3 + 1, "}", v323, v324, v325, v326, v327);
  }
  if (*(_QWORD *)(a1 + 136))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "event triggers = {", v329, v330, v331, v332, v333);
    for (m = *(_QWORD *)(a1 + 136); m; m = *(_QWORD *)(m + 16))
      sub_10003A998(m, a2, a3 + 2, v334, v335, v336, v337, v338);
    sub_10004391C(a2, a3 + 1, "}", v334, v335, v336, v337, v338);
  }
  if (*(_QWORD *)(a1 + 152))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "endpoints = {", v340, v341, v342, v343, v344);
    for (n = *(_QWORD *)(a1 + 152); n; n = *(_QWORD *)(n + 16))
    {
      if ((*(_BYTE *)(n + 88) & 0x40) == 0)
        sub_100046438(n, a2, a3 + 2, v345, v346, v347, v348, v349);
    }
    sub_10004391C(a2, a3 + 1, "}", v345, v346, v347, v348, v349);
  }
  if (*(_QWORD *)(a1 + 160))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "dynamic endpoints = {", v351, v352, v353, v354, v355);
    for (ii = *(_QWORD *)(a1 + 160); ii; ii = *(_QWORD *)(ii + 16))
    {
      if ((*(_BYTE *)(ii + 88) & 0x40) == 0)
        sub_100046438(ii, a2, a3 + 2, v356, v357, v358, v359, v360);
    }
    sub_10004391C(a2, a3 + 1, "}", v356, v357, v358, v359, v360);
  }
  if (*(_QWORD *)(a1 + 168))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "pid-local endpoints = {", v362, v363, v364, v365, v366);
    for (jj = *(_QWORD *)(a1 + 168); jj; jj = *(_QWORD *)(jj + 16))
    {
      if ((*(_BYTE *)(jj + 88) & 0x40) == 0)
        sub_100046438(jj, a2, a3 + 2, v367, v368, v369, v370, v371);
    }
    sub_10004391C(a2, a3 + 1, "}", v367, v368, v369, v370, v371);
  }
  if (*(_QWORD *)(a1 + 184))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "instance-specific endpoints = {", v373, v374, v375, v376, v377);
    for (kk = *(_QWORD *)(a1 + 184); kk; kk = *(_QWORD *)(kk + 16))
    {
      if ((*(_BYTE *)(kk + 88) & 0x40) == 0)
        sub_100046438(kk, a2, a3 + 2, v378, v379, v380, v381, v382);
    }
    sub_10004391C(a2, a3 + 1, "}", v378, v379, v380, v381, v382);
  }
  if (*(_QWORD *)(a1 + 176))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "event channels = {", v384, v385, v386, v387, v388);
    for (mm = *(_QWORD *)(a1 + 176); mm; mm = *(_QWORD *)(mm + 16))
    {
      if ((*(_BYTE *)(mm + 88) & 0x40) == 0)
        sub_100046438(mm, a2, a3 + 2, v389, v390, v391, v392, v393);
    }
    sub_10004391C(a2, a3 + 1, "}", v389, v390, v391, v392, v393);
  }
  if (*(_QWORD *)(a1 + 192))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "sockets = {", v395, v396, v397, v398, v399);
    for (nn = *(_QWORD *)(a1 + 192); nn; nn = *(_QWORD *)(nn + 16))
      sub_10001C1EC(nn, a2, a3 + 2, v400, v401, v402, v403, v404);
    sub_10004391C(a2, a3 + 1, "}", v400, v401, v402, v403, v404);
  }
  if (*(_QWORD *)(a1 + 200))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "instances = {", v406, v407, v408, v409, v410);
    for (i1 = *(_QWORD *)(a1 + 200); i1; i1 = *(_QWORD *)(i1 + 40))
      sub_10004391C(a2, a3 + 2, "%s,", v411, v412, v413, v414, v415, i1 + 1392);
    sub_10004391C(a2, a3 + 1, "}", v411, v412, v413, v414, v415);
  }
  if (*(_QWORD *)(a1 + 648))
  {
    sub_100043998(a2, v304, v305, v306, v307, v308, v309, v310, v889);
    sub_10004391C(a2, a3 + 1, "persist to boot modes = {", v417, v418, v419, v420, v421);
    v422 = *(void **)(a1 + 648);
    v905[0] = _NSConcreteStackBlock;
    v905[1] = 0x40000000;
    v905[2] = sub_100027CF8;
    v905[3] = &unk_10006C858;
    v905[4] = a2;
    v905[5] = a3;
    xpc_array_apply(v422, v905);
    sub_10004391C(a2, a3 + 1, "}", v423, v424, v425, v426, v427);
  }
  if ((*(_QWORD *)(a1 + 1384) & 1) != 0)
    v428 = "1";
  else
    v428 = "0";
  sub_10004391C(a2, a3 + 1, "retain only = %s", v306, v307, v308, v309, v310, v428);
  sub_100043998(a2, v429, v430, v431, v432, v433, v434, v435, v890);
  v441 = *(_DWORD *)(a1 + 1340);
  if (v441 + 1 >= 2)
  {
    object_type[0] = 0;
    object_addr[0] = 0;
    if (mach_port_kernel_object(mach_task_self_, v441, object_type, object_addr))
      sub_10004391C(a2, a3 + 1, "dext checkin port = %#x [unable to get port information]", v442, v443, v444, v445, v446, *(unsigned int *)(a1 + 1340), v900, v903);
    else
      sub_10004391C(a2, a3 + 1, "dext checkin port = %#x [type %u, object %#x]", v442, v443, v444, v445, v446, *(unsigned int *)(a1 + 1340), object_type[0], object_addr[0]);
    sub_100043998(a2, v447, v448, v449, v450, v451, v452, v453, v892);
  }
  v460 = *(unsigned int *)(a1 + 896);
  if (v460 >= 0x100)
  {
    v461 = v460 >> 8;
    if (v460 > 0x6FF)
      v462 = &unk_100056F87;
    else
      v462 = (void *)qword_10006C878[v461];
    sub_10004391C(a2, a3 + 1, "spawn type = %s (%lu)", v436, v437, v438, v439, v440, v462, v461);
  }
  v463 = *(unsigned int *)(a1 + 900);
  if ((_DWORD)v463)
  {
    if (v463 > 6)
      v464 = &unk_100056F87;
    else
      v464 = (void *)qword_10006C8B0[v463];
    sub_10004391C(a2, a3 + 1, "spawn role = %s (%lu)", v436, v437, v438, v439, v440, v464, v463);
  }
  v904 = a3 + 1;
  if (*(_QWORD *)(a1 + 904) || *(_QWORD *)(a1 + 1288))
  {
    sub_10004391C(a2, a3 + 1, "binary order preference = {", v436, v437, v438, v439, v440);
    v470 = *(_QWORD *)(a1 + 904);
    if (v470 && xpc_binprefs_count(*(_QWORD *)(a1 + 904)))
    {
      v471 = 0;
      do
      {
        v472 = xpc_binprefs_cpu_type(v470, v471);
        v478 = "(invalid)";
        if ((v472 & 0xFEFFFFFF) - 1 <= 0x11)
        {
          v479 = &off_10006C6C8[v472 & 0xFEFFFFFF];
          if ((v472 & 0x1000000) == 0)
            v479 = &off_10006C760[v472];
          v478 = *v479;
        }
        sub_10004391C(a2, a3 + 2, "%s", v473, v474, v475, v476, v477, v478);
        ++v471;
      }
      while (v471 < xpc_binprefs_count(v470));
    }
    v480 = *(_QWORD *)(a1 + 1288);
    if (v480 && xpc_binprefs_count(*(_QWORD *)(a1 + 1288)))
    {
      v481 = 0;
      do
      {
        v482 = xpc_binprefs_cpu_type(v480, v481);
        v488 = "(invalid)";
        if ((v482 & 0xFEFFFFFF) - 1 <= 0x11)
        {
          v489 = &off_10006C6C8[v482 & 0xFEFFFFFF];
          if ((v482 & 0x1000000) == 0)
            v489 = &off_10006C760[v482];
          v488 = *v489;
        }
        sub_10004391C(a2, a3 + 2, "+ %s", v483, v484, v485, v486, v487, v488);
        ++v481;
      }
      while (v481 < xpc_binprefs_count(v480));
    }
    v17 = a3 + 1;
    sub_10004391C(a2, v904, "}", v465, v466, v467, v468, v469);
    sub_100043998(a2, v490, v491, v492, v493, v494, v495, v496, v891);
  }
  sub_10004391C(a2, v17, "jetsam priority = %d", v436, v437, v438, v439, v440, *(unsigned int *)(a1 + 920));
  if ((*(_DWORD *)(a1 + 1312) & 0x80000000) == 0)
    sub_10004391C(a2, v17, "+ %d", v497, v498, v499, v500, v501, *(unsigned int *)(a1 + 1312));
  v502 = *(_DWORD *)(a1 + 924);
  if (v502 >= 1)
  {
    if ((*(_DWORD *)(a1 + 916) & 4) != 0)
      v503 = "hard";
    else
      v503 = "soft";
    v893 = v503;
    v900 = *(unsigned int *)(a1 + 924);
LABEL_231:
    v504 = "jetsam memory limit (active, %s) = %d MB";
    goto LABEL_234;
  }
  if (!v502)
  {
    if ((*(_DWORD *)(a1 + 916) & 4) != 0)
      v872 = "hard";
    else
      v872 = "soft";
    v893 = v872;
    v900 = 0xFFFFFFFFLL;
    goto LABEL_231;
  }
  v504 = "jetsam memory limit (active) = (unlimited)";
LABEL_234:
  sub_10004391C(a2, v17, v504, v497, v498, v499, v500, v501, v893, v900);
  v510 = *(_DWORD *)(a1 + 1316);
  if (v510 >= 1)
  {
    v894 = (const char *)*(unsigned int *)(a1 + 1316);
    v511 = "+ %d MB";
LABEL_236:
    sub_10004391C(a2, v17, v511, v505, v506, v507, v508, v509, v894);
    goto LABEL_238;
  }
  if (v510 < 0)
  {
    v511 = "+ (unlimited)";
    goto LABEL_236;
  }
LABEL_238:
  v512 = *(_DWORD *)(a1 + 928);
  if (v512 >= 1)
  {
    if ((*(_DWORD *)(a1 + 916) & 8) != 0)
      v513 = "hard";
    else
      v513 = "soft";
    v894 = v513;
    v901 = *(unsigned int *)(a1 + 928);
LABEL_243:
    v514 = "jetsam memory limit (inactive, %s) = %d MB";
    goto LABEL_246;
  }
  if (!v512)
  {
    if ((*(_DWORD *)(a1 + 916) & 8) != 0)
      v873 = "hard";
    else
      v873 = "soft";
    v894 = v873;
    v901 = 0xFFFFFFFFLL;
    goto LABEL_243;
  }
  v514 = "jetsam memory limit (inactive) = (unlimited)";
LABEL_246:
  sub_10004391C(a2, v17, v514, v505, v506, v507, v508, v509, v894, v901);
  v520 = *(_DWORD *)(a1 + 1316);
  if (v520 >= 1)
  {
    v895 = *(unsigned int *)(a1 + 1316);
    v521 = "+ %d MB";
LABEL_248:
    sub_10004391C(a2, v17, v521, v515, v516, v517, v518, v519, v895);
    goto LABEL_250;
  }
  if (v520 < 0)
  {
    v521 = "+ (unlimited)";
    goto LABEL_248;
  }
LABEL_250:
  v896 = sub_100023684(a1);
  sub_10004391C(a2, v17, "jetsamproperties category = %s", v522, v523, v524, v525, v526);
  if ((*(_BYTE *)(a1 + 1381) & 4) != 0)
    sub_10004391C(a2, v17, "submitted job. ignore execute allowed", v527, v528, v529, v530, v531);
  if (*(_DWORD *)(a1 + 932))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 932);
    sub_10004391C(a2, v17, "jetsam thread limit = %d", v527, v528, v529, v530, v531);
  }
  if (*(_QWORD *)(a1 + 936))
  {
    v896 = *(const char **)(a1 + 936);
    sub_10004391C(a2, v17, "jetsam address limit = %llu", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 944))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 944);
    sub_10004391C(a2, v17, "jetsam soft port limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 948))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 948);
    sub_10004391C(a2, v17, "jetsam hard port limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 952))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 952);
    sub_10004391C(a2, v17, "jetsam soft file descriptor limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 956))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 956);
    sub_10004391C(a2, v17, "jetsam hard file descriptor limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 960))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 960);
    sub_10004391C(a2, v17, "jetsam soft kqworkloop limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 964))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 964);
    sub_10004391C(a2, v17, "jetsam hard kqworkloop limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_DWORD *)(a1 + 968))
  {
    v896 = (const char *)*(unsigned int *)(a1 + 968);
    sub_10004391C(a2, v17, "jetsam wired memory limit = %u", v527, v528, v529, v530, v531);
  }
  if (*(_BYTE *)(a1 + 1018) || *(_DWORD *)(a1 + 1020))
  {
    v896 = (const char *)*(unsigned __int8 *)(a1 + 1018);
    v902 = *(unsigned int *)(a1 + 1020);
    v532 = "cpumon = %d%% over %u seconds";
  }
  else
  {
    v532 = "cpumon = default";
  }
  sub_10004391C(a2, v17, v532, v527, v528, v529, v530, v531, v896, v902);
  if (*(_QWORD *)(a1 + 680))
  {
    sub_10004391C(a2, v17, "resource limits = {", v533, v534, v535, v536, v537);
    v543 = *(uint64_t **)(a1 + 680);
    if (v543)
    {
      v544 = a3 + 2;
      do
      {
        if (*((_BYTE *)v543 + 35))
        {
          v912 = 0u;
          v913 = 0u;
          *(_OWORD *)object_type = 0u;
          v911 = 0u;
          if (v543[2] == 0x7FFFFFFFFFFFFFFFLL)
            strcpy((char *)object_type, "(infinity)");
          else
            snprintf((char *)object_type, 0x40uLL, "%llu", v543[2]);
          v897 = sub_100040380(*((unsigned __int16 *)v543 + 16));
          sub_10004391C(a2, v544, "%s (soft) => %s", v545, v546, v547, v548, v549);
        }
        if (*((_BYTE *)v543 + 34))
        {
          v912 = 0u;
          v913 = 0u;
          *(_OWORD *)object_type = 0u;
          v911 = 0u;
          if (v543[3] == 0x7FFFFFFFFFFFFFFFLL)
            strcpy((char *)object_type, "(infinity)");
          else
            snprintf((char *)object_type, 0x40uLL, "%llu", v543[3]);
          v897 = sub_100040380(*((unsigned __int16 *)v543 + 16));
          sub_10004391C(a2, v544, "%s (hard) => %s", v550, v551, v552, v553, v554);
        }
        v543 = (uint64_t *)*v543;
      }
      while (v543);
    }
    v17 = a3 + 1;
    sub_10004391C(a2, v904, "}", v538, v539, v540, v541, v542);
    sub_100043998(a2, v555, v556, v557, v558, v559, v560, v561, v897);
  }
  if (*(_DWORD *)(a1 + 880))
    sub_10004391C(a2, v17, "run interval = %u seconds", v533, v534, v535, v536, v537, *(unsigned int *)(a1 + 880));
  if ((*(_BYTE *)(a1 + 1382) & 8) != 0)
    sub_10004391C(a2, v17, "exponential throttling grace limit = %u", v533, v534, v535, v536, v537, *(unsigned __int16 *)(a1 + 1028));
  v562 = sub_10003D620(a1);
  if (v562)
    sub_10004391C(a2, v17, "job state = %s", v563, v564, v565, v566, v567, v562);
  v568 = *(_QWORD *)(a1 + 1376);
  if ((v568 & 0x400000000000) != 0)
  {
    sub_10004391C(a2, v17, "persona set at = %u", v563, v564, v565, v566, v567, *(unsigned int *)(a1 + 1328));
    v568 = *(_QWORD *)(a1 + 1376);
  }
  if ((v568 & 0x2000000000000) == 0)
  {
    if (*(_DWORD *)(a1 + 720) != -101)
      sub_10004391C(a2, v17, "resolved uid = %d", v563, v564, v565, v566, v567, *(unsigned int *)(a1 + 720));
    if (*(_DWORD *)(a1 + 724) != -101)
    {
      sub_10004391C(a2, v17, "resolved gid = %d", v563, v564, v565, v566, v567, *(unsigned int *)(a1 + 724));
      if (*(_DWORD *)(a1 + 792))
      {
        sub_10004391C(a2, v17, "resolved groups = {", v563, v564, v565, v566, v567);
        if (*(int *)(a1 + 792) >= 1)
        {
          v574 = 0;
          do
            sub_10004391C(a2, a3 + 2, "%d", v569, v570, v571, v572, v573, *(unsigned int *)(a1 + 728 + 4 * v574++));
          while (v574 < *(int *)(a1 + 792));
        }
        sub_10004391C(a2, v17, "}", v569, v570, v571, v572, v573);
      }
    }
  }
  if (*(_BYTE *)(a1 + 1030))
    sub_10004391C(a2, v17, "crash behavior = %x", v563, v564, v565, v566, v567, *(unsigned __int8 *)(a1 + 1030));
  if ((*(_BYTE *)(a1 + 1383) & 8) != 0)
  {
    v575 = sub_100023BE0(a1);
    v581 = a1 + 1040;
    if (v575)
      v581 = v575;
    count = *(void **)(v581 + 24);
    if (count)
      count = (void *)xpc_array_get_count(count);
    sub_10004391C(a2, v17, "panic on consecutive crashes (%zd)", v576, v577, v578, v579, v580, count);
  }
  sub_10004391C(a2, v17, "probabilistic guard malloc policy = {", v563, v564, v565, v566, v567);
  sub_10004391C(a2, a3 + 2, "activation rate = 1/%u", v583, v584, v585, v586, v587, *(unsigned int *)(a1 + 1352));
  LODWORD(v898) = *(_DWORD *)(a1 + 1348);
  sub_10004391C(a2, a3 + 2, "sample rate = 1/%u", v588, v589, v590, v591, v592);
  sub_10004391C(a2, v17, "}", v593, v594, v595, v596, v597);
  v603 = *(unsigned __int8 *)(a1 + 1344);
  if (*(_BYTE *)(a1 + 1344))
  {
    if (v603 == 1)
      v604 = "1";
    else
      v604 = "0";
    if (v603 == 2)
      v605 = "managed";
    else
      v605 = v604;
    sub_10004391C(a2, v17, "multiple instances = %s", v598, v599, v600, v601, v602, v605);
  }
  if (*(_QWORD *)(a1 + 1360))
  {
    v898 = *(_QWORD *)(a1 + 1360);
    sub_10004391C(a2, v17, "cryptex = %s", v598, v599, v600, v601, v602);
  }
  if (*(_QWORD *)(a1 + 1368))
  {
    v898 = *(_QWORD *)(a1 + 1368);
    sub_10004391C(a2, v17, "conclave = %s", v598, v599, v600, v601, v602);
  }
  v606 = (void **)sub_1000106C8(0x80uLL);
  sub_100027D6C((uint64_t)v606, (char)"partial import", *(_DWORD *)(a1 + 1376) & 1, v607, v608, v609, v610, v611);
  sub_100027D6C((uint64_t)v606, (char)"xpc bundle", (*(_QWORD *)(a1 + 1376) >> 1) & 1, v612, v613, v614, v615, v616);
  sub_100027D6C((uint64_t)v606, (char)"keepalive", (*(_QWORD *)(a1 + 1376) >> 2) & 1, v617, v618, v619, v620, v621);
  sub_100027D6C((uint64_t)v606, (char)"runatload", (*(_QWORD *)(a1 + 1376) >> 4) & 1, v622, v623, v624, v625, v626);
  sub_100027D6C((uint64_t)v606, (char)"low priority i/o", (*(_QWORD *)(a1 + 1376) >> 5) & 1, v627, v628, v629, v630, v631);
  sub_100027D6C((uint64_t)v606, (char)"low priority background i/o", (*(_QWORD *)(a1 + 1376) >> 6) & 1, v632, v633, v634, v635, v636);
  sub_100027D6C((uint64_t)v606, (char)"dataless file mode", *(_BYTE *)(a1 + 1332) != 0, v637, v638, v639, v640, v641);
  sub_100027D6C((uint64_t)v606, (char)"exception handler", (*(_QWORD *)(a1 + 1376) >> 7) & 1, v642, v643, v644, v645, v646);
  sub_100027D6C((uint64_t)v606, (char)"supports transactions", (*(_QWORD *)(a1 + 1376) >> 8) & 1, v647, v648, v649, v650, v651);
  sub_100027D6C((uint64_t)v606, (char)"supports pressured exit", (*(_QWORD *)(a1 + 1376) >> 9) & 1, v652, v653, v654, v655, v656);
  sub_100027D6C((uint64_t)v606, (char)"supports idle hysteresis", (*(_QWORD *)(a1 + 1376) >> 47) & 1, v657, v658, v659, v660, v661);
  sub_100027D6C((uint64_t)v606, (char)"enter kdp before kill", (*(_QWORD *)(a1 + 1376) >> 10) & 1, v662, v663, v664, v665, v666);
  sub_100027D6C((uint64_t)v606, (char)"wait for debugger", (*(_QWORD *)(a1 + 1376) >> 11) & 1, v667, v668, v669, v670, v671);
  sub_100027D6C((uint64_t)v606, (char)"app", (*(_QWORD *)(a1 + 1376) >> 12) & 1, v672, v673, v674, v675, v676);
  sub_100027D6C((uint64_t)v606, (char)"system app", (*(_QWORD *)(a1 + 1376) >> 13) & 1, v677, v678, v679, v680, v681);
  sub_100027D6C((uint64_t)v606, (char)"inetd-compatible", (*(_QWORD *)(a1 + 1376) >> 14) & 1, v682, v683, v684, v685, v686);
  sub_100027D6C((uint64_t)v606, (char)"inetd listener", (*(_QWORD *)(a1 + 1376) >> 15) & 1, v687, v688, v689, v690, v691);
  sub_100027D6C((uint64_t)v606, (char)"abandon process group", (*(_QWORD *)(a1 + 1376) >> 16) & 1, v692, v693, v694, v695, v696);
  sub_100027D6C((uint64_t)v606, (char)"event monitor", (*(_QWORD *)(a1 + 1376) >> 17) & 1, v697, v698, v699, v700, v701);
  sub_100027D6C((uint64_t)v606, (char)"penalty box", (*(_QWORD *)(a1 + 1376) >> 18) & 1, v702, v703, v704, v705, v706);
  sub_100027D6C((uint64_t)v606, (char)"role account", (*(_QWORD *)(a1 + 1376) >> 19) & 1, v707, v708, v709, v710, v711);
  sub_100027D6C((uint64_t)v606, (char)"launch only once", (*(_QWORD *)(a1 + 1376) >> 20) & 1, v712, v713, v714, v715, v716);
  sub_100027D6C((uint64_t)v606, (char)"system support", (*(_QWORD *)(a1 + 1376) >> 21) & 1, v717, v718, v719, v720, v721);
  sub_100027D6C((uint64_t)v606, (char)"initial system support", (*(_QWORD *)(a1 + 1376) >> 22) & 1, v722, v723, v724, v725, v726);
  sub_100027D6C((uint64_t)v606, (char)"inferred program", (*(_QWORD *)(a1 + 1376) >> 24) & 1, v727, v728, v729, v730, v731);
  sub_100027D6C((uint64_t)v606, (char)"ios home screen app", (*(_QWORD *)(a1 + 1376) >> 29) & 1, v732, v733, v734, v735, v736);
  sub_100027D6C((uint64_t)v606, (char)"abandon coalition", (*(_QWORD *)(a1 + 1376) >> 30) & 1, v737, v738, v739, v740, v741);
  sub_100027D6C((uint64_t)v606, (char)"disable pointer auth", (*(_QWORD *)(a1 + 1376) >> 55) & 1, v742, v743, v744, v745, v746);
  sub_100027D6C((uint64_t)v606, (char)"high bits aslr", (*(_QWORD *)(a1 + 1376) >> 33) & 1, v747, v748, v749, v750, v751);
  v752 = sub_100023BE0(a1);
  v758 = (unsigned __int8 *)(a1 + 1040);
  if (v752)
    v758 = (unsigned __int8 *)v752;
  sub_100027D6C((uint64_t)v606, (char)"reslide shared cache", *v758, v753, v754, v755, v756, v757);
  sub_100027D6C((uint64_t)v606, (char)"disable resliding", (*(_QWORD *)(a1 + 1376) >> 53) & 1, v759, v760, v761, v762, v763);
  sub_100027D6C((uint64_t)v606, (char)"extension", (*(_QWORD *)(a1 + 1376) >> 34) & 1, v764, v765, v766, v767, v768);
  sub_100027D6C((uint64_t)v606, (char)"nano allocator", (*(_QWORD *)(a1 + 1376) >> 25) & 1, v769, v770, v771, v772, v773);
  sub_100027D6C((uint64_t)v606, (char)"enable sec_transition shim", (*(_QWORD *)(a1 + 1376) >> 26) & 1, v774, v775, v776, v777, v778);
  sub_100027D6C((uint64_t)v606, (char)"no initgroups", (*(_QWORD *)(a1 + 1376) >> 31) & 1, v779, v780, v781, v782, v783);
  sub_100027D6C((uint64_t)v606, (char)"needs implicit endpoint", (*(_QWORD *)(a1 + 1376) >> 38) & 1, v784, v785, v786, v787, v788);
  sub_100027D6C((uint64_t)v606, (char)"platform binary", (*(_QWORD *)(a1 + 1376) >> 40) & 1, v789, v790, v791, v792, v793);
  sub_100027D6C((uint64_t)v606, (char)"is copy", (*(_QWORD *)(a1 + 1376) >> 41) & 1, v794, v795, v796, v797, v798);
  sub_100027D6C((uint64_t)v606, (char)"disallow all lookups", (*(_QWORD *)(a1 + 1376) >> 43) & 1, v799, v800, v801, v802, v803);
  sub_100027D6C((uint64_t)v606, (char)"always sigterm on shutdown", (*(_QWORD *)(a1 + 1376) >> 45) & 1, v804, v805, v806, v807, v808);
  sub_100027D6C((uint64_t)v606, (char)"one-shot", (*(_DWORD *)(a1 + 368) >> 5) & 1, v809, v810, v811, v812, v813);
  sub_100027D6C((uint64_t)v606, (char)"use maximum address space limit (for sanitizers)", HIWORD(*(_QWORD *)(a1 + 1376)) & 1, v814, v815, v816, v817, v818);
  sub_100027D6C((uint64_t)v606, (char)"null bootstrap port", (*(_QWORD *)(a1 + 1376) >> 50) & 1, v819, v820, v821, v822, v823);
  sub_100027D6C((uint64_t)v606, (char)"exponential throttling", (*(_QWORD *)(a1 + 1376) >> 51) & 1, v824, v825, v826, v827, v828);
  sub_100027D6C((uint64_t)v606, (char)"abandon during shutdown", HIBYTE(*(_QWORD *)(a1 + 1376)) & 1, v829, v830, v831, v832, v833);
  sub_100027D6C((uint64_t)v606, (char)"needs proxy", (*(_QWORD *)(a1 + 1376) >> 49) & 1, v834, v835, v836, v837, v838);
  sub_100027D6C((uint64_t)v606, (char)"has spawn constraint", *(_DWORD *)(a1 + 624) != 0, v839, v840, v841, v842, v843);
  sub_100027D6C((uint64_t)v606, (char)"tle system", *(unsigned __int8 *)(a1 + 984) == 1, v844, v845, v846, v847, v848);
  sub_100027D6C((uint64_t)v606, (char)"has provenance", *(_DWORD *)(a1 + 608) != 0, v849, v850, v851, v852, v853);
  sub_100043998(a2, v854, v855, v856, v857, v858, v859, v860, v898);
  sub_10004391C(a2, v17, "properties = %s", v861, v862, v863, v864, v865, *v606);
  sub_100010718(v606);
  return sub_10004391C(a2, a3, "}", v866, v867, v868, v869, v870);
}

const char *sub_100023684(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 1376);
  if ((v1 & 0x400000000) != 0)
    return "extension";
  if ((v1 & 2) != 0)
  {
    if (sub_100028DB4(*(_QWORD *)(a1 + 248)))
      return "system xpcservice";
    else
      return "xpcservice";
  }
  else if ((v1 & 0x2000) != 0)
  {
    return "system app";
  }
  else if ((v1 & 0x1000) != 0)
  {
    return "app";
  }
  else if (*(_DWORD *)(a1 + 896) == 1792)
  {
    return "DriverKit";
  }
  else
  {
    return "daemon";
  }
}

uint64_t sub_10002370C(uint64_t a1, FILE *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = a3 + 1;
  v5 = a1 + 1392;
  v6 = sub_100023684(a1);
  return sub_10004391C(a2, v4, "%s : %s", v7, v8, v9, v10, v11, v5, v6);
}

uint64_t sub_10002375C(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;
  __int16 v12;
  int v13;
  char v15[8];
  uint64_t v16;
  uint64_t v17;
  char __str[8];
  uint64_t v19;
  uint64_t v20;

  if (*(_DWORD *)(a1 + 296))
    sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
  *(_QWORD *)__str = 0;
  v19 = 0;
  v20 = 0;
  if (*(_DWORD *)(a1 + 1152))
    snprintf(__str, 0x18uLL, "%d", *(_DWORD *)(a1 + 1152));
  else
    strcpy(__str, "0");
  *(_QWORD *)v15 = 0;
  v16 = 0;
  v17 = 0;
  v11 = *(_DWORD *)(a1 + 1200);
  if (v11 == 2)
  {
    v15[4] = 0;
    v13 = 695363112;
    goto LABEL_12;
  }
  if (v11 == 1)
  {
    v15[4] = 0;
    v13 = 694313256;
    goto LABEL_12;
  }
  if (v11)
  {
    if (sub_100044038(a1 + 1200))
    {
      sub_100044064((_DWORD *)(a1 + 1200));
      snprintf(v15, 0x18uLL, "%d");
      return sub_10004391C(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1392);
    }
    if (sub_10004410C((_DWORD *)(a1 + 1200)))
    {
      sub_100044154((_DWORD *)(a1 + 1200));
      snprintf(v15, 0x18uLL, "-%d");
      return sub_10004391C(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1392);
    }
    if (sub_10004423C((_DWORD *)(a1 + 1200)))
    {
      v15[4] = 0;
      if (sub_100044284(a1 + 1200))
        v13 = 694513704;
      else
        v13 = 695495208;
    }
    else if (sub_1000442DC((_DWORD *)(a1 + 1200)))
    {
      v15[4] = 0;
      v13 = 695427880;
    }
    else
    {
      if (!sub_1000442B0(a1 + 1200))
      {
        v12 = 63;
        goto LABEL_9;
      }
      v15[4] = 0;
      v13 = 695232040;
    }
LABEL_12:
    *(_DWORD *)v15 = v13;
    return sub_10004391C(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1392);
  }
  v12 = 45;
LABEL_9:
  *(_WORD *)v15 = v12;
  return sub_10004391C(a2, a3, "%8s %6s \t%s", a4, a5, a6, a7, a8, __str, v15, a1 + 1392);
}

uint64_t sub_100023950(uint64_t a1, const char *a2)
{
  uint64_t i;
  const char *v4;

  for (i = *(_QWORD *)(a1 + 144); i; i = *(_QWORD *)(i + 16))
  {
    v4 = (const char *)sub_10003A770(i);
    if (!strcmp(v4, a2))
      break;
  }
  return i;
}

char *sub_100023994(unsigned int a1)
{
  if (a1 >= 0x11)
    sub_10004D738();
  return off_10006C528[a1];
}

uint64_t sub_1000239BC(uint64_t result, int a2)
{
  *(_DWORD *)(result + 1128) = a2;
  return result;
}

BOOL sub_1000239C4(uint64_t a1, int a2)
{
  int v2;
  BOOL v3;

  v2 = *(_DWORD *)(a1 + 1128);
  if (v2)
    v3 = v2 == a2;
  else
    v3 = 1;
  return !v3;
}

BOOL sub_1000239D8(uint64_t a1)
{
  return *(_DWORD *)(a1 + 1128) != 0;
}

uint64_t sub_1000239E8(uint64_t a1, unsigned __int8 *uu1)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 200); i; i = *(_QWORD *)(i + 40))
  {
    if (!uuid_compare(uu1, (const unsigned __int8 *)(i + 408)))
      break;
  }
  return i;
}

uint64_t sub_100023A28(mach_port_context_t a1)
{
  uint64_t result;

  if ((*(_BYTE *)(a1 + 1379) & 0x10) != 0)
    sub_10004D738();
  result = *(unsigned int *)(a1 + 1336);
  if (!(_DWORD)result)
  {
    result = sub_10000D880(1u, 0, a1);
    *(_DWORD *)(a1 + 1336) = result;
  }
  return result;
}

uint64_t sub_100023A6C(mach_port_context_t guard)
{
  uint64_t result;

  if ((*(_BYTE *)(guard + 1379) & 0x10) == 0)
    sub_10004D738();
  result = *(unsigned int *)(guard + 1336);
  if ((_DWORD)result)
  {
    result = sub_10000D994(result, 0, guard);
    if ((_DWORD)result)
      sub_10004D764(result);
    *(_DWORD *)(guard + 1336) = 0;
  }
  return result;
}

uint64_t sub_100023AB4(uint64_t a1)
{
  return *(_BYTE *)(a1 + 1383) & 1;
}

uint64_t sub_100023AC0(uint64_t a1)
{
  if (byte_100071AC4)
    return sub_100023AF0(a1) ^ 1;
  else
    return 0;
}

uint64_t sub_100023AF0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  const char *v8;
  uint64_t v9;

  if ((*(_BYTE *)(a1 + 1382) & 2) != 0)
    return 1;
  if (sub_100039000())
    sub_10004D738();
  v7 = *(_DWORD *)(a1 + 700);
  if ((v7 || (v9 = *(_QWORD *)(a1 + 256)) != 0 && (v7 = *(_DWORD *)(v9 + 700)) != 0) && v7 != -1)
  {
    v8 = "it has a control port set";
LABEL_11:
    sub_10001D418(a1, 5, "service will use proxy because %s", v2, v3, v4, v5, v6, (char)v8);
    return 1;
  }
  if ((*(_BYTE *)(a1 + 1322) & 0xA) != 0 || *(_QWORD *)(a1 + 1256))
  {
    v8 = "it is being debugged";
    goto LABEL_11;
  }
  if (*(_QWORD *)(a1 + 1272))
  {
    v8 = "its working directory has been overridden";
    goto LABEL_11;
  }
  return 0;
}

uint64_t sub_100023BAC(uint64_t a1)
{
  if ((*(_BYTE *)(a1 + 1381) & 0x40) != 0)
    return *(unsigned int *)(a1 + 1328);
  else
    return sub_10002EBF4(*(_QWORD *)(a1 + 248), (const void *)(a1 + 1392));
}

uint64_t sub_100023BCC(uint64_t a1)
{
  return *(_QWORD *)(a1 + 1360);
}

uint64_t sub_100023BD4(uint64_t a1)
{
  return *(_BYTE *)(a1 + 1384) & 1;
}

uint64_t sub_100023BE0(uint64_t a1)
{
  uint64_t result;

  result = sub_10001D0CC(a1);
  if (result)
    return os_map_str_find(result, *(_QWORD *)(a1 + 576));
  return result;
}

void sub_100023C14(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 40);
  v3 = *(void **)(a1 + 24);
  sub_100044E20(*(unsigned int *)(a1 + 16), v3);
  xpc_release(v3);
  sub_10001962C(v2);
  free((void *)a1);
}

xpc_object_t sub_100023C6C(void *a1, __uint64_t a2)
{
  __uint64_t v4;
  xpc_object_t v5;
  size_t v6;
  uint64_t uint64;
  uint64_t v8;

  v4 = clock_gettime_nsec_np(_CLOCK_MONOTONIC);
  v5 = 0;
  if (xpc_array_get_count(a1))
  {
    v6 = 0;
    do
    {
      uint64 = xpc_array_get_uint64(a1, v6);
      v8 = uint64;
      if (v4 < uint64)
      {
        _os_assumes_log(uint64 - v4);
      }
      else if (v4 - uint64 < a2)
      {
        if (!v5)
          v5 = xpc_array_create(0, 0);
        xpc_array_set_uint64(v5, 0xFFFFFFFFFFFFFFFFLL, v8);
      }
      ++v6;
    }
    while (v6 < xpc_array_get_count(a1));
  }
  return v5;
}

void sub_100023D28(uint64_t a1, int a2)
{
  int v2;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(unsigned __int8 *)(a1 + 424);
  if (v2 != a2)
  {
    if (v2 == 2 && a2 != 0 && a2 != 3)
      sub_10004DEEC(a2);
    *(_BYTE *)(a1 + 424) = a2;
    if (a2 == 1)
      sub_10001D2D4(a1, 0, 0);
    v6 = sub_100023DAC(a1);
    sub_10001D418(a1, 5, "service state: %s", v7, v8, v9, v10, v11, v6);
  }
}

const char *sub_100023DAC(uint64_t a1)
{
  const char *result;

  switch(*(_BYTE *)(a1 + 424))
  {
    case 1:
      result = "spawn scheduled";
      break;
    case 2:
      result = "spawning";
      break;
    case 3:
      if ((*(_BYTE *)(a1 + 1192) & 0x80) != 0)
        result = "xpcproxy";
      else
        result = "spawned";
      break;
    case 4:
      result = "running";
      break;
    case 5:
      result = "SIGTERMed";
      break;
    case 6:
      result = "SIGKILLed";
      break;
    case 7:
      result = "languishing";
      break;
    case 8:
      result = "exited";
      break;
    default:
      result = "not running";
      break;
  }
  return result;
}

uint64_t sub_100023E54(uint64_t a1, int a2)
{
  __uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;

  if (*(_BYTE *)(a1 + 424) != 1)
    sub_10004D738();
  sub_100023D28(a1, 2);
  if (*(_BYTE *)(a1 + 424) != 2)
    sub_10004D738();
  if (*(_QWORD *)(a1 + 976))
  {
    v4 = clock_gettime_nsec_np(_CLOCK_UPTIME_RAW);
    sub_10001CFE4(*(_QWORD *)(a1 + 976), v4 / 0xF4240);
  }
  v5 = sub_100023BE0(a1);
  v6 = a1 + 1040;
  if (v5)
    v6 = v5;
  *(_BYTE *)(v6 + 1) = 0;
  *(_QWORD *)(a1 + 1376) &= ~0x800000uLL;
  *(_DWORD *)(a1 + 1160) = a2;
  *(_QWORD *)(a1 + 1188) = *(_QWORD *)(a1 + 1188) & 0xFFFFFFF7FFFFFFFFLL | ((unint64_t)((*(unsigned __int8 *)(a1 + 1322) >> 1) & 1) << 35);
  result = sub_100023AF0(a1);
  v8 = 0x8000000000;
  if (!(_DWORD)result)
    v8 = 0;
  *(_QWORD *)(a1 + 1188) = *(_QWORD *)(a1 + 1188) & 0xFFFFFD7FFFFFFFFFLL | v8;
  return result;
}

uint64_t sub_100023F34(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  mach_port_t v22;
  unint64_t *v23;
  __int16 v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _DWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _DWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t i;
  int v73;
  int v74;
  int v75;
  void *v76;
  uint64_t v77;
  NSObject *v78;
  char v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  const char *v86;
  uint64_t v87;
  unsigned int v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char v97;
  char v98;
  _QWORD v99[5];
  pid_t v100;
  posix_spawnattr_t v101;
  posix_spawn_file_actions_t v102[141];
  int v103;
  _BYTE v104[124];
  _QWORD v105[2];
  _QWORD v106[2];
  _DWORD v107[128];
  unint64_t v108;
  mach_port_name_t v109;
  _DWORD __str[4];
  __int128 v111;
  __int128 v112;
  __int128 v113;
  unint64_t v114;
  sigset_t v115[2];
  uint64_t v116;
  uint64_t v117;
  sigset_t v118[2];
  uint64_t v119;
  sigset_t *v120;
  uint64_t v121;

  bzero(&v101, 0x728uLL);
  sub_100012734((uint64_t)&v101, 0);
  *(_QWORD *)&v104[116] = a1;
  v8 = *(_QWORD *)(a1 + 152);
  if (v8)
  {
    v9 = 0;
    do
    {
      if ((*(_BYTE *)(v8 + 88) & 0x40) == 0)
      {
        v107[v9++] = sub_1000457E0(v8, 1, v2, v3, v4, v5, v6, v7);
        if (v9 == 128)
        {
          sub_10001D418(a1, 4, "Skipping remaining service endpoints for importance boosting.", v3, v4, v5, v6, v7, v97);
          goto LABEL_20;
        }
      }
      v8 = *(_QWORD *)(v8 + 16);
    }
    while (v8);
    if (v9 <= 0x7F)
      goto LABEL_9;
    goto LABEL_20;
  }
  v9 = 0;
LABEL_9:
  v10 = *(_QWORD *)(a1 + 176);
  if (v10)
  {
    while (1)
    {
      if ((*(_BYTE *)(v10 + 88) & 0x40) == 0)
      {
        v107[v9++] = sub_1000457E0(v10, 1, v2, v3, v4, v5, v6, v7);
        if (v9 == 128)
          break;
      }
      v10 = *(_QWORD *)(v10 + 16);
      if (!v10)
      {
        if (v9 > 0x7F)
          goto LABEL_21;
        goto LABEL_14;
      }
    }
LABEL_20:
    sub_10001D418(a1, 4, "Skipping remaining event endpoints for importance boosting.", v3, v4, v5, v6, v7, v97);
    goto LABEL_21;
  }
LABEL_14:
  v11 = *(_QWORD *)(a1 + 184);
  if (!v11)
    goto LABEL_22;
  while (1)
  {
    if ((*(_BYTE *)(v11 + 88) & 0x40) == 0)
    {
      v107[v9++] = sub_1000457E0(v11, 1, v2, v3, v4, v5, v6, v7);
      if (v9 == 128)
        break;
    }
    v11 = *(_QWORD *)(v11 + 16);
    if (!v11)
      goto LABEL_22;
  }
LABEL_21:
  sub_10001D418(a1, 4, "Skipping remaining instance endpoints for importance boosting.", v3, v4, v5, v6, v7, v97);
LABEL_22:
  v108 = v9;
  v12 = *(char **)(a1 + 888);
  if (v12)
  {
    v13 = sub_10002CCF8(*(_QWORD *)(a1 + 248), v12);
    if (v13)
    {
      v109 = sub_1000457E0(v13, 1, v14, v15, v16, v17, v18, v19);
      v20 = sub_10000D964(v109);
      if (v20)
        sub_10004D764(v20);
    }
    else
    {
      sub_10001D418(a1, 3, "Could not find exception endpoint for service: %s", v15, v16, v17, v18, v19, *(_QWORD *)(a1 + 888));
    }
  }
  v21 = v108;
  v22 = v109;
  v23 = (unint64_t *)(a1 + 1188);
  if ((*(_QWORD *)(a1 + 1188) & 0x800000000) != 0)
    v24 = 16524;
  else
    v24 = 16396;
  if (posix_spawnattr_setflags(&v101, v24))
    _os_assumes_log_ctx(sub_10001F174, a1);
  v118[0] = 0;
  if (posix_spawnattr_setsigmask(&v101, v118))
    _os_assumes_log_ctx(sub_10001F174, a1);
  v115[0] = -1;
  if (posix_spawnattr_setsigdefault(&v101, v115))
    _os_assumes_log_ctx(sub_10001F174, a1);
  v25 = *(_DWORD *)(a1 + 896);
  if (v25 == 1792)
    v26 = 1024;
  else
    v26 = v25;
  if (posix_spawnattr_setprocesstype_np(&v101, v26))
    _os_assumes_log_ctx(sub_10001F174, a1);
  v27 = *(unsigned int *)(a1 + 900);
  if ((_DWORD)v27)
  {
    v28 = posix_spawnattr_set_darwin_role_np(&v101, v27);
    if (v28)
      sub_10004D764(v28);
  }
  if (*(_QWORD *)(a1 + 1368))
  {
    v29 = posix_spawnattr_set_conclave_id_np(&v101);
    if (v29)
      sub_10004D764(v29);
  }
  if (posix_spawnattr_set_importancewatch_port_np(&v101, v21, v107))
    _os_assumes_log_ctx(sub_10001F174, a1);
  if (posix_spawnattr_setjetsam_ext(&v101, 1, 210, 0xFFFFFFFFLL, 0xFFFFFFFFLL))
    _os_assumes_log_ctx(sub_10001F174, a1);
  v30 = *(_QWORD *)(a1 + 976);
  if (v30)
  {
    v31 = sub_10001D034(v30);
    if (v31)
    {
      v32 = 0;
      v112 = 0u;
      v113 = 0u;
      v33 = v31;
      *(_OWORD *)__str = 0u;
      v111 = 0u;
      do
      {
        __str[v32] = sub_10001D03C(*(_QWORD *)(a1 + 976), v32);
        ++v32;
      }
      while (v33 != v32);
      if (posix_spawnattr_set_jetsam_ttr_np(&v101, v33, __str))
        _os_assumes_log_ctx(sub_10001F174, a1);
    }
  }
  *(_QWORD *)__str = sub_10002E5C8(*(_QWORD *)(a1 + 248), a1, (*(_QWORD *)(a1 + 1376) >> 30) & 1);
  *(_QWORD *)&__str[2] = v34;
  sub_100010234(a1, (uint64_t)&v101, 0, (uint64_t)__str);
  *(_QWORD *)__str = sub_10002E718(*(_QWORD *)(a1 + 248), a1);
  *(_QWORD *)&__str[2] = v35;
  sub_100010234(a1, (uint64_t)&v101, 1, (uint64_t)__str);
  if ((*(_BYTE *)(a1 + 1381) & 0x40) != 0)
    v36 = *(unsigned int *)(a1 + 1328);
  else
    v36 = sub_10002EBF4(*(_QWORD *)(a1 + 248), (const void *)(a1 + 1392));
  if ((_DWORD)v36 != -1)
  {
    if (posix_spawnattr_set_persona_np(&v101, v36, 0))
      _os_assumes_log_ctx(sub_10001F174, a1);
    if (posix_spawnattr_set_persona_uid_np(&v101, 0))
      _os_assumes_log_ctx(sub_10001F174, a1);
    if (posix_spawnattr_set_persona_gid_np(&v101, 0))
      _os_assumes_log_ctx(sub_10001F174, a1);
  }
  if (v22 - 1 <= 0xFFFFFFFD)
  {
    v37 = sub_10000DB0C(&v101, v22);
    if (v37)
      sub_10004D764(v37);
  }
  ++*(_DWORD *)(a1 + 1024);
  v38 = mach_absolute_time();
  v39 = sub_100023BE0(a1);
  v40 = a1 + 1040;
  if (v39)
    v41 = v39;
  else
    v41 = a1 + 1040;
  *(_QWORD *)(v41 + 8) = v38;
  v42 = sub_100023BE0(a1);
  if (v42)
    v43 = v42;
  else
    v43 = a1 + 1040;
  if (v43 == v40)
    v44 = a1 + 1200;
  else
    v44 = v43 + 32;
  v45 = sub_10004419C(v44);
  v46 = sub_100023BE0(a1);
  if (v45)
  {
    if (v46)
      v52 = v46;
    else
      v52 = a1 + 1040;
    if (v52 == v40)
      v53 = (_DWORD *)(a1 + 1200);
    else
      v53 = (_DWORD *)(v52 + 32);
    if (!sub_10004423C(v53) && (*(_BYTE *)(a1 + 1382) & 8) != 0)
    {
      v54 = sub_100023BE0(a1);
      if (v54)
        v55 = v54;
      else
        v55 = a1 + 1040;
      sub_100024F6C((xpc_object_t *)(v55 + 16));
    }
    v56 = sub_100023BE0(a1);
    if (v56)
      v57 = v56;
    else
      v57 = a1 + 1040;
    if (v57 == v40)
      v58 = (_DWORD *)(a1 + 1200);
    else
      v58 = (_DWORD *)(v57 + 32);
    if (!sub_10004423C(v58)
      || ((v59 = sub_100023BE0(a1)) != 0 ? (v60 = v59) : (v60 = a1 + 1040),
          v60 != v40 ? (v61 = v60 + 32) : (v61 = a1 + 1200),
          sub_100044254(v61)))
    {
      if ((*(_BYTE *)(a1 + 1383) & 8) != 0)
      {
        v62 = sub_100023BE0(a1);
        if (v62)
          v63 = v62;
        else
          v63 = a1 + 1040;
        sub_100024F6C((xpc_object_t *)(v63 + 24));
      }
    }
  }
  else if ((*(_BYTE *)(a1 + 1383) & 8) != 0)
  {
    v64 = v46 ? v46 : a1 + 1040;
    if (*(_QWORD *)(v64 + 24))
    {
      sub_10001D418(a1, 5, "Reseting consecutive crash history", v47, v48, v49, v50, v51, v97);
      xpc_release(*(xpc_object_t *)(v64 + 24));
      *(_QWORD *)(v64 + 24) = 0;
    }
  }
  v65 = sub_100023994(*(_DWORD *)(a1 + 1160));
  sub_10001D418(a1, 5, "launching: %s", v66, v67, v68, v69, v70, v65);
  sub_100014714();
  v71 = qword_100071D58;
  *(_QWORD *)(a1 + 24) = qword_100071D58;
  if (v71)
    *(_QWORD *)(v71 + 32) = a1 + 24;
  qword_100071D58 = a1;
  *(_QWORD *)(a1 + 32) = &qword_100071D58;
  if ((*(_BYTE *)(a1 + 1192) & 0x80) == 0)
  {
    v106[1] = sub_100004B34(a1, v105, v106) - 240;
    v105[1] = *(_QWORD *)(a1 + 1304);
    *(_QWORD *)(a1 + 1304) = 0;
    v102[140] = *(posix_spawn_file_actions_t *)(a1 + 720);
    v103 = *(_DWORD *)(a1 + 792);
    __memcpy_chk(v104, a1 + 728, 4 * v103, 692);
    for (i = 0; i != 3; ++i)
    {
      v73 = *(_DWORD *)(a1 + 4 * i + 688);
      if (v73 != -1)
      {
        if ((_DWORD)i == v73)
        {
          v74 = posix_spawn_file_actions_addinherit_np(v102, v73);
          if (v74)
            sub_10004D764(v74);
        }
        else
        {
          v75 = posix_spawn_file_actions_adddup2(v102, v73, i);
          if (v75)
            sub_10004D764(v75);
        }
      }
    }
    *v23 = *v23 & 0xFFFFFFFBFFFFFFFFLL | ((unint64_t)*(unsigned __int8 *)(v106[0] + 108) << 34);
    sub_100024C88(a1);
    *v23 |= (unint64_t)&_mh_execute_header;
    *(_DWORD *)(a1 + 1156) = 0;
    v76 = sub_10001541C(&v101, 0x728uLL);
    v77 = sub_10003D470(a1);
    v78 = sub_100014720();
    v99[0] = _NSConcreteStackBlock;
    v99[1] = 0x40000000;
    v99[2] = sub_100024D40;
    v99[3] = &unk_10006C5F0;
    v99[4] = v76;
    v79 = sub_100038EFC(v77, v78, v99);
    v85 = 0;
    if (v77 && (v79 & 1) == 0)
    {
      sub_10001D418(a1, 5, "couldn't handoff a spawn, asynced away", v80, v81, v82, v83, v84, v98);
      return 0;
    }
    return v85;
  }
  v100 = 0;
  v86 = off_100071A80[0];
  *(_QWORD *)v118 = "xpcproxy";
  v119 = a1 + 1392;
  v120 = 0;
  v121 = 0;
  *(_QWORD *)v115 = 0;
  v116 = 0;
  v117 = 0;
  if ((_UNKNOWN *)sub_10002E360(*(_QWORD *)(a1 + 248)) == &unk_100071750)
  {
    v87 = sub_10002E368(*(_QWORD *)(a1 + 248));
    snprintf((char *)v115, 0x18uLL, "%lu", v87);
    v120 = v115;
  }
  if (posix_spawn_file_actions_addopen(v102, 0, "/dev/console", 0, 0) == -1)
    sub_10004D914();
  if (posix_spawn_file_actions_addopen(v102, 1, "/dev/console", 1, 0) == -1)
    sub_10004D914();
  if (posix_spawn_file_actions_addopen(v102, 2, "/dev/console", 2, 0) == -1)
    sub_10004D914();
  v114 = 0;
  v112 = 0u;
  v113 = 0u;
  *(_OWORD *)__str = 0u;
  v111 = 0u;
  sub_100047FD0((*(_QWORD *)(a1 + 1376) >> 24) & 0x400, (char *)__str);
  v88 = *(_DWORD *)(a1 + 700);
  if (!v88)
  {
    v89 = *(_QWORD *)(a1 + 256);
    if (!v89)
      goto LABEL_138;
    v88 = *(_DWORD *)(v89 + 700);
  }
  if (v88 - 1 < 0xFFFFFFFE)
  {
    v114 = __PAIR64__(v88, dword_100072A00);
    v90 = posix_spawnattr_set_registered_ports_np(&v101, &v114, 2);
    if (v90)
      sub_10004D764(v90);
    goto LABEL_139;
  }
LABEL_138:
  v114 = 0;
LABEL_139:
  if (posix_spawnattr_set_launch_type_np(&v101, 1) == -1)
    sub_10004D914();
  v85 = posix_spawnp(&v100, v86, v102, &v101, (char *const *)v118, (char *const *)qword_100072A28);
  if (!(_DWORD)v85 && v100 <= 0)
  {
    sub_10001D418(a1, 3, "posix_spawnp() returned 0 but pid=%d", v91, v92, v93, v94, v95, v100);
    v85 = 153;
  }
  sub_100024FB8((uint64_t)&v101, v85);
  sub_10001FC8C(a1, v100, v85, 0);
  return v85;
}

void sub_1000248C8(uint64_t a1, uint64_t a2, int a3)
{
  NSObject *v6;
  NSObject *v7;
  dispatch_time_t v8;
  char *v9;
  char **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  size_t v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD v37[6];
  _QWORD handler[5];

  v6 = sub_1000146E4();
  v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v6);
  v8 = dispatch_time(0, 1000000000 * a2);
  dispatch_source_set_timer(v7, v8, 0xFFFFFFFFFFFFFFFFLL, 0);
  sub_100019580((void *)a1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_100024A98;
  handler[3] = &unk_10006C5B0;
  handler[4] = a1;
  dispatch_source_set_event_handler(v7, handler);
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 0x40000000;
  v37[2] = sub_100024B6C;
  v37[3] = &unk_10006C5D0;
  v37[4] = a1;
  v37[5] = v7;
  dispatch_source_set_mandatory_cancel_handler(v7, v37);
  dispatch_activate(v7);
  *(_QWORD *)(a1 + 824) = v7;
  *(_DWORD *)(a1 + 820) = a3;
  *(_QWORD *)(a1 + 1188) = *(_QWORD *)(a1 + 1188) & 0xFFFFFFFF000000FFLL | ((_DWORD)a2 << 8);
  v9 = sub_10001F264(a1, 1);
  v10 = (char **)sub_1000106C8(0x40uLL);
  sub_100010740((uint64_t)v10, "%s throttled", v11, v12, v13, v14, v15, v16, (char)v9);
  v17 = sub_100043F58(a1 + 1200);
  if (v17)
    sub_100010740((uint64_t)v10, " after %s", v18, v19, v20, v21, v22, v23, (char)v17);
  v24 = sub_100004214(1, *v10);
  if (!v25)
    *(_QWORD *)(a1 + 840) = v24;
  sub_100010718((void **)v10);
  free(v9);
  sub_100024BA0(a1, 1, v26, v27, v28, v29, v30, v31);
  sub_100023D28(a1, 1);
  sub_10001D418(a1, 5, "service throttled by %llu seconds", v32, v33, v34, v35, v36, a2);
}

void sub_100024A98(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  dispatch_semaphore_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v1 = *(_QWORD *)(a1 + 32);
  dispatch_source_cancel(*(dispatch_source_t *)(v1 + 824));
  *(_QWORD *)(v1 + 824) = 0;
  v8 = *(dispatch_semaphore_t **)(v1 + 840);
  if (v8)
  {
    sub_100004478(v8);
    *(_QWORD *)(v1 + 840) = 0;
  }
  sub_100024BA0(v1, 0, v2, v3, v4, v5, v6, v7);
  v9 = sub_100023BE0(v1);
  v10 = v1 + 1040;
  if (v9)
    v10 = v9;
  *(_BYTE *)(v10 + 1) = 1;
  v11 = *(unsigned int *)(v1 + 820);
  *(_DWORD *)(v1 + 820) = 0;
  v12 = sub_10001D47C(v1, v11);
  sub_10001D418(v1, 5, "deferred event: domain spawn response: %d", v13, v14, v15, v16, v17, v12);
  if ((_DWORD)v12 && (_DWORD)v12 != 36)
  {
    if ((_DWORD)v12 == 139)
      sub_10003E208("deferral event on service in penalty box");
    xpc_strerror(v12);
    sub_10001D418(v1, 3, "Deferred spawn of service failed: %d: %s", v18, v19, v20, v21, v22, v12);
  }
}

void sub_100024B6C(uint64_t a1)
{
  sub_10001962C(*(void **)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void sub_100024BA0(uint64_t a1, integer_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v10;
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t v14;

  if (((*(_BYTE *)(a1 + 1383) & 0x40) == 0) == a2)
  {
    for (i = *(_QWORD *)(a1 + 152); i; i = *(_QWORD *)(i + 16))
      sub_1000468E8(i, a2, a3, a4, a5, a6, a7, a8);
    for (j = *(_QWORD *)(a1 + 176); j; j = *(_QWORD *)(j + 16))
      sub_1000468E8(j, a2, a3, a4, a5, a6, a7, a8);
    for (k = *(_QWORD *)(a1 + 184); k; k = *(_QWORD *)(k + 16))
      sub_1000468E8(k, a2, a3, a4, a5, a6, a7, a8);
    v14 = 0x4000000000000000;
    if (!a2)
      v14 = 0;
    *(_QWORD *)(a1 + 1376) = *(_QWORD *)(a1 + 1376) & 0xBFFFFFFFFFFFFFFFLL | v14;
  }
  else
  {
    v10 = "unmarked";
    if (a2)
      v10 = "marked";
    sub_10001D418(a1, 7, "Service already %s as throttled", a4, a5, a6, a7, a8, (char)v10);
  }
}

double sub_100024C88(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  mach_port_name_t v5;
  double result;

  free(*(void **)(a1 + 1256));
  *(_QWORD *)(a1 + 1256) = 0;
  v2 = *(void **)(a1 + 1264);
  if (v2)
  {
    xpc_release(v2);
    *(_QWORD *)(a1 + 1264) = 0;
  }
  free(*(void **)(a1 + 1272));
  *(_QWORD *)(a1 + 1272) = 0;
  v3 = *(void **)(a1 + 1280);
  if (v3)
  {
    xpc_release(v3);
    *(_QWORD *)(a1 + 1280) = 0;
  }
  free(*(void **)(a1 + 1288));
  *(_QWORD *)(a1 + 1288) = 0;
  v4 = *(void **)(a1 + 1304);
  if (v4)
  {
    xpc_release(v4);
    *(_QWORD *)(a1 + 1304) = 0;
  }
  v5 = *(_DWORD *)(a1 + 1296);
  if (v5)
  {
    if (sub_10000D980(v5))
      _os_assumes_log_ctx(sub_10001F174, a1);
    *(_DWORD *)(a1 + 1296) = 0;
  }
  *(_WORD *)(a1 + 1320) = 0;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 1312) = 0xFFFFFFFFLL;
  *(_BYTE *)(a1 + 1322) &= 0xC8u;
  return result;
}

void sub_100024D40(uint64_t a1)
{
  uint64_t v1;
  NSObject *v2;
  uid_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  void *v17;
  int (__cdecl **v18)(pid_t *, const char *, const posix_spawn_file_actions_t *, const posix_spawnattr_t *, char *const [], char *const []);
  uint64_t v19;
  uint64_t v20;
  _QWORD block[5];
  int v22;
  int v23;

  v1 = *(_QWORD *)(a1 + 32);
  v2 = sub_100014720();
  dispatch_assert_queue_V2(v2);
  *(_QWORD *)(v1 + 1208) = _xpc_spawnattr_unpack_string(*(_QWORD *)(v1 + 1280), *(_QWORD *)(v1 + 1288), *(_DWORD *)(*(_QWORD *)(v1 + 1280) + 4));
  if (*(_DWORD *)(v1 + 1128) == -101)
    v3 = 0;
  else
    v3 = *(_DWORD *)(v1 + 1128);
  bzero(block, 0x1090uLL);
  v4 = sub_100019EF0(v3, block);
  if ((_DWORD)v4)
  {
    LODWORD(v9) = v4;
    sub_10001EC4C(v1, v4, 0, 3024, 0, "launch_kern_credentials_resolve_by_uid(%d) failed", v7, v8, v3);
  }
  else
  {
    LODWORD(v9) = sub_10001285C(v1, *(_QWORD *)(v1 + 1280), *(_QWORD *)(v1 + 1288), (uint64_t)block, v5, v6, v7, v8);
    if (!(_DWORD)v9)
    {
      LODWORD(v9) = sub_100013388((posix_spawnattr_t *)v1, *(_QWORD *)(v1 + 1280), *(_QWORD *)(v1 + 1288), *(xpc_object_t *)(v1 + 1264), v10, v11, v12, v13);
      if (!(_DWORD)v9)
      {
        v17 = *(void **)(v1 + 1272);
        if (!v17 || (LODWORD(v9) = sub_100013528(v1, v17), !(_DWORD)v9))
        {
          LODWORD(v9) = sub_10001367C(v1, *(_QWORD *)(v1 + 1280), *(_QWORD *)(v1 + 1288), 0, 0);
          if (!(_DWORD)v9)
          {
            if (((*(_QWORD *)(v1 + 1256) + 1156) & 3) != 0)
              sub_10004D738();
            if ((*(_DWORD *)(*(_QWORD *)(v1 + 1280) + 236) & 0x800) != 0)
              v18 = &_posix_spawnp;
            else
              v18 = &_posix_spawn;
            v9 = ((uint64_t (*)(void))v18)();
            if ((_DWORD)v9)
              sub_10001EC4C(v1, v9, 0, 3060, 0, "posix_spawn(%s) failed", v19, v20, *(_QWORD *)(v1 + 1208));
          }
        }
      }
    }
  }
  v14 = *(_QWORD *)(v1 + 1256);
  v15 = *(_DWORD *)(v14 + 1156);
  sub_100024FB8(v1, v9);
  free((void *)v1);
  v16 = sub_1000146E4();
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10002506C;
  block[3] = &unk_10006C610;
  block[4] = v14;
  v22 = v15;
  v23 = v9;
  dispatch_async(v16, block);
}

void sub_100024F6C(xpc_object_t *a1)
{
  xpc_object_t v1;
  __uint64_t v3;

  v1 = *a1;
  if (!*a1)
  {
    v1 = xpc_array_create(0, 0);
    *a1 = v1;
  }
  v3 = clock_gettime_nsec_np(_CLOCK_MONOTONIC);
  xpc_array_set_uint64(v1, 0xFFFFFFFFFFFFFFFFLL, v3);
}

void sub_100024FB8(uint64_t a1, int a2)
{
  unint64_t v3;
  mach_port_name_t v4;
  int v5;
  void *v6;
  void *v7;

  if (a2 && *(_QWORD *)(a1 + 1808))
  {
    v3 = 0;
    do
    {
      if (sub_10000D9B0(*(_DWORD *)(a1 + 1296 + 4 * v3)))
        _os_assumes_log_ctx(sub_10001F174, *(_QWORD *)(a1 + 1256));
      ++v3;
    }
    while (v3 < *(_QWORD *)(a1 + 1808));
  }
  v4 = *(_DWORD *)(a1 + 1816);
  if (v4 + 1 >= 2)
  {
    v5 = sub_10000D980(v4);
    if (v5)
      sub_10004D764(v5);
  }
  free(*(void **)(a1 + 1280));
  v6 = *(void **)(a1 + 1264);
  if (v6)
    xpc_release(v6);
  v7 = *(void **)(a1 + 1272);
  if (v7)
    xpc_release(v7);
  sub_100012788(a1);
}

uint64_t sub_10002506C(uint64_t a1)
{
  return sub_10001FC8C(*(_QWORD *)(a1 + 32), *(unsigned int *)(a1 + 40), *(unsigned int *)(a1 + 44), 0);
}

uint64_t sub_100025080(uint64_t a1)
{
  uint64_t result;

  result = sub_100023BE0(a1);
  if (result)
    return sub_1000291BC(*(_QWORD *)(a1 + 248));
  return result;
}

double sub_1000250B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double result;

  v10 = *(_QWORD *)(a1 + 1188);
  if ((v10 & 0x20000000000) != 0)
  {
    sub_10001D418(a1, 5, "already handled failed init, ignoring", a4, a5, a6, a7, a8, a9);
  }
  else
  {
    v11 = a3;
    v12 = a2;
    *(_QWORD *)(a1 + 1188) = v10 | 0x20000000000;
    if ((*(_BYTE *)(a1 + 1380) & 0x10) != 0)
      sub_100020AFC(a1, a2, a3, a4, a5, a6, a7, a8);
    if (v12 != 111 || v11 == 75)
    {
      if (!v12)
        sub_10004D738();
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 1376);
      if ((v13 & 0x40000000000) == 0)
      {
        if (*(_DWORD *)(a1 + 296))
          sub_10003E208("unmanaged service given to service interface. pid: %d service: %s", *(_DWORD *)(a1 + 296), (const char *)(a1 + 1392));
        if ((v13 & 0x10000000000) != 0)
        {
          sub_10001CFB8(a1);
          sub_10001D418(a1, 65539, "Missing executable detected. Job: '%s' Executable: '%s'", v14, v15, v16, v17, v18, a1 + 112);
        }
      }
    }
    sub_10001D2D4(a1, 4, v12);
    return sub_100024C88(a1);
  }
  return result;
}

size_t sub_1000251B0(uint64_t a1, uint64_t a2, size_t a3)
{
  return sub_100003B5C(a3, *(_DWORD *)(a1 + 72), *(const char **)(a1 + 32), *(_DWORD *)(a1 + 76), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 80), HIDWORD(*(_QWORD *)(a1 + 80)), *(_DWORD *)(a1 + 88), *(_WORD *)(a1 + 92));
}

void sub_1000251FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;

  if ((sub_100040AC4(*(_DWORD *)(a1 + 1152)) & 1) != 0 || (*(_BYTE *)(a1 + 1192) & 0xC) != 0)
  {
    sub_10001D418(a1, 5, "service is being debugged, not timing out launch", v10, v11, v12, v13, v14, a9);
  }
  else
  {
    if (*(_QWORD *)(a1 + 856))
    {
      sub_100019A44(a1);
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 856));
      dispatch_release(*(dispatch_object_t *)(a1 + 856));
      *(_QWORD *)(a1 + 856) = 0;
    }
    sub_10001D418(a1, 4, "Extension is hanging on launch. Killing.", v10, v11, v12, v13, v14, v33);
    sub_10001D418(a1, 5, "killing extension hanging on launch", v15, v16, v17, v18, v19, v34);
    v20 = sub_10000DA1C();
    v26 = sub_100020658(a1, 2, v20, v21, v22, v23, v24, v25);
    v27 = v26;
    if (v26 > 0x25 || ((1 << v26) & 0x2000000009) == 0)
    {
      strerror(v26);
      sub_10001D418(a1, 4, "Failed to kill hanging extension: %d: %s", v28, v29, v30, v31, v32, v27);
    }
  }
}

uint64_t sub_10002530C(void *a1, int *a2)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  xpc_object_t value;
  xpc_object_t v8;
  uint64_t right;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int int64;
  uint64_t v18;
  _DWORD *v19;
  char *string;
  char *v21;
  const uint8_t *uuid;
  const unsigned __int8 *v23;
  _QWORD *v24;
  uint64_t v25;
  _DWORD *v26;
  __int128 v27;
  __int128 v28;

  if (xpc_dictionary_get_BOOL(a1, "self"))
  {
    v27 = 0u;
    v28 = 0u;
    xpc_dictionary_get_audit_token(a1, &v27);
    v4 = sub_10001FB38(SDWORD1(v28));
    if (v4)
    {
      v5 = v4;
      if (sub_10002E300(*(_QWORD *)(v4 + 248), a1))
        return v5;
      v6 = 36;
    }
    else
    {
      v6 = 135;
    }
    v5 = 0;
LABEL_10:
    *a2 = v6;
    return v5;
  }
  value = xpc_dictionary_get_value(a1, "service-port");
  if (!value)
    goto LABEL_13;
  v8 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_mach_send)
  {
LABEL_7:
    v5 = 0;
    v6 = 22;
    goto LABEL_10;
  }
  right = xpc_mach_send_get_right(v8);
  if ((right + 1) < 2)
  {
LABEL_13:
    int64 = xpc_dictionary_get_int64(a1, "pid");
    if (int64)
    {
      v5 = sub_10001FB38(int64);
      if (v5)
        return v5;
      goto LABEL_15;
    }
    v18 = sub_10002E22C(a1, 1, a2);
    if (!v18)
      return 0;
    v19 = (_DWORD *)v18;
    if (sub_10002E300(v18, a1))
    {
      string = (char *)xpc_dictionary_get_string(a1, "name");
      if (!string)
        goto LABEL_7;
      v21 = string;
      v5 = (uint64_t)sub_10002C4E4(v19, string);
      if (v5)
        goto LABEL_21;
      v5 = (uint64_t)sub_10002E7F0((uint64_t)v19, v21);
      if (v5)
        goto LABEL_21;
      if (!xpc_dictionary_get_BOOL(a1, "unidomain")
        || (_UNKNOWN *)sub_10002E360((uint64_t)v19) != &unk_1000715B8
        || (v25 = sub_10003E404()) == 0)
      {
LABEL_33:
        v5 = 0;
LABEL_15:
        v6 = 113;
        goto LABEL_10;
      }
      v26 = (_DWORD *)v25;
      if (sub_10002E300(v25, a1))
      {
        v5 = (uint64_t)sub_10002C4E4(v26, v21);
        if (v5)
        {
LABEL_21:
          uuid = xpc_dictionary_get_uuid(a1, "_instance");
          if (!uuid)
            return v5;
          v5 = *(_QWORD *)(v5 + 200);
          if (v5)
          {
            v23 = uuid;
            while (uuid_compare(v23, (const unsigned __int8 *)(v5 + 408)))
            {
              v5 = *(_QWORD *)(v5 + 40);
              if (!v5)
                goto LABEL_33;
            }
            return v5;
          }
          goto LABEL_33;
        }
        goto LABEL_33;
      }
    }
    v5 = 0;
    v6 = 36;
    goto LABEL_10;
  }
  v24 = sub_10002E080(right, 0, v11, v12, v13, v14, v15, v16);
  if (!v24)
  {
    v5 = 0;
    v6 = 135;
    goto LABEL_10;
  }
  return sub_1000463E0((uint64_t)v24);
}

xpc_object_t sub_10002555C(uint64_t a1, void *a2, int a3)
{
  _DWORD *v6;
  xpc_object_t result;
  _QWORD *v8;
  uint64_t v9;

  v6 = sub_10002EBB8(*(_QWORD *)(a1 + 248));
  result = xpc_retain(a2);
  *((_QWORD *)v6 + 3) = result;
  v6[8] = a3;
  v8 = (_QWORD *)(a1 + 512);
  v9 = *(_QWORD *)(a1 + 512);
  *(_QWORD *)v6 = v9;
  if (v9)
    *(_QWORD *)(v9 + 8) = v6;
  *v8 = v6;
  *((_QWORD *)v6 + 1) = v8;
  return result;
}

uint64_t sub_1000255C0(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  void *v17;
  int v18;
  uint64_t result;
  unint64_t *v20;
  uint64_t v21;
  xpc_object_t reply;
  size_t v23;
  void *v24;
  NSObject *v25;
  xpc_object_t v26;
  xpc_object_t v27;
  int64_t i;
  int v29;
  void *v30;
  size_t v31;
  xpc_object_t v32;
  void *buffer;
  xpc_object_t value;

  value = 0;
  sub_100011420(570425352, *(int *)(a1 + 1152));
  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20))
    return 1;
  v13 = *(unsigned int *)(a1 + 700);
  if (!(_DWORD)v13)
  {
    v14 = *(_QWORD *)(a1 + 256);
    if (!v14)
    {
      v13 = 0;
      v15 = 1;
      goto LABEL_10;
    }
    v13 = *(unsigned int *)(v14 + 700);
  }
  v15 = (_DWORD)v13 == 0;
  if ((v13 - 1) <= 0xFFFFFFFD && (*(_BYTE *)(a1 + 1322) & 4) == 0)
  {
    sub_10001D418(a1, 5, "blocking xpcproxy until controller configures the service", v8, v9, v10, v11, v12, (char)buffer);
    v16 = a1;
    v17 = a3;
    v18 = 3;
LABEL_13:
    sub_10002555C(v16, v17, v18);
    return 0;
  }
LABEL_10:
  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  v20 = (unint64_t *)(a1 + 1188);
  v21 = *(_QWORD *)(a1 + 1188);
  if ((v21 & 0x1000000000) == 0)
  {
    v16 = a1;
    v17 = a3;
    v18 = 2;
    goto LABEL_13;
  }
  if ((v21 & 0x100000000) != 0)
    return 37;
  reply = xpc_dictionary_create_reply(a3);
  buffer = 0;
  v23 = sub_100004B34(a1, &value, &buffer);
  v24 = buffer;
  *v20 = *v20 & 0xFFFFFFFBFFFFFFFFLL | ((unint64_t)*((unsigned __int8 *)buffer + 108) << 34);
  v25 = dispatch_data_create(v24, v23, 0, _dispatch_data_destructor_free);
  v26 = xpc_data_create_with_dispatch_data(v25);
  dispatch_release(v25);
  xpc_dictionary_set_value(reply, "blob", v26);
  xpc_release(v26);
  xpc_dictionary_set_value(reply, "ports", value);
  xpc_release(value);
  if (!v15)
    xpc_dictionary_set_mach_send(reply, "control", v13);
  v27 = xpc_array_create(0, 0);
  for (i = 0; i != 3; ++i)
  {
    v29 = *(_DWORD *)(a1 + 4 * i + 688);
    if (v29 != -1)
    {
      xpc_array_set_fd(v27, 0xFFFFFFFFFFFFFFFFLL, v29);
      xpc_array_set_int64(v27, 0xFFFFFFFFFFFFFFFFLL, i);
    }
  }
  v30 = *(void **)(a1 + 1304);
  if (v30 && xpc_array_get_count(v30))
  {
    v31 = 0;
    do
    {
      v32 = xpc_array_get_value(*(xpc_object_t *)(a1 + 1304), v31);
      xpc_array_append_value(v27, v32);
      ++v31;
    }
    while (v31 < xpc_array_get_count(*(xpc_object_t *)(a1 + 1304)));
  }
  xpc_dictionary_set_value(reply, "fds", v27);
  xpc_release(v27);
  sub_100011420(570425356, *(int *)(a1 + 1152));
  sub_100024C88(a1);
  result = 0;
  *v20 |= (unint64_t)&_mh_execute_header;
  *a4 = reply;
  return result;
}

uint64_t sub_100025878(uint64_t a1, uint64_t a2, xpc_object_t xdict, _QWORD *a4)
{
  uint64_t uint64;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  const uint8_t *uuid;
  unsigned __int8 *v17;
  _BOOL4 v18;
  char string;
  int64_t int64;
  uint64_t v21;
  uint64_t v22;
  int64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  xpc_object_t reply;
  uint64_t result;
  char *v31;
  char v32;

  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20))
    return 1;
  if ((*(_BYTE *)(a1 + 1192) & 2) != 0)
    return 131;
  uint64 = xpc_dictionary_get_uint64(xdict, "pc");
  if (!uint64)
  {
    v31 = "Failure info has no PC.";
LABEL_17:
    sub_10001D418(a1, 3, v31, v8, v9, v10, v11, v12, v32);
    return 22;
  }
  v13 = uint64;
  v14 = xpc_dictionary_get_uint64(xdict, "line");
  if (!v14)
  {
    v31 = "Failure info has no line number.";
    goto LABEL_17;
  }
  v15 = v14;
  uuid = xpc_dictionary_get_uuid(xdict, "uuid");
  if (!uuid)
  {
    v31 = "Failure info has no image UUID.";
    goto LABEL_17;
  }
  v17 = (unsigned __int8 *)uuid;
  v18 = xpc_dictionary_get_BOOL(xdict, "setup-event");
  string = xpc_dictionary_get_string(xdict, "string");
  int64 = xpc_dictionary_get_int64(xdict, "code");
  if (!int64)
    return 22;
  v21 = int64;
  v23 = xpc_dictionary_get_int64(xdict, "subcode");
  if (byte_100072A7A)
    nullsub_23("xpcproxy failed", v22);
  sub_10001ED58(a1, v13, v15, v17, v21, v23, string);
  if (v18)
  {
    sub_10001D418(a1, 5, "Service setup event to handle failure and will not launch until it fires.", v24, v25, v26, v27, v28, v32);
    *(_QWORD *)(a1 + 1376) |= 0x40000uLL;
  }
  sub_1000250B4(a1, v21, v23, v24, v25, v26, v27, v28, v32);
  reply = xpc_dictionary_create_reply(xdict);
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100025A40(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL4 v11;
  _BOOL4 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t result;
  uint64_t v21;
  void *v22;
  int v23;
  char v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  int v31;
  int v32;
  void *v33;
  int64_t v34;
  const char *v35;
  _OWORD v36[2];

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if ((sub_10000FEF4(a2, 13) & 1) == 0)
  {
    memset(v36, 0, sizeof(v36));
    v24 = sub_10003FC08(*(_DWORD *)(a2 + 20), (char *)v36);
    sub_10001D418(a1, 4, "denied kick request from %s - missing entitlement %s", v25, v26, v27, v28, v29, v24);
    return 144;
  }
  v8 = xpc_dictionary_get_BOOL(a3, "unthrottle");
  if (v8)
  {
    v9 = sub_100023BE0(a1);
    v10 = a1 + 1040;
    if (v9)
      v10 = v9;
    *(_BYTE *)(v10 + 1) = 1;
  }
  v11 = xpc_dictionary_get_BOOL(a3, "suspended");
  v12 = xpc_dictionary_get_BOOL(a3, "kill");
  v19 = *(_DWORD *)(a1 + 1152);
  if (v12)
  {
    if (v19)
    {
      result = sub_1000204AC(a1, a2, v13, v14, v15, v16, v17, v18);
      if ((_DWORD)result)
        return result;
      xpc_dictionary_set_BOOL(a3, "kill", 0);
      v21 = a1;
      v22 = a3;
      v23 = 5;
      goto LABEL_25;
    }
  }
  else if (v19)
  {
    v30 = a3;
LABEL_22:
    result = (uint64_t)xpc_dictionary_create_reply(v30);
    if (!result)
      return result;
    v33 = (void *)result;
    v34 = *(int *)(a1 + 1152);
    v35 = "pid";
    goto LABEL_28;
  }
  if (v11)
    *(_BYTE *)(a1 + 1322) |= 1u;
  if (v8)
    v31 = sub_100020264(a1, 9);
  else
    v31 = sub_1000203B0(a1, 9, v13, v14, v15, v16, v17, v18);
  v32 = v31;
  if (v31 == 36)
  {
    v21 = a1;
    v22 = a3;
    v23 = 1;
LABEL_25:
    sub_10002555C(v21, v22, v23);
    return 0;
  }
  v30 = a3;
  if (!v32)
    goto LABEL_22;
  result = (uint64_t)xpc_dictionary_create_reply(a3);
  if (!result)
    return result;
  v33 = (void *)result;
  v34 = v32;
  v35 = "error";
LABEL_28:
  xpc_dictionary_set_int64(v33, v35, v34);
  result = 0;
  *a4 = v33;
  return result;
}

uint64_t sub_100025C48(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  _BOOL4 v8;
  _BOOL4 v9;
  _BOOL4 v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  char v19;
  char v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  int v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  xpc_object_t v33;
  xpc_object_t v34;
  int v35;
  int v36;
  xpc_object_t reply;
  xpc_object_t v38;
  _OWORD v40[2];

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if ((sub_10000FEF4(a2, 13) & 1) == 0)
  {
    memset(v40, 0, sizeof(v40));
    v27 = sub_10003FC08(*(_DWORD *)(a2 + 20), (char *)v40);
    sub_10001D418(a1, 4, "denied attach request from %s - missing entitlement %s", v28, v29, v30, v31, v32, v27);
    return 144;
  }
  v8 = xpc_dictionary_get_BOOL(a3, "kill");
  v9 = xpc_dictionary_get_BOOL(a3, "run");
  v10 = xpc_dictionary_get_BOOL(a3, "proxy");
  v11 = xpc_dictionary_get_BOOL(a3, "pended");
  v18 = *(_BYTE *)(a1 + 1322);
  v19 = v18 | 1;
  v20 = v18 & 0xFC | 2;
  if ((v10 & ~v11) == 0)
    v20 = v19;
  *(_BYTE *)(a1 + 1322) = v20;
  v21 = *(_DWORD *)(a1 + 1152);
  if ((v11 & 1) == 0 && (v8 || v10))
  {
    if (v21)
    {
      v22 = sub_1000204AC(a1, a2, v12, v13, v14, v15, v16, v17);
      if ((_DWORD)v22 != 37)
      {
        v23 = v22;
        if ((_DWORD)v22)
        {
          sub_100024C88(a1);
          return v23;
        }
      }
      xpc_dictionary_set_BOOL(a3, "pended", 1);
      v24 = a1;
      v25 = a3;
      v26 = 5;
      goto LABEL_23;
    }
    goto LABEL_16;
  }
  if (!v21)
  {
LABEL_16:
    if (!v9 || (v35 = sub_10001D47C(a1, 9), v35 == 36))
    {
      xpc_dictionary_set_BOOL(a3, "pended", 1);
      v24 = a1;
      v25 = a3;
      v26 = 1;
LABEL_23:
      sub_10002555C(v24, v25, v26);
      return 0;
    }
    v36 = v35;
    if (v35)
    {
      reply = xpc_dictionary_create_reply(a3);
      if (reply)
      {
        v38 = reply;
        xpc_dictionary_set_int64(reply, "error", v36);
        *a4 = v38;
      }
      sub_100024C88(a1);
      return 0;
    }
  }
  v33 = xpc_dictionary_create_reply(a3);
  if (!v33)
    return 0;
  v34 = v33;
  xpc_dictionary_set_int64(v33, "pid", *(int *)(a1 + 1152));
  v23 = 0;
  *a4 = v34;
  return v23;
}

uint64_t sub_100025E90(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  const char *string;
  const char *v9;
  uint64_t uint64;
  uint64_t v11;
  const char **v12;
  const char *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  xpc_object_t v17;
  uint64_t v18;
  const char *v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int mach_send;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  xpc_object_t reply;
  NSObject *v35;
  NSObject *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  const char **v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  const char *v69;
  char v70;
  _QWORD v71[2];
  uint64_t v72;
  int v73;
  int v74;
  unsigned int v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;

  v75 = -1;
  if ((xpc_dictionary_expects_reply(a3) & 1) == 0)
  {
    sub_100040F68(3, "no reply expected, failing");
    return 22;
  }
  string = xpc_dictionary_get_string(a3, "name");
  if (!string)
  {
    sub_100040F68(3, "no name, failing");
    return 22;
  }
  v9 = string;
  if ((sub_10000FEF4(a2, 13) & 1) == 0)
  {
    v78 = 0u;
    v79 = 0u;
    v76 = 0u;
    v77 = 0u;
    v20 = sub_10003FBC0(a2, (char *)&v76);
    sub_100040F68(3, "Non-entitled process tried to control service \"%s\": %s.%d", v9, v20, *(_DWORD *)(a2 + 20));
    return 144;
  }
  uint64 = xpc_dictionary_get_uint64(a3, "type");
  v11 = xpc_dictionary_get_uint64(a3, "handle");
  if (uint64 == 5 && !v11)
  {
    sub_100040F68(5, "will attach to %s next time it is spawned", v9);
    v12 = (const char **)&qword_100071D50;
    while (1)
    {
      v12 = (const char **)*v12;
      if (!v12)
        break;
      if (!strcmp(v12[2], v9))
      {
        sub_100040F68(5, "canceling old global attach request to %s", v9);
        sub_10002743C((uint64_t)v12);
        v13 = *v12;
        if (*v12)
          *((_QWORD *)v13 + 1) = v12[1];
        *(_QWORD *)v12[1] = v13;
        *v12 = (const char *)-1;
        v12[1] = (const char *)-1;
        xpc_release((xpc_object_t)v12[3]);
        free(v12);
        break;
      }
    }
    v14 = sub_10001389C(0x20uLL);
    v15 = v14;
    v16 = qword_100071D50;
    *v14 = qword_100071D50;
    if (v16)
      *(_QWORD *)(v16 + 8) = v14;
    qword_100071D50 = (uint64_t)v14;
    v14[1] = &qword_100071D50;
LABEL_15:
    v15[2] = v9;
    v17 = xpc_retain(a3);
    v18 = 0;
    v15[3] = v17;
    return v18;
  }
  if (!a1)
  {
    v43 = sub_10002E22C(a3, 1, (int *)&v75);
    if (!v43)
    {
      v68 = v75;
      v69 = (const char *)xpc_strerror(v75);
      sub_100040F68(3, "couldn't find domain to attach to %s, error %d - %s", v9, v68, v69);
      return v75;
    }
    v49 = v43;
    sub_100028C34(v43, 5, "will attach to %s next time it's created", v44, v45, v46, v47, v48, (char)v9);
    v50 = (uint64_t *)(v49 + 48);
    v51 = (const char **)(v49 + 48);
    while (1)
    {
      v51 = (const char **)*v51;
      if (!v51)
        break;
      if (!strcmp(v51[2], v9))
      {
        sub_100028C34(v49, 5, "canceling old domain attach request to %s", v52, v53, v54, v55, v56, (char)v9);
        sub_10002743C((uint64_t)v51);
        v57 = *v51;
        if (*v51)
          *((_QWORD *)v57 + 1) = v51[1];
        *(_QWORD *)v51[1] = v57;
        *v51 = (const char *)-1;
        v51[1] = (const char *)-1;
        xpc_release((xpc_object_t)v51[3]);
        free(v51);
        break;
      }
    }
    v58 = sub_10001389C(0x20uLL);
    v15 = v58;
    v59 = *v50;
    *v58 = *v50;
    if (v59)
      *(_QWORD *)(v59 + 8) = v58;
    *v50 = (uint64_t)v58;
    v58[1] = v50;
    goto LABEL_15;
  }
  if (*(_DWORD *)(a1 + 700))
  {
    v78 = 0u;
    v79 = 0u;
    v76 = 0u;
    v77 = 0u;
    v71[1] = 0;
    v72 = 0;
    v71[0] = 0;
    HIDWORD(v72) = *(_DWORD *)(a1 + 704);
    v73 = 0;
    v74 = *(_DWORD *)(a1 + 708);
    v21 = sub_10003FBC0((uint64_t)v71, (char *)&v76);
    sub_10003FBC0(a2, (char *)&v76);
    sub_10001D418(a1, 4, "Replacing controller %s[%d] with %s[%d]", v22, v23, v24, v25, v26, v21);
    sub_1000274A0(a1);
  }
  mach_send = _xpc_dictionary_extract_mach_send(a3, "port");
  if (mach_send - 1 >= 0xFFFFFFFE)
  {
    sub_10001D418(a1, 4, "Got dead control port", v28, v29, v30, v31, v32, v70);
    v18 = 57;
  }
  else
  {
    v33 = mach_send;
    reply = xpc_dictionary_create_reply(a3);
    *(_DWORD *)(a1 + 704) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 708) = *(_DWORD *)(a2 + 28);
    *(_DWORD *)(a1 + 700) = v33;
    v35 = sub_1000146E4();
    v36 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, v33, 1uLL, v35);
    *(_QWORD *)(a1 + 712) = v36;
    dispatch_set_context(v36, (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 712), (dispatch_function_t)sub_1000274D8);
    dispatch_source_set_mandatory_cancel_handler_f(*(_QWORD *)(a1 + 712), sub_1000274DC);
    dispatch_activate(*(dispatch_object_t *)(a1 + 712));
    v42 = *(int *)(a1 + 1152);
    if ((_DWORD)v42)
    {
      xpc_dictionary_set_int64(reply, "pid", v42);
      xpc_dictionary_set_BOOL(reply, "configurable", 0);
    }
    v18 = 0;
    *a4 = reply;
  }
  if ((*(_BYTE *)(a1 + 1322) & 8) != 0)
  {
    sub_10001D418(a1, 5, "controller attached, spawning", v37, v38, v39, v40, v41, v70);
    v60 = *(unsigned int *)(a1 + 820);
    *(_DWORD *)(a1 + 820) = 0;
    v61 = sub_10001D47C(a1, v60);
    if ((_DWORD)v61)
    {
      v62 = v61;
      if ((_DWORD)v61 != 36)
      {
        if ((_DWORD)v61 == 139)
          sub_10003E208("deferral event on service waiting for controller");
        xpc_strerror(v61);
        sub_10001D418(a1, 3, "service spawn failed after attach: %d: %s", v63, v64, v65, v66, v67, v62);
      }
    }
    *(_BYTE *)(a1 + 1322) &= ~8u;
  }
  return v18;
}

uint64_t sub_100026358(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  int v8;
  uint64_t v9;
  const char *string;
  xpc_object_t value;
  void *v12;
  const char *v13;
  xpc_object_t v14;
  void *v15;
  int int64;
  uint64_t v17;
  xpc_object_t v18;
  void *v19;
  mach_port_name_t mach_send;
  __int16 v21;
  int v22;
  int v23;
  _BOOL4 v24;
  char v25;
  xpc_object_t reply;
  uint64_t result;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  v8 = *(_DWORD *)(a1 + 704);
  v9 = a1;
  if (!v8)
  {
    v9 = *(_QWORD *)(a1 + 256);
    if (!v9)
      v9 = a1;
    v8 = *(_DWORD *)(v9 + 704);
    if (!v8)
      return 142;
  }
  if (v8 != *(_DWORD *)(a2 + 20) || *(_DWORD *)(v9 + 708) != *(_DWORD *)(a2 + 28))
    return 142;
  if ((*(_BYTE *)(a1 + 1322) & 4) != 0)
    return 37;
  string = xpc_dictionary_get_string(a3, "program");
  if (string)
    *(_QWORD *)(a1 + 1256) = sub_10001544C(string);
  value = xpc_dictionary_get_value(a3, "argv");
  if (value)
  {
    v12 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
      *(_QWORD *)(a1 + 1264) = xpc_retain(v12);
  }
  v13 = xpc_dictionary_get_string(a3, "cwd");
  if (v13)
    *(_QWORD *)(a1 + 1272) = sub_10001544C(v13);
  v14 = xpc_dictionary_get_value(a3, "environment");
  if (v14)
  {
    v15 = v14;
    if (xpc_get_type(v14) == (xpc_type_t)&_xpc_type_dictionary)
      *(_QWORD *)(a1 + 1280) = xpc_retain(v15);
  }
  int64 = xpc_dictionary_get_int64(a3, "binpref");
  if (int64)
  {
    xpc_binprefs_alloc();
    *(_QWORD *)(a1 + 1288) = v17;
    xpc_binprefs_add(v17, int64, -1);
  }
  v18 = xpc_dictionary_get_value(a3, "fds");
  if (v18)
  {
    v19 = v18;
    if (xpc_get_type(v18) == (xpc_type_t)&_xpc_type_array)
      *(_QWORD *)(a1 + 1304) = xpc_retain(v19);
  }
  mach_send = _xpc_dictionary_extract_mach_send(a3, "endpoint");
  if (!mach_send)
    goto LABEL_27;
  if ((*(_DWORD *)(a1 + 1340) + 1) >= 2)
  {
    v28 = sub_10000D980(mach_send);
    if (v28)
      sub_10004D764(v28);
    sub_10001D418(a1, 3, "Cannot set configure key endpoint on service: service has dext checkin port %#x", v29, v30, v31, v32, v33, *(_DWORD *)(a1 + 1340));
    return 22;
  }
  *(_DWORD *)(a1 + 1296) = mach_send;
LABEL_27:
  v21 = xpc_dictionary_get_int64(a3, "jetsam-flags");
  if (v21)
    *(_WORD *)(a1 + 1320) = v21;
  v22 = xpc_dictionary_get_int64(a3, "jetsam-priority");
  if (v22 >= 1)
    *(_DWORD *)(a1 + 1312) = v22;
  v23 = xpc_dictionary_get_int64(a3, "jetsam-memlimit");
  if (v23)
    *(_DWORD *)(a1 + 1316) = v23;
  if (xpc_dictionary_get_BOOL(a3, "nano-allocator"))
    *(_BYTE *)(a1 + 1322) |= 0x10u;
  v24 = xpc_dictionary_get_BOOL(a3, "sec-transition");
  v25 = *(_BYTE *)(a1 + 1322);
  if (v24)
  {
    v25 |= 0x20u;
    *(_BYTE *)(a1 + 1322) = v25;
  }
  if ((v25 & 1) == 0)
    v25 = *(_BYTE *)(a1 + 1322) & 0xFE | xpc_dictionary_get_BOOL(a3, "suspended");
  *(_BYTE *)(a1 + 1322) = v25 | 4;
  sub_10001D2D4(a1, 3, 0);
  reply = xpc_dictionary_create_reply(a3);
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100026630(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  v5 = *(_DWORD *)(a1 + 704);
  if (!v5 || v5 != *(_DWORD *)(a2 + 20) || *(_DWORD *)(a1 + 708) != *(_DWORD *)(a2 + 28))
    return 1;
  sub_1000274A0(a1);
  return 0;
}

uint64_t sub_10002669C(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  xpc_object_t reply;
  void *v11;
  char *v12;
  char *v13;

  v8 = sub_10002EA78(*(_QWORD *)(a1 + 248), 5, 0, a2);
  if ((_DWORD)v8)
  {
    v9 = v8;
    sub_100027514(a1, a2, v8);
  }
  else
  {
    reply = xpc_dictionary_create_reply(a3);
    if (reply)
    {
      v11 = reply;
      v12 = sub_100023994(*(_DWORD *)(a1 + 1160));
      v13 = sub_100015630("%s", v12);
      xpc_dictionary_set_string(v11, "reason", v13);
      free(v13);
      v9 = 0;
      *a4 = v11;
    }
    else
    {
      return 22;
    }
  }
  return v9;
}

uint64_t sub_100026770(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[5];

  v8 = sub_10002EA78(*(_QWORD *)(a1 + 248), 5, 0, a2);
  if ((_DWORD)v8)
  {
    v9 = v8;
    sub_100027514(a1, a2, v8);
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_100027644;
    v11[3] = &unk_10006C7F8;
    v11[4] = a1;
    return sub_1000436FC(a3, a4, (uint64_t)v11);
  }
  return v9;
}

uint64_t sub_100026830(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t result;
  xpc_object_t value;
  void *v11;
  xpc_object_t reply;

  v8 = *(_QWORD *)(a1 + 248);
  if ((_QWORD *)sub_10002E360(v8) != qword_100071750)
    return 125;
  if (sub_10002E368(v8) != *(_DWORD *)(a2 + 20))
    return 1;
  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  value = xpc_dictionary_get_value(a3, "bootstrap");
  v11 = *(void **)(a1 + 632);
  if (v11)
  {
    xpc_release(v11);
    *(_QWORD *)(a1 + 632) = 0;
  }
  if (value)
    *(_QWORD *)(a1 + 632) = xpc_retain(value);
  reply = xpc_dictionary_create_reply(a3);
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100026904(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  void *v11;
  xpc_object_t reply;
  void *v13;
  _OWORD v14[2];

  v8 = *(_QWORD *)(a1 + 248);
  if ((_QWORD *)sub_10002E360(v8) != qword_100071750)
    return 125;
  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20))
    return 1;
  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  v10 = *(_QWORD *)(a1 + 256);
  if (!v10)
    v10 = a1;
  v11 = *(void **)(v10 + 632);
  reply = xpc_dictionary_create_reply(a3);
  v13 = reply;
  if (v11)
    xpc_dictionary_set_value(reply, "bootstrap", v11);
  memset(v14, 0, sizeof(v14));
  sub_10002E5B4(v8, (uint64_t)v14);
  xpc_dictionary_set_data(v13, "creator", v14, 0x20uLL);
  result = 0;
  *a4 = v13;
  return result;
}

uint64_t sub_1000269FC(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t result;
  uint64_t v9;
  void *v10;
  char v11;
  xpc_object_t reply;
  xpc_object_t v13;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (*(_DWORD *)(a1 + 296))
    return 113;
  v9 = *(_QWORD *)(a1 + 344);
  v11 = v9 && (v10 = *(void **)(v9 + 48)) != 0 && *(_QWORD *)(v9 + 56) && sub_10003C2B0(a2, v10);
  reply = xpc_dictionary_create_reply(a3);
  v13 = sub_10002102C(a1, v11);
  xpc_dictionary_set_value(reply, "attrs", v13);
  xpc_release(v13);
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100026ABC(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  BOOL v8;
  uint64_t result;
  xpc_object_t reply;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (!sub_10000FEF4(a2, 3))
    return 144;
  if (!*(_DWORD *)(a1 + 1152))
    return 3;
  v8 = xpc_dictionary_get_BOOL(a3, "deferred");
  if ((*(_BYTE *)(a1 + 1192) & 2) != 0)
  {
    reply = xpc_dictionary_create_reply(a3);
    xpc_dictionary_set_int64(reply, "pid", *(int *)(a1 + 1152));
    result = 0;
    *a4 = reply;
  }
  else
  {
    if (v8)
      return 3;
    xpc_dictionary_set_BOOL(a3, "deferred", 1);
    sub_10002555C(a1, a3, 4);
    return 0;
  }
  return result;
}

uint64_t sub_100026B94(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t result;
  unsigned int v10;
  uint64_t v11;
  xpc_object_t reply;
  void *v13;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (!sub_10000FEF4(a2, 3))
    return 144;
  if (*(_DWORD *)(a1 + 1024) && *(_DWORD *)(a1 + 1200))
  {
    if (sub_100044038(a1 + 1200))
    {
      v8 = 1;
    }
    else if (sub_1000440E8((_DWORD *)(a1 + 1200)))
    {
      if (*(_DWORD *)(a1 + 1204))
        v8 = 128;
      else
        v8 = 64;
    }
    else
    {
      v8 = 64;
    }
  }
  else
  {
    v8 = 0;
  }
  v10 = *(_DWORD *)(a1 + 1204);
  v11 = *(_QWORD *)(a1 + 1208);
  reply = xpc_dictionary_create_reply(a3);
  v13 = reply;
  if (*(_DWORD *)(a1 + 1024) && *(_DWORD *)(a1 + 364) == 80)
  {
    xpc_dictionary_set_uint64(reply, "termination-state", 0x80uLL);
    v10 = 9;
    v11 = 10;
LABEL_14:
    xpc_dictionary_set_uint64(v13, "os-namespace", v10);
    xpc_dictionary_set_uint64(v13, "os-code", v11);
    goto LABEL_15;
  }
  xpc_dictionary_set_uint64(reply, "termination-state", v8);
  if (v8 == 128)
    goto LABEL_14;
LABEL_15:
  result = 0;
  *a4 = v13;
  return result;
}

uint64_t sub_100026CE4(uint64_t a1, uint64_t a2, xpc_object_t xdict, _QWORD *a4)
{
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  NSObject *v16;
  NSObject *v17;
  dispatch_time_t v18;
  xpc_object_t reply;
  char v20;

  v8 = xpc_dictionary_get_BOOL(xdict, "yesno");
  if (!xpc_dictionary_expects_reply(xdict))
    return 22;
  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20))
    return 1;
  v14 = *(_QWORD *)(a1 + 848);
  if (v8)
  {
    if (v14)
    {
      sub_10001D418(a1, 5, "extension already attempting clean exit", v9, v10, v11, v12, v13, v20);
      return 36;
    }
    if (*(unsigned __int8 *)(a1 + 424) > 4u)
      goto LABEL_12;
    sub_10001D418(a1, 5, "extension attempting to exit cleanly", v9, v10, v11, v12, v13, v20);
    v16 = sub_1000146E4();
    *(_QWORD *)(a1 + 848) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v16);
    sub_100019A20(a1);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 848), (void *)a1);
    v17 = *(NSObject **)(a1 + 848);
    v18 = dispatch_time(0, 1000000000 * *(unsigned int *)(a1 + 864));
    dispatch_source_set_timer(v17, v18, 0xFFFFFFFFFFFFFFFFLL, 0);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 848), (dispatch_function_t)sub_100027650);
    dispatch_activate(*(dispatch_object_t *)(a1 + 848));
  }
  else
  {
    if (!v14)
    {
      sub_10001D418(a1, 5, "extension already interrupted clean exit attempt", v9, v10, v11, v12, v13, v20);
      return 37;
    }
    if (*(unsigned __int8 *)(a1 + 424) >= 5u)
    {
LABEL_12:
      sub_10001D418(a1, 5, "extension is being stopped", v9, v10, v11, v12, v13, v20);
      return 124;
    }
    sub_10001D418(a1, 5, "extension canceled clean exit attempt", v9, v10, v11, v12, v13, v20);
    sub_100019A44(a1);
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 848));
    dispatch_release(*(dispatch_object_t *)(a1 + 848));
    *(_QWORD *)(a1 + 848) = 0;
  }
  reply = xpc_dictionary_create_reply(xdict);
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100026EC8(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  xpc_object_t reply;
  char v14;

  if ((*(_BYTE *)(a1 + 1380) & 4) == 0)
    return 137;
  if (*(_DWORD *)(a2 + 20) != *(_DWORD *)(a1 + 1152))
    return 1;
  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (!*(_QWORD *)(a1 + 856))
    return 37;
  sub_10001D418(a1, 5, "extension checked in as alive", v8, v9, v10, v11, v12, v14);
  sub_100019A44(a1);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 856));
  dispatch_release(*(dispatch_object_t *)(a1 + 856));
  *(_QWORD *)(a1 + 856) = 0;
  *(_QWORD *)(a1 + 1188) |= 0x4000000000uLL;
  reply = xpc_dictionary_create_reply(a3);
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100026FA0(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  xpc_object_t reply;
  void *v10;
  uint64_t result;

  if (*(_DWORD *)(a1 + 1152) != *(_DWORD *)(a2 + 20))
    return 1;
  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  v7 = sub_10001CFD0(a1);
  v8 = *(_QWORD *)(a1 + 256);
  if (v8)
    v7 = sub_10001CFD0(v8);
  reply = xpc_dictionary_create_reply(a3);
  if (v7)
  {
    v10 = (void *)sub_100043334(v7);
    xpc_dictionary_set_value(reply, "xpcservice-dict", v10);
    xpc_release(v10);
    xpc_dictionary_set_string(reply, "identifier", *(const char **)(a1 + 576));
  }
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100027068(uint64_t a1, void *a2, _QWORD *a3)
{
  xpc_object_t reply;
  xpc_object_t v7;
  uint64_t result;

  if (!xpc_dictionary_expects_reply(a2))
    return 22;
  reply = xpc_dictionary_create_reply(a2);
  v7 = reply;
  if ((*(_BYTE *)(a1 + 1381) & 2) != 0)
    xpc_dictionary_set_uuid(reply, "instance", (const unsigned __int8 *)(a1 + 408));
  result = 0;
  *a3 = v7;
  return result;
}

uint64_t sub_1000270D8(uint64_t a1, _OWORD *a2, void *a3, xpc_object_t *a4)
{
  const uint8_t *uuid;
  unsigned __int8 *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v13;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  uuid = xpc_dictionary_get_uuid(a3, "instance");
  if (!uuid)
    return 22;
  v9 = (unsigned __int8 *)uuid;
  if (!sub_10000FEF4((uint64_t)a2, 29))
    return 144;
  v10 = *(_QWORD *)(a1 + 200);
  if (v10)
  {
    while (uuid_compare(v9, (const unsigned __int8 *)(v10 + 408)))
    {
      v10 = *(_QWORD *)(v10 + 40);
      if (!v10)
        goto LABEL_7;
    }
    return 37;
  }
  else
  {
LABEL_7:
    v13 = 0;
    sub_100029E2C(*(_QWORD *)(a1 + 248), a1, v9, 0, 0, a2, (int *)&v13);
    v11 = v13;
    if (!v13)
      *a4 = xpc_dictionary_create_reply(a3);
  }
  return v11;
}

uint64_t sub_1000271C0(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  const uint8_t *uuid;
  const unsigned __int8 *v9;
  mach_port_context_t v10;
  uint64_t result;
  xpc_object_t reply;
  uint64_t v13;
  void *v14;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  uuid = xpc_dictionary_get_uuid(a3, "instance");
  if (!uuid)
    return 22;
  v9 = uuid;
  if (!sub_10000FEF4(a2, 29))
    return 144;
  v10 = *(_QWORD *)(a1 + 200);
  if (!v10)
    return 113;
  while (uuid_compare(v9, (const unsigned __int8 *)(v10 + 408)))
  {
    v10 = *(_QWORD *)(v10 + 40);
    if (!v10)
      return 113;
  }
  result = sub_100029C5C(*(_QWORD *)(v10 + 248), v10);
  if (!(_DWORD)result)
  {
    reply = xpc_dictionary_create_reply(a3);
    goto LABEL_15;
  }
  if ((_DWORD)result == 36)
  {
    reply = xpc_dictionary_create_reply(a3);
    v13 = sub_100023A28(v10);
    v14 = (void *)xpc_mach_send_create_with_disposition(v13, 20);
    xpc_dictionary_set_value(reply, "monitor", v14);
    xpc_release(v14);
LABEL_15:
    result = 0;
    *a4 = reply;
  }
  return result;
}

uint64_t sub_1000272D0(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  xpc_object_t empty;
  uint64_t i;
  xpc_object_t reply;
  uint64_t result;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (!sub_10000FEF4(a2, 29))
    return 144;
  empty = xpc_array_create_empty();
  for (i = *(_QWORD *)(a1 + 200); i; i = *(_QWORD *)(i + 40))
    xpc_array_set_uuid(empty, 0xFFFFFFFFFFFFFFFFLL, (const unsigned __int8 *)(i + 408));
  reply = xpc_dictionary_create_reply(a3);
  xpc_dictionary_set_value(reply, "uuids", empty);
  xpc_release(empty);
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_100027380(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  xpc_object_t reply;
  char *v9;
  char *v10;
  uint64_t result;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (!sub_10000FEF4(a2, 38))
    return 144;
  reply = xpc_dictionary_create_reply(a3);
  v9 = sub_10001F264(a1, 1);
  if (v9)
  {
    v10 = v9;
    xpc_dictionary_set_string(reply, "service-name", v9);
    free(v10);
  }
  else
  {
    xpc_dictionary_set_string(reply, "service-name", "Unknown service");
  }
  result = 0;
  *a4 = reply;
  return result;
}

void sub_10002743C(uint64_t a1)
{
  xpc_object_t reply;
  void *v2;
  int v3;

  reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 24));
  if (reply)
  {
    v2 = reply;
    xpc_dictionary_set_int64(reply, "error", 89);
    v3 = xpc_pipe_routine_reply(v2);
    if ((v3 & 0xFFFFFFDF) != 0)
      _os_assumes_log(v3);
    xpc_release(v2);
  }
}

void sub_1000274A0(uint64_t a1)
{
  *(_QWORD *)(a1 + 704) = 0;
  *(_DWORD *)(a1 + 700) = 0;
  if ((*(_BYTE *)(a1 + 1322) & 4) != 0)
    sub_100024C88(a1);
  sub_100005A58(a1);
}

void sub_1000274DC(NSObject *a1)
{
  mach_port_name_t handle;
  int v3;

  handle = dispatch_source_get_handle(a1);
  v3 = sub_10000D980(handle);
  if (v3)
    _os_assumes_log(v3);
  dispatch_release(a1);
}

void sub_100027514(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _OWORD v17[4];

  if ((_DWORD)a3 != 124)
  {
    if ((_DWORD)a3 == 154)
      v5 = 65539;
    else
      v5 = 3;
    memset(v17, 0, sizeof(v17));
    v6 = sub_10003FBC0(a2, (char *)v17);
    xpc_strerror(a3);
    sub_10001D418(a1, v5, "Caller not allowed to perform action: %s.%d, action = %s, code = %d: %s, uid = %u, euid = %u, gid = %u, egid = %u, asid = %u", v7, v8, v9, v10, v11, v6);
    xpc_strerror(a3);
    sub_10001D418(a1, 5, "violation: %s.%d, action = %s, code = %d: %s, uid = %u, euid = %u, gid = %u, egid = %u, asid = %u", v12, v13, v14, v15, v16, v6);
  }
}

uint64_t sub_100027644(uint64_t a1, FILE *a2)
{
  return sub_1000216F8(*(_QWORD *)(a1 + 32), a2, 0);
}

void sub_100027650(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  char v34;

  sub_100019A44(a1);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 848));
  dispatch_release(*(dispatch_object_t *)(a1 + 848));
  *(_QWORD *)(a1 + 848) = 0;
  if (sub_100040AC4(*(_DWORD *)(a1 + 1152)))
  {
    sub_10001D418(a1, 5, "extension is being debugged; not timing out exit", v10, v11, v12, v13, v14, a9);
  }
  else
  {
    sub_10001D418(a1, 4, "Extension remained dirty for too long after trying to exit. Killing.", v10, v11, v12, v13, v14, v33);
    sub_10001D418(a1, 5, "extension timed out trying to exit; killing", v15, v16, v17, v18, v19, v34);
    v20 = sub_10000DA1C();
    v26 = sub_100020658(a1, 1, v20, v21, v22, v23, v24, v25);
    v27 = v26;
    if (v26 > 0x25 || ((1 << v26) & 0x2000000009) == 0)
    {
      strerror(v26);
      sub_10001D418(a1, 4, "Failed to kill extension. It may linger forever: %d: %s", v28, v29, v30, v31, v32, v27);
    }
  }
}

void sub_100027748(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *a1;
  v2 = *(_QWORD *)(v1 + 1188);
  if ((v2 & 0x1000000000) != 0)
    sub_10003E208("proc source registration handler invoked twice");
  *(_QWORD *)(v1 + 1188) = v2 | 0x1000000000;
  sub_10001D2D4(v1, 2, 0);
}

uint64_t sub_100027788(uint64_t a1, _OWORD *a2, unsigned int a3, char a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v7 = sub_1000409A8(a2);
  v8 = v7;
  if ((_DWORD)v7)
  {
    sub_10004DF0C(v7, a1, a4);
  }
  else
  {
    sub_100011430(570425424, *(int *)(a1 + 1152), a3);
    strsignal(a3);
    sub_10001D418(a1, 5, "signaled service for %s: %s", v9, v10, v11, v12, v13, a4);
  }
  return v8;
}

void sub_10002781C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uintptr_t v42;
  NSObject *global_queue;
  NSObject *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  char v53;
  char v54;
  char v55;
  _OWORD buffer[4];

  sub_10001D418(a1, 5, "exceeded sigkill timeout: %u", a4, a5, a6, a7, a8, dword_100071A94);
  sub_10001D418(a1, 4, "Service did not exit %u seconds after SIGKILL.", v9, v10, v11, v12, v13, dword_100071A94);
  memset(buffer, 0, sizeof(buffer));
  v14 = sub_10003FB48(*(_DWORD *)(a1 + 1152), buffer);
  if (v14)
  {
    _os_assumes_log(v14);
  }
  else if (HIDWORD(buffer[0]) == 5)
  {
    sub_10001D418(a1, 5, "service is already a zombie", v15, v16, v17, v18, v19, v52);
    sub_10001DFE8(a1, 0);
    return;
  }
  sub_10001D418(a1, 5, "service is still not a zombie, abandoning", v15, v16, v17, v18, v19, v52);
  v20 = (*(uint64_t (**)(uint64_t, _QWORD))(a1 + 536))(a1, *(_QWORD *)(a1 + 568));
  if ((_DWORD)v20)
  {
    v26 = v20;
    xpc_strerror(v20);
    sub_10001D418(a1, 5, "cannot safely abandon: %d: %s", v27, v28, v29, v30, v31, v26);
    sub_10001D418(a1, 4, "Cannot safely abandon service instance. Leaving it to languish. This may lead to deadlocks.", v32, v33, v34, v35, v36, v54);
    sub_100023D28(a1, 7);
    sub_10001D2D4(a1, 6, 0);
  }
  else
  {
    sub_10001D418(a1, 5, "abandoning", v21, v22, v23, v24, v25, v53);
    sub_10001D418(a1, 4, "Abandoning service instance. This may lead to deadlocks.", v37, v38, v39, v40, v41, v55);
    v42 = *(int *)(a1 + 1152);
    global_queue = dispatch_get_global_queue(0, 0);
    v44 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v42, 0x80000000uLL, global_queue);
    dispatch_set_context(v44, v44);
    dispatch_source_set_event_handler_f(v44, (dispatch_function_t)sub_100027B80);
    dispatch_activate(v44);
    sub_10001DF50(a1, v45, v46, v47, v48, v49, v50, v51);
  }
}

void sub_1000279F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_error_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  dispatch_time_t v17;
  uint64_t v18;
  int v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _OWORD v26[2];

  if (!byte_100072A44
    || *(_BYTE *)(a1 + 1030)
    || (_UNKNOWN *)sub_10002E360(*(_QWORD *)(a1 + 248)) == &unk_100071750
    && (v18 = sub_10002E190(), !sub_1000291BC(v18)))
  {
    sub_10001D418(a1, 4, "Service did not exit %u seconds after SIGTERM. Sending SIGKILL.", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 832));
    memset(v26, 0, sizeof(v26));
    v9 = sub_100040A08(*(_DWORD *)(a1 + 1152), (integer_t *)v26);
    if (v9)
    {
      v10 = *(_DWORD *)(a1 + 1152);
      mach_error_string(v9);
      sub_10001D418(a1, 5, "could not get audit token for service (PID %d): %d: %s", v11, v12, v13, v14, v15, v10);
    }
    else
    {
      sub_100027788(a1, v26, 9u, (char)"SIGTERM timeout");
    }
  }
  else
  {
    sub_10001D418(a1, 4, "Service did not exit %u seconds after SIGTERM. Terminating with a crash report.", a4, a5, a6, a7, a8, *(_DWORD *)(a1 + 832));
    v19 = sub_1000407FC(*(unsigned int *)(a1 + 1152), 4u, (uint64_t)"SIGTERM timeout", 0);
    if (v19)
    {
      v20 = v19;
      strerror(v19);
      sub_10001D418(a1, 5, "could not terminate service after SIGTERM timeout: %d: %s", v21, v22, v23, v24, v25, v20);
    }
  }
  *(_BYTE *)(a1 + 1188) = 9;
  sub_100023D28(a1, 6);
  v16 = *(NSObject **)(a1 + 1176);
  v17 = dispatch_time(0, 1000000000 * dword_100071A94);
  dispatch_source_set_timer(v16, v17, 0xFFFFFFFFFFFFFFFFLL, 0);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 1176), (dispatch_function_t)sub_10002781C);
}

void sub_100027B80(NSObject *a1)
{
  pid_t handle;
  int v3;
  int *v4;
  char *v5;
  int v6;

  handle = dispatch_source_get_handle(a1);
  v6 = 0;
  if (waitpid(handle, &v6, 0) == -1)
  {
    v3 = *__error();
    v4 = __error();
    v5 = strerror(*v4);
    sub_100040F68(3, "Could not reap abandoned service instance: %d: %s", v3, v5);
  }
  dispatch_release(a1);
}

uint64_t sub_100027BF0(uint64_t a1, int a2, xpc_object_t xstring)
{
  FILE *v3;
  uint64_t v4;
  const char *string_ptr;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *(FILE **)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40) + 2;
  string_ptr = xpc_string_get_string_ptr(xstring);
  sub_10004391C(v3, v4, "%s", v6, v7, v8, v9, v10, string_ptr);
  return 1;
}

uint64_t sub_100027C3C(uint64_t a1, int a2, xpc_object_t xstring)
{
  FILE *v3;
  uint64_t v4;
  const char *string_ptr;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v3 = *(FILE **)(a1 + 32);
  v4 = *(_QWORD *)(a1 + 40) + 2;
  string_ptr = xpc_string_get_string_ptr(xstring);
  sub_10004391C(v3, v4, "%s", v6, v7, v8, v9, v10, string_ptr);
  return 1;
}

xpc_type_t sub_100027C88(uint64_t a1, xpc_object_t object, uint64_t a3)
{
  FILE *v5;
  uint64_t v6;
  xpc_type_t result;
  const char *string_ptr;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v5 = *(FILE **)a3;
  v6 = *(_QWORD *)(a3 + 16);
  result = xpc_get_type(object);
  if (result == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    return (xpc_type_t)sub_10004391C(v5, v6, "%s => %s", v9, v10, v11, v12, v13, a1, string_ptr);
  }
  return result;
}

uint64_t sub_100027CF8(uint64_t a1, int a2, xpc_object_t object)
{
  FILE *v5;
  uint64_t v6;
  const char *string_ptr;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    v5 = *(FILE **)(a1 + 32);
    v6 = *(_QWORD *)(a1 + 40) + 2;
    string_ptr = xpc_string_get_string_ptr(object);
    sub_10004391C(v5, v6, "%s", v8, v9, v10, v11, v12, string_ptr);
  }
  return 1;
}

void sub_100027D6C(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10;

  if ((_DWORD)a3)
  {
    if (*(_QWORD *)(a1 + 16))
      sub_100010740(a1, " | ", a3, a4, a5, a6, a7, a8, v10);
    sub_100010740(a1, "%s", a3, a4, a5, a6, a7, a8, a2);
  }
}

void *sub_100027DC4(char *__s1)
{
  uint64_t v2;
  char *v3;
  _QWORD aBlock[5];

  v2 = 0;
  while (strcmp(__s1, (&off_10006C968)[v2]))
  {
    v2 += 2;
    if (v2 == 16)
      sub_10003E208("Unable to find boot task block for: %s", __s1);
  }
  v3 = (&off_10006C968)[v2 + 1];
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 0x40000000;
  aBlock[2] = sub_10002826C;
  aBlock[3] = &unk_10006C9E8;
  aBlock[4] = v3;
  return _Block_copy(aBlock);
}

void sub_100027E68()
{
  char *v0;
  const char *v1;
  int v2;

  if (sub_100004810())
  {
    sub_100040F68(65541, "Boot mode forced.");
  }
  else
  {
    v0 = getenv("XPC_USERSPACE_REBOOT_TO_BOOT_MODE");
    if (v0)
    {
      v1 = v0;
      if (sub_100004700(v0) != 7)
        sub_10003E208("userspace reboot into boot mode not allowed: %s", v1);
      sub_100040F68(65541, "Setting boot mode to %s", v1);
      sub_10000477C(7);
      if (setenv("XPC_IN_REM", "1", 1) == -1)
        sub_10004D83C();
      v2 = unsetenv("XPC_USERSPACE_REBOOT_TO_BOOT_MODE");
      if (v2 < 0)
        sub_100040F68(65540, "failed to unset env: XPC_USERSPACE_REBOOT_TO_BOOT_MODE: %d", v2);
    }
  }
}

void sub_100027F54()
{
  char *v0;

  if (sub_10000486C(7))
  {
    v0 = getenv("XPC_IN_REM_DEVELOPMENT");
    if (sub_1000157A8(v0, "1"))
    {
      sub_100040F68(65541, "Not calling into AMFI to enable REM.");
    }
    else
    {
      sub_100040F68(65541, "Calling into AMFI to enable REM.");
      j__amfi_restricted_execution_mode_enable();
    }
  }
}

void sub_100027FC0()
{
  uint64_t v0;
  uint64_t inited;

  v0 = sub_1000047E4();
  inited = os_variant_init_4launchd(v0);
  _os_trace_update_with_datavolume_4launchd(inited);
  sub_100047C90();
}

void sub_100027FDC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  int *v37;
  char v38;

  v0 = mkpath_np("/private/var/mobile/tmp", 0x1FFu);
  if (v0)
  {
    if (v0 == 17)
    {
      sub_100041468("fixup-mobile-tmp", 196613, "%s already exists, skipping", v1, v2, v3, v4, v5, (char)"/private/var/mobile/tmp");
      goto LABEL_16;
    }
    strerror(v0);
    v36 = "could not set create %s: %s";
LABEL_15:
    sub_100041468("fixup-mobile-tmp", 196611, v36, v31, v32, v33, v34, v35, (char)"/private/var/mobile/tmp");
    goto LABEL_16;
  }
  if (chmod("/private/var/mobile/tmp", 0x3FFu) < 0)
  {
    v11 = __error();
    strerror(*v11);
    sub_100041468("fixup-mobile-tmp", 196611, "could not chmod 1777 on %s: %s", v12, v13, v14, v15, v16, (char)"/private/var/mobile/tmp");
  }
  if (chown("/private/var/mobile/tmp", 0x1F5u, 0x1F5u) < 0)
  {
    v17 = __error();
    strerror(*v17);
    sub_100041468("fixup-mobile-tmp", 196611, "could not chown mobile/mobile %s: %s", v18, v19, v20, v21, v22, (char)"/private/var/mobile/tmp");
  }
  v23 = open_dprotected_np("/private/var/mobile/tmp", 0, 0, 1);
  if (v23 == -1)
  {
    __error();
    v37 = __error();
    strerror(*v37);
    v36 = "could not open %s: %s";
    goto LABEL_15;
  }
  v24 = v23;
  v38 = 4;
  if (fcntl(v23, 64))
  {
    __error();
    v25 = __error();
    strerror(*v25);
    sub_100041468("fixup-mobile-tmp", 196611, "could not set protection class on %s: %s", v26, v27, v28, v29, v30, (char)"/private/var/mobile/tmp");
  }
  if ((v24 & 0x80000000) == 0)
    close(v24);
LABEL_16:
  sub_100041468("fixup-mobile-tmp", 196613, "Finished boot task", v6, v7, v8, v9, v10, v38);
  byte_1000729D8 = 1;
}

uint64_t sub_1000281A4()
{
  unsigned int v0;
  uint64_t result;
  uint64_t v2;

  v0 = sub_10003E054("/");
  v2 = v0;
  if ((v0 & 1) != 0 || (result = sub_10003DF80("/private/preboot"), v2 = result, (_DWORD)result))
  {
    sub_100040F68(65541, "Found roots installed cookie");
    result = sysctlbyname("kern.roots_installed", 0, 0, &v2, 8uLL);
    if ((_DWORD)result)
      sub_10004D778(result);
  }
  return result;
}

void sub_100028224()
{
  int v0;

  v0 = exclaves_boot(0, 0);
  if (v0)
  {
    if (v0 != 46)
      sub_100040FC8(65541, "exclaves_boot failed: %d", v0);
  }
}

uint64_t sub_10002826C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(a1 + 32))();
}

uint64_t sub_100028274()
{
  return 0;
}

uint64_t sub_100028280(uint64_t a1, int a2, char a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  uint64_t v9;
  int v13;
  _BOOL4 v14;
  BOOL v15;

  switch(a2)
  {
    case 2:
      return *(_DWORD *)(a5 + 4) != 0;
    case 3:
      if ((sub_10002EE08(a5) & 1) != 0)
        return 0;
      if ((a3 & 8) != 0)
      {
        v9 = 1;
        if (!sub_1000186F4((_OWORD *)a5, (uint64_t)"job-creation", 1))
          return v9;
      }
      if (a6 && (sub_10001654C(a6) & 1) != 0)
        return 0;
      if (*(_DWORD *)(a5 + 4))
        return 1;
      v13 = *(_DWORD *)(a5 + 20);
      if (v13 == getpid())
      {
        if (!a6)
          return 0;
      }
      else
      {
        v14 = sub_1000186F4((_OWORD *)a5, (uint64_t)"job-creation", 1);
        v9 = !v14;
        if (!a6 || !v14)
          return v9;
      }
      v15 = *(_DWORD *)(a7 + 16) || (*(_WORD *)(a7 + 4) & 0x12) != 0;
      if ((a3 & 0x10) == 0 && v15)
        return 122;
      else
        return 0;
    case 4:
    case 7:
      if ((sub_10002EE08(a5) & 1) != 0)
        return 0;
      if ((a3 & 8) == 0 || (v9 = 1, sub_1000186F4((_OWORD *)a5, (uint64_t)"forbidden-launchd-operation", 1)))
      {
        if ((a3 & 4) != 0)
          return 125;
        else
          return *(_DWORD *)(a5 + 4) != 0;
      }
      return v9;
    case 5:
      if ((sub_10002EE08(a5) & 1) != 0)
        return 0;
      if ((a3 & 8) == 0)
        return !sub_1000186F4((_OWORD *)a5, (uint64_t)"process-info-pidinfo", 1);
      v9 = 1;
      if (sub_1000186F4((_OWORD *)a5, (uint64_t)"forbidden-launchd-operation", 1))
        return !sub_1000186F4((_OWORD *)a5, (uint64_t)"process-info-pidinfo", 1);
      return v9;
    case 6:
      return 0;
    default:
      return 1;
  }
}

uint64_t sub_100028434(uint64_t a1)
{
  return *(unsigned int *)(a1 + 4);
}

void sub_10002843C(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  NSObject *v10;
  char v11;

  sub_100028C34((uint64_t)a1, 5, "cleaning up", a4, a5, a6, a7, a8, v11);
  v9 = a1[4];
  if (v9)
    *(_QWORD *)(v9 + 40) = a1[5];
  *(_QWORD *)a1[5] = v9;
  a1[4] = -1;
  a1[5] = -1;
  sub_100019580(a1);
  v10 = sub_1000146E4();
  dispatch_async_f(v10, a1, (dispatch_function_t)sub_10002ED44);
}

uint64_t sub_1000284B0(uint64_t a1, int a2, __int16 a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  _BOOL8 v13;
  uint64_t v14;
  const char *v16;
  uint64_t v17;
  uint64_t v18;

  if (a1)
  {
    v13 = sub_10003E3D8(a1);
    if (v13)
      return sub_100028280(v13, a2, a3, v14, a5, a6, a7);
  }
  switch(a2)
  {
    case 1:
      if ((a3 & 0x100) == 0)
        goto LABEL_8;
      if (sub_10000FEF4(a5, 16))
        v17 = 0;
      else
        v17 = 144;
      break;
    case 2:
      v17 = 45;
      break;
    case 3:
      if ((a3 & 8) == 0 || (v17 = 1, sub_1000186F4((_OWORD *)a5, (uint64_t)"job-creation", 1)))
      {
        if ((a3 & 1) != 0 && a6 && !*(_DWORD *)(a7 + 16) && (*(_WORD *)(a7 + 4) & 0x12) == 0)
          goto LABEL_28;
        if (*(_DWORD *)(a5 + 12) != a4)
          goto LABEL_29;
        if (!a6)
          goto LABEL_22;
        v18 = *(unsigned int *)(a7 + 16);
        if (!(_DWORD)v18 && (*(_WORD *)(a7 + 4) & 0x12) == 0)
          goto LABEL_28;
        if (v18 != a4 || (*(_WORD *)(a7 + 4) & 2) != 0)
          v17 = 122;
        else
LABEL_22:
          v17 = !sub_1000186F4((_OWORD *)a5, (uint64_t)"job-creation", 1);
      }
      break;
    case 4:
    case 7:
      if ((a3 & 8) == 0)
        goto LABEL_27;
      v16 = "forbidden-launchd-operation";
      goto LABEL_26;
    case 5:
      if ((a3 & 8) == 0 || (v17 = 1, sub_1000186F4((_OWORD *)a5, (uint64_t)"forbidden-launchd-operation", 1)))
      {
        v16 = "process-info-pidinfo";
LABEL_26:
        v17 = 1;
        if (sub_1000186F4((_OWORD *)a5, (uint64_t)v16, 1))
        {
LABEL_27:
          if (*(_DWORD *)(a5 + 12) == a4)
LABEL_28:
            v17 = 0;
          else
LABEL_29:
            v17 = *(_DWORD *)(a5 + 4) != 0;
        }
      }
      break;
    case 6:
      if (*(_DWORD *)(a5 + 12) == a4)
        v17 = 0;
      else
        v17 = 144;
      break;
    default:
LABEL_8:
      v17 = 1;
      break;
  }
  return v17;
}

uint64_t sub_100028698(uint64_t a1)
{
  return *(int *)(a1 + 24);
}

uint64_t sub_1000286A4()
{
  return 45;
}

uint64_t sub_1000286AC(uint64_t a1)
{
  return *(int *)(a1 + 20);
}

void sub_1000286B4(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  char v13;

  sub_100028C34((uint64_t)a1, 5, "cleaning up", a4, a5, a6, a7, a8, v13);
  if (a1[27])
  {
    v9 = sub_10001389C(0x30uLL);
    v9[4] = dword_100072A00;
    *((_QWORD *)v9 + 3) = a1[27];
    a1[27] = 0;
    v10 = sub_1000146E4();
    dispatch_async_f(v10, v9, (dispatch_function_t)sub_10002EE48);
  }
  v11 = a1[4];
  if (v11)
    *(_QWORD *)(v11 + 40) = a1[5];
  *(_QWORD *)a1[5] = v11;
  a1[4] = -1;
  a1[5] = -1;
  sub_100019580(a1);
  v12 = sub_1000146E4();
  dispatch_async_f(v12, a1, (dispatch_function_t)sub_10002ED44);
}

uint64_t sub_10002876C(uint64_t a1, int a2, char a3, unint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v14;
  uint64_t v15;
  char *v17;
  size_t v18;
  size_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;

  result = 125;
  switch(a2)
  {
    case 1:
      if (!(a4 >> 31))
      {
        v10 = *(unsigned int *)(a5 + 20);
        if ((v10 & 0x80000000) == 0 && v10 == a4)
          return 0;
      }
      if ((sub_10000FEF4(a5, 13) & 1) != 0)
        return 0;
      v11 = a5;
      v12 = 2;
      return sub_10000FEF4(v11, v12) ^ 1;
    case 2:
      return result;
    case 3:
      if (!a1)
        return 131;
      if (!a6)
        return 147;
      v14 = *(_QWORD *)(a1 + 120);
      if (v14 >> 31 || (v15 = *(unsigned int *)(a5 + 20), (v15 & 0x80000000) != 0) || v14 != v15)
      {
        if (sub_10000FEF4(a5, 2))
          return 0;
        else
          return 144;
      }
      else
      {
        if ((a3 & 1) == 0
          && (!sub_10001654C(a6) || *(_DWORD *)(a7 + 16) || (*(_WORD *)(a7 + 4) & 0x12) != 0))
        {
          v17 = *(char **)(a1 + 240);
          if (!v17
            || !sub_1000156F0(a6, v17)
            || (v18 = strlen(*(const char **)(a1 + 240)), a6[v18 - 1] != 47)
            && (v19 = v18, strlen(a6) != v18)
            && a6[v19] != 47)
          {
            if ((sub_10000FEF4(a5, 0) & 1) == 0 && !sub_10000FEF4(a5, 1))
              return 147;
          }
        }
        return 0;
      }
    case 4:
      if (!(a4 >> 31))
      {
        v20 = *(unsigned int *)(a5 + 20);
        if ((v20 & 0x80000000) == 0 && v20 == a4)
          return 0;
      }
      v11 = a5;
      v12 = 0;
      return sub_10000FEF4(v11, v12) ^ 1;
    case 5:
      if (!(a4 >> 31) && (v21 = *(unsigned int *)(a5 + 20), (v21 & 0x80000000) == 0) && v21 == a4
        || (v22 = *(_DWORD *)(a5 + 4)) == 0
        || a1 && v22 == *(_DWORD *)(a1 + 56))
      {
        if (sub_1000186F4((_OWORD *)a5, (uint64_t)"process-info-pidinfo", 1))
          return 0;
      }
      return 1;
    case 6:
      v23 = *(unsigned int *)(a5 + 20);
      return (a4 & 0xFFFFFFFF80000000) != 0 || (int)v23 < 0 || v23 != a4;
    default:
      return 1;
  }
}

void sub_100028974(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  mach_port_name_t *v4;
  mach_port_name_t *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  void **v10;
  void **v11;
  _QWORD *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  if ((*(_BYTE *)(a1 + 1017) & 0x20) != 0)
    sub_10003E208("system domain deallocated");
  for (i = 336; i != 520; i += 8)
  {
    if (*(_QWORD *)(a1 + i))
      sub_10003E208("domain deallocated with services");
  }
  if (os_map_str_count(a1 + 520))
    sub_10003E208("domain deallocated with service stubs");
  os_map_str_destroy(a1 + 520);
  v3 = *(_QWORD *)(a1 + 960);
  if (v3)
  {
    os_map_str_clear(v3, &stru_10006CA28);
    os_map_str_destroy(*(_QWORD *)(a1 + 960));
    free(*(void **)(a1 + 960));
  }
  v4 = *(mach_port_name_t **)(a1 + 88);
  if (v4)
  {
    do
    {
      v5 = *(mach_port_name_t **)v4;
      sub_100028BCC(a1, v4);
      v4 = v5;
    }
    while (v5);
  }
  if (*(_QWORD *)(a1 + 32) != -1 || *(_QWORD *)(a1 + 40) != -1)
    sub_10003E208("domain disposal while still in the domains list", v4);
  if (*(_QWORD *)(a1 + 16) != -1 || *(_QWORD *)(a1 + 24) != -1)
    sub_10003E208("domain disposal while still in the children list", v4);
  if (*(_QWORD *)(a1 + 208))
    _os_assumes_log_ctx(sub_100028C00, a1);
  v6 = *(_QWORD **)(a1 + 96);
  if (v6)
  {
    v7 = (_QWORD *)*v6;
    v8 = (_QWORD *)v6[1];
    if (*v6)
    {
      do
      {
        v9 = v7;
        v7[1] = v8;
        *(_QWORD *)v6[1] = v7;
        *v6 = -1;
        v6[1] = -1;
        j__free(v6);
        v7 = (_QWORD *)*v9;
        v8 = (_QWORD *)v9[1];
        v6 = v9;
      }
      while (*v9);
    }
    else
    {
      v9 = *(_QWORD **)(a1 + 96);
    }
    *v8 = 0;
    *v9 = -1;
    v9[1] = -1;
    j__free(v9);
  }
  v10 = *(void ***)(a1 + 48);
  if (v10)
  {
    do
    {
      v11 = (void **)*v10;
      if ((*(_BYTE *)(a1 + 1016) & 0x80) != 0)
        sub_100044BF8(dword_100072A00, v10[3]);
      xpc_release(v10[3]);
      v12 = *v10;
      if (*v10)
        v12[1] = v10[1];
      *(_QWORD *)v10[1] = v12;
      free(v10);
      v10 = v11;
    }
    while (v11);
  }
  free(*(void **)(a1 + 312));
  free(*(void **)(a1 + 968));
  v13 = *(void **)(a1 + 248);
  if (v13)
    xpc_release(v13);
  v14 = *(void **)(a1 + 240);
  if (v14)
    free(v14);
  v15 = *(void **)(a1 + 984);
  if (v15)
    sub_10001962C(v15);
  v16 = *(void **)(a1 + 168);
  if (v16)
  {
    sub_10001A270(v16);
    *(_QWORD *)(a1 + 168) = 0;
  }
  xpc_release(*(xpc_object_t *)(a1 + 136));
}

BOOL sub_100028B9C(id a1, const char *a2, void *a3)
{
  free((void *)a2);
  free(a3);
  return 1;
}

void sub_100028BCC(uint64_t a1, mach_port_name_t *a2)
{
  uint64_t v2;

  --*(_QWORD *)(a1 + 80);
  v2 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
    *(_QWORD *)(v2 + 8) = *((_QWORD *)a2 + 1);
  **((_QWORD **)a2 + 1) = v2;
  *(_QWORD *)a2 = -1;
  *((_QWORD *)a2 + 1) = -1;
  sub_1000199C8(a2);
}

uint64_t sub_100028C00(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100028C34(a2, 3, "%s", a4, a5, a6, a7, a8, a3);
  return 1;
}

void sub_100028C34(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  char *v12;

  v12 = sub_100028C98(a1, 2);
  sub_1000412EC(v12, a2, a3, &a9, v9);
  free(v12);
}

char *sub_100028C98(uint64_t a1, int a2)
{
  const char **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  void *v20;
  char *v21;
  int v23;

  if ((a2 - 1) >= 2)
    sub_10004D738();
  v4 = (const char **)sub_1000106C8(0x80uLL);
  v11 = v4;
  v12 = *(_QWORD *)(a1 + 112);
  if ((_UNKNOWN *)v12 == &unk_1000715B8)
  {
    v19 = "system";
  }
  else
  {
    if ((_UNKNOWN *)v12 != &unk_1000716C8)
    {
      sub_100010740((uint64_t)v4, "%s/%lu", v5, v6, v7, v8, v9, v10, *(_QWORD *)(v12 + 112));
      goto LABEL_8;
    }
    v23 = *(_DWORD *)(a1 + 56);
    v19 = "gui/%u";
  }
  sub_100010740((uint64_t)v4, v19, v5, v6, v7, v8, v9, v10, v23);
LABEL_8:
  if (a2 == 2)
  {
    v20 = *(void **)(a1 + 112);
    if (v20 == &unk_100071750)
    {
      sub_100010740((uint64_t)v11, " [%s]", v13, v14, v15, v16, v17, v18, *(_QWORD *)(a1 + 312));
    }
    else if (v20 == &unk_1000716C8)
    {
      sub_100010740((uint64_t)v11, " [%lu]", v13, v14, v15, v16, v17, v18, *(_QWORD *)(a1 + 120));
    }
  }
  v21 = sub_100010710(v11);
  sub_100010718((void **)v11);
  return v21;
}

BOOL sub_100028DB4(uint64_t a1)
{
  return sub_10003E3D8(a1) || *(_QWORD *)(a1 + 112) == (_QWORD)&unk_1000715B8;
}

uint64_t sub_100028DF4(uint64_t a1, _DWORD *a2)
{
  uint64_t v2;

  v2 = 0;
  while (*(_QWORD *)&dword_1000718E8[v2 + 2] != a1)
  {
    v2 += 4;
    if (v2 == 24)
    {
      *a2 = 112;
      return 0xFFFFFFFFLL;
    }
  }
  *a2 = 0;
  return dword_1000718E8[v2];
}

uint64_t sub_100028E38(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (dword_1000718E8[v1] != a1)
  {
    v1 += 4;
    if (v1 == 24)
      return 0;
  }
  return *(_QWORD *)&dword_1000718E8[v1 + 2];
}

void sub_100028E70(uint64_t a1, int a2)
{
  uint64_t **v2;
  uint64_t *v4;
  uint64_t *v5;

  v2 = *(uint64_t ***)(a1 + 208);
  if (v2)
  {
    do
    {
      v4 = *v2;
      if (*((_DWORD *)v2 + 8) == a2)
      {
        sub_100044E20(*((unsigned int *)v2 + 4), v2[3]);
        v5 = *v2;
        if (*v2)
          v5[1] = (uint64_t)v2[1];
        *v2[1] = (uint64_t)v5;
        *v2 = (uint64_t *)-1;
        v2[1] = (uint64_t *)-1;
      }
      v2 = (uint64_t **)v4;
    }
    while (v4);
  }
}

void sub_100028EE0(uint64_t a1, int a2)
{
  _QWORD *v2;
  _QWORD *v4;
  NSObject *v5;
  _QWORD *v6;

  v2 = *(_QWORD **)(a1 + 208);
  if (v2)
  {
    do
    {
      v4 = (_QWORD *)*v2;
      if (*((_DWORD *)v2 + 8) == a2)
      {
        v5 = sub_1000146E4();
        dispatch_async_f(v5, v2, (dispatch_function_t)sub_10002EE48);
        v6 = (_QWORD *)*v2;
        if (*v2)
          v6[1] = v2[1];
        *(_QWORD *)v2[1] = v6;
        *v2 = -1;
        v2[1] = -1;
      }
      v2 = v4;
    }
    while (v4);
  }
}

void *sub_100028F64(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 188);
  *(_DWORD *)(a1 + 188) = v1 + 1;
  if (v1 < 0)
    sub_10003E208("underflow of active count during activate");
  if (v1)
    return (void *)sub_100019A20(a1);
  if ((*(_BYTE *)(a1 + 1016) & 0x10) != 0)
    sub_10003E208("activation of deactivated domain");
  return sub_100019580((void *)a1);
}

void sub_100028FC0(uint64_t a1)
{
  int v1;
  int v3;
  uint64_t i;
  uint64_t v5;
  uint64_t v6;

  v1 = *(_DWORD *)(a1 + 188);
  *(_DWORD *)(a1 + 188) = v1 - 1;
  if (v1 <= 0)
    sub_10003E208("underflow of active count during deactivate");
  if (v1 == 1)
  {
    v3 = *(_DWORD *)(a1 + 1016);
    if ((v3 & 1) == 0)
      sub_10003E208("inactive domain is not shutting down");
    if ((v3 & 0x10) != 0)
      sub_10003E208("domain already deactivated");
    for (i = 336; i != 520; i += 8)
    {
      if (*(_QWORD *)(a1 + i))
        sub_10003E208("domain cleaning up with services still in list");
    }
    if ((v3 & 0x800) != 0)
    {
      sub_1000391BC();
      v3 = *(_DWORD *)(a1 + 1016);
    }
    *(_DWORD *)(a1 + 1016) = v3 | 0x10;
    v5 = *(_QWORD *)(a1 + 112);
    if ((*(_BYTE *)(v5 + 128) & 1) != 0)
    {
      v6 = *(_QWORD *)(a1 + 136);
      if (v6)
        LODWORD(v6) = xpc_mach_send_get_right(v6);
      sub_10004483C(v6);
      v5 = *(_QWORD *)(a1 + 112);
    }
    (*(void (**)(uint64_t))(v5 + 96))(a1);
    sub_10001962C((void *)a1);
  }
  else
  {
    sub_100019A44(a1);
  }
}

void sub_1000290BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  char v17;
  char v18;

  sub_100028C34(a1, 5, "slaying domain", a4, a5, a6, a7, a8, v17);
  v15 = *(_DWORD *)(a1 + 1016);
  if ((v15 & 3) != 0)
  {
    sub_100028C34(a1, 5, "already shutting down or slain", v10, v11, v12, v13, v14, a9);
  }
  else
  {
    if (*(_QWORD *)(a1 + 152))
    {
      sub_100019A44(a1);
      dispatch_set_context(*(dispatch_object_t *)(a1 + 152), *(void **)(a1 + 152));
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 152));
      *(_QWORD *)(a1 + 152) = 0;
      *(_DWORD *)(a1 + 184) = 0;
      v15 = *(_DWORD *)(a1 + 1016);
    }
    if (*(_QWORD *)(a1 + 144))
    {
      if ((v15 & 0x200) != 0)
      {
        sub_100028C34(a1, 5, "uncorking exec source for disposal", v10, v11, v12, v13, v14, v18);
        dispatch_activate(*(dispatch_object_t *)(a1 + 144));
        *(_DWORD *)(a1 + 1016) &= ~0x200u;
      }
      sub_100019A44(a1);
      dispatch_release(*(dispatch_object_t *)(a1 + 144));
      *(_QWORD *)(a1 + 144) = 0;
      v15 = *(_DWORD *)(a1 + 1016);
    }
    *(_DWORD *)(a1 + 1016) = v15 | 2;
    v16 = sub_1000146E4();
    dispatch_async_f(v16, (void *)a1, (dispatch_function_t)sub_1000291CC);
  }
}

BOOL sub_1000291BC(uint64_t a1)
{
  return (*(_BYTE *)(a1 + 1016) & 3) != 0;
}

void sub_1000291CC(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t i;
  uint64_t v74;
  uint64_t v75;
  int v76;
  uint64_t j;
  uint64_t v78;
  uint64_t v79;
  uint64_t k;
  _QWORD *v81;
  _QWORD *v82;
  uint64_t m;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  NSObject *v89;
  char v90;
  char v91;
  uint64_t v92;

  if ((*(_BYTE *)(a1 + 1016) & 1) != 0)
    sub_10003E208("multiple invocations of death handler for domain");
  sub_100028C34(a1, 5, "shutting down", a4, a5, a6, a7, a8, v90);
  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000715B8)
    sub_100013B4C();
  *(_QWORD *)(a1 + 272) = mach_absolute_time();
  *(_DWORD *)(a1 + 1016) |= 2u;
  sub_100013970(a1, 3);
  v14 = 0;
  do
  {
    v92 = v14;
    v15 = a1 + 8 * v14;
    v16 = *(_QWORD *)(v15 + 648);
    if (v16)
    {
      v17 = (uint64_t *)(v15 + 648);
      do
      {
        sub_100028C34(a1, 5, "removing unmanaged service: %s", v9, v10, v11, v12, v13, v16 + 112);
        sub_10002FF24(a1, v16);
        if (*(_QWORD *)(v16 + 152))
        {
          sub_100028C34(a1, 3, "Unmanaged service with non-dynamic endpoints: %s", v19, v20, v21, v22, v23, v16 + 112);
          v24 = *(_QWORD *)(v16 + 152);
          if (v24)
          {
            do
            {
              v25 = *(_QWORD *)(v24 + 16);
              sub_100028C34(a1, 3, "Removing unexpected non-dynamic endpoint: %s", v19, v20, v21, v22, v23, v24 - 88);
              sub_100046AD4(v24, v26, v27, v28, v29, v30, v31, v32);
              v24 = v25;
            }
            while (v25);
          }
        }
        if (*(_QWORD *)(v16 + 176))
        {
          sub_100028C34(a1, 3, "Unmanaged service with event endpoints: %s", v19, v20, v21, v22, v23, v16 + 112);
          v33 = *(_QWORD *)(v16 + 176);
          if (v33)
          {
            do
            {
              v34 = *(_QWORD *)(v33 + 16);
              sub_100028C34(a1, 3, "Removing unexpected event endpoint: %s", v19, v20, v21, v22, v23, v33 - 88);
              sub_100046AD4(v33, v35, v36, v37, v38, v39, v40, v41);
              v33 = v34;
            }
            while (v34);
          }
        }
        v42 = *(_QWORD *)(v16 + 160);
        if (v42)
        {
          do
          {
            v43 = *(_QWORD *)(v42 + 16);
            sub_100028C34(a1, 5, "removing unmanaged endpoint: %s", v19, v20, v21, v22, v23, v42 - 88);
            sub_100046AD4(v42, v44, v45, v46, v47, v48, v49, v50);
            v42 = v43;
          }
          while (v43);
        }
        v51 = *(_QWORD *)(v16 + 168);
        if (v51)
        {
          do
          {
            v52 = *(_QWORD *)(v51 + 16);
            sub_100028C34(a1, 5, "removing unmanaged pid-local endpoint: %s", v19, v20, v21, v22, v23, v51 - 88);
            sub_100046AD4(v51, v53, v54, v55, v56, v57, v58, v59);
            v51 = v52;
          }
          while (v52);
        }
        if (*(__int16 *)(v16 + 300) >= 3)
          sub_10003E208("extra activation on unmanaged service");
        sub_10002EE9C(a1, v16, v18, v19, v20, v21, v22, v23);
        v16 = *v17;
      }
      while (*v17);
    }
    v14 = v92 + 1;
  }
  while (v92 != 6);
  sub_100013970(a1, 4);
  v65 = *(_QWORD *)(a1 + 328);
  while (v65)
  {
    v66 = v65;
    v65 = *(_QWORD *)(v65 + 104);
    sub_100028C34(a1, 5, "removing semi-active service: %s", v60, v61, v62, v63, v64, v66 + 112);
    v67 = sub_100029C60(a1, v66);
    if (v67 && v67 != 36)
      sub_10003E208("failure to remove semi-active service");
  }
  sub_100013970(a1, 5);
  for (i = 0; i != 13; ++i)
  {
    v74 = *(_QWORD *)(a1 + 8 * i + 544);
    while (v74)
    {
      while (1)
      {
        v75 = v74;
        v74 = *(_QWORD *)(v74 + 88);
        sub_100028C34(a1, 5, "removing active service: %s", v68, v69, v70, v71, v72, v75 + 112);
        v76 = sub_100029C60(a1, v75);
        if (v76)
        {
          if (v76 != 36)
            break;
        }
        if (!v74)
          goto LABEL_31;
      }
      _os_assumes_log_ctx(sub_10001F174, v75);
    }
LABEL_31:
    ;
  }
  sub_100013970(a1, 6);
  for (j = 0; j != 23; ++j)
  {
    v78 = *(_QWORD *)(a1 + 8 * j + 336);
    while (v78)
    {
      v79 = v78;
      v78 = *(_QWORD *)(v78 + 120);
      if (!*(_WORD *)(v79 + 300) && (*(_BYTE *)(v79 + 368) & 1) == 0 && sub_100029C60(a1, v79))
        sub_10003E208("failed to remove inactive service");
    }
  }
  os_map_str_clear(a1 + 520, &stru_10006CAA8);
  sub_100013970(a1, 7);
  for (k = 0; k != 31; ++k)
  {
    v81 = *(_QWORD **)(a1 + 8 * k + 704);
    if (v81)
    {
      do
      {
        v82 = (_QWORD *)v81[4];
        if (v81[9])
          sub_10002F868(v81);
        v81 = v82;
      }
      while (v82);
    }
  }
  sub_100013970(a1, 8);
  for (m = *(_QWORD *)(a1 + 320); m; m = *(_QWORD *)(m + 16))
    sub_1000290BC(m);
  sub_100013970(a1, 9);
  *(_DWORD *)(a1 + 1016) |= 1u;
  if (*(_QWORD *)(a1 + 152))
  {
    sub_100019A44(a1);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 152), *(void **)(a1 + 152));
    dispatch_source_cancel(*(dispatch_source_t *)(a1 + 152));
    *(_QWORD *)(a1 + 152) = 0;
    *(_DWORD *)(a1 + 184) = 0;
  }
  if (*(_QWORD *)(a1 + 144))
  {
    if ((*(_BYTE *)(a1 + 1017) & 2) != 0)
    {
      sub_100028C34(a1, 5, "uncorking exec source for disposal", v84, v85, v86, v87, v88, v91);
      dispatch_activate(*(dispatch_object_t *)(a1 + 144));
      *(_DWORD *)(a1 + 1016) &= ~0x200u;
    }
    sub_100019A44(a1);
    dispatch_release(*(dispatch_object_t *)(a1 + 144));
    *(_QWORD *)(a1 + 144) = 0;
  }
  sub_100013970(a1, 10);
  sub_100028E70(a1, 1);
  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000715B8 && qword_100072488)
    dispatch_release((dispatch_object_t)qword_100072488);
  v89 = *(NSObject **)(a1 + 160);
  if (v89)
  {
    dispatch_source_cancel(v89);
    *(_QWORD *)(a1 + 160) = 0;
  }
  sub_100013970(a1, 11);
  sub_100028FC0(a1);
}

void sub_1000296E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (sub_10003E3D8(a1))
    sub_1000296E0(*(_QWORD *)(a1 + 232), a2);
  v11 = *(unsigned __int16 *)(a1 + 204);
  *(_WORD *)(a1 + 204) = v11 + 1;
  sub_100028F64(a1);
  if (!v11 && *(_QWORD **)(a1 + 112) != qword_100071750)
    sub_100028C34(a1, 5, "entering bootstrap mode", v12, v13, v14, v15, v16, a9);
}

void sub_10002976C(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  rb_tree_t **v18;
  char v19;

  if (sub_10003E3D8(a1))
    sub_10002976C(*(_QWORD *)(a1 + 232), a2);
  v9 = *(unsigned __int16 *)(a1 + 204);
  v10 = v9-- != 0;
  *(_WORD *)(a1 + 204) = v9;
  if (v9 == 0 || !v10)
  {
    if (*(_QWORD **)(a1 + 112) != qword_100071750)
      sub_100028C34(a1, 5, "exiting bootstrap mode", v4, v5, v6, v7, v8, v19);
    sub_100028EE0(a1, 1);
    sub_10002981C(a1);
    if ((*(_BYTE *)(a1 + 1016) & 0x40) != 0)
    {
      sub_1000298A0(a1, v11, v12, v13, v14, v15, v16, v17);
      *(_DWORD *)(a1 + 1016) &= ~0x40u;
      v18 = (rb_tree_t **)sub_1000299B8(a1);
      sub_10003AD40(v18);
    }
  }
  sub_100028FC0(a1);
}

void sub_10002981C(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  for (i = 0; i != 23; ++i)
  {
    v3 = *(_QWORD *)(a1 + 8 * i + 336);
    if (v3)
    {
      do
      {
        v4 = *(_QWORD *)(v3 + 120);
        sub_100019580((void *)v3);
        if (*(_DWORD *)(v3 + 288))
          sub_10002EE7C(v3, v5, v6, v7, v8, v9, v10, v11);
        sub_10001962C((void *)v3);
        v3 = v4;
      }
      while (v4);
    }
  }
}

void sub_1000298A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t i;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  char v26;

  v8 = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(a1 + 192) = v8 - 1;
  if (!v8)
    sub_10003E208("underflow of on-demand count");
  if (v8 <= 1)
  {
    if (*(_UNKNOWN **)(a1 + 112) != &unk_100071750)
      sub_100028C34(a1, 5, "exiting ondemand mode", a4, a5, a6, a7, a8, v26);
    for (i = 0; i != 23; ++i)
    {
      v11 = *(_QWORD *)(a1 + 8 * i + 336);
      if (v11)
      {
        do
        {
          v12 = *(_QWORD *)(v11 + 120);
          if (*(_DWORD *)(v11 + 292))
          {
            sub_100019580((void *)v11);
            v19 = sub_1000203B0(v11, *(unsigned int *)(v11 + 292), v13, v14, v15, v16, v17, v18);
            if ((v19 & 0xFFFFFFFE) == 0x24)
              v25 = 0;
            else
              v25 = v19;
            if (v25)
            {
              if (v25 != 37)
                sub_10001D418(v11, 3, "pended nondemand spawn failed: %d", v20, v21, v22, v23, v24, v25);
            }
            *(_DWORD *)(v11 + 292) = 0;
            sub_10001962C((void *)v11);
          }
          v11 = v12;
        }
        while (v12);
      }
    }
  }
}

void *sub_1000299B8(uint64_t a1)
{
  void *result;
  uint64_t v3;
  uint64_t v4;
  void *v5;

  result = *(void **)(a1 + 984);
  if (!result)
  {
    if (*(_UNKNOWN **)(a1 + 112) == &unk_1000715B8)
    {
      result = sub_10003ACD8(0);
    }
    else
    {
      v3 = a1;
      do
      {
        v4 = v3;
        v3 = *(_QWORD *)(v3 + 232);
      }
      while (v3);
      v5 = (void *)sub_1000299B8(v4);
      result = sub_100019580(v5);
    }
    *(_QWORD *)(a1 + 984) = result;
  }
  return result;
}

uint64_t sub_100029A24(uint64_t a1)
{
  void *v2;

  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000715B8)
    byte_1000729F0 = 0;
  v2 = *(void **)(a1 + 168);
  if (v2)
  {
    sub_10001A270(v2);
    *(_QWORD *)(a1 + 168) = 0;
  }
  sub_100011420(570425368, *(_QWORD *)(a1 + 120));
  return *(_QWORD *)(a1 + 120);
}

void sub_100029A88(_QWORD *a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v11;

  if ((_UNKNOWN *)a1[14] == &unk_1000715B8 || sub_10003E3D8((uint64_t)a1))
  {
    v11 = &qword_100072A30;
  }
  else
  {
    if ((*(_BYTE *)(a1[14] + 128) & 2) == 0)
      return;
    v11 = &qword_100072A38;
  }
  if (*v11)
    sub_1000173C8(a1, 1, a3, (void *)*v11, a2, 0x2000, a7, a8);
}

uint64_t sub_100029B24(_DWORD *a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  char *v13;
  char *v14;

  if (*(_DWORD **)(a2 + 248) != a1)
  {
    v13 = sub_10001F264(a2, 1);
    v14 = sub_100028C98((uint64_t)a1, 1);
    sub_10003E208("%s is being added to a mismatched domain %s", v13, v14);
  }
  v4 = (uint64_t *)&a1[2 * (sub_1000158FC((_BYTE *)(a2 + 1392)) % 0x17uLL) + 84];
  v5 = *v4;
  *(_QWORD *)(a2 + 120) = *v4;
  if (v5)
    *(_QWORD *)(v5 + 128) = a2 + 120;
  *v4 = a2;
  *(_QWORD *)(a2 + 128) = v4;
  ++a1[49];
  *(_QWORD *)(a2 + 248) = sub_100019580(a1);
  if (!*(_DWORD *)(a2 + 296))
    *(_DWORD *)(a2 + 368) |= 6u;
  ++*(_WORD *)(a2 + 300);
  sub_100028F64((uint64_t)a1);
  sub_10002EE9C((uint64_t)a1, a2, v6, v7, v8, v9, v10, v11);
  result = sub_10001FAFC(a2);
  if ((result & 1) == 0)
  {
    sub_10001D054(a2);
    return sub_1000201F0(a2);
  }
  return result;
}

uint64_t sub_100029C60(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t result;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v4 = *(_DWORD *)(a2 + 368);
  if ((v4 & 0x600) == 0x200)
  {
    v5 = *(_QWORD *)(a2 + 40);
    if (v5 == -1)
    {
      v8 = *(_QWORD *)(a2 + 48);
      if (v8 == -1)
        sub_10003E208("multiple attempts to remove service instance");
    }
    else
    {
      if (!v5)
      {
        v6 = *(_QWORD **)(a2 + 48);
        v7 = *(_QWORD *)(a2 + 256);
        *(_DWORD *)(v7 + 240) = *(_DWORD *)(v7 + 224);
        *(_QWORD *)(v7 + 232) = *(_QWORD *)(v7 + 216);
        *(_DWORD *)(v7 + 224) = 5708;
        *(_QWORD *)(v7 + 208) = v6;
        *(_QWORD *)(v7 + 216) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
LABEL_9:
        *v6 = v5;
        *(_QWORD *)(a2 + 40) = -1;
        *(_QWORD *)(a2 + 48) = -1;
        *(_DWORD *)(a2 + 80) = *(_DWORD *)(a2 + 64);
        *(_QWORD *)(a2 + 72) = *(_QWORD *)(a2 + 56);
        *(_DWORD *)(a2 + 64) = 5708;
        *(_QWORD *)(a2 + 56) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
        v4 = *(_DWORD *)(a2 + 368) | 0x400;
        goto LABEL_10;
      }
      v8 = *(_QWORD *)(a2 + 48);
    }
    *(_QWORD *)(v5 + 48) = v8;
    v6 = *(_QWORD **)(a2 + 48);
    goto LABEL_9;
  }
LABEL_10:
  *(_DWORD *)(a2 + 368) = v4 | 0x10;
  if ((v4 & 1) != 0)
  {
    v16 = sub_100020A8C(a2);
    if ((v16 - 36) >= 2)
    {
      if (v16 != 89)
        sub_10003E208("inconsistency between domain and service semi-active state during semi-active bootout");
      return 0;
    }
    return 36;
  }
  if (!*(_WORD *)(a2 + 300))
  {
    if (sub_100020D78(a2))
      sub_10003E208("active service has zero active count");
    sub_10002F1E8(a1, a2, v19, v20, v21, v22, v23, v24);
    return 0;
  }
  if (*(__int16 *)(a2 + 300) <= 0)
    sub_10004D738();
  if (sub_100023AB4(a2) && sub_100013DB4(0))
  {
    if (*(__int16 *)(a2 + 300) <= 0)
      sub_10004D738();
    sub_10002F8BC(a1, a2);
    sub_10001DF50(a2, v9, v10, v11, v12, v13, v14, v15);
    return 0;
  }
  v18 = sub_100020A8C(a2);
  result = 36;
  if (v18 && v18 != 37)
  {
    if (v18 == 89)
      sub_10003E208("inconsistency between domain and service semi-active state during active bootout");
    _os_assumes_log_ctx(sub_10001F174, a2);
    return 36;
  }
  return result;
}

char *sub_100029E2C(uint64_t a1, uint64_t a2, unsigned __int8 *uu1, int a4, uint64_t *a5, _OWORD *a6, int *a7)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  uint64_t i;
  uint64_t v36;
  uint64_t v37;
  size_t v38;
  char **v39;
  uint64_t v40;
  _QWORD *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  _QWORD v57[7];

  if (*(_QWORD *)(a2 + 248) != a1)
    sub_10004D738();
  if (a5)
    v14 = *a5;
  else
    v14 = 0;
  v15 = sub_1000239E8(a2, uu1);
  if (v15)
  {
    v21 = (char *)v15;
    if (!xpc_binprefs_equal(*(_QWORD *)(v15 + 904), v14))
    {
      v27 = xpc_binprefs_copy_description(*((_QWORD *)v21 + 113));
      v56 = xpc_binprefs_copy_description(v14);
      sub_10001D418((uint64_t)v21, 4, "Mismatched binprefs: %s != %s", v28, v29, v30, v31, v32, (char)v27);
      free(v27);
      free(v56);
    }
    if (((*((_DWORD *)v21 + 92) >> 5) & 1) != a4)
      sub_10001D418((uint64_t)v21, 4, "One-shot property mismatch: requested=%d existing=%d", v22, v23, v24, v25, v26, a4);
  }
  else
  {
    v33 = *(unsigned int *)(a2 + 264);
    if (qword_100072A70 <= v33)
    {
      v34 = **(_QWORD **)(*(_QWORD *)(a2 + 208) + 8);
      if (v34)
      {
        while (1)
        {
          if ((sub_10001FAFC(v34) & 1) == 0)
            sub_10004D738();
          if ((*(_BYTE *)(v34 + 368) & 0x10) == 0)
            break;
          v34 = **(_QWORD **)(*(_QWORD *)(v34 + 48) + 8);
          if (!v34)
          {
            LODWORD(v33) = *(_DWORD *)(a2 + 264);
            goto LABEL_16;
          }
        }
        sub_100028C34(a1, 4, "Too many instances (%d >= %lu : %d), slaying '%s' to make room", v16, v17, v18, v19, v20, *(_DWORD *)(a2 + 264));
        v49 = sub_100029C60(a1, v34);
        if (v49 && v49 != 36)
          sub_10004DF74(a1, v49, v50, v51, v52, v53, v54, v55);
      }
      else
      {
LABEL_16:
        sub_100028C34(a1, 4, "Too many instances (%d >= %lu : %d), but nothing to slay since all instances are already being removed.", v16, v17, v18, v19, v20, v33);
      }
    }
    sub_10002A1A8(a1, a2);
    v57[0] = sub_10002A27C;
    v57[1] = sub_10002A664;
    v57[2] = sub_10002A7A8;
    v57[3] = sub_10002A940;
    v57[4] = sub_10002A998;
    v57[5] = sub_10002AA84;
    v57[6] = a1;
    v21 = sub_100006688(a2, uu1, 0xFFFFFFFFLL, (uint64_t)a5, a6, (uint64_t)v57, 0, a7);
    if (v21)
    {
      for (i = *(_QWORD *)(a2 + 152); i; i = *(_QWORD *)(i + 16))
      {
        if ((*(_BYTE *)(i + 88) & 0x40) == 0)
        {
          sub_100045FF0(i, (unint64_t)sub_10002AB90, (unint64_t)v21, (unint64_t)v21);
          v37 = v36;
          if (*(_QWORD *)(a1 + 976))
            v38 = *(_QWORD *)(a1 + 976);
          else
            v38 = a1;
          sub_10002ADB4(v38, v21, v37, 64);
        }
      }
      sub_100029B24((_DWORD *)a1, (uint64_t)v21);
      v39 = (char **)(a2 + 200);
      v40 = *(_QWORD *)(a2 + 200);
      ++*(_DWORD *)(a2 + 264);
      *((_QWORD *)v21 + 5) = v40;
      if (v40)
        v41 = (_QWORD *)(v40 + 48);
      else
        v41 = (_QWORD *)(a2 + 208);
      *v41 = v21 + 40;
      *v39 = v21;
      *(_DWORD *)(a2 + 240) = *(_DWORD *)(a2 + 224);
      *(_QWORD *)(a2 + 232) = *(_QWORD *)(a2 + 216);
      *(_DWORD *)(a2 + 224) = 6463;
      *(_QWORD *)(a2 + 216) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
      *((_DWORD *)v21 + 20) = *((_DWORD *)v21 + 16);
      *((_QWORD *)v21 + 9) = *((_QWORD *)v21 + 7);
      *((_DWORD *)v21 + 16) = 6463;
      *((_QWORD *)v21 + 6) = v39;
      *((_QWORD *)v21 + 7) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
      *((_DWORD *)v21 + 92) |= 0x200u;
      *((_QWORD *)v21 + 32) = a2;
      sub_100019580((void *)a2);
      if (a4)
        *((_DWORD *)v21 + 92) |= 0x20u;
    }
    else
    {
      v42 = *a7;
      xpc_strerror(*a7);
      sub_10001D418(a2, 3, "Could not create copy of service: %d: %s", v43, v44, v45, v46, v47, v42);
    }
  }
  return v21;
}

uint64_t sub_10002A1A8(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  char v17;

  if (*(_UNKNOWN **)(a1 + 112) == &unk_100071750)
  {
    v2 = sub_100005E7C(a2);
    if (!v2)
      return v2;
    sub_10001D418(a2, 5, "initialized endpoint after lookup", v6, v7, v8, v9, v10, v16);
    if (*(__int16 *)(a2 + 300) >= 1)
      sub_10003E208("lazy initialization of endpoint on active service");
    if ((*(_BYTE *)(a2 + 368) & 1) != 0)
      sub_10003E208("lazy initialization of endpoint on semi-active service");
    if (!sub_10002F988(a1, v2))
    {
      sub_100046670(v2);
      return v2;
    }
    sub_10001D418(a2, 3, "Failed to initialize implicit endpoint", v11, v12, v13, v14, v15, v17);
    sub_10002F68C(a1, v2);
  }
  return 0;
}

void sub_10002A27C(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t n;
  const char *v36;
  uint64_t v37;
  const char *v38;
  char v39;
  int v40;

  switch((int)a2)
  {
    case 0:
      if (*(_WORD *)(a1 + 300))
        sub_10003E208("will-spawn received on active service");
      if ((*(_BYTE *)(a1 + 368) & 1) != 0)
        sub_10003E208("multiple will-spawn events received");
      sub_10002A1A8(a4, a1);
      for (i = *(_QWORD *)(a1 + 152); i; i = *(_QWORD *)(i + 16))
        sub_1000469A0(i);
      for (j = *(_QWORD *)(a1 + 176); j; j = *(_QWORD *)(j + 16))
        sub_1000469A0(j);
      for (k = *(_QWORD *)(a1 + 184); k; k = *(_QWORD *)(k + 16))
        sub_1000469A0(k);
      for (m = *(_QWORD *)(a1 + 192); m; m = *(_QWORD *)(m + 16))
        sub_10001BE04(m);
      sub_100020CCC(a1);
      *(_DWORD *)(a1 + 368) |= 1u;
      v14 = (uint64_t *)(*(_QWORD *)(a1 + 248) + 328);
      v15 = *v14;
      *(_QWORD *)(a1 + 104) = *v14;
      if (v15)
        *(_QWORD *)(v15 + 112) = a1 + 104;
      *v14 = a1;
      *(_QWORD *)(a1 + 112) = v14;
      sub_100003FEC(a1);
      return;
    case 1:
      if ((*(_BYTE *)(a1 + 368) & 1) == 0)
        sub_10003E208("out-of-order spawn event received");
      v16 = *(_QWORD *)(a1 + 104);
      if (v16)
        *(_QWORD *)(v16 + 112) = *(_QWORD *)(a1 + 112);
      **(_QWORD **)(a1 + 112) = v16;
      *(_QWORD *)(a1 + 104) = -1;
      *(_QWORD *)(a1 + 112) = -1;
      *(_DWORD *)(a1 + 368) &= ~1u;
      *(_DWORD *)(a1 + 292) = 0;
      if (!(_DWORD)a3)
        goto LABEL_21;
      sub_100004108(a1, a2, a3, a4, a5, a6, a7, a8, v39);
      if ((*(_BYTE *)(a1 + 368) & 0x10) != 0)
        sub_10002F1E8(a4, a1, v17, v18, v19, v20, v21, v22);
      else
        sub_10002F518((_QWORD *)a1);
      return;
    case 4:
      *(_DWORD *)(a1 + 360) = a3;
      *(_DWORD *)(a1 + 364) = a3;
      if (a3)
        return;
      v23 = sub_100020D78(a1);
      v24 = sub_10002E19C(qword_100071750, (int)v23);
      if (v24)
      {
        v30 = v24;
        if ((*(_BYTE *)(v24 + 1017) & 2) != 0)
        {
          sub_100028C34(v24, 5, "uncorking exec source after service init", v25, v26, v27, v28, v29, v39);
          dispatch_activate(*(dispatch_object_t *)(v30 + 144));
          *(_DWORD *)(v30 + 1016) &= ~0x200u;
        }
      }
      if (!sub_1000215C8(a1))
        return;
      v40 = 0;
      if (csops(v23, 0, &v40, 4))
      {
        if (*__error() != 3)
        {
          v31 = __error();
          sub_100040FC8(65539, "csops returned %d", *v31);
          goto LABEL_52;
        }
      }
      else if ((v40 & 0x4000000) == 0)
      {
LABEL_52:
        v36 = (const char *)sub_1000213BC(a1);
        sub_10003E264("unexpected exec of non-platform binary: %s: %s [%d]", v36, (const char *)(a1 + 1392), v23);
      }
      return;
    case 5:
      if (byte_1000729D9 && (*(_BYTE *)(a4 + 1016) & 3) == 0 && !*(_DWORD *)(a1 + 296))
      {
        v32 = sub_100020D78(a1);
        if (!v32)
          sub_10004D738();
        if (v32 == dword_1000725C0)
        {
          v37 = sub_10002153C(a1);
          v38 = sub_100043F58(v37);
          sub_100040FC8(0x10000, "Obliterator task exited: %s", v38);
          sub_100040FC8(0x10000, "The system may be in an inconsistent half-obliterated state.");
          sub_100040FC8(0x10000, "Rebooting now, so the finish-obliteration boot task can clean things up.");
          sub_1000404A8(1, 0);
        }
      }
      v33 = *(_DWORD *)(a1 + 368);
      if ((v33 & 0x120) != 0)
        *(_DWORD *)(a1 + 368) = v33 | 0x10;
      sub_100004108(a1, a2, a3, a4, a5, a6, a7, a8, v39);
      for (n = *(_QWORD *)(a1 + 192); n; n = *(_QWORD *)(n + 16))
      {
        if ((*(_WORD *)(n + 204) & 1) != 0)
          sub_10001BF7C(n);
      }
      if ((*(_BYTE *)(a1 + 369) & 0x10) != 0)
      {
        sub_1000298A0(a4, v34, a3, a4, a5, a6, a7, a8);
        *(_DWORD *)(a1 + 368) &= ~0x1000u;
      }
      goto LABEL_43;
    case 6:
      sub_10002F1A4(a1);
      return;
    case 7:
LABEL_21:
      sub_10002FF24(a4, a1);
      return;
    case 8:
LABEL_43:
      sub_10002EE9C(a4, a1, a3, a4, a5, a6, a7, a8);
      return;
    default:
      return;
  }
}

uint64_t sub_10002A664(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t result;
  int v12;
  uint64_t v13;

  v9 = *(_DWORD *)(a3 + 1016);
  if ((v9 & 3) != 0)
  {
    sub_100028C34(a3, 5, "denying spawn, domain shutting down: %s", a4, a5, a6, a7, a8, a1 + 112);
    return 124;
  }
  v12 = *(_DWORD *)(a1 + 368);
  if ((v12 & 2) != 0)
  {
    sub_100028C34(a3, 5, "pending spawn, service not yet activated: %s", a4, a5, a6, a7, a8, a1 + 112);
    goto LABEL_7;
  }
  if (*(_WORD *)(a1 + 300))
  {
    sub_100028C34(a3, 5, "pending spawn, service not yet quiesced: %s", a4, a5, a6, a7, a8, a1 + 112);
    goto LABEL_7;
  }
  if (*(_DWORD *)(a3 + 192))
  {
    v13 = 0;
    while (dword_100071590[v13] != a2)
    {
      if (++v13 == 8)
      {
        if (*(_DWORD *)(a1 + 292) != a2)
        {
          *(_DWORD *)(a1 + 292) = a2;
          sub_100028C34(a3, 5, "pending spawn, domain in on-demand-only mode: %s", a4, a5, a6, a7, a8, a1 + 112);
        }
        return 36;
      }
    }
  }
  if ((v12 & 4) == 0)
  {
    sub_100028C34(a3, 5, "pending spawn, service not yet imported: %s", a4, a5, a6, a7, a8, a1 + 112);
LABEL_7:
    *(_DWORD *)(a1 + 288) = a2;
    return 36;
  }
  if ((v9 & 0x8000) != 0)
    goto LABEL_7;
  if (!*(_WORD *)(a3 + 204))
    return 0;
  result = sub_100023AC0(a1);
  if ((_DWORD)result)
    goto LABEL_7;
  return result;
}

uint64_t sub_10002A7A8(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v39;

  if ((*(_BYTE *)(a2 + 1016) & 3) != 0)
  {
    sub_100028C34(a2, 5, "resetting service: %s", a4, a5, a6, a7, a8, (_BYTE)a1 + 112);
    sub_10002F8BC(a2, (uint64_t)a1);
    return 0;
  }
  if (a1[20])
  {
    sub_100028C34(a2, 4, "Service cannot reset: active unmanaged endpoints", a4, a5, a6, a7, a8, v39);
    sub_100028C34(a2, 5, "cannot reset service active unmanaged endpoints: %s", v11, v12, v13, v14, v15, (_BYTE)a1 + 112);
  }
  else if (a1[21])
  {
    sub_100028C34(a2, 4, "Service cannot reset: active PID-local endpoints", a4, a5, a6, a7, a8, v39);
    sub_100028C34(a2, 5, "cannot reset service active pid-local endpoints: %s", v16, v17, v18, v19, v20, (_BYTE)a1 + 112);
  }
  else
  {
    v21 = a1[19];
    if (v21)
    {
      while ((*(_BYTE *)(v21 + 88) & 4) == 0)
      {
        v21 = *(_QWORD *)(v21 + 16);
        if (!v21)
          goto LABEL_12;
      }
      sub_100028C34(a2, 4, "Service cannot reset: active endpoints", a4, a5, a6, a7, a8, v39);
      sub_100028C34(a2, 5, "cannot reset service active endpoints: %s", v24, v25, v26, v27, v28, (_BYTE)a1 + 112);
    }
    else
    {
LABEL_12:
      v22 = a1[22];
      if (v22)
      {
        while ((*(_BYTE *)(v22 + 88) & 4) == 0)
        {
          v22 = *(_QWORD *)(v22 + 16);
          if (!v22)
            goto LABEL_15;
        }
        sub_100028C34(a2, 4, "Service cannot reset: active event channels", a4, a5, a6, a7, a8, v39);
        sub_100028C34(a2, 5, "cannot reset service active event channels: %s", v29, v30, v31, v32, v33, (_BYTE)a1 + 112);
      }
      else
      {
LABEL_15:
        v23 = a1[23];
        if (!v23)
          return 0;
        result = 0;
        while ((*(_BYTE *)(v23 + 88) & 4) == 0)
        {
          v23 = *(_QWORD *)(v23 + 16);
          if (!v23)
            return result;
        }
        sub_100028C34(a2, 4, "Service cannot reset: active instance endpoints", a4, a5, a6, a7, a8, v39);
        sub_100028C34(a2, 5, "cannot reset service: active instance endpoints: %s", v34, v35, v36, v37, v38, (_BYTE)a1 + 112);
      }
    }
  }
  return 16;
}

char *sub_10002A940(_QWORD *a1, const char *a2, void *a3, uint64_t a4, _BYTE *a5, size_t a6)
{
  char *v8;

  v8 = sub_100045B90((uint64_t)a1, a2, a3, (uint64_t)sub_10002AB90, a5, (uint64_t)a1);
  if (v8)
    sub_10002ADB4(a6, a1, (uint64_t)v8, 0);
  return v8;
}

char *sub_10002A998(uint64_t a1, const char *a2, void *a3, _BYTE *a4, uint64_t a5)
{
  int v9;
  NSObject *v10;
  char *v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  char **v15;
  uint64_t v16;

  if ((*(_BYTE *)(a5 + 104) & 1) != 0)
    v9 = *(_DWORD *)(a5 + 56);
  else
    v9 = 0;
  v10 = sub_1000146E4();
  v11 = sub_10001A7F0(a1, a2, v9, a3, v10, (uint64_t)sub_100030074, a1, (uint64_t)a4);
  if (sub_10001BF74((uint64_t)v11))
  {
    v12 = sub_10001BF74((uint64_t)v11);
    v13 = (const char *)xpc_strerror(v12);
    sub_100014830(a4, 4, "Ignored socket %s: %s", a2, v13);
    sub_10001962C(v11);
    return 0;
  }
  else
  {
    v16 = *(_QWORD *)(a1 + 192);
    v15 = (char **)(a1 + 192);
    v14 = v16;
    *((_QWORD *)v11 + 2) = v16;
    if (v16)
      *(_QWORD *)(v14 + 24) = v11 + 16;
    *v15 = v11;
    *((_QWORD *)v11 + 3) = v15;
  }
  return v11;
}

void sub_10002AA84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t v23;
  char v24;

  if (*(_QWORD **)(a2 + 112) != qword_100071750 && sub_100005E7C(a1))
    sub_10001D418(a1, 5, "created the implicit endpoint upfront", a4, a5, a6, a7, a8, v24);
  v10 = *(_QWORD *)(a1 + 192);
  if (v10)
  {
    do
    {
      v11 = *(_QWORD *)(v10 + 16);
      v12 = *(_QWORD *)(v10 + 56);
      sub_1000296E0(a2, 9, a3, a4, a5, a6, a7, a8, v24);
      ++*(_WORD *)(v12 + 300);
      *(_DWORD *)(v12 + 368) |= 8u;
      sub_10001AEBC(v10, v13, v14, v15, v16, v17, v18, v19);
      v10 = v11;
    }
    while (v11);
  }
  v20 = *(_QWORD **)(a1 + 152);
  while (v20)
  {
    v21 = v20;
    v22 = v20 + 2;
    v20 = (_QWORD *)v20[2];
    if ((v22[9] & 0x40) == 0 && sub_10002F988(a2, (uint64_t)v21))
    {
      v23 = *v22;
      if (*v22)
        *(_QWORD *)(v23 + 24) = v21[3];
      *(_QWORD *)v21[3] = v23;
      *v22 = -1;
      v22[1] = -1;
      sub_10001962C(v21);
    }
  }
}

void sub_10002AB90(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  mach_port_name_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  mach_port_name_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  char v39;
  mach_msg_id_t msg_idp;
  mach_msg_size_t msg_sizep;
  mach_msg_type_number_t trailer_infopCnt;
  char trailer_infop[16];
  __int128 v44;
  __int128 v45;
  int v46;
  mach_port_seqno_t request_seqnop;

  v10 = *(_QWORD *)(a3 + 248);
  if ((*(_BYTE *)(a1 + 88) & 8) != 0)
    v11 = 8;
  else
    v11 = 1;
  if (a2 == 1)
  {
    if ((*(_BYTE *)(a3 + 369) & 8) != 0)
      sub_100028C34(v10, 7, "Deactivated abandoned endpoint: %s", a4, a5, a6, a7, a8, a1 - 88);
    if (sub_100046408(a1))
      *(_BYTE *)(a1 + 88) &= ~4u;
    else
      sub_10002F68C(v10, a1);
    sub_10002EE9C(v10, a3, v31, v32, v33, v34, v35, v36);
  }
  else
  {
    if (a2)
      return;
    v12 = sub_1000457E0(a1, 4, a3, a4, a5, a6, a7, a8);
    if (byte_1000729D9)
    {
      v19 = v12;
      request_seqnop = 0;
      v46 = 0;
      v44 = 0u;
      v45 = 0u;
      *(_OWORD *)trailer_infop = 0u;
      msg_sizep = 0;
      trailer_infopCnt = 52;
      msg_idp = 0;
      if (mach_port_peek(mach_task_self_, v12, 0x3000000u, &request_seqnop, &msg_sizep, &msg_idp, trailer_infop, &trailer_infopCnt))
      {
LABEL_13:
        if (sub_100029C60(v10, a3))
          sub_10003E208("failed to boot out inactive service during obliteration; endpoint event");
        return;
      }
      while (1)
      {
        sub_100028C34(v10, 5, "peeking at message: seqno = %u, pid = %d", v20, v21, v22, v23, v24, request_seqnop);
        if (!DWORD2(v45) || DWORD2(v45) == dword_1000725C0)
          break;
        ++request_seqnop;
        if (mach_port_peek(mach_task_self_, v19, 0x3000000u, &request_seqnop, &msg_sizep, &msg_idp, trailer_infop, &trailer_infopCnt))
        {
          goto LABEL_13;
        }
      }
      sub_100028C34(v10, 5, "port has message from obliterator or kernel", v25, v26, v27, v28, v29, v39);
    }
    v37 = sub_1000203B0(a3, v11, v13, v14, v15, v16, v17, v18);
    if ((v37 & 0xFFFFFFFE) == 0x24)
      v38 = 0;
    else
      v38 = v37;
    if (v38)
    {
      if (v38 == 37)
        sub_10003E208("endpoint event received for running service");
      _os_assumes_log_ctx(sub_10001F174, a3);
    }
  }
}

size_t sub_10002ADB4(size_t result, _QWORD *a2, uint64_t a3, char a4)
{
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  size_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  char *v16;
  char *v17;
  uint64_t v18;
  char **v19;
  uint64_t v20;
  char **v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if ((a4 & 4) != 0)
  {
    v9 = result;
    v10 = strlen((const char *)(a3 + 168));
    v11 = v10 + 168;
    v12 = v10 >= 0xFFFFFFFFFFFFFF58;
    result = v10 + 169;
    v13 = v11 == -1;
    v14 = v13 << 63 >> 63;
    v15 = v14 != v13;
    if (v12 || v15 || v14 < 0)
    {
      __break(1u);
    }
    else
    {
      v16 = (char *)sub_10001389C(result);
      v17 = strcpy(v16 + 168, (const char *)(a3 + 168));
      *((_QWORD *)v16 + 9) = a3;
      v20 = *(_QWORD *)(a3 + 64);
      v19 = (char **)(a3 + 64);
      v18 = v20;
      *((_QWORD *)v16 + 6) = v20;
      if (v20)
        *(_QWORD *)(v18 + 56) = v16 + 48;
      *v19 = v16;
      *((_QWORD *)v16 + 7) = v19;
      result = sub_1000158FC(v17);
      v21 = (char **)(v9 + 8 * (result % 0x1F) + 704);
      v22 = *v21;
      *((_QWORD *)v16 + 4) = *v21;
      if (v22)
        *((_QWORD *)v22 + 5) = v16 + 32;
      *v21 = v16;
      *((_QWORD *)v16 + 5) = v21;
    }
  }
  else
  {
    v5 = (_QWORD *)(a3 + 16);
    if (*(_QWORD *)(a3 + 16) != -1 || *(_QWORD *)(a3 + 24) != -1)
      sub_10003E208("attempting to re-add an endpoint into service");
    if ((a4 & 2) != 0)
    {
      v23 = a2[21];
      v6 = a2 + 21;
      v7 = v23;
    }
    else if ((a4 & 0x10) != 0)
    {
      v24 = a2[22];
      v6 = a2 + 22;
      v7 = v24;
    }
    else if ((a4 & 0x40) != 0)
    {
      v25 = a2[23];
      v6 = a2 + 23;
      v7 = v25;
    }
    else if ((a4 & 1) != 0)
    {
      v26 = a2[20];
      v6 = a2 + 20;
      v7 = v26;
    }
    else
    {
      v8 = a2[19];
      v6 = a2 + 19;
      v7 = v8;
    }
    *v5 = v7;
    if (v7)
      *(_QWORD *)(v7 + 24) = v5;
    *v6 = a3;
    *(_QWORD *)(a3 + 24) = v6;
  }
  return result;
}

uint64_t sub_10002AF14(uint64_t a1, FILE *a2)
{
  uint64_t result;
  uint64_t i;
  uint64_t j;
  uint64_t k;

  result = sub_10002AF90(a1, a2);
  for (i = 0; i != 23; ++i)
  {
    for (j = *(_QWORD *)(a1 + 8 * i + 336); j; j = *(_QWORD *)(j + 120))
      result = sub_1000216C4(j, a2, 0);
  }
  for (k = *(_QWORD *)(a1 + 320); k; k = *(_QWORD *)(k + 16))
    result = sub_10002AF14(k, a2);
  return result;
}

uint64_t sub_10002AF90(uint64_t a1, FILE *a2)
{
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  _QWORD *i;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t j;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  _QWORD *k;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  _QWORD *m;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t n;
  uint64_t ii;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t jj;
  uint64_t kk;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t mm;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t nn;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t i1;
  uint64_t i2;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t i3;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t **i4;
  uint64_t v272;
  const char *v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  const char *v281;
  _QWORD *v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  void **v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v348;
  int v349;
  char *v350;
  char v351;
  __int16 v352;
  char v353;
  char v354;
  _QWORD v355[6];
  _OWORD v356[2];
  _QWORD v357[6];
  __int128 v358;
  __int128 v359;
  __int128 v360;
  __int128 v361;

  v4 = sub_100028C98(a1, 1);
  sub_10004391C(a2, 0, "%s = {", v5, v6, v7, v8, v9, v4);
  free(v4);
  sub_10004391C(a2, 1, "type = %s", v10, v11, v12, v13, v14, *(_QWORD *)(*(_QWORD *)(a1 + 112) + 112));
  sub_10004391C(a2, 1, "handle = %lu", v15, v16, v17, v18, v19, *(_QWORD *)(a1 + 120));
  sub_10004391C(a2, 1, "active count = %d", v20, v21, v22, v23, v24, *(unsigned int *)(a1 + 188));
  if (*(_DWORD *)(a1 + 192))
    sub_10004391C(a2, 1, "on-demand count = %d", v25, v26, v27, v28, v29, *(unsigned int *)(a1 + 192));
  if (*(_DWORD *)(a1 + 196))
    sub_10004391C(a2, 1, "service count = %u", v25, v26, v27, v28, v29, *(unsigned int *)(a1 + 196));
  if (*(_DWORD *)(a1 + 200))
    sub_10004391C(a2, 1, "active service count = %u", v25, v26, v27, v28, v29, *(unsigned int *)(a1 + 200));
  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000715B8)
  {
    v30 = sub_1000047E4();
    if (v30)
      sub_10004391C(a2, 1, "boot mode = %s", v31, v32, v33, v34, v35, v30);
    *(_QWORD *)&v358 = 0;
    if (sub_100003F84((unint64_t *)&v358))
    {
      sub_10004391C(a2, 1, "prob guard = true", v36, v37, v38, v39, v40);
      sub_10004391C(a2, 1, "prob guard sample rate = %zu", v41, v42, v43, v44, v45, (_QWORD)v358);
    }
    sub_10004391C(a2, 1, "maximum allowed shutdown time = %d s", v36, v37, v38, v39, v40, dword_100071A9C);
    sub_10004391C(a2, 1, "service stats = {", v46, v47, v48, v49, v50);
    v357[0] = _NSConcreteStackBlock;
    v357[1] = 0x40000000;
    v357[2] = sub_10003045C;
    v357[3] = &unk_10006CAC8;
    v357[4] = a2;
    v357[5] = 0;
    sub_100003D10((uint64_t)v357);
    sub_10004391C(a2, 1, "}", v51, v52, v53, v54, v55);
  }
  if (*(_QWORD *)(a1 + 240))
    sub_10004391C(a2, 1, "originator = %s", v25, v26, v27, v28, v29, *(_QWORD *)(a1 + 240));
  sub_10004391C(a2, 1, "creator = %s[%d]", v25, v26, v27, v28, v29, *(_QWORD *)(a1 + 312), *(unsigned int *)(a1 + 300));
  sub_10004391C(a2, 1, "creator euid = %d", v56, v57, v58, v59, v60, *(unsigned int *)(a1 + 284));
  if (*(_QWORD **)(a1 + 112) == qword_100071750)
    sub_10004391C(a2, 1, "uniqueid = %llu", v61, v62, v63, v64, v65, *(_QWORD *)(a1 + 128));
  if (*(_QWORD *)(a1 + 968))
    sub_10004391C(a2, 1, "session = %s", v61, v62, v63, v64, v65, *(_QWORD *)(a1 + 968));
  v66 = *(_QWORD *)(a1 + 976);
  if (v66)
    sub_10004391C(a2, 1, "endpoint destination = %s", v61, v62, v63, v64, v65, v66 + 1024);
  sub_10004391C(a2, 1, "security context = {", v61, v62, v63, v64, v65);
  if ((*(_BYTE *)(a1 + 104) & 1) != 0)
  {
    v348 = *(unsigned int *)(a1 + 56);
    v72 = "uid = %u";
  }
  else
  {
    v72 = "uid unset";
  }
  sub_10004391C(a2, 2, v72, v67, v68, v69, v70, v71, v348);
  v349 = *(_DWORD *)(a1 + 60);
  sub_10004391C(a2, 2, "session uid = %d", v73, v74, v75, v76, v77);
  if (*(_DWORD *)(a1 + 64) != -1)
  {
    v349 = *(_DWORD *)(a1 + 64);
    sub_10004391C(a2, 2, "persona id = %u", v78, v79, v80, v81, v82);
  }
  sub_10004391C(a2, 1, "}", v78, v79, v80, v81, v82);
  sub_100043998(a2, v83, v84, v85, v86, v87, v88, v89, v349);
  v95 = *(_QWORD *)(a1 + 264);
  if (v95)
    sub_10004391C(a2, 1, "bringup time = %llu ms", v90, v91, v92, v93, v94, v95 / 0xF4240);
  if (*(_QWORD *)(a1 + 248))
  {
    sub_10004391C(a2, 1, "xpc service paths = {", v90, v91, v92, v93, v94);
    *(_QWORD *)&v358 = 0;
    *((_QWORD *)&v358 + 1) = a2;
    *(_QWORD *)&v359 = 2;
    xpc_dictionary_apply_f(*(_QWORD *)(a1 + 248));
    sub_10004391C(a2, 1, "}", v96, v97, v98, v99, v100);
  }
  sub_10004391C(a2, 1, "death port = 0x%x", v90, v91, v92, v93, v94, *(unsigned int *)(a1 + 184));
  if (*(_WORD *)(a1 + 204))
  {
    LOWORD(v350) = *(_WORD *)(a1 + 204);
    sub_10004391C(a2, 1, "in-progress bootstraps = %hu", v103, v104, v105, v106, v107);
  }
  if (*(_QWORD *)(a1 + 208))
  {
    sub_10004391C(a2, 1, "pending requests = {", v103, v104, v105, v106, v107);
    for (i = *(_QWORD **)(a1 + 208); i; i = (_QWORD *)*i)
    {
      v360 = 0u;
      v361 = 0u;
      v358 = 0u;
      v359 = 0u;
      memset(v356, 0, sizeof(v356));
      xpc_dictionary_get_audit_token(i[3], v356);
      LOBYTE(v350) = sub_10003FBC0((uint64_t)v356, (char *)&v358);
      sub_10004391C(a2, 2, "caller = %s.%d, event = %d", v114, v115, v116, v117, v118);
    }
    sub_10004391C(a2, 1, "}", v108, v109, v110, v111, v112);
  }
  if (*(_QWORD *)(a1 + 320))
  {
    sub_10004391C(a2, 1, "subdomains = {", v103, v104, v105, v106, v107);
    for (j = *(_QWORD *)(a1 + 320); j; j = *(_QWORD *)(j + 16))
    {
      if (*(_QWORD **)(j + 112) != qword_100071750 || !*(_QWORD *)(j + 248))
      {
        v350 = sub_100028C98(j, 1);
        sub_10004391C(a2, 2, "%s", v125, v126, v127, v128, v129);
        free(v350);
      }
    }
    sub_10004391C(a2, 1, "}", v119, v120, v121, v122, v123);
  }
  if (*(_QWORD *)(a1 + 48))
  {
    sub_10004391C(a2, 1, "pending attachments = {", v103, v104, v105, v106, v107);
    for (k = *(_QWORD **)(a1 + 48); k; k = (_QWORD *)*k)
      sub_10004391C(a2, 2, "%s", v130, v131, v132, v133, v134, k[2]);
    sub_10004391C(a2, 1, "}", v130, v131, v132, v133, v134);
  }
  if (*(_UNKNOWN **)(a1 + 112) == &unk_1000715B8)
    sub_100021610(a2, 0, v102, v103, v104, v105, v106, v107);
  if (*(_QWORD *)(a1 + 96))
  {
    sub_100043998(a2, v101, v102, v103, v104, v105, v106, v107, (char)v350);
    sub_10004391C(a2, 1, "environment = {", v136, v137, v138, v139, v140);
    for (m = *(_QWORD **)(a1 + 96); m; m = (_QWORD *)*m)
      sub_1000197E0((uint64_t)m, 2, a2);
    sub_10004391C(a2, 1, "}", v141, v142, v143, v144, v145);
  }
  sub_100043998(a2, v101, v102, v103, v104, v105, v106, v107, (char)v350);
  sub_10004391C(a2, 1, "services = {", v147, v148, v149, v150, v151);
  for (n = 0; n != 23; ++n)
  {
    for (ii = *(_QWORD *)(a1 + 8 * n + 336); ii; ii = *(_QWORD *)(ii + 120))
      sub_10002375C(ii, a2, 2, v152, v153, v154, v155, v156);
  }
  sub_10004391C(a2, 1, "}", v152, v153, v154, v155, v156);
  if (os_map_str_count(a1 + 520))
  {
    sub_100043998(a2, v159, v160, v161, v162, v163, v164, v165, v351);
    sub_10004391C(a2, 1, "service stubs = {", v166, v167, v168, v169, v170);
    v355[0] = _NSConcreteStackBlock;
    v355[1] = 0x40000000;
    v355[2] = sub_1000304E0;
    v355[3] = &unk_10006CAE8;
    v355[4] = a2;
    v355[5] = 0;
    os_map_str_foreach(a1 + 520, v355);
    sub_10004391C(a2, 1, "}", v171, v172, v173, v174, v175);
  }
  sub_100043998(a2, v159, v160, v161, v162, v163, v164, v165, v351);
  sub_10004391C(a2, 1, "unmanaged processes = {", v176, v177, v178, v179, v180);
  for (jj = 0; jj != 7; ++jj)
  {
    for (kk = *(_QWORD *)(a1 + 8 * jj + 648); kk; kk = *(_QWORD *)(kk + 88))
    {
      sub_10004391C(a2, 2, "%s = {", v181, v182, v183, v184, v185, kk + 1392);
      v352 = *(_WORD *)(kk + 300);
      sub_10004391C(a2, 3, "active count = %d", v188, v189, v190, v191, v192);
      sub_10004391C(a2, 3, "dynamic endpoints = {", v193, v194, v195, v196, v197);
      for (mm = *(_QWORD *)(kk + 160); mm; mm = *(_QWORD *)(mm + 16))
        sub_100046438(mm, a2, 4, v198, v199, v200, v201, v202);
      sub_10004391C(a2, 3, "}", v198, v199, v200, v201, v202);
      sub_10004391C(a2, 3, "pid-local endpoints = {", v204, v205, v206, v207, v208);
      for (nn = *(_QWORD *)(kk + 168); nn; nn = *(_QWORD *)(nn + 16))
        sub_100046438(nn, a2, 4, v209, v210, v211, v212, v213);
      sub_10004391C(a2, 3, "}", v209, v210, v211, v212, v213);
      sub_10004391C(a2, 2, "}", v215, v216, v217, v218, v219);
    }
  }
  sub_10004391C(a2, 1, "}", v181, v182, v183, v184, v185);
  sub_100043998(a2, v220, v221, v222, v223, v224, v225, v226, v352);
  sub_10004391C(a2, 1, "endpoints = {", v227, v228, v229, v230, v231);
  for (i1 = 0; i1 != 31; ++i1)
  {
    for (i2 = *(_QWORD *)(a1 + 8 * i1 + 704); i2; i2 = *(_QWORD *)(i2 + 32))
      sub_10003051C(a2, i2, v232, v233, v234, v235, v236, v237);
  }
  sub_10004391C(a2, 1, "}", v233, v234, v235, v236, v237);
  if (*(_QWORD *)(a1 + 976))
  {
    sub_100043998(a2, v240, v241, v242, v243, v244, v245, v246, v353);
    sub_10004391C(a2, 1, "externally-hosted endpoints = {", v247, v248, v249, v250, v251);
    v258 = 0;
    v259 = *(_QWORD *)(a1 + 976);
    do
    {
      for (i3 = *(_QWORD *)(v259 + 8 * v258 + 704); i3; i3 = *(_QWORD *)(i3 + 32))
        sub_10003051C(a2, i3, v252, v253, v254, v255, v256, v257);
      ++v258;
    }
    while (v258 != 31);
    sub_10004391C(a2, 1, "}", v253, v254, v255, v256, v257);
  }
  sub_100043998(a2, v240, v241, v242, v243, v244, v245, v246, v353);
  sub_10004391C(a2, 1, "task-special ports = {", v261, v262, v263, v264, v265);
  for (i4 = *(uint64_t ***)(a1 + 88); i4; i4 = (uint64_t **)*i4)
  {
    v272 = *((unsigned int *)i4 + 5);
    v273 = "exception";
    if ((_DWORD)v272 != 128)
      v273 = (const char *)mach_task_special_port_description(v272);
    v274 = *((unsigned int *)i4 + 4);
    v275 = sub_1000306AC(a1, v274);
    if (v275)
    {
      v281 = (const char *)(v275 + 1024);
    }
    else
    {
      v282 = sub_10002E094(a1, v274, 0, v276, v277, v278, v279, v280);
      v281 = (const char *)(v282 + 21);
      if (!v282)
        v281 = "(unknown)";
    }
    sub_10004391C(a2, 3, "%#8x %-4u %12s  %s", v276, v277, v278, v279, v280, *((unsigned int *)i4 + 4), *((unsigned int *)i4 + 5), v273, v281);
  }
  sub_10004391C(a2, 1, "}", v266, v267, v268, v269, v270);
  v283 = sub_10002E370(a1);
  if (os_map_str_count(v283))
  {
    sub_10004391C(a2, 1, "attractive services = {", v284, v285, v286, v287, v288);
    *(_QWORD *)&v358 = _NSConcreteStackBlock;
    *((_QWORD *)&v358 + 1) = 0x40000000;
    *(_QWORD *)&v359 = sub_100030718;
    *((_QWORD *)&v359 + 1) = &unk_10006CB08;
    v360 = (unint64_t)a2;
    os_map_str_foreach(v283, &v358);
    sub_10004391C(a2, 1, "}", v289, v290, v291, v292, v293);
  }
  sub_1000305B8(a1, a2, 1, v284, v285, v286, v287, v288);
  v294 = (void **)sub_1000106C8(0x80uLL);
  sub_100027D6C((uint64_t)v294, (char)"shutting down", *(_DWORD *)(a1 + 1016) & 1, v295, v296, v297, v298, v299);
  sub_100027D6C((uint64_t)v294, (char)"slain", (*(_DWORD *)(a1 + 1016) >> 1) & 1, v300, v301, v302, v303, v304);
  sub_100027D6C((uint64_t)v294, (char)"uncorked", (*(_DWORD *)(a1 + 1016) >> 2) & 1, v305, v306, v307, v308, v309);
  sub_100027D6C((uint64_t)v294, (char)"deactivated", (*(_DWORD *)(a1 + 1016) >> 4) & 1, v310, v311, v312, v313, v314);
  sub_100027D6C((uint64_t)v294, (char)"inactive", (*(_DWORD *)(a1 + 1016) >> 5) & 1, v315, v316, v317, v318, v319);
  sub_100027D6C((uint64_t)v294, (char)"in initial on-demand", (*(_DWORD *)(a1 + 1016) >> 6) & 1, v320, v321, v322, v323, v324);
  sub_100027D6C((uint64_t)v294, (char)"exec hack", (*(_DWORD *)(a1 + 1016) >> 7) & 1, v325, v326, v327, v328, v329);
  sub_100043998(a2, v330, v331, v332, v333, v334, v335, v336, v354);
  sub_10004391C(a2, 1, "properties = %s", v337, v338, v339, v340, v341, *v294);
  sub_100010718(v294);
  return sub_10004391C(a2, 0, "}", v342, v343, v344, v345, v346);
}

uint64_t sub_10002BB18(uint64_t a1, uint64_t a2)
{
  char *v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  xpc_object_t v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  const char *v14;
  uint64_t v16;
  int v17;
  uint64_t v18;
  unint64_t v19;
  _BOOL4 v20;
  uint64_t v21;
  uint64_t v23;
  unint64_t v24;
  _BOOL4 v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  const char *v30;
  uint64_t v31;
  char *v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void (*v37)(uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v38)(uint64_t, int, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v39)(_QWORD *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  char *(*v40)(_QWORD *, const char *, void *, uint64_t, _BYTE *, size_t);
  char *(*v41)(uint64_t, const char *, void *, _BYTE *, uint64_t);
  void (*v42)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v43;
  xpc_object_t v44;
  unsigned int v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;

  v4 = (char *)sub_1000105F4(a2);
  v5 = sub_1000105EC(a2);
  v6 = sub_1000105BC(a2);
  v43 = a1;
  v44 = 0;
  v37 = sub_10002A27C;
  v38 = sub_10002A664;
  v39 = sub_10002A7A8;
  v40 = sub_10002A940;
  v41 = sub_10002A998;
  v42 = sub_10002AA84;
  if (v6)
  {
    v7 = sub_10002BF68(v6, &v44);
    v45 = v7;
    v8 = v44;
    if ((_DWORD)v7)
    {
      v33 = (const char *)v7;
      v34 = xpc_strerror(v7);
      v32 = v4;
      v9 = "Could not parse plist: path = %s, error = %d: %s";
LABEL_4:
      sub_10002BFF4(a1, v8, 3, v9, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44);
      goto LABEL_22;
    }
  }
  else
  {
    v8 = sub_1000105DC(a2);
    v44 = v8;
  }
  v10 = (*(_QWORD *)(a2 + 48) >> 13) & 1;
  if ((sub_10002C0BC(v8, "Label") & 1) != 0 || sub_1000105C4(a2))
    v11 = 128;
  else
    v11 = 0;
  if (*(_QWORD **)(a1 + 112) != qword_100071750)
    v10 |= 0x80uLL;
  v12 = sub_10002C0E4(a1, 3, v10, a2 + 16, (uint64_t)v4, v5);
  if (!v12)
  {
    if (sub_1000156F0(v4, "/System/Library/LaunchDaemons/com.apple.jetsamproperties")
      || sub_1000156F0(v4, "/AppleInternal/Library/LaunchDaemons/com.apple.jetsamproperties"))
    {
      v45 = 0;
      goto LABEL_22;
    }
    v16 = (*(_QWORD *)(a2 + 48) >> 10) & 0x22;
    v17 = sub_1000105D0(a2);
    v18 = 0x20000;
    if (!v17)
      v18 = 0;
    v19 = (v16 | v11 | v18) & 0xFFFFFFFFFFFFFDFFLL | ((((unint64_t)*(unsigned int *)(a2 + 48) >> 8) & 1) << 9);
    if (sub_1000156F0(v4, "/System/Library/LaunchAngels/")
      || sub_1000156F0(v4, "/AppleInternal/Library/LaunchAngels/")
      || (*(_BYTE *)(a2 + 50) & 4) != 0)
    {
      v19 |= 0x400uLL;
    }
    v20 = sub_10003E3D8(a1);
    v21 = *(_QWORD *)(a1 + 112);
    if ((_UNKNOWN *)v21 == &unk_1000715B8 || v20)
      v23 = v19 | 0x800;
    else
      v23 = v19;
    v24 = v23 | ((unint64_t)(*(_BYTE *)(v21 + 128) & 2) << 11);
    v25 = sub_1000156F0(v4, "/Library/LaunchAgents/");
    v26 = v24 | 0x12000;
    if (!v25)
      v26 = v24;
    v27 = v26 | (*(_QWORD *)(a2 + 48) >> 3) & 0x10000;
    if (sub_1000156F0(v4, "/System/Library/DeveloperModeLaunchDaemons/"))
      v28 = v27 | 0x4000;
    else
      v28 = v27;
    v45 = 0;
    v29 = sub_100005F4C((_DWORD *)a1, v8, v4, a2 + 16, (uint64_t)&v37, v28, (int *)&v45);
    if (v29)
    {
      sub_100029B24((_DWORD *)a1, v29);
      goto LABEL_22;
    }
    if ((int)v45 > 118)
    {
      if (v45 == 119 || v45 == 134)
        goto LABEL_22;
    }
    else
    {
      if (v45 == 17)
      {
        v48 = 0u;
        v49 = 0u;
        v46 = 0u;
        v47 = 0u;
        v33 = sub_10003FBC0(a2 + 16, (char *)&v46);
        v34 = *(unsigned int *)(a2 + 36);
        v32 = v4;
        v9 = "Caller tried to import service with same label as an existing service: path = %s, caller = %s[%d]";
        goto LABEL_4;
      }
      if (v45 == 37)
        goto LABEL_22;
    }
    v48 = 0u;
    v49 = 0u;
    v46 = 0u;
    v47 = 0u;
    v30 = sub_10003FBC0(a2 + 16, (char *)&v46);
    v31 = *(unsigned int *)(a2 + 36);
    if (v45 == 152)
    {
      xpc_strerror(152);
      sub_10002BFF4(a1, v8, 5, "Did not import service from caller: path = %s, caller = %s[%d], error = %d: %s", v4);
      goto LABEL_22;
    }
    v35 = v45;
    v36 = xpc_strerror(v45);
    v33 = v30;
    v34 = v31;
    v32 = v4;
    v9 = "Could not import service from caller: path = %s, caller = %s[%d], error = %d: %s";
    goto LABEL_4;
  }
  v13 = v12;
  v48 = 0u;
  v49 = 0u;
  v46 = 0u;
  v47 = 0u;
  v14 = sub_10003FBC0(a2 + 16, (char *)&v46);
  if (v13 == 122)
  {
    sub_10002BFF4(a1, v8, 3, "Caller specified a plist with bad ownership/permissions: path = %s, caller = %s[%d]", v4, v14, *(_DWORD *)(a2 + 36));
  }
  else if (v13 == 1)
  {
    sub_10002C1B8(a1, a2 + 16, 1, "service bootstrap (%s, io flags=%#llx, eval flags=%#llx)", v4, *(_QWORD *)(a2 + 48), v10);
  }
  v45 = v13;
LABEL_22:
  if (v8)
    xpc_release(v8);
  return v45;
}

uint64_t sub_10002BF68(NSObject *a1, _QWORD *a2)
{
  dispatch_data_t v3;
  NSObject *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  size_t v9;
  void *buffer_ptr;

  v9 = 0;
  buffer_ptr = 0;
  v3 = dispatch_data_create_map(a1, (const void **)&buffer_ptr, &v9);
  if (!v3)
    return 12;
  v4 = v3;
  v5 = (void *)xpc_create_from_plist(buffer_ptr, v9);
  if (v5 && (v6 = v5, xpc_get_type(v5) == (xpc_type_t)&_xpc_type_dictionary))
  {
    v7 = 0;
    *a2 = v6;
  }
  else
  {
    v7 = 109;
  }
  dispatch_release(v4);
  return v7;
}

void sub_10002BFF4(uint64_t a1, xpc_object_t xdict, int a3, char *a4, ...)
{
  uint64_t v4;
  const char *string;
  const char *v9;
  char *v10;
  char *v11;
  va_list va;

  va_start(va, a4);
  if (xdict && (string = xpc_dictionary_get_string(xdict, "Label")) != 0)
  {
    v9 = string;
    v10 = sub_100028C98(a1, 1);
    v11 = sub_100015630("%s/%s", v10, v9);
    free(v10);
  }
  else
  {
    v11 = sub_100028C98(a1, 1);
  }
  sub_1000412EC(v11, a3, a4, va, v4);
  free(v11);
}

const char *sub_10002C0BC(void *a1, const char *a2)
{
  const char *result;

  result = xpc_dictionary_get_string(a1, a2);
  if (result)
    return (const char *)sub_1000156F0(result, "com.apple.");
  return result;
}

uint64_t sub_10002C0E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v12;
  uint64_t v13;

  v12 = a1;
  do
  {
    v13 = v12;
    v12 = *(_QWORD *)(v12 + 232);
  }
  while (v12);
  if ((a2 - 1) <= 1 && (*(_DWORD *)(v13 + 1016) & 1) != 0
    || (a2 - 3) <= 1 && (*(_BYTE *)(a1 + 1016) & 3) != 0)
  {
    return 124;
  }
  if ((a3 & 0x88) != 0 && !sub_1000307A8(a4))
    return 154;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a1 + 112)
                                                                                                 + 104))(a1, a2, a3, *(_QWORD *)(a1 + 120), a4, a5, a6);
}

void sub_10002C1B8(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, ...)
{
  int v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v14[2];
  _OWORD v15[4];
  va_list va;

  va_start(va, a4);
  if ((_DWORD)a3 != 124)
  {
    if ((_DWORD)a3 == 154)
      v7 = 65539;
    else
      v7 = 3;
    v14[0] = 0;
    va_copy((va_list)&v14[1], va);
    vasprintf(v14, a4, va);
    memset(v15, 0, sizeof(v15));
    v8 = sub_10003FBC0(a2, (char *)v15);
    xpc_strerror(a3);
    sub_100028C34(a1, v7, "Caller not allowed to perform action: %s.%d, action = %s, code = %d: %s, uid = %u, euid = %u, gid = %u, egid = %u, asid = %u", v9, v10, v11, v12, v13, v8);
    free(v14[0]);
  }
}

uint64_t sub_10002C2C4(uint64_t a1, uint64_t a2, NSObject *a3)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  xpc_object_t v18;
  char *string;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  xpc_object_t object;

  v6 = (const char *)sub_1000105F4(a2);
  v7 = sub_1000105EC(a2);
  v8 = sub_1000105BC(a2);
  object = 0;
  if ((*(_BYTE *)(a1 + 1016) & 3) != 0)
    return 124;
  v10 = v8;
  v11 = sub_10002C0E4(a1, 4, 128, a2 + 16, (uint64_t)v6, v7);
  if ((_DWORD)v11)
  {
    v9 = v11;
    sub_10002C1B8(a1, a2 + 16, v11, "service bootout (%s)", v6);
    return v9;
  }
  if (v10)
  {
    v12 = sub_10002BF68(v10, &object);
    if ((_DWORD)v12)
    {
      v9 = v12;
      xpc_strerror(v12);
      sub_100028C34(a1, 3, "Could not parse plist: path = %s, error = %d: %s:", v13, v14, v15, v16, v17, (char)v6);
      v18 = object;
      goto LABEL_12;
    }
    v18 = object;
  }
  else
  {
    v18 = sub_1000105DC(a2);
  }
  if (xpc_get_type(v18) != (xpc_type_t)&_xpc_type_dictionary
    || (string = (char *)xpc_dictionary_get_string(v18, "Label")) == 0)
  {
    v9 = 109;
    goto LABEL_12;
  }
  v21 = string;
  v22 = sub_10002C4E4((_DWORD *)a1, string);
  if (!v22)
  {
    v9 = 113;
    goto LABEL_12;
  }
  v23 = (uint64_t)v22;
  v24 = sub_10001F090();
  if ((_DWORD)v24)
  {
    v9 = v24;
    sub_10002C1B8(a1, a2 + 16, v24, "service bootout (%s)", v21);
    goto LABEL_12;
  }
  sub_10002C67C(v23, a2 + 16, (char)"booting out service");
  v9 = sub_100029C60(a1, v23);
  if ((_DWORD)v9 != 36)
  {
LABEL_25:
    if ((*(_BYTE *)(a2 + 49) & 8) != 0)
    {
      sub_10002E41C(a1, v21, 1);
      sub_100048018();
    }
    goto LABEL_12;
  }
  if (!*(_QWORD *)(v23 + 280))
  {
    if (a3)
    {
      *(_QWORD *)(v23 + 280) = a3;
      dispatch_group_enter(a3);
    }
    goto LABEL_25;
  }
  v9 = 37;
LABEL_12:
  if (v18)
    xpc_release(v18);
  return v9;
}

char *sub_10002C4E4(_DWORD *a1, char *a2)
{
  char *i;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v17;
  _QWORD v18[7];

  for (i = *(char **)&a1[2 * (sub_1000158FC(a2) % 0x17uLL) + 84]; i; i = (char *)*((_QWORD *)i + 15))
  {
    if (!strcmp(i + 1392, a2))
      break;
  }
  v5 = os_map_str_delete(a1 + 130, a2);
  if (v5)
  {
    v6 = v5;
    v18[0] = sub_10002A27C;
    v18[1] = sub_10002A664;
    v18[2] = sub_10002A7A8;
    v18[3] = sub_10002A940;
    v18[4] = sub_10002A998;
    v18[5] = sub_10002AA84;
    v18[6] = a1;
    v7 = sub_10004438C(v5);
    v8 = (void *)xpc_bundle_create(v7, 1);
    v9 = sub_100044398(v6);
    xpc_bundle_populate(v8, v9, 0);
    v17 = 0;
    i = sub_10000766C((uint64_t)a1, (uint64_t)v8, (_OWORD *)(v6 + 16), 0, (uint64_t)v18, *(_QWORD *)(v6 + 48), &v17);
    v10 = sub_100044380(v6);
    if (i)
    {
      sub_100028C34((uint64_t)a1, 5, "Service stub initialized for %s", v11, v12, v13, v14, v15, v10);
      sub_100029B24(a1, (uint64_t)i);
    }
    else
    {
      sub_100028C34((uint64_t)a1, 5, "Service stub initialization failed for %s [%d]", v11, v12, v13, v14, v15, v10);
    }
    xpc_release(v8);
    sub_10001962C((void *)v6);
  }
  return i;
}

void sub_10002C67C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11[1024];

  bzero(v11, 0x400uLL);
  sub_1000307EC(*(_DWORD *)(a2 + 20), v11);
  sub_10001D418(a1, 5, "%s: caller = %s, value = 0x%llx", v6, v7, v8, v9, v10, a3);
}

void sub_10002C720(uint64_t a1, char *a2, int a3)
{
  sub_10002E41C(a1, a2, a3);
  sub_100048018();
}

uint64_t sub_10002C734(size_t a1, uint64_t a2)
{
  unsigned int v3;

  v3 = 0;
  sub_10002C76C(a1, a2, 0, &v3);
  if ((v3 & 0xFFFFFFFD) == 0x79)
    return 0;
  else
    return v3;
}

char *sub_10002C76C(size_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  const char *property;
  void *info_dictionary;
  char *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  xpc_object_t value;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v43;
  char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char v50;
  char *v51;
  const char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  _DWORD *v61;
  const char *string;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  xpc_object_t v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _OWORD *v72;
  void *v73;
  uint64_t v74;
  _DWORD *v75;
  _QWORD v76[7];
  int v77;
  _QWORD v78[2];

  v8 = sub_1000105FC(a2);
  v9 = sub_1000105EC(a2);
  property = (const char *)xpc_bundle_get_property(v8, 2);
  info_dictionary = (void *)xpc_bundle_get_info_dictionary(v8);
  if ((*(_BYTE *)(a1 + 1016) & 3) == 0)
  {
    v13 = info_dictionary;
    v73 = a3;
    v75 = a4;
    v14 = (*(_QWORD *)(a2 + 48) >> 13) & 1;
    if ((sub_10002C0BC(info_dictionary, "CFBundleIdentifier") & 1) != 0
      || sub_1000105C4(a2))
    {
      v15 = 128;
    }
    else
    {
      v15 = 0;
    }
    v16 = v14 | 0x80;
    if (*(_QWORD **)(a1 + 112) == qword_100071750)
      v16 = v14;
    v74 = v16;
    if ((*(_BYTE *)(a2 + 49) & 0x40) != 0 && sub_100015730(property, ".appex"))
      v15 |= 0x40uLL;
    v78[0] = 0;
    v17 = sub_10003092C(a1, v8, v78);
    if ((_DWORD)v17)
    {
      v18 = v17;
      v19 = xpc_bundle_get_property(v8, 2);
      xpc_strerror(v18);
      sub_100028C34(a1, 3, "Could not get domain target from bundle: path = %s, error = %d: %s", v20, v21, v22, v23, v24, v19);
LABEL_14:
      v12 = 0;
      v25 = 112;
LABEL_15:
      v77 = v25;
LABEL_30:
      a4 = v75;
      goto LABEL_31;
    }
    v72 = (_OWORD *)(a2 + 16);
    v26 = (_QWORD *)v78[0];
    v27 = a1;
    if ((_QWORD *)v78[0] != qword_100071750)
    {
      v28 = (*(uint64_t (**)(_OWORD *))(v78[0] + 88))(v72);
      v29 = sub_10002E19C(v26, v28);
      if (*(_UNKNOWN **)(v29 + 112) == &unk_1000715B8)
      {
        v27 = v29;
        if (*(_QWORD *)(v29 + 968))
        {
          v27 = sub_10003E404();
          if (!v27)
            goto LABEL_14;
        }
      }
      else
      {
        v27 = v29;
      }
    }
    v30 = sub_1000105D0(a2);
    v31 = 0x20000;
    if (!v30)
      v31 = 0;
    v71 = v31 | v15;
    if ((v15 & 0x40) != 0)
    {
      value = xpc_dictionary_get_value(v13, "XPCService");
      if (value && (v34 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary))
      {
        string = xpc_dictionary_get_string(v34, "_RoleAccount");
        v32 = v74;
        if (string && !strcmp(string, "mobile"))
          v32 = v14 | 0x10;
      }
      else
      {
        v32 = v74;
      }
      v71 &= ~0x80uLL;
    }
    else
    {
      v32 = v74;
    }
    v35 = sub_10002C0E4(v27, 3, v32, (uint64_t)v72, (uint64_t)property, v9);
    v77 = v35;
    if ((_DWORD)v35)
    {
      v36 = *(_QWORD *)(*(_QWORD *)(v27 + 112) + 112);
      xpc_strerror(v35);
      sub_100028C34(a1, 3, "Path not allowed in target domain: type = %s, path = %s error = %d: %s, origin = %s", v37, v38, v39, v40, v41, v36);
      goto LABEL_29;
    }
    v43 = *(_DWORD *)(a2 + 48);
    v76[0] = sub_10002A27C;
    v76[1] = sub_10002A664;
    v76[2] = sub_10002A7A8;
    v76[3] = sub_10002A940;
    v76[4] = sub_10002A998;
    v76[5] = sub_10002AA84;
    v76[6] = v27;
    v44 = (char *)xpc_dictionary_get_string(v13, "CFBundleIdentifier");
    if (!v44)
    {
      sub_100028C34(a1, 3, "Bundle Info.plist at %s does not have a CFBundleIdentifier", v45, v46, v47, v48, v49, (char)property);
      v12 = 0;
      v25 = 107;
      goto LABEL_15;
    }
    v50 = (char)v44;
    v51 = sub_10002C4E4((_DWORD *)v27, v44);
    if (v51)
    {
      v12 = v51;
      v52 = (const char *)sub_10001CFC4((uint64_t)v51);
      if (strcmp(property, v52))
      {
        sub_10001CFC4((uint64_t)v12);
        sub_100028C34(a1, 4, "Attempt to re-bootstrap service from different path, will use existing: service = %s, existing = %s, conflicting = %s", v53, v54, v55, v56, v57, v50);
      }
      v58 = 121;
      v77 = 121;
    }
    else
    {
      v63 = (2 * v43) & 0x200 | v71;
      if ((*(_BYTE *)(a2 + 49) & 0x40) == 0 && *(_QWORD **)(a1 + 112) == qword_100071750)
      {
        v64 = sub_1000105FC(a2);
        v78[0] = 0;
        if (!sub_10003092C(a1, v64, v78) && (_QWORD *)v78[0] == qword_100071750)
        {
          v65 = (void *)xpc_bundle_get_info_dictionary(v64);
          v66 = xpc_dictionary_get_value(v65, "XPCService");
          if (v66)
          {
            v67 = v66;
            if (xpc_get_type(v66) == (xpc_type_t)&_xpc_type_dictionary
              && !xpc_dictionary_get_value(v67, "_AdditionalSubServices")
              && !xpc_dictionary_get_value(v67, "_AdditionalServices")
              && !byte_100072A46)
            {
              if (v27 != a1)
                sub_10004D738();
              sub_100044334(a1, v8, (uint64_t)v72, v63, &v77);
              if (v68)
              {
                v69 = v68;
                v70 = sub_100044380(v68);
                os_map_str_insert(a1 + 520, v70, v69);
                v12 = 0;
                v25 = 123;
                goto LABEL_15;
              }
LABEL_29:
              v12 = 0;
              goto LABEL_30;
            }
          }
        }
      }
      v12 = sub_10000766C(v27, v8, v72, v73, (uint64_t)v76, v63, &v77);
      if (!v12)
        goto LABEL_30;
      v58 = v77;
      if (v27 == a1 && v77 != 121)
      {
        v61 = (_DWORD *)a1;
LABEL_62:
        sub_100029B24(v61, (uint64_t)v12);
        goto LABEL_30;
      }
    }
    v59 = *((_QWORD *)v12 + 19);
    if (v59)
    {
      do
      {
        if ((*(_BYTE *)(v59 + 88) & 0x40) == 0)
        {
          if (*(_QWORD *)(a1 + 976))
            v60 = *(_QWORD *)(a1 + 976);
          else
            v60 = a1;
          if (!sub_10002E860(v60, (char *)(v59 + 168)))
            sub_10002ADB4(a1, v12, v59, 4);
        }
        v59 = *(_QWORD *)(v59 + 16);
      }
      while (v59);
      v58 = v77;
    }
    if (v58)
      goto LABEL_30;
    v61 = (_DWORD *)v27;
    goto LABEL_62;
  }
  v12 = 0;
  v77 = 124;
LABEL_31:
  *a4 = v77;
  return v12;
}

uint64_t sub_10002CCF8(uint64_t a1, char *a2)
{
  if (*(_QWORD *)(a1 + 976))
    a1 = *(_QWORD *)(a1 + 976);
  return sub_10002E860(a1, a2);
}

uint64_t sub_10002CD08(uint64_t a1, uint64_t a2)
{
  __int128 *v3;

  v3 = sub_100044524();
  if (*((_DWORD *)v3 + 5) || *((_DWORD *)v3 + 3) || *((_DWORD *)v3 + 7))
  {
    sub_100040F68(65539, "Dropping coalition notification from unknown source (%llu)", a2);
    return 5;
  }
  else
  {
    sub_10001CAC8(a2);
    sub_1000141C0();
    return 0;
  }
}

BOOL sub_10002CD78(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;
  unint64_t v3;
  uint64_t v4;

  result = 1;
  if (*(_UNKNOWN **)(a1 + 112) == &unk_100071750)
  {
    v3 = *(_QWORD *)(a1 + 120);
    if (!(v3 >> 31))
    {
      v4 = *(unsigned int *)(a2 + 20);
      if ((v4 & 0x80000000) == 0 && v3 == v4)
        return 0;
    }
  }
  return result;
}

uint64_t sub_10002CDB8()
{
  mach_port_t v0;
  uint64_t result;

  qword_100072478 = (uint64_t)sub_10002CE8C((uint64_t)&unk_1000715B8, 0, 0, 0, 0, 0, (uint64_t)&qword_1000729A0);
  *(_DWORD *)(qword_100072478 + 1016) |= 0x2000u;
  byte_100072480 = os_variant_is_darwinos("com.apple.xpc.launchd");
  sub_10004454C(3, (uint64_t)sub_10002D4E4);
  sub_10004454C(5, (uint64_t)sub_10002D878);
  sub_10004454C(7, (uint64_t)sub_10002D9E4);
  sub_1000446D0((uint64_t)sub_100049EF4, 0x830uLL);
  sub_1000446D0((uint64_t)sub_10004A150, 0x2CuLL);
  v0 = mach_host_self();
  result = host_set_special_port(v0, 22, dword_100072A00);
  if ((_DWORD)result)
    return sub_10004DFC4();
  return result;
}

_QWORD *sub_10002CE8C(uint64_t a1, uint64_t a2, const char *a3, const char *a4, int a5, uint64_t a6, uint64_t a7)
{
  size_t v15;
  size_t v16;
  size_t v17;
  _QWORD *v18;
  uint64_t *v19;
  __int128 v20;
  uint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  __int128 *v27;
  BOOL v28;
  BOOL v29;
  BOOL v30;
  uint64_t v31;
  const char *v32;
  int v33;
  _QWORD *v34;
  uint64_t v35;
  _DWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  xpc_object_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v57;
  _OWORD buffer[2];
  uint64_t v59;
  mach_port_name_t tn[4];
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  _OWORD v72[4];
  char v73[8];
  _QWORD v74[2];
  char __str[16];
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;

  if ((_QWORD *)a1 == qword_100071750 && a2 == 0)
    sub_10003E208("Can't create PID domain for PID 0");
  v15 = strlen(*(const char **)(a1 + 120));
  v16 = v15;
  v81 = 0u;
  v82 = 0u;
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  *(_OWORD *)__str = 0u;
  v76 = 0u;
  *(_QWORD *)v73 = 0;
  v74[0] = 0;
  *(_QWORD *)((char *)v74 + 5) = 0;
  if (a3)
  {
    snprintf(__str, 0x80uLL, ".%s", a3);
    v17 = v16 + strlen(a3) + 22;
LABEL_8:
    snprintf(v73, 0x15uLL, ".%lu", a2);
    goto LABEL_9;
  }
  v17 = v15 + 21;
  if ((_UNKNOWN *)a1 != &unk_1000715B8)
    goto LABEL_8;
LABEL_9:
  v18 = sub_100019AC4(v17);
  v18[14] = a1;
  v18[15] = a2;
  v19 = v18 + 15;
  v18[29] = a6;
  snprintf((char *)v18 + 1024, v17, "%s%s%s", *(const char **)(a1 + 120), __str, v73);
  v20 = *(_OWORD *)a7;
  *(_OWORD *)(v18 + 37) = *(_OWORD *)(a7 + 16);
  *(_OWORD *)(v18 + 35) = v20;
  if (*(_QWORD *)(v18[14] + 88) && sub_10002E19C((_QWORD *)v18[14], *v19))
    sub_10003E208("refusing to add a duplicate domain: type=%s handle=%lu", *(const char **)(v18[14] + 112), v18[15]);
  v21 = (uint64_t *)(v18[14] + 8 * (sub_1000158C8(v19, 8) % 0xBuLL));
  v22 = *v21;
  v18[4] = *v21;
  if (v22)
    *(_QWORD *)(v22 + 40) = v18 + 4;
  *v21 = (uint64_t)v18;
  v18[5] = v21;
  os_map_str_init(v18 + 65, 0, 1);
  if (a5)
    *((_DWORD *)v18 + 46) = a5;
  v23 = sub_10001FB38(*(_DWORD *)(a7 + 20));
  if (v23)
  {
    v24 = *(_QWORD *)(v23 + 248);
  }
  else
  {
    v25 = sub_1000391E0(a7);
    if ((_DWORD)v25 == -1 || (v26 = sub_100039324(v25), v26 == -3) || (v24 = sub_10002E19C(qword_100071640, v26)) == 0)
    {
      if ((v27 = sub_100044524(), v27 != (__int128 *)a7)
        && (!v27
         || (*(_QWORD *)v27 == *(_QWORD *)a7 ? (v28 = *((_QWORD *)v27 + 1) == *(_QWORD *)(a7 + 8)) : (v28 = 0),
             v28 ? (v29 = *((_QWORD *)v27 + 2) == *(_QWORD *)(a7 + 16)) : (v29 = 0),
             v29 ? (v30 = *((_QWORD *)v27 + 3) == *(_QWORD *)(a7 + 24)) : (v30 = 0),
             !v30))
        || (v24 = sub_100044530()) == 0
        || *(_QWORD **)(v24 + 112) != qword_100071640)
      {
        v24 = sub_10002E19C(qword_100071640, *(unsigned int *)(a7 + 4));
      }
    }
  }
  if (v24)
    v31 = v24;
  else
    v31 = a6;
  memset(v72, 0, sizeof(v72));
  v32 = sub_10003FBC0(a7, (char *)v72);
  v18[39] = sub_10001544C(v32);
  if (a4)
  {
    v18[121] = sub_10001544C(a4);
    if ((_QWORD *)a1 == qword_100071640)
      goto LABEL_49;
  }
  else
  {
    if ((_QWORD *)a1 == qword_100071640)
    {
      v18[121] = sub_10001544C("PostLogOutSync");
LABEL_49:
      v33 = a2;
LABEL_50:
      *((_DWORD *)v18 + 14) = v33;
      *((_BYTE *)v18 + 104) |= 1u;
      goto LABEL_51;
    }
    v18[121] = 0;
  }
  if ((_QWORD *)a1 == qword_100071750)
  {
    v33 = *(_DWORD *)(a7 + 4);
    if (v33 || *(_UNKNOWN **)(v31 + 112) != &unk_1000715B8)
      goto LABEL_50;
  }
LABEL_51:
  *((_DWORD *)v18 + 15) = -101;
  v34 = (_QWORD *)v18[14];
  if (v34 != (_QWORD *)&unk_1000715B8)
  {
    if (v34 == qword_100071640)
    {
      v36 = v18 + 7;
    }
    else if (v34 == qword_100071750)
    {
      v36 = (_DWORD *)(v31 + 60);
    }
    else
    {
      v35 = v18[29];
      if (!v35)
        sub_10004D738();
      v36 = (_DWORD *)(v35 + 60);
    }
    *((_DWORD *)v18 + 15) = *v36;
  }
  *((_DWORD *)v18 + 16) = -1;
  sub_10002DF80((uint64_t)v18);
  sub_100028F64((uint64_t)v18);
  if (sub_10003E3D8((uint64_t)v18) || (_UNKNOWN *)v18[14] == &unk_1000715B8)
  {
    sub_10002DDF0((uint64_t)v18, v37, v38, v39, v40, v41, v42, v43, v57);
    *((_DWORD *)v18 + 254) |= 0x40u;
  }
  if ((_UNKNOWN *)a1 == &unk_1000715B8)
  {
    if (a6)
      sub_10004D738();
  }
  else
  {
    if ((_QWORD *)a1 == qword_100071750)
    {
      sub_10002DDF0((uint64_t)v18, v37, v38, v39, v40, v41, v42, v43, v57);
      v70 = 0u;
      v71 = 0u;
      v68 = 0u;
      v69 = 0u;
      v66 = 0u;
      v67 = 0u;
      v64 = 0u;
      v65 = 0u;
      v62 = 0u;
      v63 = 0u;
      *(_OWORD *)tn = 0u;
      v61 = 0u;
      v44 = sub_10003FB84(a2, tn);
      if (v44 != 3)
      {
        if (v44)
          _os_assumes_log_ctx(sub_100028C00, v18);
        else
          v18[16] = *((_QWORD *)&v69 + 1);
      }
      v59 = 0;
      memset(buffer, 0, sizeof(buffer));
      v45 = sub_10003FCAC(a2, buffer);
      if (v45 != 3)
      {
        if (v45)
          _os_assumes_log_ctx(sub_100028C00, v18);
        else
          *(_OWORD *)(v18 + 125) = buffer[0];
      }
    }
    v46 = *(_QWORD *)(a6 + 320);
    v18[2] = v46;
    if (v46)
      *(_QWORD *)(v46 + 24) = v18 + 2;
    *(_QWORD *)(a6 + 320) = v18;
    v18[3] = a6 + 320;
    sub_100019580(v18);
    sub_100028F64(a6);
    sub_10001962C(v18);
  }
  tn[0] = -1;
  v47 = v18[14];
  if ((_UNKNOWN *)v47 == &unk_1000715B8)
  {
    v48 = sub_10000D880(0x33u, 6u, (mach_port_context_t)v18);
  }
  else
  {
    if ((_QWORD *)v47 != qword_100071750)
      goto LABEL_80;
    v48 = *((unsigned int *)v18 + 46);
    if (!(_DWORD)v48)
    {
      task_name_for_pid(mach_task_self_, *(_DWORD *)v19, tn);
      v48 = tn[0];
    }
  }
  sub_100038BEC((uint64_t)v18, v48, v38, v39, v40, v41, v42, v43, v57);
  v47 = v18[14];
LABEL_80:
  if ((_UNKNOWN *)v47 == &unk_1000715B8)
  {
    sub_10002FDC4(v18, 0, dword_100072A00, 4, v40, v41, v42, v43);
LABEL_87:
    v50 = xpc_retain((xpc_object_t)qword_100072A08);
LABEL_89:
    v18[17] = v50;
    goto LABEL_90;
  }
  if ((*(_BYTE *)(v47 + 128) & 1) != 0)
  {
    v51 = sub_100015D78((uint64_t)(v18 + 128), (mach_port_context_t)v18);
    sub_10004478C(v51, v18);
    sub_10002FDC4(v18, 0, v51, 4, v52, v53, v54, v55);
    v50 = (xpc_object_t)xpc_mach_send_create_with_disposition(v51, 17);
    goto LABEL_89;
  }
  if ((_QWORD *)v47 == qword_100071750)
  {
    if (!v31)
      sub_10003E208("user cannot create its own domain");
    v49 = sub_10002FDC4(v18, 0, *(_DWORD *)(*(_QWORD *)(v31 + 88) + 16), 4, v40, v41, v42, v43);
    if (v49)
      sub_10004DFEC(v49);
    goto LABEL_87;
  }
LABEL_90:
  sub_100028C34((uint64_t)v18, 5, "created", v39, v40, v41, v42, v43, v57);
  return v18;
}

uint64_t sub_10002D4E4(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  uint64_t result;
  unsigned int v11;

  v11 = 0;
  v7 = sub_10002E22C(a3, a2 != 817, (int *)&v11);
  if (!v7)
    return v11;
  v8 = v7;
  v9 = sub_100044524();
  result = 45;
  switch(a2)
  {
    case 800:
      result = sub_100030B00(v8, (uint64_t)v9, a3, a4);
      break;
    case 801:
      result = sub_100030CF4((_QWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 802:
      result = sub_100031070(v8, (uint64_t)v9, a3, a4);
      break;
    case 803:
      result = sub_10003126C(v8, (uint64_t)v9, a3, a4);
      break;
    case 804:
      result = sub_100031318(v8, (uint64_t)v9, a3, a4);
      break;
    case 805:
      result = sub_100031684(v8, (uint64_t)v9, a3, a4);
      break;
    case 806:
      result = sub_100031998(v8, a3, a4);
      break;
    case 807:
      result = sub_1000319FC(v8, a3, a4);
      break;
    case 808:
      result = sub_100031AAC(v8, (uint64_t)v9, a3, a4);
      break;
    case 809:
      result = sub_100031C48(v8, (uint64_t)v9, a3, a4);
      break;
    case 811:
      result = sub_100031DE4(v8, (uint64_t)v9, a3, a4);
      break;
    case 812:
      result = sub_100031FA8(v8, (uint64_t)v9, a3, a4);
      break;
    case 813:
      result = sub_1000321D8((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 814:
      result = sub_100032308((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 815:
      result = sub_100032650((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 816:
      result = sub_1000324C8((_DWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 817:
    case 818:
    case 823:
    case 824:
    case 827:
    case 836:
    case 845:
      return result;
    case 819:
      result = sub_100032840(v8, (uint64_t)v9, a3, a4);
      break;
    case 820:
      result = sub_10003294C(v8, (uint64_t)v9, a3, a4);
      break;
    case 821:
      result = sub_100032A44((void **)v8, (uint64_t)v9, a3, a4);
      break;
    case 822:
    case 826:
      result = 142;
      break;
    case 825:
      result = sub_100032E60(v8, (uint64_t)v9, a3, a4);
      break;
    case 828:
      result = sub_100033084(v8, (uint64_t)v9, a3, a4);
      break;
    case 829:
      if (*(_UNKNOWN **)(v8 + 112) == &unk_1000715B8)
        result = sub_10001C8A8(a3, a4);
      else
        result = 125;
      break;
    case 830:
      result = sub_10001C9E4(a3, a4);
      break;
    case 831:
      result = sub_100033148((_QWORD **)v8, v9, a3);
      break;
    case 832:
      result = sub_100033270((void **)v8, (uint64_t)v9, a3);
      break;
    case 833:
      result = sub_1000334D8(v8, (uint64_t)v9, a3, a4);
      break;
    case 834:
      result = sub_1000336F4(v8, (uint64_t)v9, a3, a4);
      break;
    case 835:
      result = sub_1000337EC(v8, (uint64_t)v9, a3, a4);
      break;
    case 837:
      result = sub_1000339DC(v8, (uint64_t)v9, a3, a4);
      break;
    case 838:
      result = sub_100033ABC((uint64_t)v9, a3, a4);
      break;
    case 839:
      result = sub_100033EAC(v8, (uint64_t)v9, a3, a4);
      break;
    case 840:
      result = sub_100034024(v8, (uint64_t)v9, a3, a4);
      break;
    case 841:
      result = sub_100033B9C(v8, (uint64_t)v9, a3, a4);
      break;
    case 842:
      result = sub_100033CA0(v8, (uint64_t)v9, a3, a4);
      break;
    case 843:
      result = sub_100033DA4(v8, (uint64_t)v9, a3);
      break;
    case 844:
      result = sub_100034118((_QWORD *)v8, (uint64_t)v9, a3, a4);
      break;
    case 846:
      result = sub_1000341C4(v8, (uint64_t)v9, a3, a4);
      break;
    case 847:
      result = sub_10003426C(v8, (uint64_t)v9, a3);
      break;
    default:
      result = 33;
      break;
  }
  return result;
}

uint64_t sub_10002D878(uint64_t a1, int a2, void *a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  int right;
  __int128 *v12;
  unsigned int v13;

  v13 = 0;
  v7 = sub_10002E22C(a3, 1, (int *)&v13);
  if (!v7)
    return v13;
  v8 = v7;
  if ((*(_BYTE *)(v7 + 1016) & 3) != 0)
    return 124;
  if (*(_QWORD **)(v7 + 112) == qword_100071750)
    return 45;
  if (*(_WORD *)(v7 + 204))
  {
    v10 = *(_QWORD *)(v7 + 136);
    if (v10)
      right = xpc_mach_send_get_right(v10);
    else
      right = 0;
    sub_10003465C(v8, right, a3, 1);
    return 0;
  }
  else
  {
    v12 = sub_100044524();
    result = 126;
    switch(a2)
    {
      case 200:
      case 201:
      case 202:
      case 205:
        return result;
      case 203:
        return sub_1000371A8(v8, a3, a4);
      case 204:
        return sub_100037228(v8, (uint64_t)v12, a3, a4);
      case 206:
        return sub_100037318(v8, (uint64_t)v12, a3, a4);
      case 207:
        return sub_100037408(v8, (uint64_t)v12, a3, a4);
      case 208:
        return 45;
      case 209:
        if (xpc_dictionary_expects_reply(a3))
        {
          sub_10004453C();
          return 45;
        }
        result = 22;
        break;
      case 211:
        return sub_100037728(a3, a4);
      default:
        return 33;
    }
  }
  return result;
}

uint64_t sub_10002D9E4(uint64_t a1, int a2, void *a3, _QWORD *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;
  __int128 *v16;
  uint64_t v17;
  xpc_object_t value;
  void *v19;
  size_t v20;
  uint64_t v21;
  xpc_object_t v22;
  xpc_object_t reply;
  xpc_object_t v24;
  char *string_ptr;
  uint64_t v26;
  xpc_object_t v27;
  uint64_t v28;
  uint64_t v29;
  xpc_object_t v30;
  xpc_object_t v31;
  xpc_object_t v32;
  char v33;
  unsigned int v34;
  uint64_t v35[2];
  xpc_object_t object;
  xpc_object_t v37;

  v34 = 0;
  v7 = sub_10002E22C(a3, 1, (int *)&v34);
  if (!v7)
    return v34;
  v13 = v7;
  if ((*(_BYTE *)(v7 + 1016) & 3) != 0)
    return 124;
  v15 = *(_QWORD *)(v7 + 112);
  if ((_UNKNOWN *)v15 != &unk_1000715B8 && (*(_BYTE *)(v15 + 128) & 2) == 0)
  {
    sub_100028C34(v7, 3, "The launch_msg(3) API may only be used on the system or user domains.", v8, v9, v10, v11, v12, v33);
    return 125;
  }
  if (xpc_dictionary_get_BOOL(a3, "justdoit"))
    *(_DWORD *)(v13 + 1016) |= 0x100u;
  v16 = sub_100044524();
  v17 = (uint64_t)v16;
  if (a2 == 101)
  {
    v35[0] = v13;
    v20 = sub_1000352F4(v35, *((_DWORD *)v16 + 5), 0);
    if (!v20)
    {
      result = 113;
      goto LABEL_37;
    }
    v21 = v20;
    result = (uint64_t)sub_100020DB0(v20);
    if (result)
    {
      v22 = (xpc_object_t)result;
      sub_100038930(v13, v21, (void *)result, 0);
      reply = xpc_dictionary_create_reply(a3);
      v24 = reply;
LABEL_19:
      xpc_dictionary_set_value(reply, "response", v22);
      xpc_release(v22);
      result = 0;
      *a4 = v24;
    }
  }
  else
  {
    if (a2 != 100)
    {
      result = 33;
      goto LABEL_37;
    }
    value = xpc_dictionary_get_value(a3, "request");
    if (!value)
      goto LABEL_15;
    v19 = value;
    v37 = 0;
    if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_string)
    {
      if (xpc_get_type(v19) == (xpc_type_t)&_xpc_type_dictionary)
      {
        v35[0] = v13;
        v35[1] = v17;
        object = 0;
        xpc_dictionary_apply_f(v19);
        v26 = *(_QWORD *)(v13 + 992);
        if (v26)
        {
          if (object)
          {
            xpc_release(object);
            v26 = *(_QWORD *)(v13 + 992);
          }
          *(_QWORD *)(v13 + 992) = 0;
          v27 = xpc_dictionary_create_reply(a3);
          xpc_dictionary_set_uint64(v27, "response", 0);
          v28 = *(_QWORD *)(v26 + 272);
          if (v28)
            sub_10004D95C(v28);
          *(_QWORD *)(v26 + 272) = v27;
        }
        else
        {
          v31 = xpc_dictionary_create_reply(a3);
          v32 = object;
          if (!object)
          {
            v32 = xpc_uint64_create(0);
            object = v32;
          }
          xpc_dictionary_set_value(v31, "response", v32);
          xpc_release(object);
          *a4 = v31;
        }
        result = 0;
        goto LABEL_37;
      }
LABEL_15:
      result = 22;
      goto LABEL_37;
    }
    string_ptr = (char *)xpc_string_get_string_ptr(v19);
    result = sub_1000377F0((_DWORD *)v13, v17, string_ptr, 0, &v37);
    if ((_DWORD)result == 36)
    {
      v29 = *(_QWORD *)(v13 + 992);
      if (v29)
      {
        *(_QWORD *)(v13 + 992) = 0;
        v30 = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_uint64(v30, "response", 0);
        result = *(_QWORD *)(v29 + 272);
        if (result)
          sub_10004D95C(result);
        *(_QWORD *)(v29 + 272) = v30;
      }
      else
      {
        result = 36;
      }
      goto LABEL_37;
    }
    if (!(_DWORD)result)
    {
      reply = xpc_dictionary_create_reply(a3);
      v24 = reply;
      v22 = v37;
      goto LABEL_19;
    }
  }
LABEL_37:
  *(_DWORD *)(v13 + 1016) &= ~0x100u;
  return result;
}

void sub_10002DCD0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  NSObject *v15;
  dispatch_time_t v16;
  char v17;
  char v18;
  _QWORD v19[5];
  _QWORD handler[6];

  if (sub_100039000())
  {
    if (sub_10003E3D8(a1))
    {
      sub_100028C34(a1, 5, "going into initial on-demand mode for a multiuser device", v2, v3, v4, v5, v6, v17);
      sub_10002DDF0(a1, v7, v8, v9, v10, v11, v12, v13, v18);
      v14 = sub_1000146E4();
      v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v14);
      v16 = dispatch_time(0, 45000000000);
      dispatch_source_set_timer(v15, v16, 0xFFFFFFFFFFFFFFFFLL, 0);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 0x40000000;
      handler[2] = sub_10002DE28;
      handler[3] = &unk_10006CA48;
      handler[4] = a1;
      handler[5] = v15;
      dispatch_source_set_event_handler(v15, handler);
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 0x40000000;
      v19[2] = sub_10002DE80;
      v19[3] = &unk_10006CA68;
      v19[4] = v15;
      dispatch_source_set_mandatory_cancel_handler(v15, v19);
      dispatch_activate(v15);
      *(_QWORD *)(a1 + 160) = v15;
    }
  }
}

void sub_10002DDF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v9;

  v9 = *(_DWORD *)(a1 + 192);
  *(_DWORD *)(a1 + 192) = v9 + 1;
  if (!v9 && *(_QWORD **)(a1 + 112) != qword_100071750)
    sub_100028C34(a1, 5, "entering ondemand mode", a4, a5, a6, a7, a8, a9);
}

void sub_10002DE28(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  char v17;

  sub_100028C34(*(_QWORD *)(a1 + 32), 4, "timed out initial on-demand mode for a multiuser device", a4, a5, a6, a7, a8, v17);
  sub_1000298A0(*(_QWORD *)(a1 + 32), v9, v10, v11, v12, v13, v14, v15);
  v16 = *(NSObject **)(a1 + 40);
  if (v16 != *(NSObject **)(*(_QWORD *)(a1 + 32) + 160))
    sub_10004D738();
  dispatch_source_cancel(v16);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 160) = 0;
}

void sub_10002DE80(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void sub_10002DE88()
{
  _QWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;

  if (qword_100072A30)
  {
    v0 = (_QWORD *)qword_100072478;
    *(_DWORD *)(qword_100072478 + 1016) |= 4u;
    v0[119] = sub_100047FC4();
    sub_10002DF80((uint64_t)v0);
    sub_10003E5F0((uint64_t)v0);
    sub_10002DCD0((uint64_t)v0);
    if (v0[121])
      sub_10004D738();
    v0[121] = sub_10001544C("System");
    sub_100029A88(v0, (uint64_t)&qword_1000729A0, 0, v1, v2, v3, v4, v5);
    if (signal(15, (void (__cdecl *)(int))1) == (void (__cdecl *)(int))-1)
      sub_10004E004((uint64_t)v0);
    v6 = sub_1000146E4();
    qword_100072488 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, 0xFuLL, 0, v6);
    dispatch_set_context((dispatch_object_t)qword_100072488, v0);
    dispatch_source_set_event_handler_f((dispatch_source_t)qword_100072488, (dispatch_function_t)sub_10002E050);
    dispatch_activate((dispatch_object_t)qword_100072488);
  }
}

uint64_t sub_10002DF80(uint64_t result)
{
  _DWORD *v1;
  _QWORD *v2;
  int v3;
  int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;

  v1 = (_DWORD *)result;
  v2 = *(_QWORD **)(result + 112);
  if (v2 == (_QWORD *)&unk_1000715B8)
  {
    if ((*(_BYTE *)(result + 1016) & 4) == 0)
      return result;
    result = sub_100039000();
    if (!(_DWORD)result)
      return result;
    v3 = v1[15];
    if (v3 == -101)
      v3 = -1;
    v6 = v3;
    v7 = 0xFFFFFFFFLL;
LABEL_15:
    result = sub_100039090(&v6);
    v1[16] = result;
    v1[254] |= 0x800u;
    return result;
  }
  if (v2 == qword_100071640)
  {
    result = sub_100039000();
    if (!(_DWORD)result)
      return result;
    v5 = v1[14];
    v4 = v1[15];
    if (v4 == -101)
      v4 = -1;
    v6 = v4;
    v7 = v5;
    goto LABEL_15;
  }
  if (v2 == qword_100071750)
  {
    result = sub_100039000();
    if ((_DWORD)result)
    {
      result = sub_1000391E0((uint64_t)(v1 + 70));
      v1[16] = result;
    }
  }
  return result;
}

void sub_10002E050(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  sub_100028C34(a1, 196611, "System shutdown initiated by kernel - launchd got a SIGTERM", a4, a5, a6, a7, a8, v16);
  sub_1000291CC(a1, v9, v10, v11, v12, v13, v14, v15);
}

_QWORD *sub_10002E080(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10002E094(qword_100072478, a1, a2, a4, a5, a6, a7, a8);
}

_QWORD *sub_10002E094(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v11 = 0;
  while (1)
  {
    v12 = *(_QWORD **)(a1 + 8 * v11 + 704);
    if (v12)
      break;
LABEL_8:
    if (++v11 == 31)
    {
      if ((_DWORD)a3)
      {
        v14 = 0;
        while (1)
        {
          v15 = *(_QWORD *)(a1 + 8 * v14 + 336);
          if (v15)
            break;
LABEL_19:
          if (++v14 == 23)
            goto LABEL_20;
        }
        while (1)
        {
          v12 = *(_QWORD **)(v15 + 184);
          if (v12)
            break;
LABEL_18:
          v15 = *(_QWORD *)(v15 + 120);
          if (!v15)
            goto LABEL_19;
        }
        while (1)
        {
          v16 = v12[9] ? v12[9] : (uint64_t)v12;
          if (sub_1000457E0(v16, 2, a3, a4, a5, a6, a7, a8) == (_DWORD)a2)
            break;
          v12 = (_QWORD *)v12[2];
          if (!v12)
            goto LABEL_18;
        }
      }
      else
      {
LABEL_20:
        v17 = *(_QWORD *)(a1 + 320);
        if (v17)
        {
          do
          {
            v12 = (_QWORD *)sub_10002E094(v17, a2, a3);
            if (v12)
              break;
            v17 = *(_QWORD *)(v17 + 16);
          }
          while (v17);
        }
        else
        {
          return 0;
        }
      }
      return v12;
    }
  }
  while (1)
  {
    v13 = v12[9] ? v12[9] : (uint64_t)v12;
    if (sub_1000457E0(v13, 2, a3, a4, a5, a6, a7, a8) == (_DWORD)a2)
      return v12;
    v12 = (_QWORD *)v12[4];
    if (!v12)
      goto LABEL_8;
  }
}

uint64_t sub_10002E190()
{
  return qword_100072478;
}

uint64_t sub_10002E19C(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;

  v3 = a2;
  if (a1 == (_QWORD *)&unk_1000715B8)
    return qword_100072478;
  for (result = a1[sub_1000158C8(&v3, 8) % 0xBuLL]; result; result = *(_QWORD *)(result + 32))
  {
    if (*(_QWORD *)(result + 120) == v3)
      break;
  }
  return result;
}

uint64_t sub_10002E22C(void *a1, char a2, int *a3)
{
  int v6;
  int v7;
  uint64_t result;
  unint64_t v9;
  _QWORD *v10;
  _OWORD v11[2];
  int v12;
  uint64_t v13;
  _QWORD *v14;

  memset(v11, 0, sizeof(v11));
  xpc_dictionary_get_audit_token(a1, v11);
  v13 = 0;
  v14 = 0;
  v6 = sub_100036A5C(a1, &v14, (uint64_t *)&v13);
  v12 = v6;
  if (v6)
  {
    v7 = v6;
    result = 0;
LABEL_3:
    *a3 = v7;
    return result;
  }
  v9 = v13;
  v10 = v14;
  result = sub_100036B74(v14, v13, (uint64_t)v11);
  if (!result)
  {
    if ((a2 & 1) != 0)
    {
      result = (uint64_t)sub_100036BF0(v10, v9, 0, 0, (uint64_t)v11, &v12);
      v7 = v12;
    }
    else
    {
      sub_100040F68(3, "Could not find domain from request: type=%s handle=%lu", (const char *)v10[14], v9);
      result = 0;
      v7 = 112;
    }
    goto LABEL_3;
  }
  return result;
}

BOOL sub_10002E300(uint64_t a1, void *a2)
{
  int v2;
  uint64_t v5;
  int right;

  v2 = *(unsigned __int16 *)(a1 + 204);
  if (*(_WORD *)(a1 + 204))
  {
    v5 = *(_QWORD *)(a1 + 136);
    if (v5)
      right = xpc_mach_send_get_right(v5);
    else
      right = 0;
    sub_10003465C(a1, right, a2, 1);
  }
  return v2 == 0;
}

uint64_t sub_10002E360(uint64_t a1)
{
  return *(_QWORD *)(a1 + 112);
}

uint64_t sub_10002E368(uint64_t a1)
{
  return *(_QWORD *)(a1 + 120);
}

uint64_t sub_10002E370(uint64_t a1)
{
  uint64_t result;
  void *v3;

  result = *(_QWORD *)(a1 + 960);
  if (!result)
  {
    v3 = sub_10001389C(0x18uLL);
    *(_QWORD *)(a1 + 960) = v3;
    os_map_str_init(v3, 0, 1);
    return *(_QWORD *)(a1 + 960);
  }
  return result;
}

BOOL sub_10002E3B0(uint64_t a1, char *__s1)
{
  void *v2;
  const char *v3;

  v2 = *(void **)(a1 + 112);
  if (__s1)
  {
    if (v2 == &unk_1000715B8)
    {
      v3 = "System";
    }
    else
    {
      v3 = *(const char **)(a1 + 968);
      if (!v3)
        sub_10003E208("non-system session had no name");
    }
    return sub_1000157A8(__s1, v3);
  }
  else if (v2 == &unk_1000715B8)
  {
    return *(_QWORD *)(a1 + 968) == 0;
  }
  else
  {
    return sub_10003E3D8(a1);
  }
}

uint64_t sub_10002E41C(uint64_t a1, char *__s, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v12;
  xpc_object_t value;
  void *v14;

  if ((a3 - 1) >= 2)
    sub_10004D738();
  if (!*(_QWORD *)(a1 + 952))
    return 125;
  if (strchr(__s, 60))
  {
    sub_100028C34(a1, 4, "refusing to persist enabled/disabled state for '%s' as it contains illegal XML character '<'", v6, v7, v8, v9, v10, (char)__s);
    return 140;
  }
  else
  {
    v12 = "Disabling";
    if (a3 == 2)
      v12 = "Enabling";
    sub_100028C34(a1, 5, "%s service %s", v6, v7, v8, v9, v10, (char)v12);
    value = xpc_dictionary_get_value(*(xpc_object_t *)(a1 + 952), __s);
    if (!value
      || (v14 = value, xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL)
      || (a3 == 1) != xpc_BOOL_get_value(v14))
    {
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 952), __s, a3 == 1);
      xpc_dictionary_set_BOOL(*(xpc_object_t *)(a1 + 952), "_dirty", 1);
    }
    return 0;
  }
}

xpc_object_t sub_10002E544(uint64_t a1, const char *a2)
{
  xpc_object_t result;
  void *v3;

  result = *(xpc_object_t *)(a1 + 952);
  if (result)
  {
    result = xpc_dictionary_get_value(result, a2);
    if (result)
    {
      v3 = result;
      if (xpc_get_type(result) != (xpc_type_t)&_xpc_type_dictionary
        || (result = xpc_dictionary_get_value(v3, "Disabled"), (v3 = result) != 0))
      {
        if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_BOOL)
          return v3;
        else
          return 0;
      }
    }
  }
  return result;
}

__n128 sub_10002E5B4(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a1 + 280);
  v3 = *(_OWORD *)(a1 + 296);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v3;
  return result;
}

uint64_t sub_10002E5C8(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  _QWORD v6[2];
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  if (*(_QWORD *)(a2 + 312))
  {
    if (sub_1000124FC(*(_QWORD *)(a2 + 312)))
      _os_assumes_log_ctx(sub_10001F174, a2);
    v4 = *(_QWORD *)(a2 + 312);
    return sub_100011400(v4);
  }
  if (a3)
    goto LABEL_6;
  if (*(_UNKNOWN **)(a1 + 112) != &unk_100071750)
  {
    if (*(_QWORD *)(a2 + 304))
    {
      v9 = 0;
      v7 = 0u;
      v8 = 0u;
      v6[0] = 0;
      v6[1] = a2 + 1392;
      *(_QWORD *)&v7 = sub_1000214CC(a2);
      DWORD2(v7) = *(_DWORD *)(a2 + 896);
      v8 = *(_OWORD *)(a2 + 992);
      v4 = sub_10001CCA0(*(const void **)(a2 + 304), v6);
      goto LABEL_10;
    }
LABEL_6:
    v4 = (uint64_t)sub_10002E6AC(a2, 0);
LABEL_10:
    *(_QWORD *)(a2 + 312) = v4;
    return sub_100011400(v4);
  }
  return *(_QWORD *)(a1 + 1000);
}

_BYTE *sub_10002E6AC(uint64_t a1, unsigned int a2)
{
  _QWORD v4[2];
  __int128 v5;
  __int128 v6;
  uint64_t v7;

  v7 = 0;
  v5 = 0u;
  v6 = 0u;
  v4[0] = a2;
  v4[1] = a1 + 1392;
  *(_QWORD *)&v5 = sub_1000214CC(a1);
  DWORD2(v5) = *(_DWORD *)(a1 + 896);
  v6 = *(_OWORD *)(a1 + 992);
  LOBYTE(v7) = *(uint64_t *)(a1 + 1376) < 0;
  return sub_10001CC44((uint64_t)v4);
}

uint64_t sub_10002E718(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _BYTE *v5;
  char *v6;
  char *v7;
  size_t v8;

  if (*(_QWORD *)(a2 + 320))
  {
    if (sub_1000124FC(*(_QWORD *)(a2 + 320)) != 1)
      _os_assumes_log_ctx(sub_10001F174, a2);
    return sub_100011400(*(_QWORD *)(a2 + 320));
  }
  else if (*(_UNKNOWN **)(a1 + 112) == &unk_100071750)
  {
    return *(_QWORD *)(a1 + 1008);
  }
  else
  {
    v5 = sub_10002E6AC(a2, 1u);
    *(_QWORD *)(a2 + 320) = v5;
    v3 = sub_100011400((uint64_t)v5);
    v6 = sub_1000213F0(a2);
    if (v6)
    {
      v7 = v6;
      v8 = strlen(v6);
      coalition_info_set_name(v3, v7, v8);
    }
  }
  return v3;
}

const char *sub_10002E7F0(uint64_t a1, char *a2)
{
  const char *result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*(_QWORD **)(a1 + 112) != qword_100071750)
    return 0;
  v3 = *(_QWORD *)(a1 + 232);
  if (*(_QWORD *)(v3 + 976))
    v4 = *(_QWORD *)(v3 + 976);
  else
    v4 = *(_QWORD *)(a1 + 232);
  result = (const char *)sub_10002E860(v4, a2);
  if (result)
  {
    v5 = sub_1000463E0((uint64_t)result);
    result = (const char *)sub_100021494(v5);
    if (result)
    {
      if (!strcmp(result, "com.apple.keyboard-service"))
        return (const char *)v5;
      else
        return 0;
    }
  }
  return result;
}

uint64_t sub_10002E860(uint64_t a1, char *a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 8 * (sub_1000158FC(a2) % 0x1FuLL) + 704); i; i = *(_QWORD *)(i + 32))
  {
    if ((*(_BYTE *)(i + 88) & 0x40) == 0 && sub_1000157A8((char *)(i + 168), a2))
      break;
  }
  return i;
}

uint64_t sub_10002E900(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t i;

  for (i = *(_QWORD *)(a2 + 176); i; i = *(_QWORD *)(i + 16))
  {
    if ((*(_BYTE *)(i + 88) & 0x40) == 0 && sub_1000157A8((char *)(i + 168), a3))
      break;
  }
  return i;
}

uint64_t sub_10002E948(size_t a1, _QWORD *a2, const char *a3)
{
  uint64_t v6;
  uint64_t v7;

  v6 = sub_10002E900(a1, (uint64_t)a2, a3);
  if (!v6)
  {
    sub_100045918((unint64_t)a2, a3, (unint64_t)sub_10002AB90, (unint64_t)a2);
    v6 = v7;
    *(_BYTE *)(v7 + 88) |= 8u;
    sub_10002ADB4(a1, a2, v7, 16);
  }
  return v6;
}

xpc_object_t sub_10002E9C0(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  unint64_t v9;
  xpc_object_t result;
  xpc_object_t v11;
  _DWORD *v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v9 = *(_QWORD *)(a1 + 80) + a5;
  result = xpc_array_create(0, 0);
  if (v9 >> 62)
  {
    __break(1u);
  }
  else
  {
    v11 = result;
    result = sub_10001389C(4 * v9);
    v12 = result;
    v13 = *(uint64_t **)(a1 + 88);
    if (v13)
    {
      v14 = 0;
      do
      {
        result = (xpc_object_t)xpc_array_set_mach_send(v11, -1, *((unsigned int *)v13 + 4));
        v15 = v14 + 1;
        v12[v14] = *((_DWORD *)v13 + 5);
        v13 = (uint64_t *)*v13;
        ++v14;
      }
      while (v13);
    }
    else
    {
      v15 = 0;
    }
    *a2 = v11;
    *a3 = v12;
    *a4 = v15;
  }
  return result;
}

uint64_t sub_10002EA78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return sub_10002C0E4(a1, a2, a3, a4, 0, 0);
}

uint64_t sub_10002EA84(_DWORD *a1, void *a2, char *a3, uint64_t a4, unint64_t a5, _DWORD *a6)
{
  uint64_t result;
  _QWORD v8[7];
  int v9;

  v9 = 0;
  v8[0] = sub_10002A27C;
  v8[1] = sub_10002A664;
  v8[2] = sub_10002A7A8;
  v8[3] = sub_10002A940;
  v8[4] = sub_10002A998;
  v8[5] = sub_10002AA84;
  v8[6] = a1;
  result = sub_100005F4C(a1, a2, a3, a4, (uint64_t)v8, a5, &v9);
  if (v9)
  {
    if (result)
      sub_10004D738();
  }
  else if (!result)
  {
    sub_10004D738();
  }
  *a6 = v9;
  return result;
}

uint64_t sub_10002EB18()
{
  return byte_100072480;
}

const char *sub_10002EB24(uint64_t a1)
{
  uint64_t v3;

  if ((*(_BYTE *)(a1 + 1016) & 3) == 0)
    return 0;
  if (sub_100013DB4(0))
    return "system shutdown";
  if (sub_100013DB4(1))
    return "userspace reboot";
  v3 = *(_QWORD *)(a1 + 112);
  if ((_UNKNOWN *)v3 == &unk_100071750)
    return "teardown of process-scoped services after host exited";
  if ((*(_BYTE *)(v3 + 128) & 2) != 0)
    return "logout";
  return 0;
}

_DWORD *sub_10002EBB8(uint64_t a1)
{
  _DWORD *v2;
  uint64_t v3;

  v2 = sub_10001389C(0x30uLL);
  v3 = *(_QWORD *)(a1 + 136);
  if (v3)
    LODWORD(v3) = xpc_mach_send_get_right(v3);
  v2[4] = v3;
  return v2;
}

uint64_t sub_10002EBF4(uint64_t a1, const void *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  unint64_t v19;
  _DWORD v20[512];

  result = *(unsigned int *)(a1 + 64);
  if ((_DWORD)result == -1)
  {
    if (!qword_100072AB0)
      return 0xFFFFFFFFLL;
    if (sub_10004310C((rb_tree_t **)qword_100072AB0, a2) == (rb_tree_t **)&_xpc_BOOL_true)
      v4 = 4;
    else
      v4 = 6;
    bzero(v20, 0x800uLL);
    v19 = 512;
    if (sub_100039298(v4, (uint64_t)v20, (uint64_t *)&v19))
    {
      xpc_strerror();
      sub_100028C34(a1, 3, "Unable to find persona with type %d: %d - %s", v10, v11, v12, v13, v14, v4);
      return 0xFFFFFFFFLL;
    }
    if (*(_DWORD *)(a1 + 60) == -101)
      v15 = -1;
    else
      v15 = *(_DWORD *)(a1 + 60);
    if (!v19)
    {
LABEL_18:
      sub_100028C34(a1, 3, "No matching personas of type %d uid %d, found %zu", v5, v6, v7, v8, v9, v4);
      return 0xFFFFFFFFLL;
    }
    v16 = 0;
    while (1)
    {
      v17 = sub_100039324(v20[v16]);
      if (v17 != -3 && v17 == v15)
        break;
      if (++v16 >= v19)
        goto LABEL_18;
    }
    result = v20[v16];
    if ((_DWORD)result == -1)
      return 0xFFFFFFFFLL;
  }
  return result;
}

void sub_10002ED44(_QWORD *a1)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v2 = a1[29];
  v3 = sub_100028C98((uint64_t)a1, 1);
  sub_100028C34(v2, 5, "removing child: %s", v4, v5, v6, v7, v8, (char)v3);
  free(v3);
  v9 = a1[2];
  if (v9)
    *(_QWORD *)(v9 + 24) = a1[3];
  *(_QWORD *)a1[3] = v9;
  a1[2] = -1;
  a1[3] = -1;
  if ((*(_BYTE *)(v2 + 1017) & 0x10) != 0)
    sub_10003E760(v2, (uint64_t)a1);
  sub_10001962C(a1);
  sub_100028FC0(v2);
  sub_10001962C(a1);
}

uint64_t sub_10002EE08(uint64_t a1)
{
  if ((sub_10000FEF4(a1, 3) & 1) != 0)
    return 1;
  else
    return sub_10000FEF4(a1, 4);
}

void sub_10002EE48(uint64_t a1)
{
  sub_100044E20(*(unsigned int *)(a1 + 16), *(void **)(a1 + 24));
  xpc_release(*(xpc_object_t *)(a1 + 24));
  free((void *)a1);
}

uint64_t sub_10002EE7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  v8 = *(unsigned int *)(a1 + 288);
  if (!(_DWORD)v8)
    sub_10004D738();
  *(_DWORD *)(a1 + 288) = 0;
  return sub_1000203B0(a1, v8, a3, a4, a5, a6, a7, a8);
}

void sub_10002EE9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  int v26;
  void *v27;
  NSObject *v28;
  NSObject *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  NSObject *v43;

  if (*(_QWORD *)(a2 + 248) != a1)
    sub_10004E0B0(a2);
  v10 = *(unsigned int *)(a2 + 296);
  v11 = (__int16)(*(_WORD *)(a2 + 300))--;
  if ((v11 - 32769) <= 0xFFFEFFFF)
    sub_10004E038(v10, a2);
  if (v11 <= 0)
    sub_10004E074(v10, a2);
  if ((_DWORD)v10)
    v12 = 2;
  else
    v12 = 1;
  if (v12 >= v11)
  {
    v13 = *(_DWORD *)(a2 + 368);
    if ((v13 & 2) != 0)
    {
      *(_DWORD *)(a2 + 368) = v13 & 0xFFFFFFFD;
      if (!(_DWORD)v10)
        goto LABEL_16;
    }
    else
    {
      sub_100028C34(a1, 5, "service inactive: %s%s", a4, a5, a6, a7, a8, a2 + 112);
      v14 = *(_QWORD *)(a2 + 88);
      if (v14)
        *(_QWORD *)(v14 + 96) = *(_QWORD *)(a2 + 96);
      **(_QWORD **)(a2 + 96) = v14;
      *(_QWORD *)(a2 + 88) = -1;
      *(_QWORD *)(a2 + 96) = -1;
      if (!*(_DWORD *)(a2 + 296))
      {
        --*(_DWORD *)(a1 + 200);
LABEL_16:
        v16 = sub_10002153C(a2);
        v17 = sub_1000442F4(v16);
        v25 = *(_DWORD *)(a2 + 368) & 0xFFFFDFFF;
        if (!v17)
          v25 = *(_DWORD *)(a2 + 368);
        v26 = *(_DWORD *)(a2 + 296);
        *(_DWORD *)(a2 + 360) = -1;
        v15 = v25 & 0xFFFFFF3F;
        *(_DWORD *)(a2 + 368) = v25 & 0xFFFFFF3F;
        *(_WORD *)(a2 + 300) = 0;
        if (!(v26 | v25 & 0x2000))
        {
          sub_100020AB4(a2, v18, v19, v20, v21, v22, v23, v24);
          v15 = *(_DWORD *)(a2 + 368);
        }
        goto LABEL_20;
      }
    }
    *(_DWORD *)(a2 + 360) = -1;
    v15 = *(_DWORD *)(a2 + 368) & 0xFFFFFF3F;
    *(_WORD *)(a2 + 300) = 0;
LABEL_20:
    *(_DWORD *)(a2 + 368) = v15 & 0xFFFFDFFF;
    v27 = *(void **)(a2 + 272);
    if (v27)
    {
      *(_QWORD *)(a2 + 272) = 0;
      if ((xpc_pipe_routine_reply(v27) | 0x20) != 0x20)
        _os_assumes_log_ctx(sub_10001F174, a1);
      xpc_release(v27);
    }
    v28 = *(NSObject **)(a2 + 328);
    if (v28)
    {
      *(_QWORD *)(a2 + 328) = 0;
      dispatch_group_leave(v28);
      dispatch_release(v28);
    }
    v29 = *(NSObject **)(a2 + 336);
    if (v29)
    {
      dispatch_group_leave(v29);
      *(_QWORD *)(a2 + 336) = 0;
    }
    *(_DWORD *)(a2 + 368) &= ~0x8000u;
    sub_10002F1A4(a2);
    if (*(_DWORD *)(a2 + 296))
    {
      if (*(_QWORD *)(a2 + 160))
        sub_10003E208("unmanaged service deactivated with active dynamic endpoints");
      if (*(_QWORD *)(a2 + 168))
        sub_10003E208("unmanaged service deactivated with active pid endpoints");
      sub_100028C34(a1, 5, "removing inactive unmanaged service: %s", v31, v32, v33, v34, v35, a2 + 112);
      memset((void *)a2, 204, 0x570uLL);
      free((void *)a2);
      sub_10001962C((void *)a1);
    }
    else if ((*(_BYTE *)(a1 + 1016) & 1) != 0 || (*(_BYTE *)(a2 + 368) & 0x10) != 0)
    {
      v43 = *(NSObject **)(a2 + 280);
      if (v43)
      {
        dispatch_group_leave(v43);
        *(_QWORD *)(a2 + 280) = 0;
      }
      sub_10002F1E8(a1, a2, v30, v31, v32, v33, v34, v35);
    }
    else
    {
      sub_10002F518((_QWORD *)a2);
      if (!*(_WORD *)(a1 + 204) && *(_DWORD *)(a2 + 288))
        sub_10002EE7C(a2, v36, v37, v38, v39, v40, v41, v42);
    }
  }
}

void sub_10002F1A4(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 296) && (*(_BYTE *)(a1 + 369) & 0x40) != 0)
  {
    dispatch_group_leave((dispatch_group_t)qword_100072490);
    *(_DWORD *)(a1 + 368) &= ~0x4000u;
  }
}

void sub_10002F1E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _DWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  void *v33;
  char *v34;
  char *v35;

  if (*(_QWORD *)(a2 + 248) != a1)
  {
    v34 = sub_10001F264(a2, 1);
    v35 = sub_100028C98(a1, 1);
    sub_10003E208("%s is being removed from a mismatched domain %s", v34, v35);
  }
  if (*(_UNKNOWN **)(a1 + 112) != &unk_100071750 || *(_WORD *)(a2 + 300))
    sub_100028C34(a1, 5, "removing service: %s", a4, a5, a6, a7, a8, a2 + 112);
  *(_DWORD *)(a2 + 368) = *(_DWORD *)(a2 + 368) & 0xFFFFFFEE | 0x10;
  sub_10002F5D4(a2, a2, a3, a4, a5, a6, a7, a8);
  v10 = *(_QWORD *)(a2 + 152);
  if (v10)
  {
    do
    {
      v11 = *(_QWORD *)(v10 + 16);
      sub_10002F68C(a1, v10);
      v10 = v11;
    }
    while (v11);
  }
  v12 = *(_QWORD *)(a2 + 176);
  if (v12)
  {
    do
    {
      v13 = *(_QWORD *)(v12 + 16);
      sub_10002F68C(a1, v12);
      v12 = v13;
    }
    while (v13);
  }
  v14 = *(_QWORD *)(a2 + 184);
  if (v14)
  {
    do
    {
      v15 = *(_QWORD *)(v14 + 16);
      sub_10002F68C(a1, v14);
      v14 = v15;
    }
    while (v15);
  }
  v16 = *(_QWORD **)(a2 + 192);
  if (v16)
  {
    v18 = (_QWORD *)v16[2];
    v19 = (_QWORD *)v16[3];
    v17 = v16 + 2;
    if (v18)
    {
      do
      {
        v20 = v18;
        v18[3] = v19;
        *(_QWORD *)v16[3] = v18;
        *v17 = -1;
        v17[1] = -1;
        sub_10001962C(v16);
        v17 = v20 + 2;
        v18 = (_QWORD *)v20[2];
        v19 = (_QWORD *)v20[3];
        v16 = v20;
      }
      while (v18);
    }
    else
    {
      v20 = *(_QWORD **)(a2 + 192);
    }
    *v19 = 0;
    *v17 = -1;
    v17[1] = -1;
    sub_10001962C(v20);
  }
  v21 = *(_QWORD *)(a2 + 200);
  if (v21)
  {
    do
    {
      v22 = *(_QWORD *)(v21 + 40);
      sub_100029C60(a1);
      v21 = v22;
    }
    while (v22);
  }
  if ((*(_DWORD *)(a2 + 368) & 0x600) == 0x200)
  {
    v23 = *(_QWORD *)(a2 + 40);
    *(_DWORD *)(a2 + 368) |= 0x400u;
    v24 = *(_QWORD **)(a2 + 48);
    if (v23)
    {
      *(_QWORD *)(v23 + 48) = v24;
      v24 = *(_QWORD **)(a2 + 48);
    }
    else
    {
      v25 = *(_QWORD *)(a2 + 256);
      *(_DWORD *)(v25 + 240) = *(_DWORD *)(v25 + 224);
      *(_QWORD *)(v25 + 232) = *(_QWORD *)(v25 + 216);
      *(_DWORD *)(v25 + 224) = 5474;
      *(_QWORD *)(v25 + 208) = v24;
      *(_QWORD *)(v25 + 216) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
    }
    *v24 = v23;
    *(_QWORD *)(a2 + 40) = -1;
    *(_QWORD *)(a2 + 48) = -1;
    *(_DWORD *)(a2 + 80) = *(_DWORD *)(a2 + 64);
    *(_QWORD *)(a2 + 72) = *(_QWORD *)(a2 + 56);
    *(_DWORD *)(a2 + 64) = 5474;
    *(_QWORD *)(a2 + 56) = "/Library/Caches/com.apple.xbs/Sources/libxpc_executables/launchd/domain.c";
  }
  if (sub_10001FAFC(a2))
  {
    v26 = *(_DWORD **)(a2 + 256);
    --v26[66];
    sub_10001962C(v26);
  }
  v27 = *(_QWORD **)(a1 + 96);
  if (v27)
  {
    do
    {
      v28 = (_QWORD *)*v27;
      if (v27[2] == a2)
      {
        if (v28)
          v28[1] = v27[1];
        *(_QWORD *)v27[1] = v28;
        *v27 = -1;
        v27[1] = -1;
        j__free(v27);
      }
      v27 = v28;
    }
    while (v28);
  }
  v29 = *(_QWORD *)(a2 + 120);
  if (v29)
    *(_QWORD *)(v29 + 128) = *(_QWORD *)(a2 + 128);
  **(_QWORD **)(a2 + 128) = v29;
  *(_QWORD *)(a2 + 120) = -1;
  *(_QWORD *)(a2 + 128) = -1;
  --*(_DWORD *)(a1 + 196);
  v30 = *(_QWORD *)(a2 + 312);
  if (v30)
  {
    v31 = (void *)sub_100012438(v30);
    os_release(v31);
    *(_QWORD *)(a2 + 312) = 0;
  }
  v32 = *(_QWORD *)(a2 + 320);
  if (v32)
  {
    v33 = (void *)sub_100012438(v32);
    os_release(v33);
    *(_QWORD *)(a2 + 320) = 0;
  }
  if (*(_QWORD *)(a1 + 72) == a2)
    *(_QWORD *)(a1 + 72) = 0;
  sub_1000075A0((_QWORD *)a2);
  sub_10001962C((void *)a2);
  sub_100028FC0(a1);
  sub_10001962C((void *)a1);
}

void sub_10002F518(_QWORD *a1)
{
  uint64_t i;
  uint64_t j;
  uint64_t k;
  uint64_t m;

  for (i = a1[19]; i; i = *(_QWORD *)(i + 16))
  {
    if ((*(_BYTE *)(i + 88) & 4) != 0)
      sub_10003E208("service deactivated with active endpoints");
    sub_100046670(i);
  }
  for (j = a1[22]; j; j = *(_QWORD *)(j + 16))
  {
    if ((*(_BYTE *)(j + 88) & 4) != 0)
      sub_10003E208("service deactivated with active event endpoints");
    sub_100046670(j);
  }
  for (k = a1[23]; k; k = *(_QWORD *)(k + 16))
  {
    if ((*(_BYTE *)(k + 88) & 4) != 0)
      sub_10003E208("service deactivated with active instance endpoints");
    sub_100046670(k);
  }
  for (m = a1[24]; m; m = *(_QWORD *)(m + 16))
    sub_10001BC4C(m);
  sub_100020BA8((uint64_t)a1);
}

void sub_10002F5D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if ((*(_BYTE *)(a1 + 369) & 8) != 0)
  {
    v9 = *(_QWORD *)(a1 + 160);
    if (v9)
    {
      do
      {
        v10 = *(_QWORD *)(v9 + 16);
        sub_100046AD4(v9, a2, a3, a4, a5, a6, a7, a8);
        v9 = v10;
      }
      while (v10);
    }
    v11 = *(_QWORD *)(a1 + 168);
    if (v11)
    {
      do
      {
        v12 = *(_QWORD *)(v11 + 16);
        sub_100046AD4(v11, a2, a3, a4, a5, a6, a7, a8);
        v11 = v12;
      }
      while (v12);
    }
  }
  v13 = *(_QWORD *)(a1 + 152);
  if (v13)
  {
    do
    {
      v14 = *(_QWORD *)(v13 + 16);
      sub_100046AD4(v13, a2, a3, a4, a5, a6, a7, a8);
      v13 = v14;
    }
    while (v14);
  }
  v15 = *(_QWORD *)(a1 + 176);
  if (v15)
  {
    do
    {
      v16 = *(_QWORD *)(v15 + 16);
      sub_100046AD4(v15, a2, a3, a4, a5, a6, a7, a8);
      v15 = v16;
    }
    while (v16);
  }
  v17 = *(_QWORD *)(a1 + 184);
  if (v17)
  {
    do
    {
      v18 = *(_QWORD *)(v17 + 16);
      sub_100046AD4(v17, a2, a3, a4, a5, a6, a7, a8);
      v17 = v18;
    }
    while (v18);
  }
  v19 = *(_QWORD *)(a1 + 192);
  if (v19)
  {
    do
    {
      v20 = *(_QWORD *)(v19 + 16);
      sub_10001C00C(v19);
      v19 = v20;
    }
    while (v20);
  }
  sub_100020D0C(a1);
}

void sub_10002F68C(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  mach_port_name_t *v10;
  int v11;
  task_t v12;
  uint64_t *v13;
  uint64_t v14;
  mach_port_t v15;
  kern_return_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  if (*(_QWORD *)(a2 + 72))
  {
    sub_10002F868((_QWORD *)a2);
  }
  else
  {
    v4 = *(_QWORD **)(a2 + 64);
    if (v4)
    {
      do
      {
        v5 = (_QWORD *)v4[6];
        sub_10002F868(v4);
        v4 = v5;
      }
      while (v5);
    }
    if ((*(_BYTE *)(a2 + 88) & 0x20) != 0)
    {
      v6 = *(_DWORD *)(a2 + 80);
      if (v6)
      {
        if (*(_QWORD *)(a1 + 976))
          v7 = *(_QWORD *)(a1 + 976);
        else
          v7 = a1;
        v8 = *(_QWORD *)(v7 + 976);
        if (v8)
          v9 = v6 == 4;
        else
          v9 = 1;
        if (v9)
          v8 = v7;
        v10 = (mach_port_name_t *)(v8 + 88);
        do
        {
          v10 = *(mach_port_name_t **)v10;
          if (!v10)
            sub_10003E208("domain has no corresponding special port entry");
        }
        while (v10[5] != v6);
        sub_100028BCC(v7, v10);
      }
      v11 = *(_DWORD *)(a2 + 84);
      if (v11)
      {
        if (v11 == 24)
        {
          v12 = mach_host_self();
          sub_100042AAC(v12, 0);
          v13 = &qword_100072498;
        }
        else
        {
          v14 = v11;
          v15 = mach_host_self();
          v16 = host_set_special_port(v15, v14, 0);
          if (v16)
            _os_assumes_log(v16);
          v13 = (uint64_t *)((char *)&unk_1000724A0 + 8 * v14);
        }
        *v13 = 0;
      }
      if (sub_10003E3D8(a1))
      {
        if (*(_QWORD *)(a1 + 168))
        {
          if (sub_1000480EC((char *)(a2 + 168)))
          {
            v23 = *(_QWORD *)(a1 + 168);
            if (v23)
            {
              v24 = sub_100046C64(a2, v23, v17, v18, v19, v20, v21, v22);
              if ((_DWORD)v24)
              {
                v25 = v24;
                v26 = sub_1000463E0(a2);
                xpc_strerror(v25);
                sub_10001D418(v26, 4, "Failed to stash endpoint %s: %d - %s", v27, v28, v29, v30, v31, a2 - 88);
              }
            }
          }
        }
      }
      v32 = *(_QWORD *)(a2 + 32);
      if (v32)
        *(_QWORD *)(v32 + 40) = *(_QWORD *)(a2 + 40);
      **(_QWORD **)(a2 + 40) = v32;
      *(_QWORD *)(a2 + 32) = -1;
      *(_QWORD *)(a2 + 40) = -1;
    }
    v33 = *(_QWORD *)(a2 + 16);
    if (v33)
      *(_QWORD *)(v33 + 24) = *(_QWORD *)(a2 + 24);
    **(_QWORD **)(a2 + 24) = v33;
    *(_QWORD *)(a2 + 16) = -1;
    *(_QWORD *)(a2 + 24) = -1;
    sub_10001962C((void *)a2);
  }
}

void sub_10002F868(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;

  if (!a1[9])
    sub_10003E208("alias-removal attempt of non-aliased endpoint");
  v1 = a1[4];
  if (v1)
    *(_QWORD *)(v1 + 40) = a1[5];
  *(_QWORD *)a1[5] = v1;
  v2 = a1[6];
  if (v2)
    *(_QWORD *)(v2 + 56) = a1[7];
  *(_QWORD *)a1[7] = v2;
  free(a1);
}

void sub_10002F8BC(uint64_t a1, uint64_t a2)
{
  pid_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v4 = sub_100020D78(a2);
  if (sub_100040964(v4) && sub_100013DB4(1))
  {
    v12 = sub_100010698("kern.darkboot");
    sub_100028C34(a1, 5, "Queried sysctl kern.darkboot: %u", v13, v14, v15, v16, v17, v12);
    if (v12 == 1)
    {
      sub_100028C34(a1, 5, "Setting sysctl kern.darkboot to %u", v18, v19, v20, v21, v22, 2);
      sub_100010694("kern.darkboot", 2);
    }
    sub_100013DD4("Abandoning service: %s", (const char *)(a2 + 1392));
  }
  *(_DWORD *)(a2 + 368) |= 0x800u;
  sub_10002F5D4(a2, v5, v6, v7, v8, v9, v10, v11);
}

uint64_t sub_10002F988(uint64_t a1, uint64_t a2)
{
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t result;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _DWORD *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  mach_port_name_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  task_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  mach_port_t v86;
  mach_port_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  mach_port_t v94;
  kern_return_t v95;

  v4 = (const char *)sub_1000463E0(a2);
  if (*(_QWORD *)(a1 + 976))
    v5 = *(_QWORD *)(a1 + 976);
  else
    v5 = a1;
  v6 = sub_10002E860(v5, (char *)(a2 + 168));
  if (v6)
  {
    if (*(_QWORD *)(v6 + 72))
      v7 = *(_QWORD *)(v6 + 72);
    else
      v7 = v6;
    v8 = sub_1000463E0(v7);
    if (sub_100046408(a2) && !sub_100046408(v7))
    {
      sub_10001D418(v8, 4, "Unmanaged endpoint \"%s\" was canceled to transfer the ownership to: %s", v10, v11, v12, v13, v14, v7 - 88);
      sub_100046AD4(v7, v21, v22, v23, v24, v25, v26, v27);
    }
    else
    {
      v15 = sub_1000457E0(v7, 2, v9, v10, v11, v12, v13, v14);
      if (!sub_10002FD78(v15))
      {
        sub_10001D418((uint64_t)v4, 4, "The endpoint \"%s\" defined in plist already exists and is owned by: %s", v16, v17, v18, v19, v20, a2 - 88);
        return 37;
      }
      *(_BYTE *)(v7 + 88) |= 0x40u;
    }
  }
  if ((sub_100005BA8((uint64_t)v4, 3) & 1) == 0)
  {
    v28 = a1;
    do
    {
      if (*(_QWORD *)(v28 + 976))
        v29 = *(_QWORD *)(v28 + 976);
      else
        v29 = v28;
      v30 = sub_10002E860(v29, (char *)(a2 + 168));
      v31 = sub_10002FEE8(v28);
      v28 = v31;
      if (v30)
        v32 = 1;
      else
        v32 = v31 == 0;
    }
    while (!v32);
    if (v30)
    {
      v33 = sub_1000463E0(v30);
      if (sub_100005BA8(v33, 3))
      {
        sub_10001D418((uint64_t)v4, 4, "The endpoint \"%s\" would shadow a trusted one owned by %s, ignoring", v34, v35, v36, v37, v38, a2 - 88);
        return 37;
      }
    }
  }
  if (*(_QWORD *)(a1 + 976))
    a1 = *(_QWORD *)(a1 + 976);
  if ((*(_BYTE *)(a2 + 88) & 0x10) != 0)
  {
    if (sub_10003E3D8(a1) || *(_UNKNOWN **)(a1 + 112) == &unk_1000715B8)
      *(_DWORD *)(a2 + 84) = 24;
    else
      *(_DWORD *)(a2 + 80) = 128;
  }
  v40 = sub_1000463E0(a2);
  if ((sub_100005BA8(v40, 2) & 1) != 0)
  {
    v46 = (_DWORD *)(a2 + 84);
    if (*(_DWORD *)(a2 + 84) && !sub_10003E3D8(a1) && *(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    {
      v47 = *v46;
LABEL_43:
      mach_host_special_port_description(v47);
      sub_10001D418(v40, 3, "Non-system service tried to claim host-special port: %d: %s", v48, v49, v50, v51, v52, v47);
      *v46 = 0;
    }
  }
  else
  {
    if (*(_DWORD *)(a2 + 80))
    {
      sub_10001D418(v40, 3, "Non-system service tried to claim task-special port: %d", v41, v42, v43, v44, v45, *(_DWORD *)(a2 + 80));
      *(_DWORD *)(a2 + 80) = 0;
    }
    v46 = (_DWORD *)(a2 + 84);
    v47 = *(unsigned int *)(a2 + 84);
    if ((_DWORD)v47)
      goto LABEL_43;
  }
  v53 = (uint64_t *)(a1 + 8 * (sub_1000158FC((_BYTE *)(a2 + 168)) % 0x1FuLL) + 704);
  v54 = *v53;
  *(_QWORD *)(a2 + 32) = *v53;
  if (v54)
    *(_QWORD *)(v54 + 40) = a2 + 32;
  *v53 = a2;
  *(_QWORD *)(a2 + 40) = v53;
  if (sub_10003E3D8(a1))
  {
    v61 = *(_QWORD *)(a1 + 168);
    if (v61)
      sub_100046D3C(a2, v61);
  }
  if (*(_DWORD *)(a2 + 80))
  {
    v62 = sub_1000457E0(a2, 1, v55, v56, v57, v58, v59, v60);
    if (sub_10002FDC4((_QWORD *)a1, v4, v62, *(unsigned int *)(a2 + 80), v63, v64, v65, v66))
      *(_DWORD *)(a2 + 80) = 0;
  }
  v67 = *(int *)(a2 + 84);
  if (!(_DWORD)v67)
    goto LABEL_63;
  v73 = sub_1000463E0(a2);
  if ((_DWORD)v67 == 24)
  {
    if (!qword_100072498)
    {
      qword_100072498 = a2;
      v79 = mach_host_self();
      v86 = sub_1000457E0(a2, 1, v80, v81, v82, v83, v84, v85);
      sub_100042AAC(v79, v86);
      goto LABEL_63;
    }
    sub_10001D418(v73, 3, "Endpoint \"%s\" tried to steal host exception port from \"%s\"", v68, v69, v70, v71, v72, a2 - 88);
  }
  else
  {
    if (!qword_1000724A0[v67])
    {
      v87 = mach_host_self();
      v94 = sub_1000457E0(a2, 1, v88, v89, v90, v91, v92, v93);
      v95 = host_set_special_port(v87, v67, v94);
      if (v95)
        _os_assumes_log(v95);
      qword_1000724A0[v67] = a2;
      goto LABEL_63;
    }
    mach_host_special_port_description(v67);
    sub_10001D418(v73, 3, "Endpoint \"%s\" tried to steal host %s port (%d) from \"%s\"", v74, v75, v76, v77, v78, a2 - 88);
  }
  *(_DWORD *)(a2 + 84) = 0;
LABEL_63:
  result = 0;
  *(_BYTE *)(a2 + 88) |= 0x20u;
  return result;
}

uint64_t sub_10002FD78(uint64_t name)
{
  mach_port_type_t ptype;

  ptype = 0;
  if ((_DWORD)name)
  {
    if (mach_port_type(mach_task_self_, name, &ptype))
      return 1;
    else
      return (BYTE2(ptype) >> 4) & 1;
  }
  return name;
}

uint64_t sub_10002FDC4(_QWORD *a1, const char *a2, mach_port_name_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;
  _QWORD *v11;
  BOOL v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;

  if (a1[122])
    v10 = (_QWORD *)a1[122];
  else
    v10 = a1;
  v11 = (_QWORD *)v10[122];
  if (v11)
    v12 = (_DWORD)a4 == 4;
  else
    v12 = 1;
  if (v12)
    v11 = v10;
  v13 = v11 + 11;
  while (1)
  {
    v13 = (_QWORD *)*v13;
    if (!v13)
      break;
    if (*((_DWORD *)v13 + 5) == (_DWORD)a4)
    {
      sub_10002E094((uint64_t)v10, *((unsigned int *)v13 + 4), 0, a4, a5, a6, a7, a8);
      if (a2)
        LOBYTE(a2) = (_BYTE)a2 + 112;
      else
        a2 = "(unknown)";
      if ((_DWORD)a4 != 128)
        mach_task_special_port_description(a4);
      sub_100028C34((uint64_t)v10, 3, "service \"%s\" tried to claim task-%s port from endpoint \"%s\"", v14, v15, v16, v17, v18, (char)a2);
      return 17;
    }
  }
  v19 = sub_100019974(a3, a4);
  v20 = (uint64_t *)v10[11];
  if (v20)
  {
    v21 = *v20;
    *v19 = *v20;
    if (v21)
      *(_QWORD *)(v21 + 8) = v19;
  }
  else
  {
    *v19 = 0;
    v20 = v10 + 11;
  }
  v22 = 0;
  *v20 = (uint64_t)v19;
  v19[1] = v20;
  ++v10[10];
  return v22;
}

uint64_t sub_10002FEE8(uint64_t a1)
{
  uint64_t result;

  if (!sub_1000157A8(*(char **)(a1 + 968), "PostLogOutSync"))
    return *(_QWORD *)(a1 + 232);
  result = sub_10003E404();
  if (!result)
    return *(_QWORD *)(a1 + 232);
  return result;
}

unint64_t sub_10002FF24(unint64_t result, uint64_t a2)
{
  unint64_t v3;
  int v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  int v9;

  v3 = result;
  if (*(_QWORD *)(a2 + 248) != result)
    sub_10004E170(a2);
  v4 = (__int16)(*(_WORD *)(a2 + 300))++;
  if ((v4 - 0x7FFF) <= 0xFFFEFFFF)
    sub_10004E0F8(a2);
  if (v4 < 0)
    sub_10004E134(a2);
  if (!v4)
  {
    if (*(_DWORD *)(a2 + 296))
    {
      v9 = *(_DWORD *)(a2 + 296);
      result = sub_1000158C8(&v9, 4);
      v5 = (uint64_t *)(v3 + 8 * (result % 7) + 648);
      v6 = *v5;
      *(_QWORD *)(a2 + 88) = *v5;
      if (v6)
        *(_QWORD *)(v6 + 96) = a2 + 88;
      *v5 = a2;
      *(_QWORD *)(a2 + 96) = v5;
    }
    else
    {
      v9 = sub_100020D78(a2);
      result = sub_1000158C8(&v9, 4);
      v7 = (uint64_t *)(v3 + 8 * (result % 0xD) + 544);
      v8 = *v7;
      *(_QWORD *)(a2 + 88) = *v7;
      if (v8)
        *(_QWORD *)(v8 + 96) = a2 + 88;
      *v7 = a2;
      *(_QWORD *)(a2 + 96) = v7;
      ++*(_DWORD *)(v3 + 200);
    }
  }
  return result;
}

void sub_100030074(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  char *v15;
  char **v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unsigned int v34;
  char *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char v56;
  BOOL v57;
  char *__s[7];
  unsigned int v59;
  unint64_t v60;
  void *v61;
  uuid_t out;

  v6 = *(_QWORD *)(a3 + 248);
  v57 = 0;
  v7 = sub_100021544(a3, &v57);
  if (a2 == 2)
  {
    if (byte_1000729D9)
    {
      if (sub_100029C60(v6, a3))
        sub_10003E208("failed to boot out inactive service during obliteration; socket event");
      return;
    }
    if (v57)
      v18 = 0;
    else
      v18 = v7;
    if (v18 != 1)
    {
      v26 = sub_1000203B0(a3, 2, v8, v9, v10, v11, v12, v13);
      if ((v26 & 0xFFFFFFFE) == 0x24)
        v27 = 0;
      else
        v27 = v26;
      if (v27)
      {
        if (v27 == 37)
          sub_10003E208("socket event received for running service");
        _os_assumes_log_ctx(sub_10001F174, a3);
      }
      return;
    }
    v60 = 0;
    v61 = 0;
    if ((*(_BYTE *)(a3 + 1384) & 1) != 0)
    {
      sub_10001D418(a3, 3, "Could not accept inetd connection to retain-only service", v9, v10, v11, v12, v13, v56);
      v25 = 61;
LABEL_31:
      xpc_strerror(v25);
      sub_10001D418(a3, 3, "Could not accept new inetd connection: %d: %s", v28, v29, v30, v31, v32, v25);
      return;
    }
    v19 = sub_10001C044((_QWORD *)a1, (unsigned int **)&v61, &v60);
    v59 = v19;
    if ((_DWORD)v19)
    {
      v25 = v19;
      if ((_DWORD)v19 == 35)
        sub_10003E208("EWOULDBLOCK returned on socket that should not block");
      goto LABEL_31;
    }
    if (!v60)
    {
      sub_10001D418(a3, 3, "Got a socket event for an inetd service, but couldn't accept any sockets", v20, v21, v22, v23, v24, v56);
      if (!v60)
      {
LABEL_47:
        free(v61);
        return;
      }
    }
    v33 = 0;
    while (1)
    {
      __s[0] = (char *)sub_10002A27C;
      __s[1] = (char *)sub_10002A664;
      __s[2] = (char *)sub_10002A7A8;
      __s[3] = (char *)sub_10002A940;
      __s[4] = (char *)sub_10002A998;
      __s[5] = (char *)sub_10002AA84;
      __s[6] = (char *)v6;
      memset(out, 0, sizeof(out));
      uuid_generate(out);
      v34 = *(_DWORD *)(a3 + 268);
      if (v34 && *(_DWORD *)(a3 + 264) >= v34)
      {
        v50 = 67;
        v59 = 67;
      }
      else
      {
        v35 = sub_100006688(a3, out, *((unsigned int *)v61 + v33), 0, 0, (uint64_t)__s, 0, (int *)&v59);
        if (v35)
        {
          v36 = (uint64_t)v35;
          *((_DWORD *)v35 + 92) |= 0x100u;
          sub_100029B24((_DWORD *)v6, (uint64_t)v35);
          ++*(_DWORD *)(a3 + 264);
          *(_QWORD *)(v36 + 256) = a3;
          sub_100019580((void *)a3);
          v43 = sub_1000203B0(v36, 2, v37, v38, v39, v40, v41, v42);
          if ((v43 & 0xFFFFFFFE) == 0x24)
            v44 = 0;
          else
            v44 = v43;
          v59 = v44;
          if ((_DWORD)v44)
          {
            xpc_strerror(v44);
            sub_10001D418(v36, 3, "Could not spawn dedicated inetd instance: %d: %s", v45, v46, v47, v48, v49, v44);
          }
          goto LABEL_46;
        }
        v50 = v59;
      }
      xpc_strerror(v50);
      sub_10001D418(a3, 3, "Could not create new instance of inetd service: %d: %s", v51, v52, v53, v54, v55, v50);
LABEL_46:
      sub_10003BAF4((int *)*((unsigned int *)v61 + v33++));
      if (v33 >= v60)
        goto LABEL_47;
    }
  }
  if (a2 != 1)
  {
    if (a2)
      return;
    __s[0] = 0;
    v14 = (const char *)sub_10001BC30(a1, __s);
    if (v14)
    {
      *(_QWORD *)out = 0;
      v15 = sub_10001967C(__s[0], v14, 0, (size_t *)out, 0);
      if (v15)
      {
        v16 = (char **)(v6 + 96);
        v17 = *(_QWORD *)(v6 + 96);
        *(_QWORD *)v15 = v17;
        if (v17)
          *(_QWORD *)(v17 + 8) = v15;
        *v16 = v15;
        *((_QWORD *)v15 + 1) = v16;
        *((_QWORD *)v15 + 2) = a3;
      }
      else
      {
        sub_10001D418(a3, 3, "Service attempted to specify secure socket key with reserved name: %s", v9, v10, v11, v12, v13, (char)__s[0]);
      }
    }
    *(_BYTE *)(a1 + 48) |= 1u;
  }
  sub_10002EE9C(v6, a3, v8, v9, v10, v11, v12, v13);
  sub_10002976C(v6, 9);
}

BOOL sub_100030434(id a1, const char *a2, void *a3)
{
  sub_10001962C(a3);
  return 1;
}

uint64_t sub_10003045C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  FILE *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v4 = *(FILE **)(a1 + 32);
  v5 = *(_QWORD *)(a1 + 40) + 2;
  v6 = sub_100003A00(a3);
  return sub_10004391C(v4, v5, "%s (%d records)", v7, v8, v9, v10, v11, a2, v6);
}

uint64_t sub_1000304B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10004391C(*(FILE **)(a3 + 8), *(_QWORD *)(a3 + 16), "%s", a4, a5, a6, a7, a8, a1);
}

uint64_t sub_1000304E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10004391C(*(FILE **)(a1 + 32), *(_QWORD *)(a1 + 40) + 2, "%s", a4, a5, a6, a7, a8, a2);
  return 1;
}

uint64_t sub_10003051C(FILE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v9 = *(_QWORD *)(a2 + 72);
  if (v9)
    v10 = *(_QWORD *)(a2 + 72);
  else
    v10 = a2;
  v11 = *(_BYTE *)(v10 + 88);
  if (v9)
  {
    v12 = 65;
  }
  else if (sub_100046408(a2))
  {
    v12 = 77;
  }
  else
  {
    v12 = 85;
  }
  v13 = sub_1000457E0(v10, 2, a3, a4, a5, a6, a7, a8);
  v19 = 65;
  if ((v11 & 4) == 0)
    v19 = 68;
  return sub_10004391C(a1, 2, "%#8x %4c%4c   %s", v14, v15, v16, v17, v18, v13, v12, v19, v10 + 168);
}

void *sub_1000305B8(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *result;
  xpc_object_t v17;
  char *v18;
  char v19;
  _QWORD applier[5];

  v8 = a3;
  sub_100043998(a2, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v19);
  result = *(void **)(a1 + 952);
  if (result && (result = (void *)xpc_dictionary_get_count(result)) != 0)
  {
    sub_10004391C(a2, 1, "disabled services = {", v11, v12, v13, v14, v15);
    v17 = xpc_copy(*(xpc_object_t *)(a1 + 952));
    xpc_dictionary_set_value(v17, "_dirty", 0);
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_100030754;
    applier[3] = &unk_10006CB28;
    applier[4] = a2;
    xpc_dictionary_apply(v17, applier);
    xpc_release(v17);
    v18 = "}";
  }
  else
  {
    if ((v8 & 1) != 0)
      return result;
    v18 = "disabled services = (no disabled services)";
  }
  return (void *)sub_10004391C(a2, 1, v18, v11, v12, v13, v14, v15);
}

uint64_t sub_1000306AC(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = a1;
  v4 = *(_QWORD *)(a1 + 136);
  if (v4)
    LODWORD(v4) = xpc_mach_send_get_right();
  if ((_DWORD)v4 != (_DWORD)a2)
  {
    v5 = *(_QWORD *)(v3 + 320);
    if (v5)
    {
      while (1)
      {
        v6 = sub_1000306AC(v5, a2);
        if (v6)
          break;
        v5 = *(_QWORD *)(v5 + 16);
        if (!v5)
          return 0;
      }
      return v6;
    }
    else
    {
      return 0;
    }
  }
  return v3;
}

uint64_t sub_100030718(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10004391C(*(FILE **)(a1 + 32), *(_QWORD *)(a1 + 40) + 2, "%s", a4, a5, a6, a7, a8, a2);
  return 1;
}

uint64_t sub_100030754(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  FILE *v8;
  const char *v9;

  v8 = *(FILE **)(a1 + 32);
  if (a3 == &_xpc_BOOL_true)
    v9 = "disabled";
  else
    v9 = "enabled";
  sub_10004391C(v8, 2, "\"%s\" => %s", a4, a5, a6, a7, a8, a2, v9);
  return 1;
}

uint64_t sub_1000307A8(uint64_t a1)
{
  int v2;

  v2 = *(_DWORD *)(a1 + 20);
  if (v2 == getpid())
    return 1;
  else
    return sub_1000408D8(a1, 0x4000000);
}

uint64_t sub_1000307EC(int a1, char *a2)
{
  size_t v4;
  int v5;
  uint64_t result;
  int v7;
  size_t v8;
  _OWORD buffer[4];

  v4 = 1024;
  v5 = a1;
  while (1)
  {
    memset(buffer, 0, sizeof(buffer));
    result = sub_10003FB48(v5, buffer);
    v7 = result;
    if (v5 == a1)
    {
      if (v4 < 2)
        goto LABEL_11;
      result = snprintf(a2, v4, "%s[%d]");
    }
    else
    {
      if (v4 < 2)
      {
LABEL_11:
        v8 = 0;
        if ((_DWORD)result)
          return result;
        goto LABEL_12;
      }
      result = snprintf(a2, v4, "<-%s[%d]");
    }
    v8 = (int)result;
    if (v4 <= (int)result)
      v8 = v4 - 1;
    if (v7)
      return result;
LABEL_12:
    if (v5 != 1)
    {
      v5 = DWORD1(buffer[0]);
      if (DWORD1(buffer[0]) > 1)
      {
        a2 += v8;
        v4 -= v8;
        if (v4)
          continue;
      }
    }
    return result;
  }
}

uint64_t sub_10003092C(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  void *info_dictionary;
  xpc_object_t value;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *string;
  const char *v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v23;

  info_dictionary = (void *)xpc_bundle_get_info_dictionary(a2);
  if (!info_dictionary)
    return 22;
  value = xpc_dictionary_get_value(info_dictionary, "XPCService");
  if (!value)
  {
    v13 = 0;
    *a3 = qword_100071750;
    return v13;
  }
  v7 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100028C34(a1, 3, "Invalid XPCService dictionary.", v8, v9, v10, v11, v12, v23);
    return 22;
  }
  string = xpc_dictionary_get_string(v7, "ServiceType");
  if (!string)
  {
    v16 = qword_100071750;
LABEL_14:
    v13 = 0;
    *a3 = v16;
    goto LABEL_15;
  }
  v15 = string;
  if (!strcmp(string, "System"))
  {
    v16 = &unk_1000715B8;
    goto LABEL_14;
  }
  if (!strcmp(v15, "Application"))
  {
    v16 = qword_100071750;
    goto LABEL_14;
  }
  v13 = 22;
LABEL_15:
  if (xpc_dictionary_get_BOOL(v7, "_MultipleInstances") && (_QWORD *)*a3 != qword_100071750)
  {
    sub_100028C34(a1, 4, "MultipleInstance XPC services are not supported for any service type other than Application. Forcing service to PID domain.", v17, v18, v19, v20, v21, v23);
    *a3 = qword_100071750;
  }
  return v13;
}

uint64_t sub_100030A6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if ((*(_BYTE *)(qword_100072478 + 1016) & 1) != 0)
    return 124;
  if ((a2 & 0x88) != 0 && !sub_1000307A8(a4))
    return 154;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, _QWORD))(a1 + 104))(0, 1, a2, a3, a4, 0, 0);
}

uint64_t sub_100030B00(uint64_t a1, uint64_t a2, xpc_object_t xdict, _QWORD *a4)
{
  uint64_t result;
  xpc_object_t value;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  xpc_object_t reply;
  uint64_t v22;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  if ((*(_BYTE *)(a1 + 1016) & 3) != 0)
    return 124;
  value = xpc_dictionary_get_value(xdict, "paths");
  if (value)
  {
    v10 = value;
    if ((xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary || xpc_get_type(v10) == (xpc_type_t)&_xpc_type_array)
      && xpc_dictionary_expects_reply(xdict))
    {
      if (xpc_dictionary_get_BOOL(xdict, "enable"))
        v11 = 2048;
      else
        v11 = 0;
      if (xpc_dictionary_get_BOOL(xdict, "force"))
        v11 |= 0x8000uLL;
      if (xpc_dictionary_get_BOOL(xdict, "legacy-load"))
        v11 |= 0x100uLL;
      if (xpc_dictionary_get_BOOL(xdict, "angel"))
        v11 |= 0x40000uLL;
      if (xpc_dictionary_get_BOOL(xdict, "managed-lwcr"))
        v11 |= 0x80000uLL;
      if (xpc_dictionary_get_BOOL(xdict, "by-cli"))
        v11 |= 0x100000uLL;
      if (*(_QWORD **)(a1 + 112) == qword_100071750)
      {
        v22 = sub_100034388(a1, a2, v12, v13, v14, v15, v16, v17);
        if ((_BYTE)v22)
        {
          if (v22 != 37)
          {
            v23 = v22;
            xpc_strerror(v22);
            sub_100028C34(a1, 5, "failed to uncork PID domain on first bootstrap: %d - %s", v24, v25, v26, v27, v28, v23);
          }
        }
      }
      v18 = (void *)sub_100038E4C(xdict);
      sub_100016D38((_QWORD *)a1, 1, v18, v10, a2, v11, v19, v20);
      xpc_release(v18);
      return 0;
    }
    else
    {
      return 22;
    }
  }
  else
  {
    reply = xpc_dictionary_create_reply(xdict);
    result = 0;
    *a4 = reply;
  }
  return result;
}

uint64_t sub_100030CF4(_QWORD *a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  xpc_object_t value;
  void *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  const char *string;
  char *v17;
  void *v18;
  mach_port_context_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BOOL4 v26;
  _BOOL4 v27;
  xpc_object_t reply;
  uint64_t v29;
  void *v30;
  _DWORD *v31;
  char v32[1024];

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  v8 = sub_10002C0E4((uint64_t)a1, 4, 128, a2, 0, 0);
  if ((_DWORD)v8)
  {
    v9 = v8;
LABEL_4:
    sub_10002C1B8((uint64_t)a1, a2, v9, "bootout");
    return v9;
  }
  if (xpc_dictionary_get_value(a3, "paths"))
  {
    value = xpc_dictionary_get_value(a3, "paths");
    if (value)
    {
      v11 = value;
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary || xpc_get_type(v11) == (xpc_type_t)&_xpc_type_array)
      {
        if (xpc_dictionary_get_BOOL(a3, "disable"))
          v12 = 2048;
        else
          v12 = 0;
        if (xpc_dictionary_get_BOOL(a3, "no-einprogress"))
          v12 |= 0x20000uLL;
        if (xpc_dictionary_get_BOOL(a3, "by-cli"))
          v12 |= 0x100000uLL;
        v13 = (void *)sub_100038E4C(a3);
        sub_100016D38(a1, 2, v13, v11, a2, v12, v14, v15);
        xpc_release(v13);
        return 0;
      }
    }
    return 22;
  }
  if (!xpc_dictionary_get_string(a3, "name"))
  {
    v9 = sub_10002C0E4((uint64_t)a1, 7, 128, a2, 0, 0);
    if (!(_DWORD)v9)
    {
      sub_100034468((uint64_t)a1, a2, a3, a4);
      return v9;
    }
    goto LABEL_4;
  }
  v31 = a1;
  string = xpc_dictionary_get_string(a3, "name");
  if (!string)
    return 22;
  v17 = (char *)string;
  if (xpc_dictionary_get_BOOL(a3, "legacy-service-lookup"))
    v18 = sub_100034520(&v31, v17);
  else
    v18 = sub_10002C4E4(a1, v17);
  v20 = (mach_port_context_t)v18;
  if (!v18)
    return 3;
  bzero(v32, 0x400uLL);
  sub_1000307EC(*(_DWORD *)(a2 + 20), v32);
  sub_10001D418(v20, 65541, "bootout initiated by: %s", v21, v22, v23, v24, v25, (char)v32);
  xpc_dictionary_get_BOOL(a3, "attempt-unload-protected");
  v9 = sub_10001F090();
  if ((_DWORD)v9)
  {
    sub_10002C1B8((uint64_t)v31, a2, v9, "bootout (%s)");
  }
  else
  {
    v9 = sub_100029C60((uint64_t)v31, v20);
    v26 = xpc_dictionary_get_BOOL(a3, "no-einprogress");
    v27 = xpc_dictionary_get_BOOL(a3, "wait");
    if ((_DWORD)v9 && ((_DWORD)v9 != 36 || !v26))
    {
      if ((_DWORD)v9 == 36 && v27)
      {
        reply = xpc_dictionary_create_reply(a3);
        v29 = sub_100023A28(v20);
        v30 = (void *)xpc_mach_send_create_with_disposition(v29, 20);
        xpc_dictionary_set_value(reply, "monitor", v30);
        xpc_release(v30);
        v9 = 0;
        *a4 = reply;
      }
    }
    else
    {
      v9 = 0;
      *a4 = xpc_dictionary_create_reply(a3);
    }
  }
  return v9;
}

uint64_t sub_100031070(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t result;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  xpc_object_t value;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  xpc_object_t v36;
  xpc_object_t v37;
  const char *string;
  xpc_object_t reply;
  char v40;
  char v41;
  char v42;

  if (*(_QWORD **)(a1 + 112) != qword_100071750 || !xpc_dictionary_expects_reply(a3))
    return 22;
  sub_100011420(570425360, *(_QWORD *)(a1 + 120));
  v13 = *(_DWORD *)(a2 + 28);
  if (v13 > *(_DWORD *)(a1 + 308) || *(_DWORD *)(a2 + 20) != *(_DWORD *)(a1 + 300))
  {
    sub_100028C34(a1, 5, "exec count or caller mismatch: caller exec cnt = %u, creator exec cnt = %u, caller pid = %d, creator pid = %d", v8, v9, v10, v11, v12, v13);
    if (*(_QWORD *)(a1 + 216))
    {
      sub_100028C34(a1, 5, "rebirth already in progress", v15, v16, v17, v18, v19, v41);
      return 131;
    }
    else
    {
      sub_100028C34(a1, 5, "slaying domain for rebirth", v15, v16, v17, v18, v19, v41);
      *(_DWORD *)(a1 + 1016) |= 0x80u;
      *(_QWORD *)(a1 + 216) = xpc_retain(a3);
      sub_1000290BC(a1, v20, v21, v22, v23, v24, v25, v26, v42);
      return 0;
    }
  }
  if ((*(_BYTE *)(a1 + 1016) & 8) != 0 || *(_QWORD *)(a1 + 248))
  {
    sub_100028C34(a1, 5, "domain already initialized", v8, v9, v10, v11, v12, v40);
    return 37;
  }
  value = xpc_dictionary_get_value(a3, "paths");
  if (!value
    || (v35 = value, xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    || (v36 = xpc_dictionary_get_value(a3, "environment")) == 0
    || (v37 = v36, xpc_get_type(v36) != (xpc_type_t)&_xpc_type_dictionary))
  {
    sub_1000290BC(a1, v28, v29, v30, v31, v32, v33, v34, v40);
    return 22;
  }
  string = xpc_dictionary_get_string(a3, "origin");
  if (string)
    *(_QWORD *)(a1 + 240) = sub_10001544C(string);
  *(_QWORD *)(a1 + 248) = xpc_retain(v35);
  xpc_dictionary_apply_f(v37);
  *(_DWORD *)(a1 + 1016) |= 8u;
  reply = xpc_dictionary_create_reply(a3);
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_10003126C(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  xpc_object_t reply;
  uint64_t result;

  if (*(_QWORD **)(a1 + 112) != qword_100071750 || !xpc_dictionary_expects_reply(a3))
    return 22;
  v14 = sub_100034388(a1, a2, v8, v9, v10, v11, v12, v13);
  reply = xpc_dictionary_create_reply(a3);
  result = 0;
  if ((_BYTE)v14 && v14 != 37 && v14 != 124)
  {
    xpc_dictionary_set_int64(reply, "error", v14);
    result = v14;
  }
  *a4 = reply;
  return result;
}

uint64_t sub_100031318(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int right;
  const char *string;
  char *v13;
  uint64_t uint64;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  int v18;
  const uint8_t *uuid;
  unsigned __int8 *v20;
  const void *data;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  xpc_object_t v27;
  int64_t int64;
  int64_t v29;
  char *v30;
  char *v31;
  char *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  size_t length;
  _OWORD v47[4];

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  sub_10004453C();
  if (xpc_dictionary_get_uint64(a3, "type") != 7)
  {
    v8 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 112)
                                                                                              + 104))(a1, 6, 0, *(_QWORD *)(a1 + 120), a2, 0, 0);
    if ((_DWORD)v8)
    {
      v9 = v8;
      sub_10002C1B8(a1, a2, v8, "endpoint lookup");
      return v9;
    }
  }
  if ((*(_BYTE *)(a1 + 1016) & 3) != 0)
    return 124;
  if (*(_WORD *)(a1 + 204))
  {
    v10 = *(_QWORD *)(a1 + 136);
    if (v10)
      right = xpc_mach_send_get_right(v10);
    else
      right = 0;
    v16 = a1;
    v17 = a3;
    v18 = 1;
LABEL_15:
    sub_10003465C(v16, right, v17, v18);
    return 0;
  }
  string = xpc_dictionary_get_string(a3, "name");
  if (!string)
    return 22;
  v13 = (char *)string;
  uint64 = xpc_dictionary_get_uint64(a3, "flags");
  v15 = (uint64 & 0x10) != 0 ? xpc_dictionary_get_uint64(a3, "lookup-handle") : 0;
  uuid = xpc_dictionary_get_uuid(a3, "instance");
  v20 = (unsigned __int8 *)uuid;
  if (((uint64 & 4) != 0 || (uint64 & 0x20) != 0) && !uuid)
    return 22;
  length = 0;
  data = xpc_dictionary_get_data(a3, "cputypes", &length);
  v22 = (unint64_t)data;
  if ((uint64 & 0x400) == 0 || (v9 = 22, data) && length == 36 && *(_QWORD **)(a1 + 112) == qword_100071750)
  {
    if ((*(_BYTE *)(a1 + 1017) & 0x10) != 0
      && (uint64 & 0x10) == 0
      && *(_UNKNOWN **)(a1 + 112) == &unk_1000715B8
      && sub_1000480EC(v13))
    {
      memset(v47, 0, sizeof(v47));
      sub_10003FBC0(a2, (char *)v47);
      sub_100028C34(a1, 5, "pending lookup during user switch: name = %s, requestor = %s[%d]", v39, v40, v41, v42, v43, (char)v13);
      v44 = *(_QWORD *)(a1 + 136);
      if (v44)
        right = xpc_mach_send_get_right(v44);
      else
        right = 0;
      v16 = a1;
      v17 = a3;
      v18 = 2;
      goto LABEL_15;
    }
    v23 = sub_1000346D4(a1, v13, v15, uint64, v20, v22, a2);
    v45 = v22;
    v24 = v15;
    v26 = v25;
    v27 = sub_100034964(a3, v23, v25);
    if (sub_1000349F4(v23, v26, v13, v24, uint64, v20, v45, a2))
    {
      int64 = xpc_dictionary_get_int64(v27, "error");
      v29 = int64;
      v30 = "Unexpected error when looking up endpoint: %s";
      if (int64 == 3)
        v30 = "System session daemon must not initiate XPC to the User session: endpoint = %s";
      if (int64 == 159)
        v31 = sub_100015630("Sandbox violation: endpoint = %s");
      else
        v31 = sub_100015630(v30, v13);
      v32 = v31;
      xpc_strerror(v29);
      sub_100028C34(a1, 3, "%s (%s)", v33, v34, v35, v36, v37, (char)v32);
      free(v32);
    }
    v9 = 0;
    *a4 = v27;
  }
  return v9;
}

uint64_t sub_100031684(uint64_t a1, uint64_t a2, xpc_object_t xdict, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v7;
  int right;
  const char *string;
  char *v12;
  uint64_t uint64;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v22;
  size_t v23;
  uint64_t v24;
  char *v25;
  void *v26;
  uint64_t v27;
  unint64_t v28;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  xpc_object_t reply;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  xpc_object_t v43;
  int *v44;
  int v45;
  uint64_t v46;
  void *__src;
  xpc_object_t object;

  if ((*(_BYTE *)(a1 + 1016) & 3) != 0)
    return 124;
  if (*(_WORD *)(a1 + 204))
  {
    v7 = *(_QWORD *)(a1 + 136);
    if (v7)
      right = xpc_mach_send_get_right(v7);
    else
      right = 0;
    sub_10003465C(a1, right, xdict, 1);
    return 0;
  }
  string = xpc_dictionary_get_string(xdict, "name");
  if (!string)
    return 22;
  v12 = (char *)string;
  uint64 = xpc_dictionary_get_uint64(xdict, "flags");
  v19 = uint64;
  if (*(_QWORD **)(a1 + 112) == qword_100071750)
  {
    if ((uint64 & 1) != 0)
      sub_100028C34(a1, 4, "Ignoring lax activation attempt for unsupported domain: %s", v14, v15, v16, v17, v18, (char)v12);
    v19 &= ~1uLL;
    if ((v19 & 0x20) == 0)
      goto LABEL_9;
  }
  else if ((uint64 & 0x20) == 0)
  {
LABEL_9:
    object = 0;
    LOBYTE(__src) = 0;
    v20 = sub_1000354BC(a1, a2, v12, v19, 0, &object, &__src);
    if (!(_DWORD)v20)
    {
      reply = xpc_dictionary_create_reply(xdict);
      v37 = xpc_mach_send_get_right(object);
      xpc_dictionary_set_mach_recv(reply, "port", v37);
      if ((_BYTE)__src)
        xpc_dictionary_set_BOOL(reply, "non-launching", 1);
      xpc_release(object);
      goto LABEL_40;
    }
    return v20;
  }
  v22 = *(_DWORD *)(a2 + 20);
  object = (xpc_object_t)a1;
  v23 = sub_1000352F4((uint64_t *)&object, v22, 1);
  if (v23)
  {
    v24 = v23;
    v25 = (char *)sub_10001389C(0x200uLL);
    v26 = v25;
    v27 = *(_QWORD *)(v24 + 192);
    if (!v27)
    {
      v4 = 3;
      goto LABEL_35;
    }
    v28 = 0;
    v4 = 3;
    v29 = v25;
    while (1)
    {
      if (!strcmp((const char *)(v27 + 208), v12))
      {
        v46 = 0;
        __src = 0;
        v30 = sub_10001BEB4(v27, &__src, 0, &v46);
        v4 = v30;
        if ((_DWORD)v30)
        {
          xpc_strerror(v30);
          sub_10001D418(v24, 3, "Could not activate socket named \"%s\": %d: %s", v38, v39, v40, v41, v42, (char)v12);
          goto LABEL_34;
        }
        v28 += v46;
        if (v28 >= 0x80)
        {
          sub_10001D418(v24, 4, "Too many sockets for name \"%s\". Some will be skipped.", v31, v32, v33, v34, v35, (char)v12);
          sub_10001BF7C(v27);
          *(_WORD *)(v27 + 204) &= ~1u;
LABEL_34:
          if ((_DWORD)v4)
          {
LABEL_35:
            free(v26);
            return v4;
          }
          reply = xpc_dictionary_create_reply(xdict);
          v43 = xpc_array_create(0, 0);
          if (v28)
          {
            v44 = (int *)v26;
            do
            {
              v45 = *v44++;
              xpc_array_set_fd(v43, 0xFFFFFFFFFFFFFFFFLL, v45);
              --v28;
            }
            while (v28);
          }
          xpc_dictionary_set_value(reply, "port", v43);
          xpc_release(v43);
          free(v26);
LABEL_40:
          v4 = 0;
          *a4 = reply;
          return v4;
        }
        memcpy(v29, __src, 4 * v46);
        v4 = 0;
        v29 += 4 * v46;
      }
      v27 = *(_QWORD *)(v27 + 16);
      if (!v27)
        goto LABEL_34;
    }
  }
  return 113;
}

uint64_t sub_100031998(uint64_t a1, xpc_object_t original, _QWORD *a3)
{
  uint64_t result;
  xpc_object_t reply;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  xpc_object_t v14;
  char v15;

  if ((*(_BYTE *)(a1 + 1016) & 3) != 0)
    return 124;
  reply = xpc_dictionary_create_reply(original);
  if (!reply)
    return 22;
  v14 = reply;
  sub_10002DDF0(a1, v7, v8, v9, v10, v11, v12, v13, v15);
  result = 0;
  *a3 = v14;
  return result;
}

uint64_t sub_1000319FC(uint64_t a1, xpc_object_t original, _QWORD *a3)
{
  uint64_t result;
  xpc_object_t reply;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  NSObject *v15;
  char v16;

  if ((*(_BYTE *)(a1 + 1016) & 3) != 0)
    return 124;
  if (!*(_DWORD *)(a1 + 192))
    return 34;
  reply = xpc_dictionary_create_reply(original);
  if (!reply)
    return 22;
  v7 = reply;
  if (!sub_100039000())
  {
LABEL_8:
    sub_1000298A0(a1, v8, v9, v10, v11, v12, v13, v14);
    result = 0;
    *a3 = v7;
    return result;
  }
  v15 = *(NSObject **)(a1 + 160);
  if (v15)
  {
    dispatch_source_cancel(v15);
    *(_QWORD *)(a1 + 160) = 0;
    goto LABEL_8;
  }
  sub_100028C34(a1, 4, "Ignoring a request to unset ondemand", v10, v11, v12, v13, v14, v16);
  xpc_release(v7);
  return 37;
}

uint64_t sub_100031AAC(uint64_t a1, uint64_t a2, xpc_object_t xdict, _QWORD *a4)
{
  xpc_object_t value;
  void *v9;
  uint64_t v10;
  uint64_t v12;
  xpc_object_t reply;
  void *v14;
  size_t v15;
  char *string;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  value = xpc_dictionary_get_value(xdict, "names");
  if (!value)
    return 22;
  v9 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_array)
    return 22;
  v12 = sub_10002C0E4(a1, 4, 128, a2, 0, 0);
  if ((_DWORD)v12)
  {
    if ((v10 = v12, (_DWORD)v12 != 1)
      || !sub_10003E3D8(a1) && *(_UNKNOWN **)(a1 + 112) != &unk_1000715B8
      || (sub_100035A78(a2, v9) & 1) == 0)
    {
      sub_10002C1B8(a1, a2, v10, "enable service");
      return v10;
    }
  }
  reply = xpc_dictionary_create_reply(xdict);
  if (!reply)
    return 22;
  v14 = reply;
  if (xpc_array_get_count(v9))
  {
    v15 = 0;
    do
    {
      string = (char *)xpc_array_get_string(v9, v15);
      if (string)
      {
        v17 = string;
        v18 = sub_10002E41C(a1, string, 2);
        if ((_DWORD)v18)
        {
          v19 = v18;
          xpc_dictionary_set_int64(v14, v17, 0);
          xpc_strerror(v19);
          sub_100028C34(a1, 4, "Failed to enable service %s, error=%d - %s", v20, v21, v22, v23, v24, (char)v17);
        }
      }
      ++v15;
    }
    while (v15 < xpc_array_get_count(v9));
  }
  sub_100048018();
  v10 = 0;
  *a4 = v14;
  return v10;
}

uint64_t sub_100031C48(uint64_t a1, uint64_t a2, xpc_object_t xdict, _QWORD *a4)
{
  xpc_object_t value;
  void *v9;
  uint64_t v10;
  uint64_t v12;
  xpc_object_t reply;
  void *v14;
  size_t v15;
  char *string;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  value = xpc_dictionary_get_value(xdict, "names");
  if (!value)
    return 22;
  v9 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_array)
    return 22;
  v12 = sub_10002C0E4(a1, 4, 128, a2, 0, 0);
  if ((_DWORD)v12)
  {
    if ((v10 = v12, (_DWORD)v12 != 1)
      || !sub_10003E3D8(a1) && *(_UNKNOWN **)(a1 + 112) != &unk_1000715B8
      || (sub_100035A78(a2, v9) & 1) == 0)
    {
      sub_10002C1B8(a1, a2, v10, "disable service");
      return v10;
    }
  }
  reply = xpc_dictionary_create_reply(xdict);
  if (!reply)
    return 22;
  v14 = reply;
  if (xpc_array_get_count(v9))
  {
    v15 = 0;
    do
    {
      string = (char *)xpc_array_get_string(v9, v15);
      if (string)
      {
        v17 = string;
        v18 = sub_10002E41C(a1, string, 1);
        if ((_DWORD)v18)
        {
          v19 = v18;
          xpc_dictionary_set_int64(v14, v17, v18);
          xpc_strerror(v19);
          sub_100028C34(a1, 4, "Failed to disable service %s, error=%d - %s", v20, v21, v22, v23, v24, (char)v17);
        }
      }
      ++v15;
    }
    while (v15 < xpc_array_get_count(v9));
  }
  sub_100048018();
  v10 = 0;
  *a4 = v14;
  return v10;
}

uint64_t sub_100031DE4(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int right;
  const char *string;
  char *v13;
  xpc_object_t value;
  xpc_object_t reply;
  void *v16;
  _DWORD *v17;
  xpc_object_t v18;
  BOOL v19;

  if (!*(_QWORD *)(a1 + 952))
    return 125;
  v8 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 112)
                                                                                            + 104))(a1, 5, 0, *(_QWORD *)(a1 + 120), a2, 0, 0);
  if ((_DWORD)v8)
  {
    v9 = v8;
    sub_10002C1B8(a1, a2, v8, "query service enabled state");
  }
  else if (*(_WORD *)(a1 + 204))
  {
    v10 = *(_QWORD *)(a1 + 136);
    if (v10)
      right = xpc_mach_send_get_right(v10);
    else
      right = 0;
    sub_10003465C(a1, right, a3, 1);
    return 0;
  }
  else
  {
    string = xpc_dictionary_get_string(a3, "name");
    if (string
      && (v13 = (char *)string,
          value = xpc_dictionary_get_value(a3, "default-enabled"),
          (reply = xpc_dictionary_create_reply(a3)) != 0))
    {
      v16 = reply;
      v17 = sub_10002C4E4((_DWORD *)a1, v13);
      if (!v17)
      {
        v17 = (_DWORD *)sub_10003E404();
        if (v17)
          v17 = sub_10002C4E4(v17, v13);
      }
      xpc_dictionary_set_BOOL(v16, "loaded", v17 != 0);
      v18 = sub_10002E544(a1, v13);
      if (v18 == &_xpc_BOOL_true)
      {
        v19 = 0;
      }
      else
      {
        v19 = 1;
        if (v18 != &_xpc_BOOL_false && value)
          v19 = xpc_get_type(value) != (xpc_type_t)&_xpc_type_BOOL || xpc_BOOL_get_value(value);
      }
      xpc_dictionary_set_BOOL(v16, "enabled", v19);
      v9 = 0;
      *a4 = v16;
    }
    else
    {
      return 22;
    }
  }
  return v9;
}

uint64_t sub_100031FA8(uint64_t a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  _QWORD *v8;
  const char *string;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  int64_t int64;
  _BYTE *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t v22;
  uint64_t v23;
  _OWORD v24[64];

  v8 = *(_QWORD **)(a1 + 112);
  string = xpc_dictionary_get_string(xdict, "name");
  if (!string)
    return 22;
  v10 = (char *)string;
  v11 = sub_10002C0E4(a1, 4, (unint64_t)(v8 != qword_100071750) << 7, a2, 0, 0);
  if ((_DWORD)v11)
  {
    v12 = v11;
    sub_10002C1B8(a1, a2, v11, "kill service (%s)", v10);
    return v12;
  }
  int64 = xpc_dictionary_get_int64(xdict, "signal");
  if ((int64 - 32) < 0xFFFFFFE1 || !xpc_dictionary_expects_reply(xdict))
    return 22;
  v14 = sub_10002C4E4((_DWORD *)a1, v10);
  if (!v14)
  {
    v14 = sub_10002E7F0(a1, v10);
    if (!v14)
      return 113;
  }
  bzero(v24, 0x400uLL);
  sub_1000307EC(*(_DWORD *)(a2 + 20), (char *)v24);
  sub_10001D418((uint64_t)v14, 5, "%s: caller = %s, value = 0x%llx", v15, v16, v17, v18, v19, (char)"signal service");
  v20 = sub_100020D78((uint64_t)v14);
  if (!v20)
    return 3;
  if ((v14[1381] & 0x10) != 0)
    return 1;
  memset(v24, 0, 32);
  v12 = sub_100040A08(v20, (integer_t *)v24);
  if ((_DWORD)v12)
    return v12;
  if (*(_QWORD **)(a1 + 112) != qword_100071750
    || (v22 = *(_QWORD *)(a1 + 120), v22 >> 31)
    || (v23 = *(unsigned int *)(a2 + 20), (v23 & 0x80000000) != 0)
    || v22 != v23)
  {
    if (!sub_100018784((_OWORD *)a2, v24, int64))
      return 1;
  }
  v12 = sub_1000409A8(v24);
  if (!(_DWORD)v12)
    *a4 = xpc_dictionary_create_reply(xdict);
  return v12;
}

uint64_t sub_1000321D8(_DWORD *a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  const char *string;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  _DWORD *v21;

  v21 = a1;
  string = xpc_dictionary_get_string(xdict, "name");
  if (!string)
    return 22;
  v9 = (char *)string;
  if ((sub_10000FEF4(a2, 14) & 1) == 0)
  {
    v11 = 144;
    sub_10002C1B8((uint64_t)a1, a2, 144, "start service (%s)");
    return v11;
  }
  v10 = sub_10002C0E4((uint64_t)a1, 4, 8, a2, 0, 0);
  if ((_DWORD)v10)
  {
    v11 = v10;
    sub_10002C1B8((uint64_t)a1, a2, v10, "start service (%s)");
    return v11;
  }
  if (!xpc_dictionary_expects_reply(xdict))
    return 22;
  v12 = sub_100034520(&v21, v9);
  if (!v12)
    return 3;
  v19 = sub_1000203B0((uint64_t)v12, 10, v13, v14, v15, v16, v17, v18);
  if ((v19 & 0xFFFFFFFE) == 0x24)
    v11 = 0;
  else
    v11 = v19;
  if ((_DWORD)v11 == 37 || !(_DWORD)v11)
  {
    v11 = 0;
    *a4 = xpc_dictionary_create_reply(xdict);
  }
  return v11;
}

uint64_t sub_100032308(_DWORD *a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  const char *string;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _DWORD *v27;
  char v28[1024];

  v27 = a1;
  string = xpc_dictionary_get_string(xdict, "name");
  if (!string)
    return 22;
  v9 = (char *)string;
  if ((sub_10000FEF4(a2, 14) & 1) == 0)
  {
    v11 = 144;
    sub_10002C1B8((uint64_t)a1, a2, 144, "service stop (%s)");
    return v11;
  }
  v10 = sub_10002C0E4((uint64_t)a1, 4, 8, a2, 0, 0);
  if ((_DWORD)v10)
  {
    v11 = v10;
    sub_10002C1B8((uint64_t)a1, a2, v10, "service stop (%s)");
    return v11;
  }
  if (!xpc_dictionary_expects_reply(xdict))
    return 22;
  v12 = sub_100034520(&v27, v9);
  if (!v12)
    return 3;
  v13 = (uint64_t)v12;
  if (!sub_10001D840())
    return 1;
  bzero(v28, 0x400uLL);
  sub_1000307EC(*(_DWORD *)(a2 + 20), v28);
  sub_10001D418(v13, 5, "%s: caller = %s, value = 0x%llx", v14, v15, v16, v17, v18, (char)"legacy-stop service");
  v25 = sub_1000204AC(v13, a2, v19, v20, v21, v22, v23, v24);
  if (!(_DWORD)v25 || (v11 = v25, (_DWORD)v25 == 89) || (_DWORD)v25 == 37)
  {
    v11 = 0;
    *a4 = xpc_dictionary_create_reply(xdict);
  }
  return v11;
}

uint64_t sub_1000324C8(_DWORD *a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  const char *string;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  uint64_t v13;
  uint64_t v14;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _DWORD *v23;
  _OWORD v24[4];

  v23 = a1;
  string = xpc_dictionary_get_string(xdict, "name");
  if (!string)
    return 22;
  v9 = (char *)string;
  v10 = sub_10002C0E4((uint64_t)a1, 4, 128, a2, 0, 0);
  if ((_DWORD)v10)
  {
    v11 = v10;
    sub_10002C1B8((uint64_t)a1, a2, v10, "service remove (%s)");
    return v11;
  }
  if (!xpc_dictionary_expects_reply(xdict))
    return 22;
  v12 = sub_100034520(&v23, v9);
  if (!v12)
    return 3;
  v13 = (uint64_t)v12;
  v14 = sub_10001F090();
  if ((_DWORD)v14)
  {
    v11 = v14;
    sub_10002C1B8((uint64_t)v23, a2, v14, "service remove (%s)");
  }
  else
  {
    memset(v24, 0, sizeof(v24));
    v16 = sub_10003FBC0(a2, (char *)v24);
    sub_10001D418(v13, 5, "caller removing service: caller = %s[%d]", v17, v18, v19, v20, v21, v16);
    v22 = sub_100029C60((uint64_t)v23, v13);
    if ((_DWORD)v22 == 36 || (v11 = v22, !(_DWORD)v22))
    {
      v11 = 0;
      *a4 = xpc_dictionary_create_reply(xdict);
    }
  }
  return v11;
}

uint64_t sub_100032650(_DWORD *a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  char *string;
  _DWORD *v11;
  _QWORD *v12;
  xpc_object_t reply;
  xpc_object_t v14;
  xpc_object_t v15;
  uint64_t i;
  uint64_t j;
  xpc_object_t v18;
  int v19;
  uint64_t v20;
  _DWORD *v22;

  v8 = sub_10002C0E4((uint64_t)a1, 5, 8, a2, 0, 0);
  if ((_DWORD)v8)
  {
    v9 = v8;
    sub_10002C1B8((uint64_t)a1, a2, v8, "service enumeration");
  }
  else if (xpc_dictionary_expects_reply(a3))
  {
    string = (char *)xpc_dictionary_get_string(a3, "name");
    if (string)
    {
      v22 = a1;
      v11 = sub_100034520(&v22, string);
      if (!v11)
        return 113;
      v12 = v11;
      reply = xpc_dictionary_create_reply(a3);
      v14 = sub_100020DB0((uint64_t)v12);
      sub_100035BA4(v12, v14);
      xpc_dictionary_set_value(reply, "service", v14);
      xpc_release(v14);
    }
    else
    {
      reply = xpc_dictionary_create_reply(a3);
      v15 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_value(reply, "services", v15);
      xpc_release(v15);
      for (i = 0; i != 23; ++i)
      {
        for (j = *(_QWORD *)&a1[2 * i + 84]; j; j = *(_QWORD *)(j + 120))
        {
          v18 = xpc_dictionary_create(0, 0, 0);
          v19 = sub_100020D78(j);
          xpc_dictionary_set_int64(v18, "pid", v19);
          v20 = sub_10002153C(j);
          xpc_dictionary_set_int64(v18, "status", *(int *)(v20 + 28));
          xpc_dictionary_set_value(v15, (const char *)(j + 1392), v18);
          xpc_release(v18);
        }
      }
    }
    v9 = 0;
    *a4 = reply;
  }
  else
  {
    return 22;
  }
  return v9;
}

uint64_t sub_100032840(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  xpc_object_t value;
  void *v11;
  _QWORD v13[6];

  v8 = sub_10002C0E4(a1, 4, 8, a2, 0, 0);
  if ((_DWORD)v8)
  {
    v9 = v8;
    sub_10002C1B8(a1, a2, v8, "set domain environment");
  }
  else if (xpc_dictionary_expects_reply(a3)
         && (value = xpc_dictionary_get_value(a3, "envvars")) != 0
         && (v11 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary))
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_100035D84;
    v13[3] = &unk_10006CB48;
    v13[4] = a1;
    v13[5] = a2;
    xpc_dictionary_apply(v11, v13);
    v9 = 0;
    *a4 = xpc_dictionary_create_reply(a3);
  }
  else
  {
    return 22;
  }
  return v9;
}

uint64_t sub_10003294C(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  const char *string;
  const char *v11;
  _QWORD *v12;
  char *v13;
  xpc_object_t reply;

  v8 = sub_10002C0E4(a1, 5, 8, a2, 0, 0);
  if ((_DWORD)v8)
  {
    v9 = v8;
    sub_10002C1B8(a1, a2, v8, "get domain environment");
  }
  else if (xpc_dictionary_expects_reply(a3) && (string = xpc_dictionary_get_string(a3, "envvar")) != 0)
  {
    v11 = string;
    v12 = (_QWORD *)(a1 + 96);
    while (1)
    {
      v12 = (_QWORD *)*v12;
      if (!v12)
        break;
      if (sub_100019854((uint64_t)v12, v11))
      {
        v13 = sub_1000198B0((uint64_t)v12);
        reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_string(reply, "value", v13);
        v9 = 0;
        *a4 = reply;
        return v9;
      }
    }
    return 3;
  }
  else
  {
    return 22;
  }
  return v9;
}

uint64_t sub_100032A44(void **a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  uint64_t uint64;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _BOOL8 v20;
  int v21;
  const char *v22;
  const char *v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _BOOL4 v52;
  const char *v53;
  xpc_object_t reply;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  char v62;
  char v63;
  char v64[1024];

  uint64 = xpc_dictionary_get_uint64(xdict, "flags");
  if (a1[14] != &unk_1000715B8)
    return 125;
  v10 = uint64;
  if ((uint64 & 0x100000000000000) != 0)
    v11 = xpc_dictionary_get_uint64(xdict, "userreboot_purpose");
  else
    v11 = 0;
  v12 = sub_10002C0E4((uint64_t)a1, 4, 128, a2, 0, 0);
  if ((_DWORD)v12 == 150)
    v13 = 0;
  else
    v13 = v12;
  if (v13)
  {
    v9 = v12;
    if (v13 == 1)
    {
      if ((sub_10000FEF4(a2, 20) & 1) != 0)
        goto LABEL_12;
      v9 = 1;
    }
    sub_10002C1B8((uint64_t)a1, a2, v9, "reboot");
    return v9;
  }
LABEL_12:
  sub_10001140C(570425400);
  v9 = 22;
  if (xpc_dictionary_expects_reply(xdict) && (v10 & 2) == 0)
  {
    bzero(v64, 0x400uLL);
    sub_1000307EC(*(_DWORD *)(a2 + 20), v64);
    if ((v10 & 0x8000000000000000) != 0)
    {
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = "System reboot";
      v23 = "system reboot";
      goto LABEL_22;
    }
    if ((v10 & 0x2000000000000000) == 0)
    {
      if ((v10 & 0x4000000000000000) == 0)
      {
        v19 = 0;
        v20 = 0;
        v21 = 0;
        v22 = "System shutdown";
        v23 = "system shutdown";
        goto LABEL_22;
      }
      if (sub_10000FEF4(a2, 12))
      {
        v19 = 0;
        v20 = 0;
        v21 = 0;
        v22 = "Obliteration";
        v23 = "obliteration";
        goto LABEL_22;
      }
      return 144;
    }
    if (!sub_10000FEF4(a2, 18))
      return 144;
    if (sub_10000486C(7))
    {
      v46 = "cannot userspace reboot while in REM";
LABEL_34:
      sub_100028C34((uint64_t)a1, 65540, v46, v14, v15, v16, v17, v18, v61);
      return 45;
    }
    if ((v11 & 0xFFFFFFFFFFFFFFFELL) == 4)
    {
      if (!byte_100072480)
      {
        v46 = "attempted to enter REM in unsupported variant";
        goto LABEL_34;
      }
      sub_100028C34((uint64_t)a1, 65540, "attempting to enter REM", v14, v15, v16, v17, v18, v61);
      v52 = v11 == 5;
      v53 = (const char *)&unk_100056F87;
      if (v11 == 5)
        v53 = " (development)";
      sub_100028C34((uint64_t)a1, 65540, "attempting to enter REM%s", v47, v48, v49, v50, v51, (char)v53);
      v19 = 7;
    }
    else
    {
      v19 = 0;
      v52 = 0;
    }
    if ((v10 & 0x200000000000000) != 0)
      goto LABEL_51;
    v20 = v52;
    v21 = 1;
    v22 = "Userspace reboot";
    v23 = "userspace reboot";
LABEL_22:
    if ((v10 & 0x200000000000000) != 0)
    {
      if ((v10 & 0x4000000000000000) == 0 || !byte_1000729D9)
        goto LABEL_51;
    }
    else
    {
      sub_100028C34((uint64_t)a1, 196613, "%s initiated by: %s", v14, v15, v16, v17, v18, (char)v22);
      sub_100028C34((uint64_t)a1, 5, "%s: flags = 0x%llx, caller = %s", v25, v26, v27, v28, v29, (char)v23);
      if (byte_100072A45)
      {
        sub_100028C34((uint64_t)a1, 65540, "system is in sudden shutdown mode. All processes will be SIGKILLed immediately.", v30, v31, v32, v33, v34, v62);
        sub_100028C34((uint64_t)a1, 5, "system is in sudden shutdown mode. All processes will be SIGKILLed immediately.", v35, v36, v37, v38, v39, v63);
      }
      if ((v10 & 0x4000000000000000) == 0)
      {
        v40 = sub_10003E924((uint64_t)a1, v19);
        if ((_DWORD)v40)
        {
          v9 = v40;
          sub_100028C34((uint64_t)a1, 65539, "failed to persist services: %d", v41, v42, v43, v44, v45, v40);
          return v9;
        }
        v9 = sub_100013D48(v21, 0, v10);
        if ((_DWORD)v9)
          return v9;
        sub_100042BD0(v19);
        sub_100042BE8(v20);
        sub_100036074((mach_port_context_t)a1);
LABEL_51:
        v9 = 0;
        *a4 = xpc_dictionary_create_reply(xdict);
        return v9;
      }
      if (!byte_1000729D9)
      {
        reply = xpc_dictionary_create_reply(xdict);
        dword_1000725C0 = *(_DWORD *)(a2 + 20);
        sub_100035F74(a1, (uint64_t)reply, v55, v56, v57, v58, v59, v60);
        return 0;
      }
    }
    return 37;
  }
  return v9;
}

uint64_t sub_100032E60(uint64_t a1, uint64_t a2, xpc_object_t xdict, xpc_object_t *a4)
{
  uint64_t v4;
  int v9;
  int v10;
  int int64;
  uint64_t v12;
  xpc_object_t value;
  void *v14;
  xpc_object_t v16;
  void *v17;
  int64_t v18;
  int64_t v19;
  unint64_t v20;
  xpc_object_t empty;
  _QWORD v22[4];
  int v23;

  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  if (a2 && (v9 = *(_DWORD *)(a2 + 20), v9 != getpid()))
  {
    if (!xpc_dictionary_expects_reply(xdict))
      return 22;
    v10 = 0;
  }
  else
  {
    v10 = 1;
  }
  int64 = xpc_dictionary_get_int64(xdict, "which");
  if (!sub_100040380(int64))
    return 22;
  if (xpc_dictionary_get_BOOL(xdict, "print"))
  {
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 0x40000000;
    v22[2] = sub_1000362F8;
    v22[3] = &unk_10006CB88;
    v23 = int64;
    return sub_1000436FC(xdict, a4, (uint64_t)v22);
  }
  v12 = sub_10002C0E4(a1, 4, 8, a2, 0, 0);
  if ((_DWORD)v12)
  {
    v4 = v12;
    sub_10002C1B8(a1, a2, v12, "modify rlimits");
    return v4;
  }
  value = xpc_dictionary_get_value(xdict, "hardlimit");
  if (!value)
    return 22;
  v14 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_int64)
    return 22;
  v16 = xpc_dictionary_get_value(xdict, "softlimit");
  if (!v16)
    return 22;
  v17 = v16;
  if (xpc_get_type(v16) != (xpc_type_t)&_xpc_type_int64)
    return 22;
  v18 = xpc_int64_get_value(v14);
  v19 = xpc_int64_get_value(v17);
  if (v19 < 0)
    v20 = -1;
  else
    v20 = v19;
  if (v18 < 0)
    v18 = -1;
  sub_10004015C(int64, v20, v18, 0);
  if (v10)
  {
    empty = xpc_dictionary_create_empty();
    *a4 = empty;
    xpc_dictionary_set_int64(empty, "softlimit", v20);
    xpc_dictionary_set_int64(*a4, "hardlimit", v18);
    return 0;
  }
  else
  {
    v4 = 0;
    *a4 = xpc_dictionary_create_reply(xdict);
  }
  return v4;
}

uint64_t sub_100033084(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  _QWORD v11[6];

  v8 = sub_10002C0E4(a1, 5, 128, a2, 0, 0);
  if ((_DWORD)v8)
  {
    v9 = v8;
    sub_10002C1B8(a1, a2, v8, "domain print");
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_100036478;
    v11[3] = &unk_10006CBA8;
    v11[4] = a3;
    v11[5] = a1;
    return sub_1000436FC(a3, a4, (uint64_t)v11);
  }
  return v9;
}

uint64_t sub_100033148(_QWORD **a1, _OWORD *a2, void *a3)
{
  uint64_t v6;
  const char *string;
  const char *v8;
  xpc_object_t value;
  _QWORD v11[7];

  if ((sub_10000FEF4((uint64_t)a2, 2) & 1) != 0)
  {
    if (a1[14] == qword_100071750)
    {
      if (xpc_dictionary_expects_reply(a3) && (string = xpc_dictionary_get_string(a3, "path")) != 0)
      {
        v8 = string;
        v11[0] = _NSConcreteStackBlock;
        v11[1] = 0x40000000;
        v11[2] = sub_10003672C;
        v11[3] = &unk_10006CBE8;
        v11[4] = a1;
        v11[5] = sub_10001544C(string);
        v11[6] = xpc_dictionary_create_reply(a3);
        value = xpc_dictionary_get_value(a3, "overlay");
        sub_1000173D0(a1, v8, value, a2, (uint64_t)v11);
        return 0;
      }
      else
      {
        return 22;
      }
    }
    else
    {
      return 125;
    }
  }
  else
  {
    v6 = 144;
    sub_10002C1B8((uint64_t)a1, (uint64_t)a2, 144, "pid-extend");
  }
  return v6;
}

uint64_t sub_100033270(void **a1, uint64_t a2, void *a3)
{
  uint64_t v3;
  const char *string;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  xpc_object_t reply;
  NSObject *v15;
  _QWORD *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t i;
  uint64_t j;
  char *v27;
  char *v28;
  _DWORD *v29;
  _OWORD v31[4];

  if (a1[14] != &unk_1000715B8)
    return 125;
  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if ((sub_10000FEF4(a2, 2) & 1) == 0)
  {
    v3 = 144;
    sub_10002C1B8((uint64_t)a1, a2, 144, "extension removal");
    return v3;
  }
  string = xpc_dictionary_get_string(a3, "name");
  if (!string)
    return 22;
  v8 = (char *)string;
  memset(v31, 0, sizeof(v31));
  sub_10003FBC0(a2, (char *)v31);
  sub_100028C34((uint64_t)a1, 5, "%s: caller = %s.%d, extension = %s", v9, v10, v11, v12, v13, (char)"remove all extension instances");
  reply = xpc_dictionary_create_reply(a3);
  v15 = dispatch_group_create();
  dispatch_group_enter(v15);
  v16 = sub_10001952C(a1, 19, (uint64_t)v15, (uint64_t)reply);
  v17 = sub_1000146E4();
  dispatch_group_notify_f(v15, v17, v16, (dispatch_function_t)sub_1000367C8);
  v23 = 0;
  v24 = 0;
  for (i = 0; i != 11; ++i)
  {
    for (j = qword_100071750[i]; j; j = *(_QWORD *)(j + 32))
    {
      v27 = sub_10002C4E4((_DWORD *)j, v8);
      if (v27)
      {
        if (sub_100036848(*((_QWORD *)v27 + 31), (uint64_t)v27, v15) != 36)
          ++v23;
        ++v24;
      }
    }
  }
  if (!v24)
  {
    v28 = sub_10002C4E4(a1, v8);
    if (v28 || (v29 = (_DWORD *)sub_10003E404()) != 0 && (v28 = sub_10002C4E4(v29, v8)) != 0)
    {
      sub_100036848(*((_QWORD *)v28 + 31), (uint64_t)v28, v15);
      LOBYTE(v24) = 1;
    }
    else
    {
      xpc_dictionary_set_int64(reply, "error", 3);
      LOBYTE(v24) = 0;
    }
  }
  sub_100028C34((uint64_t)a1, 5, "total of %lu extension (%s) instances were found to remove, of which %lu were removed instantly", v18, v19, v20, v21, v22, v24);
  dispatch_group_leave(v15);
  return 0;
}

uint64_t sub_1000334D8(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v4;
  xpc_object_t value;
  void *v10;
  xpc_object_t reply;
  void *v13;
  xpc_object_t v14;
  uint64_t i;
  uint64_t j;
  size_t v17;
  char *string;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  xpc_object_t v23;
  _QWORD v24[2];
  uint64_t v25;

  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  if ((sub_10000FEF4(a2, 2) & 1) != 0)
  {
    value = xpc_dictionary_get_value(a3, "names");
    if (value
      && (v10 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
      && (reply = xpc_dictionary_create_reply(a3)) != 0)
    {
      v13 = reply;
      v14 = xpc_array_create(0, 0);
      for (i = 0; i != 11; ++i)
      {
        for (j = qword_100071750[i]; j; j = *(_QWORD *)(j + 32))
        {
          if (xpc_array_get_count(v10))
          {
            v17 = 0;
            do
            {
              string = (char *)xpc_array_get_string(v10, v17);
              if (string)
              {
                v19 = sub_10002C4E4((_DWORD *)j, string);
                if (v19)
                {
                  v20 = (uint64_t)v19;
                  if (!*((_DWORD *)v19 + 74))
                  {
                    v21 = sub_100020D78((uint64_t)v19);
                    if ((_DWORD)v21)
                    {
                      v24[0] = 0;
                      v24[1] = 0;
                      v25 = 0;
                      v22 = memorystatus_control(1, v21, 0, v24, 24);
                      if (v22)
                      {
                        if (v22 == 24)
                        {
                          if ((v25 & 0x4000000000) != 0)
                          {
                            v23 = sub_10002102C(v20, 0);
                            xpc_array_set_value(v14, 0xFFFFFFFFFFFFFFFFLL, v23);
                            xpc_release(v23);
                          }
                        }
                        else
                        {
                          _os_assumes_log_ctx(sub_10001F174, v20);
                        }
                      }
                    }
                  }
                }
              }
              ++v17;
            }
            while (v17 < xpc_array_get_count(v10));
          }
        }
      }
      xpc_dictionary_set_value(v13, "instances", v14);
      xpc_release(v14);
      v4 = 0;
      *a4 = v13;
    }
    else
    {
      return 22;
    }
  }
  else
  {
    v4 = 144;
    sub_10002C1B8(a1, a2, 144, "copy busy extensions");
  }
  return v4;
}

uint64_t sub_1000336F4(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v9;
  _QWORD v11[5];

  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  v9 = sub_10002C0E4(a1, 5, 128, a2, 0, 0);
  if ((_DWORD)v9)
  {
    v4 = v9;
    sub_10002C1B8(a1, a2, v9, "dump state");
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_10003692C;
    v11[3] = &unk_10006CC08;
    v11[4] = a1;
    return sub_1000436FC(a3, a4, (uint64_t)v11);
  }
  return v4;
}

uint64_t sub_1000337EC(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v4;
  unsigned int uint64;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int right;
  xpc_object_t reply;
  xpc_object_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const char *v25;

  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  uint64 = xpc_dictionary_get_uint64(a3, "uid");
  if ((*(_BYTE *)(qword_100072478 + 1016) & 1) != 0)
  {
    v4 = 124;
    sub_10002C1B8(a1, a2, 124, "get user context");
  }
  else
  {
    v10 = uint64;
    v11 = uint64;
    v12 = off_1000716A8(0, 1, 256, uint64, a2, 0, 0);
    if ((_DWORD)v12)
    {
      v4 = v12;
      sub_10002C1B8(a1, a2, v12, "get user context");
    }
    else
    {
      v14 = sub_10002E19C(qword_100071640, v11);
      if (!v14)
      {
        v14 = (uint64_t)sub_100036934(v10, a2);
        if (!v14)
          sub_10004D708(0, v15, v16, v17);
      }
      if (*(_WORD *)(v14 + 204))
      {
        v18 = *(_QWORD *)(a1 + 136);
        if (v18)
          right = xpc_mach_send_get_right(v18);
        else
          right = 0;
        sub_10003465C(v14, right, a3, 1);
        return 0;
      }
      else
      {
        reply = xpc_dictionary_create_reply(a3);
        v21 = reply;
        v22 = *(_QWORD *)(v14 + 976);
        v23 = v14 + 88;
        do
          v23 = *(_QWORD *)v23;
        while (v23 && *(_DWORD *)(v23 + 20) != 4);
        if (!v22)
          v22 = v14;
        v24 = v22 + 88;
        v25 = "bootstrap";
        while (1)
        {
          v24 = *(_QWORD *)v24;
          if (!v24)
            break;
          if (*(_DWORD *)(v24 + 20) == 128)
          {
            xpc_dictionary_set_mach_send(reply, "bootstrap", *(unsigned int *)(v23 + 16));
            v25 = "exception";
            v23 = v24;
            break;
          }
        }
        xpc_dictionary_set_mach_send(v21, v25, *(unsigned int *)(v23 + 16));
        v4 = 0;
        *a4 = v21;
      }
    }
  }
  return v4;
}

uint64_t sub_1000339DC(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v9;
  _QWORD v11[5];

  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  v9 = sub_10002C0E4(a1, 5, 128, a2, 0, 0);
  if ((_DWORD)v9)
  {
    v4 = v9;
    sub_10002C1B8(a1, a2, v9, "dump jetsam property category");
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    v11[2] = sub_10003698C;
    v11[3] = &unk_10006CC28;
    v11[4] = a1;
    return sub_1000436FC(a3, a4, (uint64_t)v11);
  }
  return v4;
}

uint64_t sub_100033ABC(uint64_t a1, void *a2, _QWORD *a3)
{
  unsigned int uint64;
  unsigned int v7;
  uint64_t v8;
  uint64_t result;
  xpc_object_t reply;

  if (!xpc_dictionary_expects_reply(a2))
    return 22;
  uint64 = xpc_dictionary_get_uint64(a2, "uid");
  if ((*(_BYTE *)(qword_100072478 + 1016) & 1) != 0)
    return 124;
  v7 = uint64;
  v8 = uint64;
  result = off_1000716A8(0, 1, 256, uint64, a1, 0, 0);
  if (!(_DWORD)result)
  {
    if (sub_10002E19C(qword_100071640, v8))
    {
      return 17;
    }
    else
    {
      sub_100036934(v7, a1);
      reply = xpc_dictionary_create_reply(a2);
      result = 0;
      *a3 = reply;
    }
  }
  return result;
}

uint64_t sub_100033B9C(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  uint64_t v8;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD v16[4];

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  if (!sub_10000FEF4(a2, 18))
    return 144;
  memset(v16, 0, sizeof(v16));
  v10 = sub_10003FBC0(a2, (char *)v16);
  sub_100028C34(a1, 196613, "Active user switch initiated by: %s[%d]", v11, v12, v13, v14, v15, v10);
  v8 = sub_10003E5E8(a1);
  if (!(_DWORD)v8)
    *a4 = xpc_dictionary_create_reply(a3);
  return v8;
}

uint64_t sub_100033CA0(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  uint64_t v8;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD v16[4];

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  if (!sub_10000FEF4(a2, 18))
    return 144;
  memset(v16, 0, sizeof(v16));
  v10 = sub_10003FBC0(a2, (char *)v16);
  sub_100028C34(a1, 196613, "Active user login, initiated by: %s[%d]", v11, v12, v13, v14, v15, v10);
  v8 = sub_10003E664(a1);
  if (!(_DWORD)v8)
    *a4 = xpc_dictionary_create_reply(a3);
  return v8;
}

uint64_t sub_100033DA4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v6;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  xpc_object_t reply;
  _OWORD v15[4];

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  if (!sub_10000FEF4(a2, 18))
    return 144;
  memset(v15, 0, sizeof(v15));
  v8 = sub_10003FBC0(a2, (char *)v15);
  sub_100028C34(a1, 196613, "Active user logout, initiated by: %s[%d]", v9, v10, v11, v12, v13, v8);
  reply = xpc_dictionary_create_reply(a3);
  v6 = sub_10003E424(a1, reply);
  xpc_release(reply);
  return v6;
}

uint64_t sub_100033EAC(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  xpc_object_t value;
  void *v9;
  uint64_t v10;
  xpc_object_t v12;
  void *v13;
  char v14;
  char v15;
  _QWORD *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  _QWORD *v28;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  value = xpc_dictionary_get_value(a3, "properties");
  if (!value)
    return 22;
  v9 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    return 22;
  v12 = xpc_dictionary_get_value(a3, "flags");
  if (!v12)
    return 22;
  v13 = v12;
  if (xpc_get_type(v12) != (xpc_type_t)&_xpc_type_uint64)
    return 22;
  v14 = xpc_uint64_get_value(v13);
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  v15 = v14;
  v27 = 0;
  v28 = 0;
  v10 = sub_100036A5C(v9, &v28, (uint64_t *)&v27);
  v26 = v10;
  if (!(_DWORD)v10)
  {
    v17 = v27;
    v16 = v28;
    v18 = sub_100036B74(v28, v27, a2);
    if (v18)
    {
      sub_100028C34(v18, 5, "Domain creation failed: it already exists", v19, v20, v21, v22, v23, v25);
      return 37;
    }
    else
    {
      sub_100036BF0(v16, v17, 0, v15, a2, (int *)&v26);
      v10 = v26;
      if (v26)
      {
        v24 = (const char *)xpc_strerror(v26);
        sub_100040F68(4, "Domain creation failed: %d %s", v10, v24);
      }
      else
      {
        *a4 = xpc_dictionary_create_reply(a3);
      }
    }
  }
  return v10;
}

uint64_t sub_100034024(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v15;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if ((*(_BYTE *)(a1 + 1016) & 3) != 0)
  {
    v8 = 124;
LABEL_6:
    sub_10002C1B8(a1, a2, v8, "unpend launches");
    return v8;
  }
  v8 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 112)
                                                                                            + 104))(a1, 4, 0, *(_QWORD *)(a1 + 120), a2, 0, 0);
  if ((_DWORD)v8)
    goto LABEL_6;
  if ((*(_BYTE *)(a1 + 1017) & 0x80) == 0)
    return 37;
  sub_100028C34(a1, 5, "unpending launches", v9, v10, v11, v12, v13, v15);
  *(_DWORD *)(a1 + 1016) &= ~0x8000u;
  sub_10002981C(a1);
  v8 = 0;
  *a4 = xpc_dictionary_create_reply(a3);
  return v8;
}

uint64_t sub_100034118(_QWORD *a1, uint64_t a2, void *a3, _QWORD *a4)
{
  const char *string;
  const char *v9;
  xpc_object_t empty;
  xpc_object_t reply;
  uint64_t result;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  string = xpc_dictionary_get_string(a3, "query");
  if (!string)
    return 22;
  v9 = string;
  empty = xpc_array_create_empty();
  sub_100036E34(a1, v9, empty, a2);
  reply = xpc_dictionary_create_reply(a3);
  xpc_dictionary_set_value(reply, "services", empty);
  xpc_release(empty);
  result = 0;
  *a4 = reply;
  return result;
}

uint64_t sub_1000341C4(uint64_t a1, uint64_t a2, void *a3, xpc_object_t *a4)
{
  const char *string;
  uint64_t v9;

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if ((sub_10000FEF4(a2, 4) & 1) != 0)
  {
    string = xpc_dictionary_get_string(a3, "mount-point");
    v9 = sub_10000E6D4(string);
    if (!(_DWORD)v9)
      *a4 = xpc_dictionary_create_reply(a3);
  }
  else
  {
    v9 = 144;
    sub_10002C1B8(a1, a2, 144, "load-jetsam-properties");
  }
  return v9;
}

uint64_t sub_10003426C(uint64_t a1, uint64_t a2, void *a3)
{
  const char *string;
  const char *v8;
  NSObject *v9;
  xpc_object_t reply;
  NSObject *v11;
  _QWORD block[7];

  if (!xpc_dictionary_expects_reply(a3))
    return 22;
  if (!sub_10000FEF4(a2, 32))
    return 144;
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    return 125;
  string = xpc_dictionary_get_string(a3, "cryptex");
  if (!string)
    return 22;
  v8 = string;
  v9 = dispatch_group_create();
  dispatch_group_enter(v9);
  reply = xpc_dictionary_create_reply(a3);
  v11 = sub_1000146E4();
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100036F5C;
  block[3] = &unk_10006CC48;
  block[4] = reply;
  block[5] = a1;
  block[6] = v9;
  dispatch_group_notify(v9, v11, block);
  sub_100036FB0(a1, v8, v9, a2);
  dispatch_group_leave(v9);
  return 0;
}

uint64_t sub_100034388(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  char v14;

  v8 = *(_DWORD *)(a1 + 1016);
  if ((v8 & 4) != 0)
    return 37;
  if ((v8 & 3) != 0)
  {
    sub_100028C34(a1, 5, "domain shutting down, not uncorking", a4, a5, a6, a7, a8, v14);
    return 124;
  }
  else if ((v8 & 8) != 0 && *(_QWORD *)(a1 + 248))
  {
    sub_100028C34(a1, 5, "uncorking domain", a4, a5, a6, a7, a8, v14);
    sub_100011420(570425364, *(_QWORD *)(a1 + 120));
    sub_100016D38((_QWORD *)a1, 1, 0, *(void **)(a1 + 248), a2, 9216, v12, v13);
    xpc_release(*(xpc_object_t *)(a1 + 248));
    result = 0;
    *(_QWORD *)(a1 + 248) = 0;
    *(_DWORD *)(a1 + 1016) |= 4u;
  }
  else
  {
    sub_100028C34(a1, 5, "domain is not initialized, can't uncork", a4, a5, a6, a7, a8, v14);
    return 131;
  }
  return result;
}

xpc_object_t sub_100034468(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  xpc_object_t result;
  char v21;
  char v22[1024];

  bzero(v22, 0x400uLL);
  sub_1000307EC(*(_DWORD *)(a2 + 20), v22);
  sub_100028C34(a1, 65541, "bootout initiated by: %s", v8, v9, v10, v11, v12, (char)v22);
  sub_1000290BC(a1, v13, v14, v15, v16, v17, v18, v19, v21);
  result = xpc_dictionary_create_reply(a3);
  *a4 = result;
  return result;
}

_DWORD *sub_100034520(_DWORD **a1, char *a2)
{
  _DWORD *result;
  _DWORD *v5;

  result = sub_10002C4E4(*a1, a2);
  if (!result)
  {
    if (*((_UNKNOWN **)*a1 + 14) == &unk_1000715B8)
    {
      result = (_DWORD *)sub_10003E404();
      if (result)
      {
        v5 = result;
        result = sub_10002C4E4(result, a2);
        if (result)
          *a1 = v5;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void sub_100034590(char *a1, xpc_object_t object, uint64_t a3)
{
  const char *string_ptr;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char **v14;
  uint64_t v15;
  size_t v16;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    v16 = 0;
    string_ptr = xpc_string_get_string_ptr(object);
    v7 = sub_10001967C(a1, string_ptr, 0, &v16, 0);
    if (v7)
    {
      v15 = *(_QWORD *)(a3 + 96);
      v14 = (char **)(a3 + 96);
      v13 = v15;
      *(_QWORD *)v7 = v15;
      if (v15)
        *(_QWORD *)(v13 + 8) = v7;
      *v14 = v7;
      *((_QWORD *)v7 + 1) = v14;
    }
    else
    {
      sub_100028C34(a3, 3, "Service attempted to %s environment variable with reserved name: %s", v8, v9, v10, v11, v12, (char)"set");
    }
  }
}

xpc_object_t sub_10003465C(uint64_t a1, int a2, void *a3, int a4)
{
  _DWORD *v8;
  xpc_object_t result;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;

  v8 = sub_10001389C(0x30uLL);
  v8[4] = a2;
  result = xpc_retain(a3);
  *((_QWORD *)v8 + 3) = result;
  v8[8] = a4;
  if (!a1)
    sub_10004D738();
  v12 = *(_QWORD *)(a1 + 208);
  v11 = (_QWORD *)(a1 + 208);
  v10 = v12;
  *(_QWORD *)v8 = v12;
  if (v12)
    *(_QWORD *)(v10 + 8) = v8;
  *v11 = v8;
  *((_QWORD *)v8 + 1) = v11;
  return result;
}

uint64_t sub_1000346D4(uint64_t a1, char *a2, uint64_t a3, unint64_t a4, unsigned __int8 *a5, unint64_t a6, uint64_t a7)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _OWORD v29[4];

  v12 = sub_10001FB38(*(_DWORD *)(a7 + 20));
  if (v12)
  {
    v13 = v12;
    if ((sub_100021604(v12) & 1) != 0)
      return 0;
    if ((*(_BYTE *)(v13 + 369) & 0x80) != 0)
      return 0;
  }
  v15 = a1;
  if ((a4 & 8) != 0)
  {
    v15 = a1;
    if (sub_1000157A8(*(char **)(a1 + 968), "PostLogOutSync"))
      v15 = sub_10002FEE8(a1);
  }
  while (1)
  {
    if (sub_1000157A8(*(char **)(a1 + 968), "PostLogOutSync")
      && (*(_UNKNOWN **)(v15 + 112) == &unk_1000715B8 || sub_10003E3D8(v15))
      && !sub_100018738((_OWORD *)a7, (uint64_t)"mach-cross-domain-lookup", 1))
    {
      v14 = 0;
      v17 = 1;
      goto LABEL_31;
    }
    v14 = sub_100034C00(v15, a2, a3, a4, a5, a6, a7, 1);
    v17 = v16;
    if ((a4 & 0x10) != 0 || v16 != 3 || *(_QWORD **)(a1 + 112) == qword_100071750)
      break;
    v15 = sub_10002FEE8(v15);
    if (!v15)
    {
      if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8
        || !sub_1000480EC(a2)
        || ((v18 = sub_10003E404()) == 0
          ? (v14 = 0, v17 = 3)
          : (v14 = sub_100034C00(v18, a2, a3, a4, a5, a6, a7, 0), v17 = v19),
            (_DWORD)v17))
      {
        v14 = 0;
        v17 = 3;
        goto LABEL_31;
      }
      memset(v29, 0, sizeof(v29));
      sub_10003FBC0(a7, (char *)v29);
      sub_100028C34(a1, 4, "rerouted lookup to a foreground user endpoint: name = %s, caller = %s[%d]", v20, v21, v22, v23, v24, (char)a2);
      break;
    }
  }
  if (!(_DWORD)v17)
  {
    if (v14)
    {
      v25 = *(_QWORD *)(v14 + 96);
      if (v25)
      {
        if ((*(_QWORD *)(v25 + 1384) & 1) != 0)
        {
          v17 = 3;
          v14 = 0;
        }
      }
    }
  }
LABEL_31:
  if ((_DWORD)v17)
    sub_100034A70(a1, (uint64_t)a2, a5, a3, a4, a7, v17);
  return v14;
}

xpc_object_t sub_100034964(void *a1, uint64_t a2, int a3)
{
  xpc_object_t reply;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;

  if (a3)
  {
    reply = xpc_dictionary_create_reply(a1);
    xpc_dictionary_set_int64(reply, "error", a3);
  }
  else
  {
    reply = xpc_dictionary_create_reply(a1);
    v12 = (void *)sub_10004616C(a2, 1, v6, v7, v8, v9, v10, v11);
    xpc_dictionary_set_value(reply, "port", v12);
    if (*(char *)(a2 + 88) < 0)
      xpc_dictionary_set_BOOL(reply, "non-launching", 1);
  }
  return reply;
}

uint64_t sub_1000349F4(uint64_t a1, int a2, char *a3, uint64_t a4, unint64_t a5, unsigned __int8 *a6, unint64_t a7, uint64_t a8)
{
  uint64_t result;
  int v15;

  if (!a2)
    return 0;
  result = sub_10003E404();
  if (result)
  {
    sub_100034C00(result, a3, a4, a5, a6, a7, a8, 0);
    return v15 == 0;
  }
  return result;
}

void sub_100034A70(uint64_t a1, uint64_t a2, const unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  void **v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void **v20;
  const char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  _OWORD v46[4];
  char out[40];

  if ((_DWORD)a7 != 145)
  {
    v13 = (void **)sub_1000106C8(0x100uLL);
    v20 = v13;
    v21 = "failed lookup";
    if ((_DWORD)a7 == 159)
      v21 = "denied lookup";
    sub_100010740((uint64_t)v13, "%s: name = %s, ", v14, v15, v16, v17, v18, v19, (char)v21);
    if (a4)
      sub_100010740((uint64_t)v20, "handle = %llu, ", v22, v23, v24, v25, v26, v27, a4);
    memset(out, 0, 37);
    if ((a5 & 0x24) != 0)
    {
      uuid_unparse(a3, out);
      sub_100010740((uint64_t)v20, "instance = %s, ", v28, v29, v30, v31, v32, v33, (char)out);
    }
    else if (!a5)
    {
LABEL_10:
      memset(v46, 0, sizeof(v46));
      v34 = sub_10003FBC0(a6, (char *)v46);
      xpc_strerror(a7);
      sub_100010740((uint64_t)v20, "requestor = %s[%d], error = %d: %s", v35, v36, v37, v38, v39, v40, v34);
      sub_100028C34(a1, 4, "%s", v41, v42, v43, v44, v45, (char)*v20);
      sub_100010718(v20);
      return;
    }
    sub_100010740((uint64_t)v20, "flags = 0x%llx, ", v22, v23, v24, v25, v26, v27, a5);
    goto LABEL_10;
  }
}

uint64_t sub_100034C00(uint64_t a1, char *a2, uint64_t a3, unint64_t a4, unsigned __int8 *a5, unint64_t a6, uint64_t a7, int a8)
{
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char v67;
  uint64_t v68;
  uint64_t v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;

  v68 = a1;
  if (*(_QWORD *)(a1 + 976))
    v14 = *(_QWORD *)(a1 + 976);
  else
    v14 = a1;
  if ((a4 & 2) != 0)
  {
    if (a8 && !sub_100018738((_OWORD *)a7, (uint64_t)"mach-lookup", 2))
      goto LABEL_47;
    *(_QWORD *)&v70 = a1;
    v22 = sub_1000352F4((uint64_t *)&v70, a3, 0);
    if (v22)
      goto LABEL_14;
    v29 = sub_10001FB38(a3);
    if (!v29)
      goto LABEL_32;
    v22 = v29;
    v30 = *(_QWORD *)(v29 + 248);
    if (*(_QWORD **)(v30 + 112) != qword_100071750)
      goto LABEL_14;
    v31 = (uint64_t *)(v30 + 88);
    do
      v31 = (uint64_t *)*v31;
    while (v31 && *((_DWORD *)v31 + 5) != 4);
    v69 = sub_1000306AC(qword_100072478, *((unsigned int *)v31 + 4));
    if (v69)
      v22 = sub_1000352F4(&v69, a3, 1);
    if (v22)
    {
LABEL_14:
      v23 = *(_QWORD *)(v22 + 168);
      if (v23)
      {
        while ((*(_BYTE *)(v23 + 88) & 0x40) != 0 || !sub_1000157A8((char *)(v23 + 168), a2))
        {
          v23 = *(_QWORD *)(v23 + 16);
          if (!v23)
            goto LABEL_18;
        }
        goto LABEL_23;
      }
LABEL_18:
      sub_100028C34(a1, 5, "could not find endpoint in pid namespace: pid = %d, name = %s", v17, v18, v19, v20, v21, a3);
    }
    else
    {
LABEL_32:
      sub_100028C34(a1, 5, "could not find active service for lookup: pid = %d, name = %s", v17, v18, v19, v20, v21, a3);
    }
    goto LABEL_33;
  }
  if ((a4 & 0x10) != 0)
  {
    *(_QWORD *)&v70 = a1;
    v24 = sub_1000352F4((uint64_t *)&v70, *(_DWORD *)(a7 + 20), 0);
    if (!v24)
    {
      v23 = 0;
      v28 = 113;
      goto LABEL_66;
    }
    v25 = sub_100023950(v24, a2);
    if (v25)
    {
      v26 = sub_10003A74C(v25, a3);
      if (v26)
      {
        v27 = sub_1000124EC(v26);
        v23 = sub_10002E900(v27, v27, a2);
        if (v23)
        {
LABEL_23:
          v28 = 0;
          goto LABEL_66;
        }
LABEL_34:
        v28 = 3;
        goto LABEL_66;
      }
    }
LABEL_33:
    v23 = 0;
    goto LABEL_34;
  }
  if ((a4 & 0x24) != 0)
  {
    if (*(_QWORD **)(v14 + 112) == qword_100071750)
    {
      if (a8 && !sub_100018738((_OWORD *)a7, (uint64_t)"mach-lookup", 3))
        goto LABEL_47;
    }
    else if (a8 && !sub_100018738((_OWORD *)a7, (uint64_t)"mach-lookup", 1))
    {
LABEL_47:
      v23 = 0;
      v28 = 159;
      goto LABEL_66;
    }
    v32 = sub_10002E860(v14, a2);
    v23 = v32;
    v28 = v33;
    if (v33)
    {
      if (v33 != 3)
        goto LABEL_66;
      v32 = sub_1000351B0(v14, a2);
      if (!v32)
        goto LABEL_66;
    }
    if (*(_QWORD *)(v32 + 72))
    {
      sub_100028C34(v14, 3, "Cannot look up instances for shared endpoints.", v17, v18, v19, v20, v21, v67);
LABEL_65:
      v23 = 0;
      v28 = 137;
      goto LABEL_66;
    }
    v34 = sub_1000463E0(v32);
    v40 = v34;
    if ((*(_BYTE *)(v34 + 369) & 2) != 0)
    {
      sub_10001D418(v34, 3, "Cannot look up instances for sub-instances.", v35, v36, v37, v38, v39, v67);
      goto LABEL_65;
    }
    v41 = sub_1000239E8(v34, a5);
    if (!v41)
    {
      if (sub_1000239C4(v40, 1))
      {
        v23 = 0;
        v28 = 45;
        goto LABEL_66;
      }
      *(_QWORD *)&v71 = 0;
      v70 = a6;
      LODWORD(v69) = 0;
      v41 = (uint64_t)sub_100029E2C(*(_QWORD *)(v40 + 248), v40, a5, (a4 >> 5) & 1, (uint64_t *)&v70, (_OWORD *)a7, (int *)&v69);
      if (!v41)
      {
        v23 = 0;
        if ((_DWORD)v69)
          v28 = v69;
        else
          v28 = 137;
        goto LABEL_66;
      }
    }
    v23 = *(_QWORD *)(v41 + 184);
    if (v23)
    {
      v28 = 3;
      while ((*(_BYTE *)(v23 + 88) & 0x40) != 0 || !sub_1000157A8((char *)(v23 + 168), a2))
      {
        v23 = *(_QWORD *)(v23 + 16);
        if (!v23)
          goto LABEL_66;
      }
      goto LABEL_23;
    }
    goto LABEL_34;
  }
  if ((a4 & 0x100) == 0)
  {
    if (*(_QWORD **)(v14 + 112) == qword_100071750)
    {
      if (a8 && !sub_100018738((_OWORD *)a7, (uint64_t)"mach-lookup", 3))
        goto LABEL_88;
    }
    else if (a8 && !sub_100018738((_OWORD *)a7, (uint64_t)"mach-lookup", 1))
    {
LABEL_88:
      v23 = 0;
      v28 = 159;
      goto LABEL_61;
    }
  }
  v23 = sub_10002E860(v14, a2);
  v28 = v42;
LABEL_61:
  if (v28 == 3)
  {
    v43 = sub_1000351B0(v14, a2);
    if (v43)
    {
      v44 = a4 & 0x100;
      goto LABEL_68;
    }
  }
LABEL_66:
  if (v28)
    return v23;
  v44 = a4 & 0x100;
  v43 = v23;
LABEL_68:
  if (*(_QWORD *)(v43 + 72))
    v23 = *(_QWORD *)(v43 + 72);
  else
    v23 = v43;
  if (v44)
  {
    v50 = sub_10001FB38(*(_DWORD *)(a7 + 20));
    if (!v50)
    {
      sub_100028C34(v68, 5, "Unable to find managed service for pid %d. Trying unmanaged services", v45, v46, v47, v48, v49, *(_DWORD *)(a7 + 20));
      v50 = sub_100035200(&v68, *(_DWORD *)(a7 + 20));
    }
    v51 = sub_1000463E0(v23);
    if (!v50 || v50 != v51)
      goto LABEL_79;
  }
  if ((a4 & 8) == 0 || sub_10003E3D8(v14) || *(_UNKNOWN **)(v14 + 112) == &unk_1000715B8)
  {
    if ((a4 & 0x200) != 0 || ((a4 >> 7) & 1) == *(unsigned __int8 *)(v23 + 88) >> 7)
    {
      v52 = sub_10004616C(v23, 1, v16, v17, v18, v19, v20, v21);
      if (v52)
      {
        if (!v23)
          sub_10004D708(v52, v53, v54, v55);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      v72 = 0u;
      v73 = 0u;
      v70 = 0u;
      v71 = 0u;
      sub_10003FBC0(a7, (char *)&v70);
      sub_100028C34(v14, 4, "failed lookup due to non-launching property mismatch: name = %s, requestor = %s.%d", v56, v57, v58, v59, v60, (char)a2);
      sub_10003FBC0(a7, (char *)&v70);
      sub_100028C34(v14, 5, "failed lookup due to non-launching property mismatch: name = %s, requestor = %s.%d", v61, v62, v63, v64, v65, (char)a2);
      return 0;
    }
  }
  else
  {
LABEL_79:
    sub_100034A70(v14, (uint64_t)a2, a5, a3, a4, a7, 1);
    return 0;
  }
  return v23;
}

uint64_t sub_1000351B0(uint64_t a1, char *a2)
{
  char *v4;

  if (*(_QWORD **)(a1 + 112) == qword_100071750 && (v4 = sub_10002C4E4((_DWORD *)a1, a2)) != 0)
    return sub_10002A1A8(a1, (uint64_t)v4);
  else
    return 0;
}

uint64_t sub_100035200(uint64_t *a1, int a2)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t i;
  int v6;
  int v7;
  int v9;
  int v10;

  v9 = a2;
  v3 = sub_1000158C8(&v9, 4);
  v4 = *a1;
  i = *(_QWORD *)(*a1 + 8 * (v3 % 0xD) + 544);
  if (i)
  {
    while (1)
    {
      v6 = sub_100020D78(i);
      v7 = v9;
      if (v6 == v9)
        break;
      i = *(_QWORD *)(i + 88);
      if (!i)
      {
        v4 = *a1;
        goto LABEL_6;
      }
    }
  }
  else
  {
    v7 = v9;
LABEL_6:
    v10 = v7;
    for (i = *(_QWORD *)(v4 + 8 * (sub_1000158C8(&v10, 4) % 7uLL) + 648); i; i = *(_QWORD *)(i + 88))
    {
      if (*(_DWORD *)(i + 296) == v10)
        break;
    }
  }
  return i;
}

size_t sub_1000352F4(uint64_t *a1, int a2, int a3)
{
  uint64_t v6;
  size_t result;
  void *v8;
  int v9;
  size_t v10;
  size_t v11;
  BOOL v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  _OWORD buffer[4];
  char __str[16];
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;

  v6 = sub_100035200(a1, a2);
  if (v6)
    return v6;
  if (sub_10001FBF0(a2))
  {
    v6 = sub_100035200(a1, a2);
    if (v6)
      return v6;
  }
  else
  {
    v6 = 0;
  }
  if (!a3)
    return v6;
  v8 = (void *)*a1;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  *(_OWORD *)__str = 0u;
  v26 = 0u;
  memset(buffer, 0, sizeof(buffer));
  v9 = sub_10003FB48(a2, buffer);
  if (v9)
  {
    if (v9 == 3)
      return 0;
    snprintf(__str, 0x80uLL, "com.apple.xpc.launchd.unmanaged.confusing.%d.%d");
  }
  else
  {
    snprintf(__str, 0x80uLL, "com.apple.xpc.launchd.unmanaged.%s.%d");
  }
  v10 = strlen(__str);
  v11 = v10 + 1392;
  v12 = v10 >= 0xFFFFFFFFFFFFFA90;
  result = v10 + 1393;
  v13 = v11 == -1;
  v14 = v13 << 63 >> 63;
  v15 = v14 != v13;
  if (!v12 && !v15 && (v14 & 0x8000000000000000) == 0)
  {
    v6 = (uint64_t)sub_10001389C(result);
    result = strlen(__str);
    v16 = result == -1;
    v17 = v16 << 63 >> 63;
    if (v17 == v16 && (v17 & 0x8000000000000000) == 0)
    {
      strlcpy((char *)(v6 + 1392), __str, result + 1);
      *(_QWORD *)(v6 + 248) = sub_100019580(v8);
      *(_DWORD *)(v6 + 296) = a2;
      sub_10002FF24((unint64_t)v8, v6);
      sub_10001D418(v6, 5, "added unmanaged active", v18, v19, v20, v21, v22, v23);
      return v6;
    }
  }
  __break(1u);
  return result;
}

uint64_t sub_1000354BC(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, void *a5, xpc_object_t *a6, _BYTE *a7)
{
  size_t v14;
  uint64_t v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t i;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void *v83;
  uint64_t v84;
  char *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  void *v93;
  size_t v94;
  uint64_t v95;

  v95 = a1;
  v14 = sub_1000352F4(&v95, *(_DWORD *)(a2 + 20), 1);
  if (v14)
  {
    v15 = v14;
    if (*(_QWORD *)(a1 + 976))
      v16 = *(_QWORD *)(a1 + 976);
    else
      v16 = a1;
    if ((a4 & 2) == 0)
    {
      if ((a4 & 0x10) != 0)
      {
        if (*(_DWORD *)(v14 + 296))
        {
          v25 = 45;
          goto LABEL_55;
        }
        v17 = sub_10002E900(v14, v14, a3);
        if (!v17)
          v17 = sub_10002E948(v16, (_QWORD *)v15, a3);
        v25 = sub_1000459D4(v17, v39, v40, v41, v42, v43, v44, v45);
        if ((_DWORD)v25)
          goto LABEL_55;
      }
      else
      {
        if ((*(_BYTE *)(v14 + 369) & 2) == 0)
          goto LABEL_39;
        v17 = *(_QWORD *)(v14 + 184);
        if (!v17)
          goto LABEL_39;
        while ((*(_BYTE *)(v17 + 88) & 0x40) != 0 || !sub_1000157A8((char *)(v17 + 168), a3))
        {
          v17 = *(_QWORD *)(v17 + 16);
          if (!v17)
            goto LABEL_39;
        }
        if (sub_1000459D4(v17, v18, v19, v20, v21, v22, v23, v24))
        {
LABEL_39:
          v60 = sub_10002E860(v16, a3);
          if (!v67)
          {
            v68 = v60;
            v69 = sub_1000457E0(v60, 2, v61, v62, v63, v64, v65, v66);
            if (!sub_10002FD78(v69))
            {
              if (*(_QWORD *)(v68 + 72))
              {
                sub_100028C34(v16, 3, "Service \"%s\" tried to register for aliased endpoint: %s", v70, v71, v72, v73, v74, v15 + 112);
              }
              else
              {
                if ((a4 & 0x200) == 0 && ((a4 >> 8) & 1) != *(unsigned __int8 *)(v68 + 88) >> 7)
                {
                  v94 = v16;
                  sub_100028C34(v16, 3, "Preventing \"%s\" from registering for %s due to non-launching property mismatch", v70, v71, v72, v73, v74, v15 + 112);
                  goto LABEL_43;
                }
                if (sub_1000463E0(v68) == v15)
                {
                  if (a5)
                  {
                    sub_100028C34(v16, 3, "Service tried to register a port for an endpoint declared in its launchd.plist(5): service = %s, endpoint = %s", v77, v78, v79, v80, v81, v15 + 112);
                    v25 = 56;
                    goto LABEL_55;
                  }
                  v94 = v16;
                  v86 = sub_1000459D4(v68, v75, v76, v77, v78, v79, v80, v81);
                  if ((_DWORD)v86 != 3)
                  {
                    v25 = v86;
                    if ((_DWORD)v86)
                      goto LABEL_55;
                    *(_DWORD *)(v15 + 368) |= 0x2000u;
                    *(_BYTE *)(v68 + 88) |= 4u;
                    if (a6)
                    {
                      v93 = (void *)sub_10004616C(v68, 4, v87, v88, v89, v90, v91, v92);
                      *a6 = xpc_retain(v93);
                    }
                    if (a7)
                      *a7 = *(_BYTE *)(v68 + 88) >> 7;
                    goto LABEL_36;
                  }
LABEL_43:
                  v25 = 1;
                  if (!sub_100018738((_OWORD *)a2, (uint64_t)"mach-register", 1))
                  {
LABEL_55:
                    sub_10002FF24(a1, v15);
                    sub_1000359C4(a1, (char)a3, a4, a2, v25);
                    goto LABEL_56;
                  }
                  if (*(_WORD *)(v15 + 300) == 32766)
                  {
                    v25 = 12;
                    goto LABEL_55;
                  }
                  if (a5)
                  {
                    xpc_retain(a5);
                  }
                  else
                  {
                    v84 = sub_10000D880(0x12u, 2u, 0);
                    a5 = (void *)xpc_mach_send_create_with_disposition(v84, 17);
                  }
                  v85 = sub_10004595C(v15, a3, a5, (uint64_t)sub_10002AB90, v15);
                  if (a6)
                    *a6 = a5;
                  else
                    xpc_release(a5);
                  v85[88] |= 4u;
                  sub_10002ADB4(v94, (_QWORD *)v15, (uint64_t)v85, 1);
                  sub_10002F988(v94, (uint64_t)v85);
LABEL_36:
                  sub_10002FF24(a1, v15);
                  sub_10002FF24(a1, v15);
                  v25 = 0;
LABEL_56:
                  sub_10002EE9C(a1, v15, v54, v55, v56, v57, v58, v59);
                  return v25;
                }
                sub_100028C34(v16, 3, "Service \"%s\" tried to register for endpoint \"%s\" already registered by owner: %s", v77, v78, v79, v80, v81, v15 + 112);
              }
LABEL_54:
              v25 = 1;
              goto LABEL_55;
            }
            *(_BYTE *)(v68 + 88) |= 0x40u;
          }
          v94 = v16;
          if ((a4 & 1) != 0)
            goto LABEL_43;
          goto LABEL_54;
        }
        *(_DWORD *)(v15 + 368) |= 0x2000u;
      }
      *(_BYTE *)(v17 + 88) |= 4u;
      if (a6)
      {
        v83 = (void *)sub_10004616C(v17, 4, v46, v47, v48, v49, v50, v51);
        *a6 = xpc_retain(v83);
      }
      goto LABEL_36;
    }
    if (sub_100018738((_OWORD *)a2, (uint64_t)"mach-register", 2))
    {
      for (i = *(_QWORD *)(v15 + 168); i; i = *(_QWORD *)(i + 16))
      {
        if ((*(_BYTE *)(i + 88) & 0x40) == 0 && sub_1000157A8((char *)(i + 168), a3))
        {
          v38 = sub_1000457E0(i, 2, v32, v33, v34, v35, v36, v37);
          if (!sub_10002FD78(v38))
          {
            v25 = 37;
            goto LABEL_55;
          }
          *(_BYTE *)(i + 88) |= 0x40u;
        }
      }
      if (a5)
      {
        xpc_retain(a5);
      }
      else
      {
        v52 = sub_10000D880(0x12u, 6u, 0);
        a5 = (void *)xpc_mach_send_create_with_disposition(v52, 17);
      }
      v53 = sub_10004595C(v15, a3, a5, (uint64_t)sub_10002AB90, v15);
      if (a6)
        *a6 = a5;
      else
        xpc_release(a5);
      v53[88] |= 5u;
      sub_10002ADB4(v16, (_QWORD *)v15, (uint64_t)v53, 2);
      goto LABEL_36;
    }
    v25 = 1;
    sub_10002C1B8(a1, a2, 1, "pid-local registration");
    v26 = a1;
    v27 = (char)a3;
    v28 = a4;
    v29 = a2;
    v30 = 1;
  }
  else
  {
    v25 = 113;
    v26 = a1;
    v27 = (char)a3;
    v28 = a4;
    v29 = a2;
    v30 = 113;
  }
  sub_1000359C4(v26, v27, v28, v29, v30);
  return v25;
}

void sub_1000359C4(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD v13[4];

  memset(v13, 0, sizeof(v13));
  sub_10003FBC0(a4, (char *)v13);
  xpc_strerror(a5);
  sub_100028C34(a1, 4, "failed activation: name = %s, flags = 0x%llx, requestor = %s[%d], error = %d: %s", v8, v9, v10, v11, v12, a2);
}

uint64_t sub_100035A78(uint64_t a1, void *a2)
{
  uint64_t result;
  xpc_object_t array;
  void *v5;
  size_t count;
  size_t v7;
  size_t v8;
  BOOL v9;
  size_t v10;
  const char *string;
  const char *v12;
  char v13;
  unint64_t v14;
  const char *v15;
  int v16;

  result = (uint64_t)sub_100040958(a1);
  if (result)
  {
    array = xpc_dictionary_get_array((xpc_object_t)result, "com.apple.private.xpc.launchd.enable-disable-system-services");
    if (!array)
      return 0;
    v5 = array;
    if (xpc_get_type(array) != (xpc_type_t)&_xpc_type_array || xpc_get_type(a2) != (xpc_type_t)&_xpc_type_array)
      sub_100040B54("Given object not of required type.");
    count = xpc_array_get_count(v5);
    v7 = xpc_array_get_count(a2);
    if (!count)
      return 0;
    v8 = v7;
    if (!v7)
      return 1;
    v9 = 0;
    v10 = 0;
LABEL_8:
    string = xpc_array_get_string(a2, v10);
    if (string)
    {
      v12 = string;
      v13 = 0;
      v14 = 1;
      while (1)
      {
        v15 = xpc_array_get_string(v5, v14 - 1);
        if (!v15)
          break;
        v16 = strcmp(v12, v15);
        v13 |= v16 == 0;
        if (v16)
        {
          if (v14++ < count)
            continue;
        }
        if ((v13 & 1) != 0)
        {
          v9 = ++v10 >= v8;
          if (v10 != v8)
            goto LABEL_8;
        }
        return v9;
      }
    }
    return v9;
  }
  return result;
}

void sub_100035BA4(_QWORD *a1, void *a2)
{
  xpc_object_t v4;
  uint64_t i;
  uint64_t j;
  xpc_object_t v7;
  uint64_t k;
  xpc_object_t v9;
  uint64_t m;
  xpc_object_t v11;
  unint64_t n;
  unint64_t v13;
  uint64_t v14;

  v4 = xpc_dictionary_create(0, 0, 0);
  for (i = a1[19]; i; i = *(_QWORD *)(i + 16))
  {
    if ((*(_BYTE *)(i + 88) & 0x40) == 0)
      xpc_dictionary_set_mach_send(v4, i + 168, 0);
  }
  for (j = a1[20]; j; j = *(_QWORD *)(j + 16))
  {
    if ((*(_BYTE *)(j + 88) & 0x40) == 0)
      xpc_dictionary_set_mach_send(v4, j + 168, 0);
  }
  if (xpc_dictionary_get_count(v4))
    xpc_dictionary_set_value(a2, "MachServices", v4);
  xpc_release(v4);
  v7 = xpc_dictionary_create(0, 0, 0);
  for (k = a1[21]; k; k = *(_QWORD *)(k + 16))
  {
    if ((*(_BYTE *)(k + 88) & 0x40) == 0)
      xpc_dictionary_set_mach_send(v7, k + 168, 0);
  }
  if (xpc_dictionary_get_count(v7))
    xpc_dictionary_set_value(a2, "PerJobMachServices", v7);
  xpc_release(v7);
  v9 = xpc_dictionary_create(0, 0, 0);
  for (m = a1[24]; m; m = *(_QWORD *)(m + 16))
  {
    v13 = 0;
    v14 = 0;
    v11 = xpc_array_create(0, 0);
    sub_10001BF60(m, &v14, &v13);
    if (v13)
    {
      for (n = 0; n < v13; ++n)
        xpc_array_set_fd(v11, 0xFFFFFFFFFFFFFFFFLL, *(_DWORD *)(v14 + 4 * n));
    }
    xpc_dictionary_set_value(v9, (const char *)(m + 208), v11);
    xpc_release(v11);
  }
  if (xpc_dictionary_get_count(v9))
    xpc_dictionary_set_value(a2, "Sockets", v9);
  xpc_release(v9);
}

uint64_t sub_100035D84(uint64_t a1, const char *a2, void *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  xpc_type_t type;
  uint64_t v11;
  char *v12;
  const char *string_ptr;
  uint64_t v14;
  uint64_t v15;

  if (!sub_1000198D8(a2))
    goto LABEL_7;
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_QWORD *)(a1 + 40);
  if ((*(_BYTE *)(v6 + 1016) & 3) == 0)
  {
    v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(v6 + 112)
                                                                                               + 104))(v6, 4, 4, *(_QWORD *)(v6 + 120), v7, 0, 0);
    if ((_DWORD)v9)
    {
      v8 = v9;
      v6 = *(_QWORD *)(a1 + 32);
      v7 = *(_QWORD *)(a1 + 40);
      goto LABEL_6;
    }
LABEL_7:
    type = xpc_get_type(a3);
    if (type == (xpc_type_t)&_xpc_type_string)
    {
      v15 = *(_QWORD *)(a1 + 32);
      string_ptr = xpc_string_get_string_ptr(a3);
      v11 = v15;
      v12 = (char *)a2;
      v14 = 1;
    }
    else
    {
      if (type != (xpc_type_t)&_xpc_type_null)
        return 1;
      v11 = *(_QWORD *)(a1 + 32);
      v12 = (char *)a2;
      string_ptr = 0;
      v14 = 0;
    }
    sub_100035E70(v11, v12, string_ptr, v14);
    return 1;
  }
  v8 = 124;
LABEL_6:
  sub_10002C1B8(v6, v7, v8, "set dyld environment variable");
  return 1;
}

void sub_100035E70(uint64_t a1, char *__s, const char *a3, uint64_t a4)
{
  char **v8;
  _QWORD *v9;
  _QWORD *v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  size_t v18;

  v8 = (char **)(a1 + 96);
  v9 = (_QWORD *)(a1 + 96);
  while (1)
  {
    v9 = (_QWORD *)*v9;
    if (!v9)
      break;
    if (sub_100019854((uint64_t)v9, __s))
    {
      v10 = (_QWORD *)*v9;
      if (*v9)
        v10[1] = v9[1];
      *(_QWORD *)v9[1] = v10;
      *v9 = -1;
      v9[1] = -1;
      j__free(v9);
      break;
    }
  }
  if (a3)
  {
    v18 = 0;
    v11 = sub_10001967C(__s, a3, a4, &v18, 0);
    if (v11)
    {
      v17 = *v8;
      *(_QWORD *)v11 = *v8;
      if (v17)
        *((_QWORD *)v17 + 1) = v11;
      *v8 = v11;
      *((_QWORD *)v11 + 1) = v8;
    }
    else
    {
      sub_100028C34(a1, 3, "Service tried to %s global environment variable with reserved name: %s", v12, v13, v14, v15, v16, (char)"set");
    }
  }
}

void sub_100035F74(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[6];

  sub_100028C34((uint64_t)a1, 65540, "Wipe them out. All of them.", a4, a5, a6, a7, a8, v18[0]);
  sub_100040FC8(5, "starting obliteration");
  byte_100072ABA = 1;
  qword_100072490 = (uint64_t)dispatch_group_create();
  dispatch_group_enter((dispatch_group_t)qword_100072490);
  sub_100019580(a1);
  v10 = qword_100072490;
  v11 = sub_1000146E4();
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 0x40000000;
  v18[2] = sub_1000360C8;
  v18[3] = &unk_10006CB68;
  v18[4] = a1;
  v18[5] = a2;
  dispatch_group_notify(v10, v11, v18);
  sub_100036148((uint64_t)a1, qword_100072490, v12, v13, v14, v15, v16, v17);
  byte_100072A79 = 1;
  byte_1000729D9 = 1;
  dispatch_group_leave((dispatch_group_t)qword_100072490);
}

uint64_t sub_100036074(mach_port_context_t guard)
{
  uint64_t result;

  if (*(_UNKNOWN **)(guard + 112) != &unk_1000715B8)
    sub_10004D738();
  result = *(unsigned int *)(guard + 184);
  if ((_DWORD)result)
  {
    result = sub_10000D994(result, 0, guard);
    if ((_DWORD)result)
      sub_10004D778(result);
    *(_DWORD *)(guard + 184) = 0;
  }
  return result;
}

void sub_1000360C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  char v11;

  v9 = *(_QWORD *)(a1 + 32);
  v10 = *(_QWORD *)(a1 + 40);
  sub_100028C34(v9, 5, "obliteration complete, sending reply", a4, a5, a6, a7, a8, v11);
  if ((xpc_pipe_routine_reply(v10) | 0x20) != 0x20)
    _os_assumes_log_ctx(sub_100028C00, v9);
  sub_10001962C(*(void **)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
}

void sub_100036148(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t i;
  uint64_t j;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t k;
  char v22;

  v10 = *(_QWORD *)(a1 + 328);
  if (v10)
  {
    do
    {
      v11 = *(_QWORD *)(v10 + 104);
      sub_100028C34(a1, 5, "obliterating semi-active service: %s", a4, a5, a6, a7, a8, v10 + 112);
      v12 = sub_100020A8C(v10);
      if ((v12 - 36) >= 2)
      {
        if (v12 != 89)
          sub_10003E208("inconsistency between domain and service semi-active state during obliterate");
      }
      else
      {
        dispatch_group_enter(a2);
        *(_DWORD *)(v10 + 368) |= 0x4000u;
      }
      v10 = v11;
    }
    while (v11);
  }
  for (i = 0; i != 13; ++i)
  {
    for (j = *(_QWORD *)(a1 + 8 * i + 544); j; j = *(_QWORD *)(j + 88))
    {
      if (sub_100020D78(j) == dword_1000725C0)
      {
        sub_100028C34(a1, 5, "skipping over obliterator: %s", v15, v16, v17, v18, v19, j + 112);
      }
      else
      {
        sub_100028C34(a1, 5, "obliterating active service: %s", v15, v16, v17, v18, v19, j + 112);
        v20 = sub_100020A8C(j);
        if (v20 > 0x25 || ((1 << v20) & 0x2000010001) == 0)
          sub_10003E208("failed to stop active service %s: %d", (const char *)(j + 1392), v20);
        dispatch_group_enter(a2);
        *(_DWORD *)(j + 368) |= 0x4000u;
      }
    }
  }
  sub_10002DDF0(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v22);
  for (k = *(_QWORD *)(a1 + 320); k; k = *(_QWORD *)(k + 16))
    sub_100036148(k, a2);
}

char *sub_1000362F8(uint64_t a1, FILE *a2)
{
  int v3;
  char *result;
  uint64_t i;

  v3 = *(_DWORD *)(a1 + 32);
  if (v3)
    return sub_100036348(a2, v3);
  for (i = 0; i != 9; ++i)
    result = sub_100036348(a2, i);
  return result;
}

char *sub_100036348(FILE *a1, int a2)
{
  char *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  rlim_t v11;
  rlim_t v12;
  char v13[16];
  __int128 v14;
  char __str[16];
  __int128 v16;

  v11 = -2;
  v12 = -2;
  sub_100040104(a2, &v11, &v12);
  result = sub_100040380(a2);
  if (result)
  {
    v10 = result;
    *(_OWORD *)__str = 0u;
    v16 = 0u;
    if (v12 == -1)
      strcpy(__str, "unlimited");
    else
      snprintf(__str, 0x20uLL, "%lld", v12);
    *(_OWORD *)v13 = 0u;
    v14 = 0u;
    if (v11 == -1)
      strcpy(v13, "unlimited");
    else
      snprintf(v13, 0x20uLL, "%lld", v11);
    return (char *)sub_10004391C(a1, 1, "%-12s%-15s%-15s", v5, v6, v7, v8, v9, v10, v13, __str);
  }
  return result;
}

xpc_type_t sub_100036478(uint64_t a1, FILE *a2)
{
  _BOOL4 v4;
  _BOOL4 v5;
  _BOOL4 v6;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char **v13;
  char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  _QWORD v57[5];

  v4 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "version");
  v5 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "variant");
  v6 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "disabled");
  v7 = xpc_dictionary_get_BOOL(*(xpc_object_t *)(a1 + 32), "cache");
  if (v4)
  {
    v13 = off_100071AC8;
LABEL_5:
    v56 = *v13;
    v14 = "%s";
    return (xpc_type_t)sub_10004391C(a2, 0, v14, v8, v9, v10, v11, v12, v56);
  }
  if (v5)
  {
    v13 = off_100071AD0;
    goto LABEL_5;
  }
  if (v7)
  {
    if (sub_100019088())
      v21 = "system services must be in cache";
    else
      v21 = "disk will be searched for uncached services";
    sub_10004391C(a2, 0, v21, v16, v17, v18, v19, v20);
    if (qword_1000729C0)
    {
      sub_1000438B0(a2, 0, "cached daemons = {", v22, v23, v24, v25, v26);
      v57[0] = _NSConcreteStackBlock;
      v57[1] = 0x40000000;
      v57[2] = sub_1000366C8;
      v57[3] = &unk_10006CBC8;
      v57[4] = a2;
      sub_100043140((rb_tree_t **)qword_1000729C0, (uint64_t)v57);
      v27 = "}";
    }
    else
    {
      v27 = "(no daemon cache)";
    }
    sub_10004391C(a2, 0, v27, v22, v23, v24, v25, v26);
    if (qword_1000729C8)
    {
      sub_100043998(a2, v29, v30, v31, v32, v33, v34, v35, (char)v56);
      sub_1000438B0(a2, 0, "framework cache = ", v36, v37, v38, v39, v40);
      sub_10001595C(a2, 0, 1, (void *)qword_1000729C8, v41, v42, v43, v44);
    }
    else
    {
      sub_10004391C(a2, 0, "(no framework cache)", v31, v32, v33, v34, v35);
    }
    if (qword_1000729D0)
    {
      sub_100043998(a2, v45, v46, v8, v9, v10, v11, v12, (char)v56);
      sub_1000438B0(a2, 0, "bundle cache = ", v47, v48, v49, v50, v51);
      return sub_10001595C(a2, 0, 1, (void *)qword_1000729D0, v52, v53, v54, v55);
    }
    v14 = "(no bundle cache)";
    return (xpc_type_t)sub_10004391C(a2, 0, v14, v8, v9, v10, v11, v12, v56);
  }
  v28 = *(_QWORD *)(a1 + 40);
  if (v6)
    return (xpc_type_t)sub_1000305B8(v28, a2, 0, v8, v9, v10, v11, v12);
  else
    return (xpc_type_t)sub_10002AF90(v28, a2);
}

void sub_1000366C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  sub_1000438B0(*(FILE **)(a1 + 32), 1, "\"%s\" => ", a4, a5, a6, a7, a8, a2);
  v10 = (void *)sub_100043334(a3);
  sub_10001595C(*(FILE **)(a1 + 32), 1, 0, v10, v11, v12, v13, v14);
  xpc_release(v10);
}

void sub_10003672C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if ((_DWORD)a3 && (_DWORD)a3 != 121)
  {
    v4 = *(_QWORD *)(a1 + 32);
    v5 = *(_QWORD *)(a1 + 40);
    xpc_strerror(a3);
    sub_100028C34(v4, 5, "failed to add extension %s: %d - %s", v6, v7, v8, v9, v10, v5);
  }
  if ((xpc_pipe_routine_reply(*(_QWORD *)(a1 + 48)) | 0x20) != 0x20)
    _os_assumes_log_ctx(sub_100028C00, *(_QWORD *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 48));
  free(*(void **)(a1 + 40));
}

void sub_1000367C8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v9;
  uint64_t v10;
  void *v11;
  char v12;

  v10 = *a1;
  v9 = a1[1];
  v11 = (void *)a1[2];
  sub_100028C34(*a1, 5, "extension removal request finished, sending reply", a4, a5, a6, a7, a8, v12);
  if ((xpc_pipe_routine_reply(v11) | 0x20) != 0x20)
    _os_assumes_log_ctx(sub_100028C00, v10);
  dispatch_release(v9);
  xpc_release(v11);
  sub_1000195F8(a1);
}

uint64_t sub_100036848(uint64_t a1, uint64_t a2, NSObject *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v20;

  v5 = sub_100029C60(a1, a2);
  v6 = v5;
  if ((_DWORD)v5)
  {
    if ((_DWORD)v5 == 36)
    {
      dispatch_retain(a3);
      dispatch_group_enter(a3);
      if (*(_QWORD *)(a2 + 328))
      {
        sub_10001D418(a2, 5, "An extension-removal request is already in flight; chaining", v7, v8, v9, v10, v11, v20);
        v12 = *(NSObject **)(a2 + 328);
        v13 = sub_1000146E4();
        dispatch_group_notify_f(v12, v13, a3, (dispatch_function_t)sub_100036908);
      }
      else
      {
        *(_QWORD *)(a2 + 328) = a3;
      }
    }
    else
    {
      xpc_strerror(v5);
      sub_10001D418(a2, 4, "An extension-removal request failed, error: %d - %s", v14, v15, v16, v17, v18, v6);
    }
  }
  return v6;
}

void sub_100036908(NSObject *a1)
{
  dispatch_group_leave(a1);
  dispatch_release(a1);
}

uint64_t sub_10003692C(uint64_t a1, FILE *a2)
{
  return sub_10002AF14(*(_QWORD *)(a1 + 32), a2);
}

_QWORD *sub_100036934(unsigned int a1, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = sub_10002CE8C((uint64_t)qword_100071640, a1, 0, 0, 0, qword_100072478, a2);
  sub_100029A88(v2, (uint64_t)&qword_1000729A0, 0, v3, v4, v5, v6, v7);
  return v2;
}

uint64_t sub_10003698C(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100036994(*(_QWORD *)(a1 + 32), a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_100036994(uint64_t result, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t i;
  uint64_t j;
  uint64_t k;

  v9 = result;
  if (*(_UNKNOWN **)(result + 112) == &unk_1000715B8)
  {
    if (qword_100072960)
      result = sub_10004391C(a2, 0, "JetsamProperties loaded from path : %s", a4, a5, a6, a7, a8, qword_100072960);
    else
      result = sub_10004391C(a2, 0, "JetsamProperties not loaded", a4, a5, a6, a7, a8);
  }
  for (i = 0; i != 23; ++i)
  {
    for (j = *(_QWORD *)(v9 + 8 * i + 336); j; j = *(_QWORD *)(j + 120))
      result = sub_10002370C(j, a2, 0);
  }
  for (k = *(_QWORD *)(v9 + 320); k; k = *(_QWORD *)(k + 16))
    result = sub_100036994(k, a2);
  return result;
}

uint64_t sub_100036A5C(void *a1, _QWORD *a2, uint64_t *a3)
{
  xpc_object_t value;
  void *v7;
  uint64_t result;
  uint64_t v9;
  xpc_object_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;

  value = xpc_dictionary_get_value(a1, "type");
  if (!value)
    return 22;
  v7 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_uint64)
    return 22;
  v9 = xpc_uint64_get_value(v7);
  v10 = xpc_dictionary_get_value(a1, "handle");
  if (!v10)
    return 22;
  v11 = v10;
  if (xpc_get_type(v10) != (xpc_type_t)&_xpc_type_uint64)
    return 22;
  v12 = xpc_uint64_get_value(v11);
  v13 = 0;
  result = 125;
  while (dword_1000718E8[v13] != (_DWORD)v9)
  {
    v13 += 4;
    if (v13 == 24)
      return result;
  }
  v14 = *(void **)&dword_1000718E8[v13 + 2];
  if (!v14)
    return 125;
  if (v9 == 3)
    return 45;
  if (v14 == &unk_100071750 && v12 == 0)
    return 112;
  result = 0;
  *a2 = v14;
  *a3 = v12;
  return result;
}

uint64_t sub_100036B74(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  if (a1 == (_QWORD *)&unk_1000717D8)
  {
    v5 = sub_10001FB38(*(_DWORD *)(a3 + 20));
    if (v5)
      return *(_QWORD *)(v5 + 248);
    a2 = *(unsigned int *)(a3 + 12);
    a1 = qword_100071640;
    return sub_10002E19C(a1, a2);
  }
  if (a1 != (_QWORD *)&unk_100071860)
    return sub_10002E19C(a1, a2);
  result = sub_100044530();
  if (!result)
    return qword_100072478;
  return result;
}

_QWORD *sub_100036BF0(_QWORD *a1, unint64_t a2, char *a3, char a4, uint64_t a5, int *a6)
{
  uint64_t v12;
  int v13;
  _QWORD *v14;
  int v15;
  char *v16;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  uint64_t v22;
  _BOOL4 v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  _OWORD v36[4];

  if (!a1[13])
  {
    v14 = 0;
    goto LABEL_5;
  }
  v12 = sub_100030A6C((uint64_t)a1, (unint64_t)(a1 != qword_100071750) << 7, a2, a5);
  if ((_DWORD)v12)
  {
    v13 = v12;
    sub_10002C1B8(qword_100072478, a5, v12, "domain creation");
    v14 = 0;
    *a6 = v13;
    return v14;
  }
  if (a1 != qword_100071750)
  {
    v16 = sub_100015630("%s/%lu", (const char *)a1[15], a2);
    sub_100034A70(qword_100072478, (uint64_t)v16, 0, 0, 0, a5, 112);
    *a6 = 112;
    free(v16);
    return 0;
  }
  memset(v36, 0, sizeof(v36));
  v18 = "(premature birth)";
  if (!(a2 >> 31))
  {
    v19 = *(unsigned int *)(a5 + 20);
    if ((v19 & 0x80000000) == 0 && v19 == a2)
    {
      v20 = sub_10001FB38(a2);
      if (v20)
        v21 = sub_1000213F0(v20);
      else
        v21 = sub_10003FBC0(a5, (char *)v36);
      v18 = v21;
    }
  }
  v22 = sub_10002E19C(qword_100071750, a2);
  if (v22)
  {
    v23 = sub_1000157A8(a3, *(const char **)(v22 + 968));
    v14 = 0;
    if (v23)
      v15 = 37;
    else
      v15 = 134;
    goto LABEL_6;
  }
  v24 = sub_10002CE8C((uint64_t)qword_100071750, a2, v18, a3, 0, qword_100072478, a5);
  v14 = v24;
  if ((a4 & 1) != 0)
  {
    sub_100028C34((uint64_t)v24, 5, "Will be pending launches until told otherwise", v25, v26, v27, v28, v29, v35);
    *((_DWORD *)v14 + 254) |= 0x8000u;
    sub_100029A88(v14, a5, 0, v30, v31, v32, v33, v34);
    return v14;
  }
  sub_100029A88(v24, a5, 0, v25, v26, v27, v28, v29);
  if (!v14)
  {
LABEL_5:
    v15 = 112;
LABEL_6:
    *a6 = v15;
  }
  return v14;
}

void sub_100036E34(_QWORD *a1, const char *a2, void *a3, uint64_t a4)
{
  uint64_t i;
  uint64_t j;
  int v10;
  char *v11;
  char *v12;
  uint64_t k;

  if (!(*(unsigned int (**)(_QWORD *, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(a1[14] + 104))(a1, 5, 0, a1[15], a4, 0, 0))
  {
    for (i = 0; i != 23; ++i)
    {
      for (j = a1[i + 42]; j; j = *(_QWORD *)(j + 120))
      {
        v10 = strtonum(a2, 1, 0x7FFFFFFFLL, 0);
        if (v10)
        {
          if (sub_100020D78(j) != v10)
            continue;
        }
        else if (!sub_10001578C((char *)(j + 1392), a2))
        {
          v11 = (char *)sub_1000213BC(j);
          if (!sub_10001578C(v11, a2))
            continue;
        }
        v12 = sub_10001F264(j, 1);
        xpc_array_set_string(a3, 0xFFFFFFFFFFFFFFFFLL, v12);
        free(v12);
      }
    }
    for (k = a1[40]; k; k = *(_QWORD *)(k + 16))
      sub_100036E34(k, a2, a3, a4);
  }
}

void sub_100036F5C(uint64_t a1)
{
  if ((xpc_pipe_routine_reply(*(_QWORD *)(a1 + 32)) | 0x20) != 0x20)
    _os_assumes_log_ctx(sub_100028C00, *(_QWORD *)(a1 + 40));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
}

uint64_t sub_100036FB0(uint64_t a1, const char *a2, NSObject *a3, uint64_t a4)
{
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t result;
  uint64_t v27;
  _QWORD block[5];
  _OWORD v30[4];

  for (i = 0; i != 13; ++i)
  {
    v8 = *(_QWORD *)(a1 + 8 * i + 544);
    if (v8)
    {
      do
      {
        v9 = *(_QWORD *)(v8 + 88);
        v10 = (char *)sub_100023BCC(v8);
        if (sub_1000157A8(v10, a2))
        {
          memset(v30, 0, sizeof(v30));
          v11 = sub_100023BCC(v8);
          sub_10003FBC0(a4, (char *)v30);
          sub_10001D418(v8, 5, "Terminating with cryptex %s, caller = %s[%d]", v12, v13, v14, v15, v16, v11);
          dispatch_group_enter(a3);
          v17 = *(NSObject **)(v8 + 336);
          if (v17)
          {
            v18 = sub_1000146E4();
            block[0] = _NSConcreteStackBlock;
            block[1] = 0x40000000;
            block[2] = sub_1000371A0;
            block[3] = &unk_10006CC68;
            block[4] = a3;
            dispatch_group_notify(v17, v18, block);
          }
          else
          {
            *(_QWORD *)(v8 + 336) = a3;
          }
          *(_DWORD *)(v8 + 368) |= 0x8000u;
          v19 = sub_100020A8C(v8);
          v20 = v19;
          if ((v19 - 36) > 0x35 || ((1 << (v19 - 36)) & 0x20000000000003) == 0)
          {
            if ((_DWORD)v19)
            {
              xpc_strerror(v19);
              sub_100028C34(a1, 3, "Error during cryptex termination: %d - %s", v21, v22, v23, v24, v25, v20);
            }
          }
        }
        v8 = v9;
      }
      while (v9);
    }
  }
  result = *(_QWORD *)(a1 + 320);
  if (result)
  {
    do
    {
      v27 = *(_QWORD *)(result + 16);
      sub_100036FB0();
      result = v27;
    }
    while (v27);
  }
  return result;
}

void sub_1000371A0(uint64_t a1)
{
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

uint64_t sub_1000371A8(uint64_t a1, void *a2, _QWORD *a3)
{
  void *v6;
  xpc_object_t reply;
  uint64_t result;

  if (!xpc_dictionary_expects_reply(a2))
    return 22;
  if (*(_UNKNOWN **)(a1 + 112) != &unk_1000715B8)
    a1 = *(_QWORD *)(a1 + 232);
  v6 = *(void **)(a1 + 136);
  reply = xpc_dictionary_create_reply(a2);
  xpc_dictionary_set_value(reply, "parent", v6);
  result = 0;
  *a3 = reply;
  return result;
}

uint64_t sub_100037228(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  const char *string;
  char *v9;
  xpc_object_t value;
  void *v11;
  uint64_t result;
  uint64_t uint64;
  uint64_t v14;
  xpc_object_t reply;

  if (!xpc_dictionary_expects_reply(a3))
    return 4294966992;
  string = xpc_dictionary_get_string(a3, "name");
  if (!string)
    return 4294966992;
  v9 = (char *)string;
  value = xpc_dictionary_get_value(a3, "port");
  if (!value)
    return 1102;
  v11 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_mach_send)
    return 1102;
  uint64 = xpc_dictionary_get_uint64(a3, "flags");
  v14 = sub_1000354BC(a1, a2, v9, ((2 * (uint64 & 1)) | (uint64 >> 6) & 1) ^ 1, v11, 0, 0);
  result = sub_100037784(v14);
  if (!(_DWORD)result)
  {
    reply = xpc_dictionary_create_reply(a3);
    result = 0;
    *a4 = reply;
  }
  return result;
}

uint64_t sub_100037318(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  const char *string;
  char *v9;
  uint64_t uint64;
  uint64_t v11;
  uint64_t v12;
  xpc_object_t reply;
  uint64_t right;
  xpc_object_t object;

  if (!xpc_dictionary_expects_reply(a3))
    return 4294966992;
  string = xpc_dictionary_get_string(a3, "name");
  if (!string)
    return 4294966992;
  v9 = (char *)string;
  uint64 = xpc_dictionary_get_uint64(a3, "flags");
  object = 0;
  v11 = sub_1000354BC(a1, a2, v9, ((2 * (uint64 & 1)) | (uint64 >> 6) & 1) ^ 1, 0, &object, 0);
  v12 = sub_100037784(v11);
  if (!(_DWORD)v12)
  {
    reply = xpc_dictionary_create_reply(a3);
    right = xpc_mach_send_get_right(object);
    xpc_dictionary_set_mach_recv(reply, "port", right);
    xpc_release(object);
    *a4 = reply;
  }
  return v12;
}

uint64_t sub_100037408(uint64_t a1, uint64_t a2, void *a3, _QWORD *a4)
{
  uint64_t v8;
  uint64_t v9;
  const char *string;
  char *v11;
  unsigned int int64;
  unsigned __int8 *uuid;
  uint64_t uint64;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  xpc_object_t reply;
  unsigned int v22;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int right;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  char *v38;
  _OWORD v39[4];

  if (!xpc_dictionary_expects_reply(a3))
    return 4294966992;
  sub_10004453C();
  if (xpc_dictionary_get_uint64(a3, "type") != 7)
  {
    v8 = (*(uint64_t (**)(uint64_t, uint64_t, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD))(*(_QWORD *)(a1 + 112)
                                                                                              + 104))(a1, 6, 0, *(_QWORD *)(a1 + 120), a2, 0, 0);
    if ((_DWORD)v8)
    {
      v9 = v8;
      sub_10002C1B8(a1, a2, v8, "endpoint lookup");
      return v9;
    }
  }
  string = xpc_dictionary_get_string(a3, "name");
  if (!string)
    return 4294966992;
  v11 = (char *)string;
  int64 = xpc_dictionary_get_int64(a3, "targetpid");
  if ((int64 & 0x80000000) != 0)
    return 22;
  uuid = (unsigned __int8 *)xpc_dictionary_get_uuid(a3, "instance");
  uint64 = xpc_dictionary_get_uint64(a3, "flags");
  v15 = uint64;
  v16 = uint64 >> 3;
  if ((((uint64 >> 3) & 4) != 0 || (uint64 & 0x100) != 0) && !uuid)
    return 22;
  if ((*(_BYTE *)(a1 + 1017) & 0x10) != 0
    && (uint64 & 0x10) == 0
    && *(_UNKNOWN **)(a1 + 112) == &unk_1000715B8
    && sub_1000480EC(v11))
  {
    memset(v39, 0, sizeof(v39));
    sub_10003FBC0(a2, (char *)v39);
    sub_100028C34(a1, 5, "pending bootstrap lookup during user switch: name = %s, requestor = %s[%d]", v24, v25, v26, v27, v28, (char)v11);
    v29 = *(_QWORD *)(a1 + 136);
    if (v29)
      right = xpc_mach_send_get_right(v29);
    else
      right = 0;
    sub_10003465C(a1, right, a3, 2);
    return 0;
  }
  else
  {
    v17 = (v15 & 8 | (2 * (v15 & 1)) | (v15 >> 7) & 1 | v16 & 0x64) ^ 1;
    v18 = sub_1000346D4(a1, v11, int64, v17, uuid, 0, a2);
    v20 = v19;
    if ((_DWORD)v19)
    {
      reply = xpc_dictionary_create_reply(a3);
      v22 = sub_100037784(v20);
      xpc_dictionary_set_int64(reply, "error", v22);
    }
    else
    {
      reply = xpc_dictionary_create_reply(a3);
      v37 = (void *)sub_10004616C(v18, 1, v31, v32, v33, v34, v35, v36);
      xpc_dictionary_set_value(reply, "port", v37);
      if (*(char *)(v18 + 88) < 0)
        xpc_dictionary_set_BOOL(reply, "non-launching", 1);
    }
    if (sub_1000349F4(v18, v20, v11, int64, v17, uuid, 0, a2))
    {
      v38 = sub_100015630("System session daemon must not bootstrap_look_up User session services (rdar://77349945): endpoint = %s", v11);
      xpc_dictionary_set_string(reply, "xpc-fault", v38);
      free(v38);
    }
    v9 = 0;
    *a4 = reply;
  }
  return v9;
}

uint64_t sub_100037728(void *a1, _QWORD *a2)
{
  xpc_object_t reply;
  uint64_t result;

  if (!xpc_dictionary_expects_reply(a1))
    return 4294966992;
  reply = xpc_dictionary_create_reply(a1);
  xpc_dictionary_set_value(reply, "rootport", *(xpc_object_t *)(qword_100072478 + 136));
  result = 0;
  *a2 = reply;
  return result;
}

uint64_t sub_100037784(uint64_t result)
{
  if ((int)result <= 36)
  {
    if (!(_DWORD)result)
      return result;
    if ((_DWORD)result != 1)
    {
      if ((_DWORD)result == 3)
        return 1102;
      return 1105;
    }
    return 1100;
  }
  if ((int)result > 144)
  {
    if ((_DWORD)result != 159)
    {
      if ((_DWORD)result == 145)
        return 1102;
      return 1105;
    }
    return 1100;
  }
  if ((_DWORD)result != 37)
  {
    if ((_DWORD)result == 56)
      return 1101;
    return 1105;
  }
  return 1103;
}

uint64_t sub_1000377F0(_DWORD *a1, uint64_t a2, char *__s1, void *a4, xpc_object_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  _DWORD *v22;
  int v23;
  char *string_ptr;
  _DWORD *v25;
  uint64_t v26;
  _DWORD *v27;
  char *v28;
  char *v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char *v39;
  _DWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  size_t v45;
  xpc_object_t value;
  int v47;
  uint64_t v48;
  _DWORD *v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  xpc_object_t v57;
  uint64_t i;
  uint64_t j;
  xpc_object_t v60;
  const char *v61;
  void *v62;
  char *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  xpc_object_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  char *v93;
  char *v94;
  _DWORD *v95;
  _DWORD *v96[128];

  if (!strcmp(__s1, "SubmitJob"))
  {
    if (!a4
      || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_dictionary && xpc_get_type(a4) != (xpc_type_t)&_xpc_type_array)
    {
      return 22;
    }
    if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_array)
    {
      *a5 = xpc_array_create(0, 0);
      if (xpc_array_get_count(a4))
      {
        v45 = 0;
        do
        {
          value = xpc_array_get_value(a4, v45);
          v47 = sub_1000385E4(a1, a2, value, 0);
          xpc_array_set_uint64(*a5, 0xFFFFFFFFFFFFFFFFLL, v47);
          ++v45;
        }
        while (v45 < xpc_array_get_count(a4));
      }
      return 0;
    }
    v96[0] = 0;
    v21 = sub_1000385E4(a1, a2, a4, v96);
    if (!(_DWORD)v21)
    {
      v22 = v96[0];
      if (!v96[0])
        goto LABEL_74;
      v23 = v96[0][92];
      if ((v23 & 8) == 0)
        goto LABEL_74;
      v96[0][92] = v23 & 0xFFFFFFF7;
      *((_QWORD *)a1 + 124) = v22;
      return 36;
    }
    return v21;
  }
  if (!strcmp(__s1, "RemoveJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string)
      return 22;
    string_ptr = (char *)xpc_string_get_string_ptr(a4);
    v95 = a1;
    v25 = sub_100034520(&v95, string_ptr);
    if (v25)
    {
      v26 = (uint64_t)v25;
      v27 = v95;
      v21 = sub_10002C0E4((uint64_t)v95, 4, 8, a2, 0, 0);
      if ((_DWORD)v21 || (v21 = sub_10001F090(), (_DWORD)v21))
      {
        v94 = string_ptr;
        v28 = "service removal (%s)";
LABEL_41:
        v43 = (uint64_t)v27;
LABEL_54:
        sub_10002C1B8(v43, a2, v21, v28, v94);
        return v21;
      }
      bzero(v96, 0x400uLL);
      sub_1000307EC(*(_DWORD *)(a2 + 20), (char *)v96);
      sub_10001D418(v26, 5, "%s: caller = %s, value = 0x%llx", v82, v83, v84, v85, v86, (char)"legacy-remove service");
      v87 = sub_100029C60((uint64_t)v27, v26);
      v21 = v87;
      if ((_DWORD)v87)
      {
        if ((_DWORD)v87 != 36)
        {
          xpc_strerror(v87);
          sub_10001D418(v26, 3, "Could not stop service: name = %s, error = %d: %s", v88, v89, v90, v91, v92, (char)string_ptr);
        }
        return v21;
      }
      goto LABEL_82;
    }
    return 3;
  }
  if (!strcmp(__s1, "StartJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string)
      return 22;
    v29 = (char *)xpc_string_get_string_ptr(a4);
    v96[0] = a1;
    v30 = sub_100034520(v96, v29);
    if (!v30)
      return 3;
    v31 = (uint64_t)v30;
    a1 = v96[0];
    v32 = sub_10002C0E4((uint64_t)v96[0], 4, 8, a2, 0, 0);
    if ((_DWORD)v32)
    {
      v21 = v32;
      v94 = v29;
      v28 = "service start (%s)";
LABEL_53:
      v43 = (uint64_t)a1;
      goto LABEL_54;
    }
    v69 = sub_1000203B0(v31, 9, v33, v34, v35, v36, v37, v38);
    v21 = v69;
    if (v69 > 0x25 || ((1 << v69) & 0x3000000001) == 0)
      return v21;
LABEL_74:
    v70 = xpc_uint64_create(0);
    v21 = 0;
LABEL_75:
    *a5 = v70;
    return v21;
  }
  if (!strcmp(__s1, "StopJob"))
  {
    if (!a4 || xpc_get_type(a4) != (xpc_type_t)&_xpc_type_string)
      return 22;
    v39 = (char *)xpc_string_get_string_ptr(a4);
    v95 = a1;
    v40 = sub_100034520(&v95, v39);
    if (v40)
    {
      v41 = (uint64_t)v40;
      v27 = v95;
      v42 = sub_10002C0E4((uint64_t)v95, 4, 8, a2, 0, 0);
      if ((_DWORD)v42)
      {
        v21 = v42;
        v94 = v39;
        v28 = "service stop (%s)";
        goto LABEL_41;
      }
      bzero(v96, 0x400uLL);
      sub_1000307EC(*(_DWORD *)(a2 + 20), (char *)v96);
      sub_10001D418(v41, 5, "%s: caller = %s, value = 0x%llx", v71, v72, v73, v74, v75, (char)"legacy-stop service");
      v21 = sub_1000204AC(v41, a2, v76, v77, v78, v79, v80, v81);
      if ((_DWORD)v21)
        return v21;
LABEL_82:
      v70 = xpc_uint64_create(0);
      goto LABEL_75;
    }
    return 3;
  }
  if (!strcmp(__s1, "GetJob"))
  {
    if (a4 && xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string)
    {
      v51 = (char *)xpc_string_get_string_ptr(a4);
      v49 = a1;
      v50 = a2;
      v52 = 0;
      return sub_10003809C(v49, v50, v51, v52, a5, v10, v11, v12);
    }
    return 22;
  }
  if (!strcmp(__s1, "GetJobs"))
  {
    v48 = sub_10002C0E4((uint64_t)a1, 5, 128, a2, 0, 0);
    if (!(_DWORD)v48)
    {
      v57 = xpc_dictionary_create(0, 0, 0);
      for (i = 0; i != 23; ++i)
      {
        for (j = *(_QWORD *)&a1[2 * i + 84]; j; j = *(_QWORD *)(j + 120))
        {
          v60 = sub_100020DB0(j);
          v61 = (const char *)(j + 1392);
          if (v60)
          {
            v62 = v60;
            xpc_dictionary_set_value(v57, v61, v60);
            xpc_release(v62);
          }
          else
          {
            xpc_dictionary_set_uint64(v57, v61, 0x99uLL);
          }
        }
      }
      v21 = 0;
      *a5 = v57;
      return v21;
    }
    v21 = v48;
    v28 = "all services read";
    goto LABEL_53;
  }
  if (!strcmp(__s1, "CheckIn"))
  {
    v49 = a1;
    v50 = a2;
    v51 = 0;
    v52 = 1;
    return sub_10003809C(v49, v50, v51, v52, a5, v10, v11, v12);
  }
  if (!strcmp(__s1, "SetUserEnvironment"))
  {
    if (a4 && xpc_get_type(a4) == (xpc_type_t)&_xpc_type_dictionary)
      return sub_10003824C((uint64_t)a1, a2, (uint64_t)a4, a5, v53, v54, v55, v56);
    return 22;
  }
  if (!strcmp(__s1, "UnsetUserEnvironment"))
  {
    if (a4 && xpc_get_type(a4) == (xpc_type_t)&_xpc_type_string)
    {
      v63 = (char *)xpc_string_get_string_ptr(a4);
      return sub_100038310((uint64_t)a1, a2, v63, v64, v65, v66, v67, v68);
    }
    return 22;
  }
  if (!strcmp(__s1, "Shutdown"))
    return sub_1000383BC((mach_port_context_t)a1, a2, a5);
  if (!strcmp(__s1, "SingleUser"))
  {
    v93 = "LAUNCH_KEY_SINGLEUSER never did anything anyway.";
    goto LABEL_85;
  }
  if (!strcmp(__s1, "GetResourceLimits") || !strcmp(__s1, "SetResourceLimits"))
  {
    v93 = "rlimit(3)? Really?";
LABEL_85:
    sub_100028C34((uint64_t)a1, 5, v93, v13, v14, v15, v16, v17, (char)v94);
    return 126;
  }
  if (!strcmp(__s1, "GetResourceUsageSelf"))
  {
    v18 = (uint64_t)a1;
    v19 = a2;
    v20 = 0;
    return sub_100038508(v18, v19, v20, a5);
  }
  if (strcmp(__s1, "GetResourceUsageChildren"))
    return 22;
  v18 = (uint64_t)a1;
  v19 = a2;
  v20 = -1;
  return sub_100038508(v18, v19, v20, a5);
}

void sub_10003803C(char *__s1, void *a2, uint64_t a3)
{
  _DWORD *v6;
  uint64_t v7;
  int v8;
  void *v9;
  xpc_object_t v10;

  v6 = *(_DWORD **)a3;
  v7 = *(_QWORD *)(a3 + 8);
  v10 = 0;
  v8 = sub_1000377F0(v6, v7, __s1, a2, &v10);
  if (v8)
    v10 = xpc_uint64_create(v8);
  v9 = *(void **)(a3 + 16);
  if (v9)
    xpc_release(v9);
  *(_QWORD *)(a3 + 16) = v10;
}

uint64_t sub_10003809C(_DWORD *a1, uint64_t a2, char *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  xpc_object_t v15;
  _DWORD *v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _DWORD *v24;
  _OWORD v25[4];

  v9 = a4;
  v24 = a1;
  if (!a3 || !(_DWORD)a4)
  {
    if (a3)
      v12 = (uint64_t)sub_100034520(&v24, a3);
    else
      v12 = sub_1000352F4((uint64_t *)&v24, *(_DWORD *)(a2 + 20), 0);
    v13 = (_QWORD *)v12;
    if (!v12 || *(_DWORD *)(v12 + 296))
      return 3;
    if ((v9 & 1) != 0)
    {
      if (sub_100020D78(v12) != *(_DWORD *)(a2 + 20))
      {
        memset(v25, 0, sizeof(v25));
        v18 = sub_10003FBC0(a2, (char *)v25);
        sub_100028C34((uint64_t)v24, 3, "Unprivileged caller tried to check into job's endpoints: caller = %s.%d, owner = %s", v19, v20, v21, v22, v23, v18);
        return 1;
      }
      v15 = sub_100020DB0((uint64_t)v13);
      sub_100038930((uint64_t)v24, (uint64_t)v13, v15, 1);
    }
    else
    {
      v16 = v24;
      v17 = sub_10002C0E4((uint64_t)v24, 5, 8, a2, 0, 0);
      if ((_DWORD)v17)
      {
        v11 = v17;
        sub_10002C1B8((uint64_t)v16, a2, v17, "service read");
        return v11;
      }
      sub_100020D78((uint64_t)v13);
      v15 = sub_100020DB0((uint64_t)v13);
      sub_100035BA4(v13, v15);
    }
    v11 = 0;
    *a5 = v15;
    return v11;
  }
  sub_100028C34((uint64_t)a1, 3, "Caller tried to check into a named job: %s", a4, (uint64_t)a5, a6, a7, a8, (char)a3);
  return 1;
}

uint64_t sub_10003824C(uint64_t a1, uint64_t a2, uint64_t a3, xpc_object_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  char v14;

  if ((*(_BYTE *)(*(_QWORD *)(a1 + 112) + 128) & 2) != 0)
  {
    v9 = sub_10002C0E4(a1, 4, 8, a2, 0, 0);
    if ((_DWORD)v9)
    {
      sub_10002C1B8(a1, a2, v9, "set domain environment");
    }
    else
    {
      *a4 = xpc_uint64_create(0);
      xpc_dictionary_apply_f(a3);
    }
  }
  else
  {
    sub_100028C34(a1, 3, "LAUNCH_KEY_SETUSERENVIRONMENT is only valid for user domains.", (uint64_t)a4, a5, a6, a7, a8, v14);
    return 125;
  }
  return v9;
}

uint64_t sub_100038310(uint64_t a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  char v13;

  if ((*(_BYTE *)(*(_QWORD *)(a1 + 112) + 128) & 2) != 0)
  {
    sub_100028C34(a1, 3, "LAUNCH_KEY_UNSETUSERENVIRONMENT is only valid for user domains.", a4, a5, a6, a7, a8, v13);
    return 125;
  }
  else
  {
    v11 = sub_10002C0E4(a1, 4, 8, a2, 0, 0);
    if ((_DWORD)v11)
      sub_10002C1B8(a1, a2, v11, "unset domain environment");
    else
      sub_100035E70(a1, a3, 0, 0);
  }
  return v11;
}

uint64_t sub_1000383BC(mach_port_context_t a1, uint64_t a2, xpc_object_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v19[1024];

  v6 = sub_10002C0E4(a1, 4, 8, a2, 0, 0);
  if ((_DWORD)v6)
  {
    v7 = v6;
    sub_10002C1B8(a1, a2, v6, "domain shutdown");
  }
  else if ((*(_BYTE *)(a1 + 1016) & 3) != 0)
  {
    return 37;
  }
  else
  {
    bzero(v19, 0x400uLL);
    sub_1000307EC(*(_DWORD *)(a2 + 20), v19);
    sub_100028C34(a1, 196613, "legacy shutdown initiated by: %s", v8, v9, v10, v11, v12, (char)v19);
    sub_100028C34(a1, 5, "legacy shutdown, caller = %s", v13, v14, v15, v16, v17, (char)v19);
    v7 = sub_10000D994(*(_DWORD *)(a1 + 184), -1, a1);
    if ((_DWORD)v7)
    {
      _os_assumes_log_ctx(sub_100028C00, a1);
    }
    else
    {
      *(_DWORD *)(a1 + 184) = 0;
      *a3 = xpc_uint64_create(0);
    }
  }
  return v7;
}

uint64_t sub_100038508(uint64_t a1, uint64_t a2, int a3, xpc_object_t *a4)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  rusage v12;

  v8 = sub_10002C0E4(a1, 5, 8, a2, 0, 0);
  if ((_DWORD)v8)
  {
    v9 = v8;
    sub_10002C1B8(a1, a2, v8, "read resource usage");
  }
  else
  {
    memset(&v12, 0, sizeof(v12));
    v10 = getrusage(a3, &v12);
    if (v10)
    {
      if (v10 == -1)
        sub_10004E004(a1);
      return *__error();
    }
    else
    {
      v9 = 0;
      *a4 = xpc_data_create(&v12, 0x90uLL);
    }
  }
  return v9;
}

uint64_t sub_1000385E4(_DWORD *a1, uint64_t a2, xpc_object_t object, _QWORD *a4)
{
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  _DWORD *v18;
  _DWORD *v19;
  uint64_t v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v15 = sub_10003877C(a1, object, a2);
    v17 = v16;
    if ((_DWORD)v16 == 134 && sub_10003E3D8((uint64_t)a1))
    {
      v18 = a1;
      do
      {
        v19 = v18;
        v18 = (_DWORD *)*((_QWORD *)v18 + 29);
      }
      while (v18);
      v15 = sub_10003877C(v19, object, a2);
      v17 = v20;
    }
    result = 0;
    if ((_DWORD)v17)
    {
      if ((_DWORD)v17 != 17 && (_DWORD)v17 != 37)
      {
        xpc_dictionary_get_string(object, "Label");
        v29 = 0u;
        v30 = 0u;
        v27 = 0u;
        v28 = 0u;
        v21 = sub_10003FBC0(a2, (char *)&v27);
        xpc_strerror(v17);
        sub_100028C34((uint64_t)a1, 3, "Could not import service from caller: caller = %s[%d], service = %s, error = %d: %s", v22, v23, v24, v25, v26, v21);
        return v17;
      }
    }
    else if (a4)
    {
      *a4 = v15;
    }
  }
  else
  {
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v8 = sub_10003FBC0(a2, (char *)&v27);
    sub_100028C34((uint64_t)a1, 3, "Could not import service from caller: caller = %s[%d], job is not a dictionary", v9, v10, v11, v12, v13, v8);
    return 22;
  }
  return result;
}

_QWORD *sub_10003877C(_DWORD *a1, void *a2, uint64_t a3)
{
  _QWORD *v6;
  const char *v8;
  unint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v14[7];
  unsigned int v15;
  _OWORD v16[4];
  char __str[16];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;

  v15 = sub_10002C0E4((uint64_t)a1, 3, 8, a3, 0, 0);
  if (v15)
    return 0;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  *(_OWORD *)__str = 0u;
  v18 = 0u;
  memset(v16, 0, sizeof(v16));
  v8 = sub_10003FBC0(a3, (char *)v16);
  snprintf(__str, 0x80uLL, "(submitted by %s[%d])", v8, *(_DWORD *)(a3 + 20));
  v14[0] = sub_10002A27C;
  v14[1] = sub_10002A664;
  v14[2] = sub_10002A7A8;
  v14[3] = sub_10002A940;
  v14[4] = sub_10002A998;
  v14[5] = sub_10002AA84;
  v14[6] = a1;
  if (sub_10002C0BC(a2, "Label"))
    v9 = 640;
  else
    v9 = 512;
  v10 = (_QWORD *)sub_100005F4C(a1, a2, __str, a3, (uint64_t)v14, v9, (int *)&v15);
  if (v10)
  {
    v6 = v10;
    sub_100019580(v10);
    sub_100029B24(a1, (uint64_t)v6);
    v13 = v6[172];
    sub_10001962C(v6);
    if ((v13 & 0x10000000) != 0)
      return 0;
  }
  else
  {
    if (!v15)
      sub_10004D720(0, v15, v11, v12);
    return 0;
  }
  return v6;
}

void sub_100038930(uint64_t a1, uint64_t a2, void *a3, int a4)
{
  xpc_object_t v8;
  uint64_t i;
  xpc_object_t value;
  xpc_object_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t j;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  xpc_object_t v24;
  uint64_t k;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t right;
  char v33;
  __int128 v34;
  __int128 v35;
  xpc_object_t object;

  v8 = xpc_dictionary_create(0, 0, 0);
  for (i = *(_QWORD *)(a2 + 192); i; i = *(_QWORD *)(i + 16))
  {
    value = xpc_dictionary_get_value(v8, (const char *)(i + 208));
    if (value)
    {
      v11 = xpc_retain(value);
    }
    else
    {
      v11 = xpc_array_create(0, 0);
      xpc_dictionary_set_value(v8, (const char *)(i + 208), v11);
    }
    *(_QWORD *)&v34 = 0;
    object = 0;
    v12 = sub_10001BEB4(i, &v34, 0, &object);
    if ((_DWORD)v12)
    {
      xpc_strerror(v12);
      sub_10001D418(a2, 3, "Could not activate socket group: %s: %d: %s", v13, v14, v15, v16, v17, i - 48);
    }
    else if (object)
    {
      for (j = 0; j < (unint64_t)object; ++j)
        xpc_array_set_fd(v11, 0xFFFFFFFFFFFFFFFFLL, *(_DWORD *)(v34 + 4 * j));
    }
    xpc_release(v11);
  }
  xpc_dictionary_set_value(a3, "Sockets", v8);
  xpc_release(v8);
  if (a4)
  {
    v24 = xpc_dictionary_create(0, 0, 0);
    if ((*(_BYTE *)(a2 + 369) & 2) != 0)
      sub_10001D418(a2, 4, "The launch(3) APIs cannot be used to check in MultipleInstance endpoints.", v19, v20, v21, v22, v23, v33);
    for (k = *(_QWORD *)(a2 + 152); k; k = *(_QWORD *)(k + 16))
    {
      object = 0;
      *(_QWORD *)&v26 = -1;
      *((_QWORD *)&v26 + 1) = -1;
      v34 = v26;
      v35 = v26;
      DWORD1(v35) = 0;
      DWORD1(v35) = sub_100020D78(a2);
      if (sub_1000354BC(a1, (uint64_t)&v34, (char *)(k + 168), 0, 0, &object, 0))
      {
        sub_10001D418(a2, 3, "Failed to activate endpoint for legacy check-in. Please just don't use this API: %s", v27, v28, v29, v30, v31, k - 88);
      }
      else
      {
        sub_10001D418(a2, 4, "Endpoint has been activated through legacy launch(3) APIs. Please switch to XPC or bootstrap_check_in(): %s", v27, v28, v29, v30, v31, k - 88);
        right = xpc_mach_send_get_right(object);
        xpc_dictionary_set_mach_recv(v24, k + 168, right);
        xpc_release(object);
      }
    }
    xpc_dictionary_set_value(a3, "MachServices", v24);
    xpc_release(v24);
  }
}

void sub_100038B80(char *a1, xpc_object_t object, uint64_t a3)
{
  const char *string_ptr;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(object);
    sub_100035E70(a3, a1, string_ptr, 0);
  }
}

void sub_100038BEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uintptr_t v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uintptr_t v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;

  *(_DWORD *)(a1 + 184) = a2;
  v11 = a2;
  v12 = sub_1000146E4();
  *(_QWORD *)(a1 + 152) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, v11, 1uLL, v12);
  sub_100019A20(a1);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 152), (void *)a1);
  dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 152), (dispatch_function_t)sub_1000291CC);
  dispatch_source_set_mandatory_cancel_handler_f(*(_QWORD *)(a1 + 152), sub_100038D6C);
  dispatch_activate(*(dispatch_object_t *)(a1 + 152));
  if (*(_QWORD **)(a1 + 112) == qword_100071750)
  {
    v20 = *(_QWORD *)(a1 + 120);
    v21 = sub_1000146E4();
    *(_QWORD *)(a1 + 144) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v20, 0x20000000uLL, v21);
    sub_100019A20(a1);
    dispatch_set_context(*(dispatch_object_t *)(a1 + 144), (void *)a1);
    dispatch_source_set_event_handler_f(*(dispatch_source_t *)(a1 + 144), (dispatch_function_t)sub_100038DB0);
    v22 = sub_10001FB38(*(_DWORD *)(a1 + 120));
    if (v22 && !sub_10002158C(v22))
    {
      sub_100028C34(a1, 5, "deferring exec source uncork", v23, v24, v25, v26, v27, v28);
      *(_DWORD *)(a1 + 1016) |= 0x200u;
    }
    else
    {
      sub_100028C34(a1, 5, "uncorking exec source upfront", v23, v24, v25, v26, v27, v28);
      dispatch_activate(*(dispatch_object_t *)(a1 + 144));
    }
  }
  if ((a2 - 1) > 0xFFFFFFFD || sub_10002FD78(a2))
    sub_1000290BC(a1, v13, v14, v15, v16, v17, v18, v19, a9);
}

void sub_100038D6C(NSObject *a1)
{
  mach_port_name_t handle;
  int v3;

  handle = dispatch_source_get_handle(a1);
  if (handle - 1 <= 0xFFFFFFFD)
  {
    v3 = sub_10000D980(handle);
    if (v3)
      _os_assumes_log(v3);
  }
  dispatch_release(a1);
}

void sub_100038DB0(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  sub_100028C34(a1, 5, "domain exec event", a4, a5, a6, a7, a8, v16);
  *(_DWORD *)(a1 + 1016) |= 0x80u;
  sub_1000291CC(a1, v9, v10, v11, v12, v13, v14, v15);
}

char *sub_100038DEC()
{
  uint64_t v0;

  return sub_100028C98(v0, 1);
}

char *sub_100038DF8(uint64_t a1, uint64_t a2)
{
  return sub_10001F264(a2, 1);
}

char *sub_100038E10(uint64_t a1)
{
  return sub_10001F264(a1, 1);
}

char *sub_100038E28(uint64_t a1)
{
  return sub_10001F264(a1, 1);
}

void sub_100038E38()
{
  qword_1000725C8 = 0;
  qword_1000725D0 = 0;
}

uint64_t sub_100038E4C(void *a1)
{
  xpc_object_t reply;
  uint64_t v3;

  reply = xpc_dictionary_create_reply(a1);
  if (!reply)
    sub_10004D74C();
  v3 = (uint64_t)reply;
  os_unfair_lock_lock_with_options(&unk_1000725D8, 0x10000);
  if ((void *)qword_1000725C8 == a1)
    qword_1000725D0 = v3;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000725D8);
  return v3;
}

void sub_100038EB0(uint64_t a1)
{
  os_unfair_lock_lock_with_options(&unk_1000725D8, 0x10000);
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_1000725D8);
  qword_1000725C8 = a1;
  qword_1000725D0 = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000725D8);
}

uint64_t sub_100038EFC(uint64_t a1, NSObject *a2, void *a3)
{
  BOOL v6;
  uint64_t v7;

  os_unfair_lock_lock_with_options(&unk_1000725D8, 0x10000);
  os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_1000725D8);
  if (qword_1000725D0)
    v6 = qword_1000725D0 == a1;
  else
    v6 = 0;
  v7 = v6;
  if (v6)
  {
    os_unfair_lock_assert_owner((const os_unfair_lock *)&unk_1000725D8);
    qword_1000725C8 = 0;
    qword_1000725D0 = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000725D8);
    xpc_dictionary_handoff_reply(a1, a2, a3);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000725D8);
    dispatch_async(a2, a3);
  }
  return v7;
}

uint64_t sub_100038FB8()
{
  mach_port_t v0;
  uint32_t multiuser_flags;

  if ((*(_BYTE *)(sub_10002E190() + 1016) & 4) == 0)
    sub_10004D74C();
  multiuser_flags = 0;
  v0 = mach_host_self();
  if (host_get_multiuser_config_flags(v0, &multiuser_flags))
    return 0;
  else
    return multiuser_flags & 0x3FFFFFFF;
}

uint64_t sub_100039000()
{
  if ((*(_BYTE *)(sub_10002E190() + 1016) & 4) == 0)
    sub_10004D74C();
  if (qword_1000725E0 != -1)
    dispatch_once(&qword_1000725E0, &stru_10006CCA8);
  return byte_1000725E8;
}

void sub_100039050(id a1)
{
  mach_port_t v1;
  BOOL v2;
  char v3;
  uint32_t multiuser_flags;

  multiuser_flags = 0;
  v1 = mach_host_self();
  if (host_get_multiuser_config_flags(v1, &multiuser_flags))
    v2 = 0;
  else
    v2 = (multiuser_flags & 0x80000000) != 0;
  v3 = v2;
  byte_1000725E8 = v3;
}

uint64_t sub_100039090(int *a1)
{
  int v1;
  int v2;
  int v3;
  unsigned int v5;
  _DWORD v6[3];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _BYTE v11[268];
  int v12;

  v5 = -1;
  v1 = *a1;
  v2 = a1[1];
  v6[0] = 2;
  v6[1] = v2;
  memset(v11, 0, sizeof(v11));
  v10 = 0u;
  v9 = 0u;
  v8 = 0u;
  v7 = 0u;
  if (a1[2])
    v3 = a1[2];
  else
    v3 = 2;
  v6[2] = v3;
  v12 = v1;
  if (v1 == -101)
    strcpy(&v11[12], "system");
  else
    snprintf(&v11[12], 0xFFuLL, "user.%d", v1);
  if (kpersona_alloc(v6, &v5) == -1)
    sub_10004D870();
  return v5;
}

uint64_t sub_1000391BC()
{
  uint64_t result;

  result = kpersona_dealloc();
  if ((_DWORD)result == -1)
    return sub_10004D870();
  return result;
}

uint64_t sub_1000391E0(uint64_t a1)
{
  int v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  v3 = 0u;
  v4 = 0u;
  v2 = 1;
  if (kpersona_pidinfo(*(unsigned int *)(a1 + 20), &v2))
    return 0xFFFFFFFFLL;
  else
    return v3;
}

uint64_t sub_100039298(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  int v4;
  uint64_t result;
  int v6;
  int v7;
  int *v8;
  char *v9;
  uint64_t v10;

  v10 = *a3;
  v4 = kpersona_find_by_type(a1, a2, &v10);
  if (v4 < 0)
  {
    v6 = v4;
    v7 = *__error();
    v8 = __error();
    v9 = strerror(*v8);
    sub_100040F68(4, "kpersona_find_by_type() failed with ret %d errno %d - %s", v6, v7, v9);
    *a3 = 0;
    return *__error();
  }
  else
  {
    result = 0;
    *a3 = v10;
  }
  return result;
}

uint64_t sub_100039324(uint64_t a1)
{
  int v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;

  v24 = 0;
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  v3 = 0u;
  v4 = 0u;
  v2 = 2;
  if (kpersona_info(a1, &v2))
    return 4294967293;
  else
    return HIDWORD(v24);
}

_DWORD *sub_1000393DC()
{
  return sub_10004454C(11, (uint64_t)sub_1000393EC);
}

uint64_t sub_1000393EC(uint64_t a1, int a2, void *a3, _QWORD *a4)
{
  __int128 *v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  xpc_object_t reply;
  xpc_object_t v12;
  void *v13;
  unsigned __int8 *v14;
  _OWORD buffer[9];
  __int128 v16;
  __int128 v17;
  __int128 v18;

  v7 = sub_100044524();
  if (!sub_10000FEF4((uint64_t)v7, 37))
    return 144;
  v8 = *((_DWORD *)v7 + 5);
  v17 = 0u;
  v18 = 0u;
  v16 = 0u;
  memset(buffer, 0, sizeof(buffer));
  result = sub_10003FB84(v8, buffer);
  if (!(_DWORD)result)
  {
    v14 = 0;
    result = sub_10003C51C(v8, &v14);
    if ((_DWORD)result)
    {
      if (v14)
        sub_10004D74C();
    }
    else if (*((_QWORD *)&v16 + 1) == *(_QWORD *)(*(_QWORD *)v14 + 1144))
    {
      if (a2 == 1200)
      {
        v10 = *(_QWORD *)v14;
        reply = xpc_dictionary_create_reply(a3);
        v12 = reply;
        v13 = *(void **)(v10 + 640);
        if (v13)
          xpc_dictionary_set_value(reply, "additional-properties", v13);
        result = 0;
        *a4 = v12;
      }
      else
      {
        return 33;
      }
    }
    else
    {
      return 113;
    }
  }
  return result;
}

uint64_t *sub_100039524(void *a1, _BYTE *a2)
{
  uint64_t *empty;
  __int128 *v6;
  uint64_t v7;
  __int128 v8;
  void **applier;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t *v13;
  uint64_t *v14;
  _BYTE *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  char v24;

  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v7 = 0;
    v8 = 0uLL;
    v21 = 0;
    v22 = &v21;
    v23 = 0x2000000000;
    v24 = 0;
    v17 = 0;
    v18 = &v17;
    v19 = 0x2000000000;
    v20 = 0;
    applier = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_1000397C4;
    v12 = &unk_10006CCF0;
    v15 = a2;
    v16 = &v7;
    v13 = &v21;
    v14 = &v17;
    xpc_dictionary_apply(a1, &applier);
    if (*((_BYTE *)v22 + 24))
    {
      if (*((_BYTE *)v18 + 24))
      {
        sub_100014830(a2, 3, "Found unsupported directives");
      }
      else if ((_BYTE)v7)
      {
        if (v8 != 0)
        {
          _Block_object_dispose(&v17, 8);
          _Block_object_dispose(&v21, 8);
          if (BYTE1(v7))
            v6 = (__int128 *)((char *)&v8 + 8);
          else
            v6 = &v8;
          if (*(_QWORD *)v6)
            return (uint64_t *)sub_100039524(*(_QWORD *)v6, a2);
          else
            return 0;
        }
        sub_100014830(a2, 3, "Either %s or %s must be present");
      }
      else
      {
        sub_100014830(a2, 3, "Missing conditions");
      }
    }
    _Block_object_dispose(&v17, 8);
    _Block_object_dispose(&v21, 8);
    empty = (uint64_t *)xpc_dictionary_create_empty();
    applier = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_10003976C;
    v12 = &unk_10006CCC8;
    v13 = (uint64_t *)a2;
    v14 = empty;
    xpc_dictionary_apply(a1, &applier);
  }
  else
  {
    if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_array)
      return (uint64_t *)xpc_copy(a1);
    empty = (uint64_t *)xpc_array_create_empty();
    applier = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = sub_100039978;
    v12 = &unk_10006CD10;
    v13 = (uint64_t *)a2;
    v14 = empty;
    xpc_array_apply(a1, &applier);
  }
  return empty;
}

uint64_t sub_10003976C(uint64_t a1, const char *a2, uint64_t a3)
{
  void *v5;
  void *v6;

  v5 = (void *)sub_100039524(a3, *(_QWORD *)(a1 + 32));
  if (v5)
  {
    v6 = v5;
    xpc_dictionary_set_value(*(xpc_object_t *)(a1 + 40), a2, v5);
    xpc_release(v6);
  }
  return 1;
}

uint64_t sub_1000397C4(_QWORD *a1, char *__s1, void *a3)
{
  _BYTE *v6;
  uint64_t v7;
  BOOL v8;
  _BOOL4 v9;
  const _xpc_type_s *type;
  char v11;
  char *string_ptr;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char v18;

  v6 = (_BYTE *)a1[6];
  v7 = a1[7];
  v8 = sub_1000157A8(__s1, "#IfFeatureFlagEnabled");
  v9 = sub_1000157A8(__s1, "#IfFeatureFlagDisabled");
  if (v8 || v9)
  {
    if (xpc_get_type(a3) == (xpc_type_t)&_xpc_type_string)
    {
      string_ptr = (char *)xpc_string_get_string_ptr(a3);
      v14 = strchr(string_ptr, 47);
      if (v14)
      {
        v15 = v14;
        v16 = v14 + 1;
        if (!strchr(v14 + 1, 47))
        {
          v17 = sub_1000154A0(string_ptr, v15 - string_ptr);
          v18 = j___os_feature_enabled_impl(v17, v16);
          free(v17);
          *(_BYTE *)(v7 + 1) |= v8 ^ v18;
          v11 = 1;
          *(_BYTE *)v7 = 1;
          goto LABEL_12;
        }
        sub_100014830(v6, 3, "Feature flag string must not have multiple '/' separators: %s");
      }
      else
      {
        sub_100014830(v6, 3, "Feature flag string must have domain/feature format: %s");
      }
    }
    else
    {
      type = xpc_get_type(a3);
      xpc_type_get_name(type);
      sub_100014830(v6, 3, "Expected string for a feature flag, got %s");
    }
    goto LABEL_11;
  }
  if (!sub_1000157A8(__s1, "#Then"))
  {
    if (sub_1000157A8(__s1, "#Else"))
    {
      *(_QWORD *)(v7 + 16) = a3;
      goto LABEL_10;
    }
LABEL_11:
    v11 = 0;
    goto LABEL_12;
  }
  *(_QWORD *)(v7 + 8) = a3;
LABEL_10:
  v11 = 1;
LABEL_12:
  *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) |= v11;
  *(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24) |= v11 ^ 1;
  return 1;
}

uint64_t sub_100039978(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v4;
  void *v5;

  v4 = (void *)sub_100039524(a3, *(_QWORD *)(a1 + 32));
  if (v4)
  {
    v5 = v4;
    xpc_array_append_value(*(xpc_object_t *)(a1 + 40), v4);
    xpc_release(v5);
  }
  return 1;
}

void sub_1000399C0(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 16) != -1 || *(_QWORD *)(a1 + 24) != -1)
    sub_10004D738();
  if (*(_QWORD *)(a1 + 48))
    sub_10004D738();
  sub_10001962C(*(void **)(a1 + 40));
}

void sub_100039A08(_QWORD *a1)
{
  uint64_t v2;

  if (a1[5])
    sub_10004D738();
  if (sub_1000431BC(a1[4]))
    sub_10004D738();
  if (sub_1000431BC(a1[7]))
    sub_10004D738();
  if (a1[6])
  {
    v2 = a1[2];
    if (v2)
      *(_QWORD *)(v2 + 24) = a1[3];
    *(_QWORD *)a1[3] = v2;
    a1[2] = -1;
    a1[3] = -1;
  }
  sub_10001962C((void *)a1[4]);
  sub_10001962C((void *)a1[7]);
}

uint64_t sub_100039AA0(uint64_t result)
{
  if (*(_QWORD *)(result + 16))
    sub_10004D738();
  return result;
}

void sub_100039ABC(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 16) != -1 || *(_QWORD *)(a1 + 24) != -1)
    sub_10004D738();
  if (*(_QWORD *)(a1 + 32) != -1 || *(_QWORD *)(a1 + 40) != -1)
    sub_10004D738();
  xpc_release(*(xpc_object_t *)(a1 + 56));
}

_DWORD *sub_100039B08()
{
  return sub_10004454C(4, (uint64_t)sub_100039B18);
}

uint64_t sub_100039B18(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  __int128 *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  xpc_object_t reply;
  uint64_t v12;
  int v13;
  void *v14;
  xpc_object_t *v15;
  uint64_t v17;
  uint64_t v18;
  const char *string;
  uint64_t uint64;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  uint64_t v28;
  _QWORD *v29;
  xpc_object_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  const char *v40;
  uint64_t v41;
  BOOL v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  Block_layout *v57;
  uint64_t v58;
  uint64_t v59;
  const char *v60;
  const char *v61;
  xpc_object_t value;
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD *v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  xpc_object_t v76;
  int v77;
  _BOOL4 v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  uint64_t v86;
  uint64_t v87;
  char v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  int int64;
  uint64_t v97;
  char *v98;
  xpc_object_t v99;
  uint64_t v100;
  char *v101;

  v7 = sub_100044524();
  v8 = a2 - 400;
  v9 = (uint64_t)v7;
  v10 = 45;
  switch(v8)
  {
    case 0:
      v101 = 0;
      v10 = sub_10003ADD4(a3, *((_DWORD *)v7 + 5), 1, &v101);
      if (!(_DWORD)v10)
      {
        reply = xpc_dictionary_create_reply(a3);
        *a4 = reply;
        if (v101)
          v12 = *((_QWORD *)v101 + 9);
        else
          v12 = 0;
        xpc_dictionary_set_uint64(reply, "token", v12);
      }
      return v10;
    case 1:
      v13 = *((_DWORD *)v7 + 5);
      v14 = a3;
      v15 = a4;
      return sub_10003AFA8(v14, v15, v13);
    case 2:
      v17 = sub_10001FB38(*((_DWORD *)v7 + 5));
      if (!v17)
        return 1;
      v18 = v17;
      string = xpc_dictionary_get_string(a3, "stream");
      uint64 = xpc_dictionary_get_uint64(a3, "token");
      v10 = 22;
      if (!string)
        return v10;
      v21 = uint64;
      if (!uint64 || !xpc_dictionary_expects_reply(a3))
        return v10;
      v22 = *(_QWORD *)(v18 + 144);
      if (!v22)
        return 3;
      while (1)
      {
        v23 = *(_QWORD *)(v22 + 40);
        if (!strcmp((const char *)(v23 + 32), string))
          break;
        v22 = *(_QWORD *)(v22 + 16);
        v10 = 3;
        if (!v22)
          return v10;
      }
      v70 = *(_QWORD *)(v23 + 16);
      if (!v70)
        goto LABEL_104;
      while (*(_QWORD *)(v70 + 72) != v21)
      {
        v70 = *(_QWORD *)(v70 + 32);
        if (!v70)
          goto LABEL_104;
      }
      v30 = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_string(v30, "name", (const char *)(v70 + 88));
      goto LABEL_27;
    case 3:
      v24 = sub_10001FB38(*((_DWORD *)v7 + 5));
      if (!v24)
        return 1;
      v25 = v24;
      v26 = xpc_dictionary_get_string(a3, "stream");
      if (!v26)
        return 22;
      v27 = v26;
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v28 = *(_QWORD *)(v25 + 144);
      if (!v28)
        goto LABEL_22;
      while (strcmp((const char *)(*(_QWORD *)(v28 + 40) + 32), v27))
      {
        v28 = *(_QWORD *)(v28 + 16);
        if (!v28)
        {
LABEL_22:
          if ((*(_BYTE *)(v25 + 368) & 0x10) != 0)
            return 124;
          if (!sub_10000FEF4(v9, 7))
            return 3;
          LODWORD(v101) = 0;
          v29 = sub_10003A32C(v25, v27, 1, (int *)&v101);
          v10 = v101;
          if ((_DWORD)v101)
            return v10;
          v28 = (uint64_t)v29;
          if (!v29)
            sub_10004D738();
          break;
        }
      }
      v30 = xpc_dictionary_create_reply(a3);
      sub_10003B148(v30, v28);
LABEL_27:
      v10 = 0;
      goto LABEL_28;
    case 4:
      v31 = sub_10001FB38(*((_DWORD *)v7 + 5));
      if (!v31)
        return 1;
      v32 = v31;
      v33 = xpc_dictionary_get_string(a3, "stream");
      v34 = xpc_dictionary_get_uint64(a3, "token");
      v10 = 22;
      if (!v33)
        return v10;
      v35 = v34;
      if (!v34 || !xpc_dictionary_expects_reply(a3))
        return v10;
      v22 = *(_QWORD *)(v32 + 144);
      if (!v22)
        return 3;
      while (1)
      {
        v36 = *(_QWORD *)(v22 + 40);
        if (!strcmp((const char *)(v36 + 32), v33))
          break;
        v22 = *(_QWORD *)(v22 + 16);
        v10 = 3;
        if (!v22)
          return v10;
      }
      v71 = *(_QWORD *)(v36 + 16);
      if (!v71)
        goto LABEL_104;
      while (*(_QWORD *)(v71 + 72) != v35)
      {
        v71 = *(_QWORD *)(v71 + 32);
        if (!v71)
          goto LABEL_104;
      }
      v78 = xpc_dictionary_get_BOOL(a3, "state");
      v85 = *(_BYTE *)(v71 + 80);
      *(_BYTE *)(v71 + 80) = v85 & 0xFE | v78;
      if (v78)
      {
        if ((v85 & 2) != 0)
          v86 = 11;
        else
          v86 = 8;
        v87 = sub_1000203B0(*(_QWORD *)(v71 + 48), v86, v79, v80, v81, v82, v83, v84);
        if (v87 > 0x25 || ((1 << v87) & 0x3000000001) == 0)
        {
          v89 = v87;
          v90 = *(_QWORD *)(v71 + 48);
          xpc_strerror(v87);
          sub_10001D418(v90, 3, "Could not spawn service in response to XPC event state change: %d: %s", v91, v92, v93, v94, v95, v89);
        }
        if ((*(_BYTE *)(v71 + 80) & 2) != 0)
        {
          sub_10003ACA8((_QWORD *)v71);
          sub_10001962C((void *)v71);
        }
      }
      v10 = 0;
      *a4 = xpc_dictionary_create_reply(a3);
      return v10;
    case 5:
    case 7:
      return v10;
    case 6:
      v37 = sub_10001FB38(*((_DWORD *)v7 + 5));
      if (!v37)
        return 1;
      v38 = v37;
      v39 = xpc_dictionary_get_string(a3, "stream");
      if (!v39)
        return 22;
      v40 = v39;
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v41 = *(_QWORD *)(v38 + 144);
      if (!v41)
      {
LABEL_43:
        v42 = (*(_BYTE *)(v38 + 368) & 0x10) == 0;
        v43 = 124;
        goto LABEL_106;
      }
      while (strcmp((const char *)(*(_QWORD *)(v41 + 40) + 32), v40))
      {
        v41 = *(_QWORD *)(v41 + 16);
        if (!v41)
          goto LABEL_43;
      }
      if ((*(_BYTE *)(v41 + 56) & 1) != 0)
      {
        v76 = xpc_dictionary_create_reply(a3);
        v77 = xpc_pipe_routine_reply(v76);
        if ((v77 & 0xFFFFFFDF) != 0)
          _os_assumes_log(v77);
        xpc_release(v76);
        return 0;
      }
      else
      {
        v68 = *(_QWORD *)(v41 + 48);
        if (v68)
        {
          v69 = xpc_pipe_routine_reply(v68);
          if ((v69 & 0xFFFFFFDF) != 0)
            _os_assumes_log(v69);
          xpc_release(*(xpc_object_t *)(v41 + 48));
          *(_QWORD *)(v41 + 48) = 0;
        }
        v10 = 0;
        *(_QWORD *)(v41 + 48) = xpc_dictionary_create_reply(a3);
      }
      return v10;
    case 8:
      v44 = sub_10001FB38(*((_DWORD *)v7 + 5));
      if (!v44)
        return 1;
      v45 = v44;
      v46 = xpc_dictionary_get_string(a3, "stream");
      v47 = xpc_dictionary_get_uint64(a3, "token");
      v10 = 22;
      if (!v46)
        return v10;
      v48 = v47;
      if (!v47 || !xpc_dictionary_expects_reply(a3))
        return v10;
      v49 = *(_QWORD *)(v45 + 144);
      if (!v49)
        return 3;
      while (1)
      {
        v50 = *(_QWORD *)(v49 + 40);
        if (!strcmp((const char *)(v50 + 32), v46))
          break;
        v49 = *(_QWORD *)(v49 + 16);
        v10 = 3;
        if (!v49)
          return v10;
      }
      v72 = *(_QWORD *)(v50 + 16);
      if (!v72)
      {
LABEL_100:
        v73 = *(_BYTE *)(v49 + 56);
        goto LABEL_105;
      }
      while (*(_QWORD *)(v72 + 72) != v48)
      {
        v72 = *(_QWORD *)(v72 + 32);
        if (!v72)
          goto LABEL_100;
      }
      xpc_dictionary_set_string(a3, "name", (const char *)(v72 + 88));
      int64 = xpc_dictionary_get_int64(a3, "subscriber-pid");
      v101 = 0;
      v10 = sub_10003ADD4(a3, int64, 0, &v101);
      if (!(_DWORD)v10)
      {
        v30 = xpc_dictionary_create_reply(a3);
        sub_10003B148(v30, v49);
        if (v101)
          v97 = *((_QWORD *)v101 + 9);
        else
          v97 = 0;
        xpc_dictionary_set_uint64(v30, "token", v97);
LABEL_28:
        *a4 = v30;
      }
      return v10;
    case 9:
      v51 = sub_10001FB38(*((_DWORD *)v7 + 5));
      if (!v51)
        return 1;
      v52 = v51;
      v53 = xpc_dictionary_get_string(a3, "stream");
      v54 = xpc_dictionary_get_uint64(a3, "token");
      v10 = 22;
      if (!v53)
        return v10;
      v55 = v54;
      if (!v54 || !xpc_dictionary_expects_reply(a3))
        return v10;
      v22 = *(_QWORD *)(v52 + 144);
      if (!v22)
        return 3;
      break;
    case 10:
      v57 = &stru_10006CDB8;
      return sub_10003B1FC(a3, a4, (uint64_t)v7, (uint64_t)v57);
    case 11:
      v57 = &stru_10006CE20;
      return sub_10003B1FC(a3, a4, (uint64_t)v7, (uint64_t)v57);
    case 12:
      v58 = sub_10001FB38(*((_DWORD *)v7 + 5));
      if (!v58)
        return 1;
      v59 = v58;
      v60 = xpc_dictionary_get_string(a3, "stream");
      v61 = xpc_dictionary_get_string(a3, "name");
      value = xpc_dictionary_get_value(a3, "descriptor");
      v63 = xpc_dictionary_get_int64(a3, "subscriber-pid");
      v10 = 22;
      if (!v60)
        return v10;
      if (!v61)
        return v10;
      v64 = v63;
      if (!v63
        || !value
        || xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary
        || !xpc_dictionary_expects_reply(a3))
      {
        return v10;
      }
      v65 = sub_10001FB38(v64);
      if (!v65)
        return 113;
      v66 = *(_QWORD *)(v59 + 144);
      if (!v66)
        return 3;
      v67 = (_QWORD *)v65;
      v10 = 3;
      while (strcmp((const char *)(*(_QWORD *)(v66 + 40) + 32), v60))
      {
        v66 = *(_QWORD *)(v66 + 16);
        if (!v66)
          return v10;
      }
      v98 = sub_10003AACC(v67, v60, v61, value, 0);
      v99 = xpc_dictionary_create_reply(a3);
      v30 = v99;
      if (v98)
      {
        sub_10003B148(v99, v66);
        v100 = *((_QWORD *)v98 + 9);
      }
      else
      {
        v100 = 0;
      }
      xpc_dictionary_set_uint64(v30, "token", v100);
      goto LABEL_27;
    default:
      return 33;
  }
  while (1)
  {
    v56 = *(_QWORD *)(v22 + 40);
    if (!strcmp((const char *)(v56 + 32), v53))
      break;
    v22 = *(_QWORD *)(v22 + 16);
    v10 = 3;
    if (!v22)
      return v10;
  }
  v74 = *(_QWORD *)(v56 + 16);
  if (v74)
  {
    while (*(_QWORD *)(v74 + 72) != v55)
    {
      v74 = *(_QWORD *)(v74 + 32);
      if (!v74)
        goto LABEL_104;
    }
    xpc_dictionary_set_string(a3, "name", (const char *)(v74 + 88));
    v13 = xpc_dictionary_get_int64(a3, "subscriber-pid");
    v14 = a3;
    v15 = a4;
    return sub_10003AFA8(v14, v15, v13);
  }
  else
  {
LABEL_104:
    v73 = *(_BYTE *)(v22 + 56);
LABEL_105:
    v42 = (v73 & 1) == 0;
    v43 = 132;
LABEL_106:
    if (v42)
      return 3;
    else
      return v43;
  }
}

_QWORD *sub_10003A32C(uint64_t a1, const void *a2, char a3, int *a4)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char *v22;
  uint64_t v23;
  char *v25;
  _QWORD v26[6];
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  rb_tree_t **v30;

  v8 = sub_1000299B8(*(_QWORD *)(a1 + 248));
  v27 = 0;
  v28 = &v27;
  v29 = 0x2000000000;
  v30 = 0;
  v30 = sub_10003A4FC((uint64_t)v8, a2);
  v9 = v28[3];
  if ((a3 & 1) == 0 && !v9)
  {
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 0x40000000;
    v26[2] = sub_10003A5B4;
    v26[3] = &unk_10006CD38;
    v26[4] = &v27;
    v26[5] = a2;
    sub_10003A550((uint64_t)v8, (uint64_t)v26);
    v9 = v28[3];
  }
  if (v9)
  {
    v25 = sub_10001F264(*(_QWORD *)(v9 + 32), 2);
    sub_10001D418(a1, 3, "Event stream %s is already monitored by %s, ignoring", v10, v11, v12, v13, v14, (char)a2);
    free(v25);
    v15 = 0;
    if (a4)
    {
      v16 = 17;
LABEL_14:
      *a4 = v16;
    }
  }
  else if ((sub_100005BA8(a1, 5) & 1) != 0)
  {
    v15 = sub_100019B94(0);
    v22 = sub_100019BEC((const char *)a2);
    v15[5] = v22;
    *((_QWORD *)v22 + 3) = v15;
    v23 = *(_QWORD *)(a1 + 144);
    v15[2] = v23;
    if (v23)
      *(_QWORD *)(v23 + 24) = v15 + 2;
    *(_QWORD *)(a1 + 144) = v15;
    v15[3] = a1 + 144;
    sub_100043048(v8[4], a2, v15);
    v15[4] = a1;
    *((_BYTE *)v15 + 56) = v15[7] & 0xF9 | (2 * (a3 & 3));
    sub_10003A5F8((uint64_t)v15, (uint64_t)v8);
    if (a4)
    {
      v16 = 0;
      goto LABEL_14;
    }
  }
  else
  {
    sub_10001D418(a1, 3, "Non-system service tried to claim event stream %s", v17, v18, v19, v20, v21, (char)a2);
    v15 = 0;
    if (a4)
    {
      v16 = 150;
      goto LABEL_14;
    }
  }
  _Block_object_dispose(&v27, 8);
  return v15;
}

rb_tree_t **sub_10003A4FC(uint64_t a1, const void *a2)
{
  uint64_t v3;
  rb_tree_t **result;

  v3 = a1;
  result = sub_10004310C(*(rb_tree_t ***)(a1 + 32), a2);
  if (!result)
  {
    while (1)
    {
      v3 = *(_QWORD *)(v3 + 48);
      if (!v3)
        break;
      result = sub_10004310C(*(rb_tree_t ***)(v3 + 32), a2);
      if (result && ((_BYTE)result[7] & 2) == 0)
        return result;
    }
    return 0;
  }
  return result;
}

uint64_t sub_10003A550(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v3 = *(_QWORD *)(result + 40);
  if (v3)
  {
    v4 = result;
    do
    {
      v5 = *(_QWORD *)(v3 + 16);
      (*(void (**)(uint64_t))(a2 + 16))(a2);
      v3 = v5;
    }
    while (v5);
    result = *(_QWORD *)(v4 + 40);
    if (result)
    {
      do
      {
        v6 = *(_QWORD *)(result + 16);
        sub_10003A550();
        result = v6;
      }
      while (v6);
    }
  }
  return result;
}

rb_tree_t **sub_10003A5B4(rb_tree_t **result, uint64_t a2)
{
  rb_tree_t **v2;

  if (!*((_QWORD *)result[4]->opaque[1] + 3))
  {
    v2 = result;
    result = sub_10004310C(*(rb_tree_t ***)(a2 + 32), result[5]);
    *((_QWORD *)v2[4]->opaque[1] + 3) = result;
  }
  return result;
}

uint64_t sub_10003A5F8(uint64_t a1, uint64_t a2)
{
  rb_tree_t **v4;
  rb_tree_t **v5;
  rb_tree_t *v6;
  rb_tree_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t result;
  uint64_t v14;

  v4 = sub_10004310C(*(rb_tree_t ***)(a2 + 56), (const void *)(*(_QWORD *)(a1 + 40) + 32));
  if (v4)
  {
    v5 = v4;
    sub_100019580(v4);
    v6 = v5[2];
    if (v6)
    {
      do
      {
        v7 = (rb_tree_t *)v6->opaque[4];
        if ((*(_BYTE *)(a1 + 56) & 4) != 0 && !sub_100005BA8((uint64_t)v6->opaque[6], 6))
        {
          sub_10001D418((uint64_t)v6->opaque[6], 4, "Rejecting untrusted event subscription on stream %s", v8, v9, v10, v11, v12, *(_BYTE *)(a1 + 40) + 32);
          sub_10003ACA8(v6);
          sub_10001962C(v6);
        }
        else
        {
          sub_10003A8EC(v6, 0, 1);
          if ((sub_10003B3C0(v6, a1, 1) & 1) == 0)
            sub_10004D738();
        }
        v6 = v7;
      }
      while (v7);
    }
    sub_100043048(*(_QWORD *)(a2 + 56), v5 + 4, 0);
    sub_10001962C(v5);
    return 1;
  }
  else
  {
    if ((*(_BYTE *)(a1 + 56) & 2) != 0)
      return 0;
    v14 = *(_QWORD *)(a2 + 40);
    if (!v14)
    {
      return 0;
    }
    else
    {
      do
      {
        result = sub_10003A5F8(a1, v14);
        if ((_DWORD)result)
          break;
        v14 = *(_QWORD *)(v14 + 16);
      }
      while (v14);
    }
  }
  return result;
}

uint64_t sub_10003A74C(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  for (result = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16); result; result = *(_QWORD *)(result + 32))
  {
    if (*(_QWORD *)(result + 72) == a2)
      break;
  }
  return result;
}

uint64_t sub_10003A770(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40) + 32;
}

uint64_t sub_10003A77C(uint64_t a1)
{
  return *(_BYTE *)(a1 + 56) & 1;
}

void sub_10003A788(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  void *v7;
  void *v8;
  int v9;

  v2 = sub_1000299B8(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 248));
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
    *(_QWORD *)(v3 + 24) = *(_QWORD *)(a1 + 24);
  **(_QWORD **)(a1 + 24) = v3;
  *(_QWORD *)(a1 + 16) = -1;
  *(_QWORD *)(a1 + 24) = -1;
  sub_100043048(v2[4], (const void *)(*(_QWORD *)(a1 + 40) + 32), 0);
  v4 = *(_QWORD **)(*(_QWORD *)(a1 + 40) + 16);
  if (v4)
  {
    do
    {
      v5 = (_QWORD *)v4[4];
      v6 = sub_1000299B8(*(_QWORD *)(v4[6] + 248));
      v7 = sub_10003A880((uint64_t)v6, (const void *)(*(_QWORD *)(a1 + 40) + 32));
      sub_10003A8EC(v4, 0, 1);
      sub_10003A97C(v4, (uint64_t)v7);
      v4 = v5;
    }
    while (v5);
  }
  v8 = *(void **)(a1 + 48);
  if (v8)
  {
    xpc_dictionary_set_int64(v8, "error", 124);
    v9 = xpc_pipe_routine_reply(*(_QWORD *)(a1 + 48));
    if ((v9 & 0xFFFFFFDF) != 0)
      _os_assumes_log(v9);
    xpc_release(*(xpc_object_t *)(a1 + 48));
    *(_QWORD *)(a1 + 48) = 0;
  }
}

void *sub_10003A880(uint64_t a1, const void *a2)
{
  void *v4;

  v4 = sub_10004310C(*(rb_tree_t ***)(a1 + 56), a2);
  if (!v4)
  {
    v4 = sub_100019BEC((const char *)a2);
    sub_100043048(*(_QWORD *)(a1 + 56), a2, v4);
    sub_10001962C(v4);
  }
  return v4;
}

void sub_10003A8EC(_QWORD *a1, int a2, int a3)
{
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;

  v3 = a1[4];
  v4 = (_QWORD *)a1[8];
  a1[8] = 0;
  a1[9] = 0;
  if (v3)
    *(_QWORD *)(v3 + 40) = a1[5];
  *(_QWORD *)a1[5] = v3;
  a1[4] = -1;
  a1[5] = -1;
  if (v4[3])
  {
    if (a3)
      sub_10003AD7C(v4[3]);
  }
  else if (a2 && !v4[2])
  {
    v5 = sub_1000299B8(*(_QWORD *)(a1[6] + 248));
    sub_100043048(v5[7], v4 + 4, 0);
  }
}

_QWORD *sub_10003A97C(_QWORD *a1, uint64_t a2)
{
  if (*(_QWORD *)(a2 + 24))
    sub_10004D738();
  return sub_10003B448(a1, a2);
}

uint64_t sub_10003A998(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;

  sub_10004391C(a2, a3, "%s => {", a4, a5, a6, a7, a8, a1 + 88);
  if ((*(_BYTE *)(a1 + 80) & 1) != 0)
    v16 = "1";
  else
    v16 = "0";
  sub_10004391C(a2, a3 + 1, "keepalive = %s", v11, v12, v13, v14, v15, v16);
  sub_10004391C(a2, a3 + 1, "service = %s", v17, v18, v19, v20, v21, *(_QWORD *)(a1 + 48) + 1392);
  sub_10004391C(a2, a3 + 1, "stream = %s", v22, v23, v24, v25, v26, *(_QWORD *)(a1 + 64) + 32);
  v32 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 24);
  if (v32)
    sub_10004391C(a2, a3 + 1, "monitor = %s", v27, v28, v29, v30, v31, *(_QWORD *)(v32 + 32) + 1392);
  sub_1000438B0(a2, a3 + 1, "descriptor = ", v27, v28, v29, v30, v31);
  sub_10001595C(a2, a3 + 1, 0, *(void **)(a1 + 56), v33, v34, v35, v36);
  return sub_10004391C(a2, a3, "}", v37, v38, v39, v40, v41);
}

char *sub_10003AAC4(_QWORD *a1, const void *a2, const char *a3, void *a4)
{
  return sub_10003AACC(a1, a2, a3, a4, 1);
}

char *sub_10003AACC(_QWORD *a1, const void *a2, const char *a3, void *a4, int a5)
{
  void *v10;
  rb_tree_t **v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char **v18;
  size_t v19;
  char *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  int v24;
  _BOOL4 v25;

  v10 = sub_1000299B8(a1[31]);
  v11 = sub_10003A4FC((uint64_t)v10, a2);
  v12 = (uint64_t)v11;
  if (v11 && ((_BYTE)v11[7] & 4) != 0 && (sub_100005BA8((uint64_t)a1, 6) & 1) == 0)
  {
    sub_10001D418((uint64_t)a1, 4, "Rejecting untrusted event subscription on stream %s", v13, v14, v15, v16, v17, (char)a2);
    return 0;
  }
  v18 = (char **)(a1 + 17);
  v19 = strlen(a3);
  v20 = (char *)sub_100019C38(v19 + 1);
  strcpy(v20 + 88, a3);
  *((_QWORD *)v20 + 6) = a1;
  *((_QWORD *)v20 + 7) = xpc_retain(a4);
  v20[80] = v20[80] & 0xFD | (2 * (strcmp((const char *)a2, "com.apple.launchd.helper") == 0));
  v21 = a1[17];
  *((_QWORD *)v20 + 2) = v21;
  if (v21)
    *(_QWORD *)(v21 + 24) = v20 + 16;
  *v18 = v20;
  *((_QWORD *)v20 + 3) = v18;
  if (v12)
  {
    if ((sub_10003B3C0(v20, v12, a5) & 1) == 0)
      sub_10004D738();
  }
  else
  {
    v22 = sub_10003A880((uint64_t)v10, a2);
    sub_10003A97C(v20, (uint64_t)v22);
  }
  v23 = sub_10002E948(a1[31], a1, (const char *)a2);
  v24 = strcmp((const char *)a2, "com.apple.iokit.matching");
  if (xpc_get_type(a4) == (xpc_type_t)&_xpc_type_dictionary)
  {
    v25 = xpc_dictionary_get_BOOL(a4, "IOMatchLaunchStream");
    if (v24)
    {
LABEL_15:
      sub_100045FE0(v23);
      return v20;
    }
  }
  else
  {
    v25 = 0;
    if (v24)
      goto LABEL_15;
  }
  if (v25)
    goto LABEL_15;
  return v20;
}

uint64_t sub_10003AC90(uint64_t a1)
{
  return *(_BYTE *)(a1 + 80) & 1;
}

uint64_t sub_10003AC9C(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 80) >> 1) & 1;
}

void sub_10003ACA8(_QWORD *a1)
{
  uint64_t v1;

  v1 = a1[2];
  if (v1)
    *(_QWORD *)(v1 + 24) = a1[3];
  *(_QWORD *)a1[3] = v1;
  a1[2] = -1;
  a1[3] = -1;
  sub_10003A8EC(a1, 1, 1);
}

_QWORD *sub_10003ACD8(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;

  v2 = sub_100019BC0(0);
  v3 = v2;
  if (a1)
  {
    v4 = (_QWORD *)(a1 + 40);
    v5 = *(_QWORD *)(a1 + 40);
    v2[2] = v5;
    v2[6] = a1;
    if (v5)
      *(_QWORD *)(v5 + 24) = v2 + 2;
    *v4 = v2;
    v2[3] = v4;
  }
  v2[4] = sub_1000431D8();
  v3[7] = sub_1000431D8();
  v3[8] = 1;
  return v3;
}

rb_tree_t **sub_10003AD40(rb_tree_t **result)
{
  if (((_BYTE)result[9] & 1) == 0)
  {
    *((_BYTE *)result + 72) |= 1u;
    return sub_100043140((rb_tree_t **)result[4], (uint64_t)&stru_10006CD78);
  }
  return result;
}

void sub_10003AD64(id a1, const char *a2, id a3)
{
  if (*(_QWORD *)(*((_QWORD *)a3 + 5) + 16))
    sub_10003AD7C((uint64_t)a3);
}

uint64_t sub_10003AD7C(uint64_t a1)
{
  uint64_t v2;
  int v3;

  *(_BYTE *)(a1 + 56) |= 1u;
  v2 = *(_QWORD *)(a1 + 48);
  if (v2)
  {
    v3 = xpc_pipe_routine_reply(v2);
    if ((v3 & 0xFFFFFFDF) != 0)
      _os_assumes_log(v3);
    xpc_release(*(xpc_object_t *)(a1 + 48));
    *(_QWORD *)(a1 + 48) = 0;
  }
  return sub_1000201F0(*(_QWORD *)(a1 + 32));
}

uint64_t sub_10003ADD4(void *a1, int a2, int a3, char **a4)
{
  uint64_t v7;
  _QWORD *v8;
  char *string;
  const char *v10;
  xpc_object_t value;
  uint64_t result;
  uint64_t v13;
  char *v14;
  void *v15;
  uint64_t v16;

  v7 = sub_10001FB38(a2);
  if (!v7)
    return 113;
  v8 = (_QWORD *)v7;
  string = (char *)xpc_dictionary_get_string(a1, "stream");
  v10 = xpc_dictionary_get_string(a1, "name");
  value = xpc_dictionary_get_value(a1, "descriptor");
  result = 22;
  if (string && v10)
  {
    if (value && xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary
      || !xpc_dictionary_expects_reply(a1))
    {
      return 22;
    }
    v13 = sub_10003AF48((uint64_t)v8, string, v10);
    if (v13)
    {
      v14 = (char *)v13;
      if (value)
      {
        v15 = *(void **)(v13 + 56);
        if (v15)
        {
          if (xpc_equal(value, v15))
            goto LABEL_19;
        }
      }
      v16 = *((_QWORD *)v14 + 2);
      if (v16)
        *(_QWORD *)(v16 + 24) = *((_QWORD *)v14 + 3);
      **((_QWORD **)v14 + 3) = v16;
      *((_QWORD *)v14 + 2) = -1;
      *((_QWORD *)v14 + 3) = -1;
      sub_10003A8EC(v14, 1, a3);
      sub_10001962C(v14);
    }
    if (value)
      v14 = sub_10003AACC(v8, string, v10, value, a3);
    else
      v14 = 0;
LABEL_19:
    result = 0;
    *a4 = v14;
  }
  return result;
}

uint64_t sub_10003AF48(uint64_t a1, char *__s2, const char *a3)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 136); i; i = *(_QWORD *)(i + 16))
  {
    if (!strcmp((const char *)(*(_QWORD *)(i + 64) + 32), __s2) && !strcmp((const char *)(i + 88), a3))
      break;
  }
  return i;
}

uint64_t sub_10003AFA8(void *a1, _QWORD *a2, int a3)
{
  uint64_t v5;
  uint64_t v6;
  char *string;
  const char *v8;
  uint64_t v9;
  xpc_object_t v10;
  uint64_t result;
  uint64_t i;
  const char *v13;
  xpc_object_t value;
  uint64_t j;
  xpc_object_t reply;

  v5 = sub_10001FB38(a3);
  if (!v5)
    return 113;
  v6 = v5;
  if (!xpc_dictionary_expects_reply(a1))
    return 22;
  string = (char *)xpc_dictionary_get_string(a1, "stream");
  v8 = xpc_dictionary_get_string(a1, "name");
  if (!string)
  {
    v10 = xpc_dictionary_create(0, 0, 0);
    for (i = *(_QWORD *)(v6 + 136); i; i = *(_QWORD *)(i + 16))
    {
      v13 = (const char *)(*(_QWORD *)(i + 64) + 32);
      value = xpc_dictionary_get_value(v10, v13);
      if (!value)
      {
        value = xpc_dictionary_create(0, 0, 0);
        xpc_dictionary_set_value(v10, v13, value);
        xpc_release(value);
      }
      xpc_dictionary_set_value(value, (const char *)(i + 88), *(xpc_object_t *)(i + 56));
    }
    goto LABEL_18;
  }
  if (!v8)
  {
    v10 = xpc_dictionary_create(0, 0, 0);
    for (j = *(_QWORD *)(v6 + 136); j; j = *(_QWORD *)(j + 16))
    {
      if (!strcmp((const char *)(*(_QWORD *)(j + 64) + 32), string))
        xpc_dictionary_set_value(v10, (const char *)(j + 88), *(xpc_object_t *)(j + 56));
    }
    goto LABEL_18;
  }
  v9 = sub_10003AF48(v6, string, v8);
  if (v9)
  {
    v10 = xpc_retain(*(xpc_object_t *)(v9 + 56));
LABEL_18:
    reply = xpc_dictionary_create_reply(a1);
    xpc_dictionary_set_value(reply, "event", v10);
    xpc_release(v10);
    result = 0;
    *a2 = reply;
    return result;
  }
  return 3;
}

void sub_10003B148(void *a1, uint64_t a2)
{
  xpc_object_t v4;
  uint64_t i;
  _BYTE *v6;

  v4 = xpc_array_create(0, 0);
  for (i = *(_QWORD *)(*(_QWORD *)(a2 + 40) + 16); i; i = *(_QWORD *)(i + 32))
  {
    xpc_array_set_uint64(v4, 0xFFFFFFFFFFFFFFFFLL, *(_QWORD *)(i + 72));
    xpc_array_append_value(v4, *(xpc_object_t *)(i + 56));
  }
  xpc_dictionary_set_value(a1, "events", v4);
  xpc_release(v4);
  v6 = sub_1000299B8(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 248));
  xpc_dictionary_set_BOOL(a1, "initial-load-completed", v6[72] & 1);
  *(_BYTE *)(a2 + 56) &= ~1u;
}

uint64_t sub_10003B1FC(void *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t uint64;
  uint64_t v10;
  void *v11;
  rb_tree_t **v12;
  uint64_t v13;
  xpc_object_t reply;
  uint64_t result;
  _QWORD v16[7];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[3];
  char v22;

  v7 = sub_10001FB38(*(_DWORD *)(a3 + 20));
  if (!v7)
    return 1;
  v8 = v7;
  uint64 = xpc_dictionary_get_uint64(a1, "token");
  if (!uint64)
    return 22;
  v10 = uint64;
  v11 = sub_1000299B8(*(_QWORD *)(v8 + 248));
  v21[0] = 0;
  v21[1] = v21;
  v21[2] = 0x2000000000;
  v22 = 0;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2000000000;
  v20 = 0;
  v12 = (rb_tree_t **)*((_QWORD *)v11 + 4);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = sub_10003B348;
  v16[3] = &unk_10006CDE0;
  v16[5] = &v17;
  v16[6] = v10;
  v16[4] = v21;
  sub_100043140(v12, (uint64_t)v16);
  v13 = v18[3];
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  if (!v13)
    return 3;
  reply = xpc_dictionary_create_reply(a1);
  (*(void (**)(uint64_t, uint64_t, xpc_object_t))(a4 + 16))(a4, v13, reply);
  result = 0;
  *a2 = reply;
  return result;
}

void sub_10003B334(id a1, _launch_service_s *a2, void *a3)
{
  xpc_dictionary_set_string(a3, "identifier", a2->var5);
}

_QWORD *sub_10003B348(_QWORD *result, uint64_t a2, uint64_t a3)
{
  _QWORD *v3;

  if (!*(_BYTE *)(*(_QWORD *)(result[4] + 8) + 24))
  {
    v3 = *(_QWORD **)(*(_QWORD *)(a3 + 40) + 16);
    if (v3)
    {
      while (v3[9] != result[6])
      {
        v3 = (_QWORD *)v3[4];
        if (!v3)
          return result;
      }
      *(_QWORD *)(*(_QWORD *)(result[5] + 8) + 24) = v3[6];
      *(_BYTE *)(*(_QWORD *)(result[4] + 8) + 24) = 1;
    }
  }
  return result;
}

void sub_10003B3A8(id a1, _launch_service_s *a2, void *a3)
{
  xpc_dictionary_set_uint64(a3, "uid", *((unsigned int *)a2->var3.var9 + 14));
}

uint64_t sub_10003B3C0(_QWORD *a1, uint64_t a2, int a3)
{
  uint64_t result;
  _QWORD *v7;
  uint64_t v8;

  if ((*(_BYTE *)(a2 + 56) & 4) == 0 || (result = sub_100005BA8(a1[6], 6), (_DWORD)result))
  {
    sub_10003B448(a1, *(_QWORD *)(a2 + 40));
    v7 = sub_1000299B8(*(_QWORD *)(*(_QWORD *)(a2 + 32) + 248));
    v8 = v7[8];
    a1[9] = v8;
    v7[8] = v8 + 1;
    if (v8 == -1)
      v7[8] = 1;
    if (a3)
      sub_10003AD7C(a2);
    return 1;
  }
  return result;
}

_QWORD *sub_10003B448(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;

  if (result[8])
    sub_10004D738();
  v2 = (_QWORD *)(a2 + 16);
  v3 = *(_QWORD *)(a2 + 16);
  result[4] = v3;
  result[8] = a2;
  if (v3)
    *(_QWORD *)(v3 + 40) = result + 4;
  *v2 = result;
  result[5] = v2;
  return result;
}

_DWORD *sub_10003B488()
{
  return sub_10004454C(8, (uint64_t)sub_10003B498);
}

uint64_t sub_10003B498(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  __int128 *v7;
  const char *string;
  uint64_t v9;
  _DWORD *v10;
  xpc_object_t value;
  vm_size_t v12;
  size_t v13;
  unint64_t v14;
  int v15;
  xpc_object_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  const char *v21;
  xpc_object_t v22;
  unsigned int count;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  uint64_t v28;
  xpc_object_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  const char *v37;
  uint64_t uint64;
  uint64_t v39;
  const char *v40;
  uint64_t v42;
  uint64_t v43;
  xpc_object_t reply;
  uint64_t v45;
  size_t v46;
  xpc_object_t xarray;
  char *v48;
  void *region;

  v7 = sub_100044524();
  switch(a2)
  {
    case 902:
      region = 0;
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      if (!sub_10000FEF4((uint64_t)v7, 23))
        return 144;
      string = xpc_dictionary_get_string(a3, "monitor_id");
      if (!string)
        return 22;
      v9 = sub_100003D00((uint64_t)string);
      if (!v9)
        return 96;
      v10 = (_DWORD *)v9;
      value = xpc_dictionary_get_value(a3, "shmem");
      if (!value)
        return 22;
      v12 = xpc_shmem_map(value, &region);
      v13 = v12;
      v48 = (char *)region;
      if (region && v12 >= vm_page_size)
      {
        v14 = v12 / 0x33;
        if (sub_100003A08((uint64_t)v10) < (v12 / 0x33))
          LODWORD(v14) = sub_100003A08((uint64_t)v10);
        v15 = sub_100003A08((uint64_t)v10);
        v16 = xpc_dictionary_create(0, 0, 0);
        xarray = xpc_array_create(0, 0);
        if ((_DWORD)v14)
        {
          v46 = v13;
          v17 = 0;
          v45 = v14;
          v18 = 51 * v14;
          v19 = v15 - v14;
          do
          {
            v20 = sub_100003A10(v10, v19);
            v21 = *(const char **)v20;
            v22 = xpc_dictionary_get_value(v16, *(const char **)v20);
            if (v22)
            {
              count = xpc_uint64_get_value(v22);
            }
            else
            {
              count = xpc_array_get_count(xarray);
              xpc_array_set_string(xarray, 0xFFFFFFFFFFFFFFFFLL, v21);
              xpc_dictionary_set_uint64(v16, v21, count);
            }
            v24 = &v48[v17];
            *(_DWORD *)v24 = count;
            *(_OWORD *)(v24 + 4) = *(_OWORD *)(v20 + 8);
            *(_QWORD *)(v24 + 20) = *(_QWORD *)(v20 + 24);
            v24[28] = *(_BYTE *)(v20 + 32);
            *(_QWORD *)(v24 + 29) = *(_QWORD *)(v20 + 33);
            *(_QWORD *)(v24 + 37) = *(_QWORD *)(v20 + 41);
            *(_DWORD *)(v24 + 45) = *(_DWORD *)(v20 + 49);
            *(_WORD *)(v24 + 49) = *(_WORD *)(v20 + 53);
            v17 += 51;
            ++v19;
          }
          while (v18 != v17);
          v25 = v45;
          v13 = v46;
        }
        else
        {
          v25 = 0;
        }
        xpc_release(v16);
        v43 = v10[5];
        sub_10000395C((uint64_t)v10);
        reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_uint64(reply, "count", v25);
        xpc_dictionary_set_uint64(reply, "dropped-count", v43);
        xpc_dictionary_set_value(reply, "labels", xarray);
        xpc_release(xarray);
        v26 = 0;
        *a4 = reply;
      }
      else
      {
        v42 = *__error();
        if ((_DWORD)v42)
          _os_assumes_log(v42);
        v26 = 22;
      }
      if (region && v13)
        munmap(region, v13);
      return v26;
    case 903:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v27 = xpc_dictionary_get_string(a3, "monitor_id");
      if (!v27)
        return 22;
      v28 = sub_100003D00((uint64_t)v27);
      v29 = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_BOOL(v29, "enabled", v28 != 0);
      goto LABEL_47;
    case 904:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v30 = 4294967195;
      v29 = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_BOOL(v29, "enabled", 1);
      v31 = sub_10003E404();
      if (v31)
      {
        v32 = v31;
        if (!sub_10002EA78(v31, 6, 0, (uint64_t)v7))
          v30 = *(unsigned int *)(v32 + 56);
      }
      xpc_dictionary_set_uint64(v29, "foreground_uid", v30);
      v33 = sub_10001FB38(*((_DWORD *)v7 + 5));
      if (v33)
      {
        v34 = *(_QWORD *)(v33 + 248);
        if (v34)
          goto LABEL_28;
LABEL_45:
        v36 = 0;
        goto LABEL_46;
      }
      v34 = sub_100044530();
      if (!v34)
        goto LABEL_45;
LABEL_28:
      v35 = *(_DWORD *)(v34 + 60);
      if (v35 == -101)
        v36 = 0;
      else
        v36 = v35;
LABEL_46:
      xpc_dictionary_set_uint64(v29, "session_uid", v36);
LABEL_47:
      v26 = 0;
      *a4 = v29;
      return v26;
    case 905:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      if (!sub_10000FEF4((uint64_t)v7, 23))
        return 144;
      v37 = xpc_dictionary_get_string(a3, "monitor_id");
      uint64 = xpc_dictionary_get_uint64(a3, "capacity");
      v26 = 22;
      if (!v37 || !uint64)
        return v26;
      v39 = sub_100003C6C(v37, uint64);
      goto LABEL_40;
    case 906:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      if (!sub_10000FEF4((uint64_t)v7, 23))
        return 144;
      v40 = xpc_dictionary_get_string(a3, "monitor_id");
      if (!v40)
        return 22;
      v39 = sub_100003CCC((uint64_t)v40);
LABEL_40:
      v26 = v39;
      if (!(_DWORD)v39)
        *a4 = xpc_dictionary_create_reply(a3);
      return v26;
    default:
      return 33;
  }
}

char *sub_10003B954(int a1)
{
  char *result;
  int *v3;
  char v4[1024];

  bzero(v4, 0x400uLL);
  if (a1 < 0)
  {
    v3 = __error();
    result = 0;
    *v3 = 9;
  }
  else
  {
    while (fcntl(a1, 50, v4) == -1)
    {
      if (*__error() != 35)
        return 0;
    }
    return sub_10001544C(v4);
  }
  return result;
}

void *sub_10003BA10(int a1, uint64_t a2, _QWORD *a3, ssize_t *a4)
{
  void *v8;
  ssize_t v9;
  ssize_t v10;
  void *v11;
  void *v12;

  v8 = sub_10001389C(*(_QWORD *)(a2 + 96));
  v9 = read(a1, v8, *(_QWORD *)(a2 + 96));
  v10 = v9;
  if (v9 != *(_QWORD *)(a2 + 96))
  {
    if (v9)
    {
      if (v9 != -1 || (v9 = *__error(), (_DWORD)v9))
        _os_assumes_log(v9);
    }
    goto LABEL_8;
  }
  v11 = (void *)xpc_create_from_plist(v8, v9);
  v12 = v11;
  if (v11)
  {
    if (xpc_get_type(v11) != (xpc_type_t)&_xpc_type_dictionary)
    {
      xpc_release(v12);
LABEL_8:
      v12 = 0;
      goto LABEL_9;
    }
    if (a3 && a4)
    {
      *a4 = v10;
      *a3 = v8;
      return v12;
    }
  }
LABEL_9:
  free(v8);
  return v12;
}

int *sub_10003BAF4(int *result)
{
  uint64_t v1;

  if ((result & 0x80000000) == 0)
  {
    result = (int *)close((int)result);
    if ((_DWORD)result)
    {
      v1 = *__error();
      if ((_DWORD)v1)
        _os_assumes_log(v1);
      result = __error();
      if (*result == 9)
        sub_10004D738();
    }
  }
  return result;
}

void *sub_10003BB38(const char *a1)
{
  return sub_10003BB44(a1, 0, 0);
}

void *sub_10003BB44(const char *a1, _QWORD *a2, ssize_t *a3)
{
  int *v5;
  int *v6;
  int v7;
  void *v8;
  stat v10;

  if (!a1)
    return 0;
  v5 = (int *)open(a1, 0);
  if ((_DWORD)v5 == -1)
    return 0;
  v6 = v5;
  memset(&v10, 0, sizeof(v10));
  v7 = fstat((int)v5, &v10);
  if (v7 | v10.st_uid || (v10.st_mode & 0x12) != 0)
    v8 = 0;
  else
    v8 = sub_10003BA10((int)v6, (uint64_t)&v10, a2, a3);
  sub_10003BAF4(v6);
  return v8;
}

uint8_t *sub_10003BC00(mach_header_64 *a1, const char *a2, const char *a3)
{
  uint8_t *result;
  unint64_t size;
  Dl_info v7;

  if (!a1)
    a1 = _NSGetMachExecuteHeader();
  size = 0;
  memset(&v7, 0, sizeof(v7));
  if (!dladdr(a1, &v7))
    return 0;
  result = getsectiondata((const mach_header_64 *)v7.dli_fbase, a2, a3, &size);
  if (result)
    return (uint8_t *)xpc_create_from_plist(result, size);
  return result;
}

int *sub_10003BC70(FILE *a1)
{
  int *result;
  uint64_t v2;

  result = (int *)fclose(a1);
  if ((_DWORD)result)
  {
    v2 = *__error();
    if ((_DWORD)v2)
      _os_assumes_log(v2);
    result = __error();
    if (*result == 9)
      sub_10004D738();
  }
  return result;
}

BOOL sub_10003BCB0(const char *a1)
{
  int v1;
  int *v2;
  stat v4;

  memset(&v4, 0, sizeof(v4));
  v1 = stat(a1, &v4);
  if (v1)
  {
    v2 = __error();
    if (v1 == -1 && *v2 != 2)
      sub_10004D870();
  }
  return v1 == 0;
}

void sub_10003BD20()
{
  void *v0;
  void *v1;
  xpc_object_t dictionary;
  void *v3;
  int v4;
  void *v5;
  size_t v6;
  int v7;
  void *v8;
  size_t v9;
  __int128 applier;
  __int128 v11;
  _BYTE v12[24];
  __int128 v13;
  __int128 v14;
  size_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;
  int v20[4];
  __int128 v21;
  __int128 v22;
  size_t v23[2];

  v8 = 0;
  v9 = 0;
  if (!byte_100072A60 && sub_10003BCB0("/System/Library/xpc/WorkloadProperties.plist"))
  {
    v0 = sub_10003BBFC("/System/Library/xpc/WorkloadProperties.plist", &v8, (ssize_t *)&v9);
    v1 = v0;
    if (v0 && xpc_get_type(v0) == (xpc_type_t)&_xpc_type_dictionary)
    {
      dictionary = xpc_dictionary_get_dictionary(v1, "SystemCallMasks");
      if (!dictionary
        || (v3 = dictionary,
            v21 = 0u,
            v22 = 0u,
            *(_OWORD *)v20 = 0u,
            v23[0] = 12,
            sysctlnametomib("kern.syscall_rejection_masks", v20, v23)))
      {
        xpc_release(v1);
        goto LABEL_9;
      }
      v18 = 0x2000000000;
      *((_QWORD *)&applier + 1) = 0x40000000;
      *(_OWORD *)&v12[8] = *(_OWORD *)v20;
      v16 = 0;
      v17 = &v16;
      v19 = 0;
      *(_QWORD *)&applier = _NSConcreteStackBlock;
      *(_QWORD *)&v11 = sub_10003BF1C;
      *((_QWORD *)&v11 + 1) = &unk_10006CE70;
      *(_QWORD *)v12 = &v16;
      v13 = v21;
      v14 = v22;
      v15 = v23[0];
      xpc_dictionary_apply(v3, &applier);
      v4 = *((_DWORD *)v17 + 6);
      _Block_object_dispose(&v16, 8);
      xpc_release(v1);
      if (!v4)
      {
LABEL_9:
        v5 = v8;
        v6 = v9;
        v11 = 0u;
        *(_OWORD *)v12 = 0u;
        applier = 0u;
        *(_QWORD *)&v12[16] = 12;
        if (sysctlnametomib("kern.workload_config", (int *)&applier, (size_t *)&v12[16]))
        {
          free(v8);
        }
        else
        {
          v7 = sysctl((int *)&applier, *(u_int *)&v12[16], 0, 0, v5, v6);
          free(v8);
          if (v7)
            sub_10003E208("error parsing the workload properties plist in the kernel (%u)", v7);
        }
        return;
      }
    }
    else
    {
      xpc_release(v1);
      v4 = 109;
    }
    sub_10003E208("error parsing the workload properties plist in launchd (%u)", v4);
  }
}

uint64_t sub_10003BF1C(uint64_t a1, char *__str, void *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  xpc_object_t array;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  void **v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  size_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  _QWORD applier[6];
  char *__endptr;

  __endptr = 0;
  strtol(__str, &__endptr, 10);
  if (*__str && !*__endptr)
  {
    array = xpc_dictionary_get_array(a3, "SystemCalls");
    if (array)
    {
      v18 = array;
      v19 = (void **)sub_1000106C8(0x800uLL);
      sub_100010740((uint64_t)v19, "%s:", v20, v21, v22, v23, v24, v25, (char)__str);
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000;
      applier[2] = sub_10003C104;
      applier[3] = &unk_10006CE48;
      applier[4] = *(_QWORD *)(a1 + 32);
      applier[5] = v19;
      xpc_array_apply(v18, applier);
      if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
      {
        sub_100010718(v19);
      }
      else
      {
        v26 = sub_100010710((const char **)v19);
        sub_100010718(v19);
        v27 = strlen(v26);
        v28 = sysctl((int *)(a1 + 40), *(_DWORD *)(a1 + 88), 0, 0, v26, v27);
        free(v26);
        if (!v28)
          return 1;
        *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = v28;
        sub_100041468("com.apple.xpc.workload_properties", 65541, "sysctl failed with error (%i)", v29, v30, v31, v32, v33, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
      }
    }
    else
    {
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 109;
      sub_100041468("com.apple.xpc.workload_properties", 65541, "invalid syscall mask array type (%i)", v13, v14, v15, v16, v17, *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    }
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 109;
    sub_100041468("com.apple.xpc.workload_properties", 65541, "invalid syscall mask key: %s (%i)", v6, v7, v8, v9, v10, (char)__str);
  }
  return 0;
}

BOOL sub_10003C104(uint64_t a1, char a2, xpc_object_t object)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  xpc_type_t type;
  uint64_t v12;
  char string_ptr;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    v12 = *(_QWORD *)(a1 + 40);
    string_ptr = xpc_string_get_string_ptr(object);
    sub_100010740(v12, " %s", v14, v15, v16, v17, v18, v19, string_ptr);
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 109;
    sub_100041468("com.apple.xpc.workload_properties", 65541, "invalid syscall mask value at index: %zu  (%i)", v6, v7, v8, v9, v10, a2);
  }
  return type == (xpc_type_t)&_xpc_type_string;
}

void sub_10003C1C4(uint64_t a1)
{
  _QWORD *v1;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;
  uint64_t v7;

  v1 = *(_QWORD **)(a1 + 344);
  if (v1)
  {
    if (v1[9])
      sub_10004D738();
    v3 = v1[8];
    if (v3)
    {
      do
      {
        v4 = *(_QWORD *)(v3 + 24);
        sub_10003C260(v3);
        v3 = v4;
      }
      while (v4);
    }
    v5 = (void *)v1[6];
    if (v5)
    {
      xpc_release(v5);
      v1[6] = 0;
    }
    v6 = (void *)v1[7];
    if (v6)
      xpc_release(v6);
    v7 = v1[4];
    if (v7)
      *(_QWORD *)(v7 + 40) = v1[5];
    *(_QWORD *)v1[5] = v7;
    *(_QWORD *)(a1 + 344) = 0;
    free(v1);
  }
}

void sub_10003C260(uint64_t a1)
{
  void *v2;
  uint64_t v3;

  v2 = *(void **)(a1 + 16);
  if (v2)
  {
    xpc_release(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 8));
  v3 = *(_QWORD *)(a1 + 24);
  if (v3)
    *(_QWORD *)(v3 + 32) = *(_QWORD *)(a1 + 32);
  **(_QWORD **)(a1 + 32) = v3;
  free((void *)a1);
}

BOOL sub_10003C2B0(uint64_t a1, void *a2)
{
  xpc_object_t v3;
  void *v4;
  _BOOL8 v5;
  const char *string;

  if (!a2)
    sub_10004D738();
  v3 = sub_100040958(a1);
  if (!v3)
    return 0;
  v4 = v3;
  if (xpc_get_type(v3) == (xpc_type_t)&_xpc_type_dictionary)
  {
    string = xpc_dictionary_get_string(v4, "com.apple.private.xpc.launchd.job-manager");
    v5 = sub_10003C330(a2, string);
  }
  else
  {
    v5 = 0;
  }
  xpc_release(v4);
  return v5;
}

BOOL sub_10003C330(void *a1, const char *a2)
{
  _BOOL8 v2;
  char *string_ptr;
  size_t v7;
  char *string;

  v2 = 0;
  if (!a1 || !a2)
    return v2;
  if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_string)
  {
    if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_array || !xpc_array_get_count(a1))
      return 0;
    v7 = 0;
    do
    {
      string = (char *)xpc_array_get_string(a1, v7);
      v2 = sub_1000157A8(string, a2);
      if (v2)
        break;
      ++v7;
    }
    while (v7 < xpc_array_get_count(a1));
    return v2;
  }
  string_ptr = (char *)xpc_string_get_string_ptr(a1);
  return sub_1000157A8(string_ptr, a2);
}

unsigned __int8 *sub_10003C3F8(void *a1, _DWORD *a2, char *a3, _DWORD *a4)
{
  _OWORD v5[2];

  memset(v5, 0, sizeof(v5));
  return sub_10003C434(a1, a2, 1, 0x40200uLL, (uint64_t)v5, a3, a4);
}

unsigned __int8 *sub_10003C434(void *a1, _DWORD *a2, char a3, unint64_t a4, uint64_t a5, char *a6, _DWORD *a7)
{
  const char *string;
  uint64_t v15;
  uint64_t v16;
  int v17;
  unsigned __int8 *result;
  int v19;

  string = xpc_dictionary_get_string(a1, "Label");
  if (string && sub_1000156F0(string, "com.apple."))
    a4 |= 0x80uLL;
  v19 = 0;
  v15 = sub_10002EA84(a2, a1, a6, a5, a4, &v19);
  v16 = v15;
  v17 = v19;
  if (v19)
  {
    if (v15)
      sub_10004D738();
    result = 0;
  }
  else
  {
    if (!v15)
      sub_10004D738();
    if ((a3 & 1) == 0)
      sub_1000239BC(v15, 15);
    sub_100029B20(*(_QWORD *)(v16 + 248), v16);
    result = sub_10003D50C(v16);
  }
  *a7 = v17;
  return result;
}

uint64_t sub_10003C51C(int a1, unsigned __int8 **a2)
{
  uint64_t v3;
  unsigned __int8 *v4;
  uint64_t result;

  v3 = sub_10001FB38(a1);
  if (!v3)
    return 113;
  v4 = *(unsigned __int8 **)(v3 + 344);
  if (!v4)
    v4 = sub_10003C560(v3);
  result = 0;
  *a2 = v4;
  return result;
}

unsigned __int8 *sub_10003C560(uint64_t a1)
{
  unsigned __int8 *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned __int8 *v9;
  int v10;

  if (*(_QWORD *)(a1 + 344))
    sub_10004D738();
  v2 = sub_10003D50C(a1);
  v9 = v2;
  *((_DWORD *)v2 + 3) = *(_DWORD *)(a1 + 364);
  v10 = *(_DWORD *)(a1 + 352);
  if (v10)
    sub_10003D314(v2, v10, v3, v4, v5, v6, v7, v8);
  *(_DWORD *)(a1 + 352) = 0;
  return v9;
}

_DWORD *sub_10003C5B0()
{
  return sub_10004454C(10, (uint64_t)sub_10003C5C0);
}

uint64_t sub_10003C5C0(uint64_t a1, int a2, void *a3, xpc_object_t *a4)
{
  __int128 *v7;
  uint64_t *value;
  uint64_t *v9;
  uint64_t v10;
  xpc_object_t array;
  void *v12;
  size_t count;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  size_t v18;
  size_t v19;
  xpc_object_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t k;
  uint64_t v31;
  uint64_t *v32;
  mach_port_name_t v33;
  uint64_t i;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char *v42;
  int v43;
  uint64_t *v44;
  uint64_t v45;
  void *v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  const char *v56;
  xpc_object_t v57;
  uint64_t j;
  xpc_object_t v59;
  xpc_object_t reply;
  const char *v61;
  uint64_t v62;
  uint64_t *v63;
  void *v64;
  char v65;
  xpc_object_t v66;
  int v67;
  xpc_object_t v68;
  xpc_object_t v69;
  uint64_t right;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t *v81;
  uint64_t *v82;
  unsigned int *v83;
  unsigned int *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  const char *v91;
  char *v92;
  _DWORD *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  _QWORD *v103;
  xpc_object_t v104;
  xpc_object_t v105;
  void *v106;
  const char *v107;
  const char *v108;
  uint64_t v109;
  void *v110;
  char *v111;
  xpc_object_t v112;
  int int64;
  uint64_t v114;
  uint64_t *v115;
  unsigned __int8 *uuid;
  uint64_t v117;
  char *v118;
  uint64_t v119;
  uint64_t v120;
  char v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;
  const char *string;
  _DWORD *v136;
  int v137;
  const char *v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  unsigned int v143;
  uint64_t v144;
  char v145;
  xpc_object_t v146;
  xpc_object_t v147;
  uint64_t v148;
  unsigned __int8 *v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  unsigned int *v158;
  unsigned int *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  xpc_object_t empty;
  size_t v169;
  xpc_object_t v170;
  xpc_object_t v171;
  int v172;
  uint64_t *v173;
  uint64_t v174;
  uint64_t v175;
  char v176;
  char v177;
  unsigned int v178;
  __int128 v179;
  __int128 v180;
  __int128 v181;
  __int128 v182;

  v7 = sub_100044524();
  if (!sub_10000FEF4((uint64_t)v7, 27))
    return 144;
  switch(a2)
  {
    case 1000:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      value = (uint64_t *)xpc_dictionary_get_value(a3, "plist");
      v9 = value;
      if (!value)
        goto LABEL_7;
      if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
      {
        v9 = 0;
LABEL_7:
        v10 = 22;
LABEL_140:
        if ((_DWORD)v10)
          return v10;
        LODWORD(v179) = 0;
        if (xpc_dictionary_get_BOOL(a3, "monitor"))
        {
          v158 = (unsigned int *)sub_10003D64C(v9, (int *)&v179);
          v159 = v158;
          v10 = v179;
          if ((_DWORD)v179)
          {
            if (v158)
              sub_10004D738();
            goto LABEL_147;
          }
          v175 = sub_100038E4C(a3);
          v160 = v175;
          if (v159)
            xpc_dictionary_set_mach_recv(v175, "monitor", *v159);
        }
        else
        {
          v160 = sub_100038E4C(a3);
        }
        v10 = sub_10003D7EC((uint64_t)v9, v160);
        if (!(_DWORD)v10)
          return v10;
LABEL_147:
        v161 = *(_QWORD *)(*v9 + 248);
        v162 = *v9 + 1392;
        xpc_strerror(v10);
        sub_100028C34(v161, 3, "Start job failed: service = %s, error = %d: %s", v163, v164, v165, v166, v167, v162);
        sub_100029C5C(v161, *v9);
        return v10;
      }
      string = xpc_dictionary_get_string(v9, "Label");
      LODWORD(v179) = 0;
      v136 = (_DWORD *)sub_10002E22C(a3, 0, (int *)&v179);
      v137 = v179;
      if ((_DWORD)v179)
      {
        v138 = (const char *)xpc_strerror(v179);
        sub_100040F68(3, "Submit job failed. Unable to find domain. Service = %s, error = %d: %s", string, v137, v138);
        v143 = v179;
        if (!(_DWORD)v179)
          sub_10004D720(v139, v140, v141, v142);
        goto LABEL_138;
      }
      v148 = (uint64_t)v136;
      v149 = sub_10003D93C(v9, v136, 0, (uint64_t)v7, (int *)&v179);
      v9 = (uint64_t *)v149;
      if (!(_DWORD)v179)
      {
        if (!v149)
          sub_10004D708(0, v150, v151, v152);
        v143 = 0;
        goto LABEL_139;
      }
      if (v149)
        sub_10004D738();
      xpc_strerror(v179);
      sub_100028C34(v148, 3, "Submit job failed: service = %s, error = %d: %s", v153, v154, v155, v156, v157, (char)string);
      v143 = v179;
      if ((_DWORD)v179)
      {
LABEL_138:
        v9 = 0;
LABEL_139:
        v10 = v143;
        goto LABEL_140;
      }
      goto LABEL_171;
    case 1001:
      LODWORD(v179) = 0;
      v81 = (uint64_t *)sub_10003DA88(a3, (int *)&v179);
      if (!v81)
        return v179;
      v82 = v81;
      v83 = (unsigned int *)sub_10003D64C(v81, (int *)&v179);
      v84 = v83;
      v10 = v179;
      if (!(_DWORD)v179)
      {
        reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_mach_recv(reply, "monitor", *v84);
        sub_10003DB0C((uint64_t)v82, reply, 0);
        goto LABEL_119;
      }
      if (v83)
        sub_10004D738();
      v85 = *v82;
      xpc_strerror(v179);
      sub_10001D418(v85, 3, "Could not monitor job: error = %d: %s", v86, v87, v88, v89, v90, v10);
      return v179;
    case 1002:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      LODWORD(v179) = 0;
      v31 = sub_10003DA88(a3, (int *)&v179);
      if (!v31)
        return v179;
      v32 = (uint64_t *)v31;
      v33 = xpc_dictionary_copy_mach_send(a3, "client-port");
      if (!v33)
        return 22;
      for (i = v32[8]; i; i = *(_QWORD *)(i + 24))
      {
        if (*(_DWORD *)i == v33)
          break;
      }
      v35 = sub_10000D980(v33);
      if (v35)
        sub_10004D764(v35);
      if (i)
      {
        if (*(_QWORD *)(i + 16))
        {
          v41 = *v32;
          v42 = "job is already monitored";
          v43 = 5;
          goto LABEL_123;
        }
        v145 = *(_BYTE *)(i + 40);
        v146 = xpc_dictionary_create_reply(a3);
        v147 = v146;
        if ((v145 & 1) != 0)
        {
          sub_10003DB0C((uint64_t)v32, v146, 0);
          v10 = 0;
          *a4 = v147;
          *(_BYTE *)(i + 40) &= ~1u;
        }
        else
        {
          v10 = 0;
          *(_QWORD *)(i + 16) = v146;
        }
      }
      else
      {
        sub_10001D418(*v32, 5, "job is not monitored, can't poll", v36, v37, v38, v39, v40, v176);
        return 3;
      }
      return v10;
    case 1003:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v178 = 0;
      v44 = (uint64_t *)sub_10003DA88(a3, (int *)&v178);
      if (!v44)
        return v178;
      v45 = *v44;
      v46 = (void *)v44[6];
      if (v46 && sub_10003C2B0((uint64_t)v7, v46))
      {
        v181 = 0u;
        v182 = 0u;
        v179 = 0u;
        v180 = 0u;
        v47 = sub_10003FBC0((uint64_t)v7, (char *)&v179);
        sub_10001D418(v45, 5, "removing job: caller = %s", v48, v49, v50, v51, v52, v47);
        v53 = sub_100029C5C(*(_QWORD *)(v45 + 248), v45);
        v178 = v53;
        if ((_DWORD)v53 == 36)
          return v178;
        v54 = v53;
        if (!(_DWORD)v53)
        {
          *a4 = xpc_dictionary_create_reply(a3);
          return v178;
        }
      }
      else
      {
        v54 = 144;
        v178 = 144;
      }
      xpc_strerror(v54);
      sub_10001D418(v45, 3, "Could not remove job: error = %d: %s", v127, v128, v129, v130, v131, v54);
      return v178;
    case 1004:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v55 = xpc_dictionary_get_string(a3, "manager");
      if (!v55)
        return 22;
      v56 = v55;
      v57 = xpc_array_create(0, 0);
      for (j = qword_1000725F0; j; j = *(_QWORD *)(j + 32))
      {
        if (sub_10003C330(*(void **)(j + 48), v56))
          xpc_array_set_uuid(v57, 0xFFFFFFFFFFFFFFFFLL, (const unsigned __int8 *)(j + 16));
      }
      v59 = xpc_dictionary_create_reply(a3);
      reply = v59;
      v61 = "handles";
      goto LABEL_116;
    case 1005:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v91 = xpc_dictionary_get_string(a3, "label");
      if (!v91)
        return 22;
      v92 = (char *)v91;
      LODWORD(v179) = 0;
      v93 = (_DWORD *)sub_10002E22C(a3, 0, (int *)&v179);
      v10 = v179;
      if ((_DWORD)v179)
        return v10;
      v94 = (uint64_t)v93;
      v78 = (uint64_t)sub_10002C4E4(v93, v92);
      if (v78)
        goto LABEL_78;
      sub_100028C34(v94, 3, "Could not find job with label %s", v95, v96, v97, v98, v99, (char)v92);
      return 113;
    case 1006:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      LODWORD(v179) = 0;
      v102 = sub_10003DA88(a3, (int *)&v179);
      if (!v102)
        return v179;
      v103 = (_QWORD *)v102;
      if (*(_DWORD *)(v102 + 8) == 1)
      {
        v104 = xpc_dictionary_create_reply(a3);
        sub_10003DB0C((uint64_t)v103, v104, 0);
        LODWORD(v179) = xpc_pipe_routine_reply(v104);
        if ((v179 | 0x20) != 0x20)
          _os_assumes_log_ctx(sub_10001F174, *v103);
        xpc_release(v104);
      }
      else
      {
        if (*(_QWORD *)(v102 + 72))
        {
          v41 = *(_QWORD *)v102;
          v42 = "Start job failed: another start request is already inflight";
          v43 = 3;
LABEL_123:
          sub_10001D418(v41, v43, v42, v36, v37, v38, v39, v40, v176);
          return 37;
        }
        v144 = sub_100038E4C(a3);
        sub_10003D7EC((uint64_t)v103, v144);
      }
      return 0;
    case 1007:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v105 = xpc_dictionary_get_value(a3, "overlay");
      v106 = v105;
      if (v105)
      {
        if (xpc_get_type(v105) != (xpc_type_t)&_xpc_type_dictionary)
          return 22;
      }
      v107 = xpc_dictionary_get_string(a3, "path");
      if (!v107)
        return 22;
      v108 = v107;
      v178 = 0;
      v109 = sub_10002E22C(a3, 0, (int *)&v178);
      v10 = v178;
      if (!v178)
      {
        v110 = (void *)v109;
        v111 = sub_10001544C(v108);
        v112 = xpc_dictionary_create_reply(a3);
        *(_QWORD *)&v179 = _NSConcreteStackBlock;
        *((_QWORD *)&v179 + 1) = 0x40000000;
        *(_QWORD *)&v180 = sub_10003DCE8;
        *((_QWORD *)&v180 + 1) = &unk_10006CED0;
        *(_QWORD *)&v181 = v112;
        *((_QWORD *)&v181 + 1) = v110;
        *(_QWORD *)&v182 = v111;
        sub_1000173D0(v110, v108, v106, v7, (uint64_t)&v179);
      }
      return v10;
    case 1008:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      int64 = xpc_dictionary_get_int64(a3, "pid");
      if (int64 < 1)
        return 22;
      *(_QWORD *)&v179 = 0;
      v10 = sub_10003C51C(int64, (unsigned __int8 **)&v179);
      if (!(_DWORD)v10)
      {
        reply = xpc_dictionary_create_reply(a3);
        xpc_dictionary_set_uuid(reply, "job-handle", (const unsigned __int8 *)(v179 + 16));
        goto LABEL_119;
      }
      if ((_QWORD)v179)
        sub_10004D738();
      return v10;
    case 1009:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      LODWORD(v179) = 0;
      v62 = sub_10003DA88(a3, (int *)&v179);
      if (!v62)
        return v179;
      v63 = (uint64_t *)v62;
      v64 = *(void **)(v62 + 48);
      v65 = v64 && *(_QWORD *)(v62 + 56) && sub_10003C2B0((uint64_t)v7, v64);
      v132 = *v63;
      reply = xpc_dictionary_create_reply(a3);
      v57 = sub_10002102C(v132, v65);
      v61 = "attrs";
      v59 = reply;
LABEL_116:
      xpc_dictionary_set_value(v59, v61, v57);
      v133 = v57;
      goto LABEL_117;
    case 1010:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v178 = 0;
      v114 = sub_10003DA88(a3, (int *)&v178);
      if (!v114)
        return v178;
      v115 = (uint64_t *)v114;
      uuid = (unsigned __int8 *)xpc_dictionary_get_uuid(a3, "instance-uuid");
      *(_QWORD *)&v179 = 0;
      *((_QWORD *)&v179 + 1) = xpc_dictionary_get_string(a3, "sandbox-profile");
      *(_QWORD *)&v180 = xpc_dictionary_get_dictionary(a3, "envvars");
      v117 = *v115;
      v118 = sub_100029E2C(*(_QWORD *)(*v115 + 248), *v115, uuid, 1, (uint64_t *)&v179, v7, (int *)&v178);
      if (v118)
      {
        v119 = (uint64_t)v118;
        if (sub_1000239D8(v117))
          sub_1000239BC(v119, 15);
        v101 = (uint64_t)sub_10003D50C(v119);
        if (v101)
          goto LABEL_106;
      }
      v120 = *v115;
      v121 = v178;
      xpc_strerror(v178);
      sub_10001D418(v120, 4, "instance creation failed: %d %s", v122, v123, v124, v125, v126, v121);
      return v178;
    case 1011:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v66 = xpc_dictionary_create_reply(a3);
      v67 = sub_10003DDCC((uint64_t)v7, a3, v66);
      if (v67)
        xpc_dictionary_set_int64(v66, "error", v67);
      v10 = 0;
      *a4 = v66;
      return v10;
    case 1012:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      v68 = xpc_dictionary_get_value(a3, "endpoint");
      if (!v68)
        return 22;
      v69 = v68;
      if (xpc_get_type(v68) != (xpc_type_t)&_xpc_type_mach_send)
        return 22;
      right = xpc_mach_send_get_right(v69);
      if ((right - 1) > 0xFFFFFFFD)
        return 113;
      v77 = sub_10002E080(right, 1, v71, v72, v73, v74, v75, v76);
      if (!v77)
        return 113;
      v78 = sub_1000463E0((uint64_t)v77);
LABEL_78:
      v100 = *(_QWORD *)(v78 + 344);
      if (!v100)
      {
        v101 = (uint64_t)sub_10003C560(v78);
LABEL_106:
        v100 = v101;
      }
      reply = xpc_dictionary_create_reply(a3);
      xpc_dictionary_set_uuid(reply, "job-handle", (const unsigned __int8 *)(v100 + 16));
      goto LABEL_118;
    case 1013:
      LODWORD(v179) = 0;
      v101 = sub_10003DA88(a3, (int *)&v179);
      if (v101)
        goto LABEL_106;
      return v179;
    case 1014:
      if (!xpc_dictionary_expects_reply(a3))
        return 22;
      array = xpc_dictionary_get_array(a3, "all-jobs");
      if (!array)
        return 22;
      v12 = array;
      if (xpc_get_type(array) != (xpc_type_t)&_xpc_type_array)
        return 22;
      count = xpc_array_get_count(v12);
      if (count >> 61)
      {
        __break(1u);
LABEL_171:
        sub_10004D720(count, v14, v15, v16);
      }
      v17 = sub_10001389C(8 * count);
      if (!xpc_array_get_count(v12))
      {
        xpc_array_get_count(v12);
        v19 = 0;
        goto LABEL_150;
      }
      v18 = 0;
      v19 = 0;
      break;
    case 1015:
      LODWORD(v179) = 0;
      v79 = sub_10003DA88(a3, (int *)&v179);
      if (!v79)
        return v179;
      v80 = v79;
      reply = xpc_dictionary_create_reply(a3);
      sub_10003DB0C(v80, reply, 1);
      goto LABEL_118;
    default:
      return 33;
  }
  do
  {
    v20 = xpc_array_get_value(v12, v18);
    LODWORD(v179) = 0;
    v21 = sub_10002E22C(v20, 0, (int *)&v179);
    v10 = v179;
    if ((_DWORD)v179)
    {
      free(v17);
      return v10;
    }
    if (v19)
    {
      if (*v17 == v21)
        goto LABEL_23;
      v22 = 1;
      while (v19 != v22)
      {
        v23 = v17[v22++];
        if (v23 == v21)
        {
          if (v22 - 1 < v19)
            goto LABEL_23;
          break;
        }
      }
    }
    v17[v19++] = v21;
LABEL_23:
    ++v18;
  }
  while (v18 < xpc_array_get_count(v12));
  if (v19 > xpc_array_get_count(v12))
    sub_10004D738();
  if (v19)
  {
    for (k = 0; k != v19; ++k)
      sub_1000296E0(v17[k], 47, v24, v25, v26, v27, v28, v29, v176);
    v177 = 0;
    goto LABEL_151;
  }
LABEL_150:
  v177 = 1;
LABEL_151:
  empty = xpc_array_create_empty();
  if (xpc_array_get_count(v12))
  {
    v169 = 0;
    do
    {
      v170 = xpc_array_get_value(v12, v169);
      v171 = xpc_dictionary_create_empty();
      v172 = sub_10003DDCC((uint64_t)v7, v170, v171);
      if (v172)
        xpc_dictionary_set_int64(v171, "error", v172);
      xpc_array_set_value(empty, 0xFFFFFFFFFFFFFFFFLL, v171);
      xpc_release(v171);
      ++v169;
    }
    while (v169 < xpc_array_get_count(v12));
  }
  if ((v177 & 1) == 0)
  {
    v173 = v17;
    do
    {
      v174 = *v173++;
      sub_10002976C(v174, 47);
      --v19;
    }
    while (v19);
  }
  free(v17);
  reply = xpc_dictionary_create_reply(a3);
  xpc_dictionary_set_value(reply, "results", empty);
  v133 = empty;
LABEL_117:
  xpc_release(v133);
LABEL_118:
  v10 = 0;
LABEL_119:
  *a4 = reply;
  return v10;
}

void sub_10003D248(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  int v10;
  int v11;

  v9 = *(_QWORD *)(a1 + 344);
  if (v9)
  {
    switch(a2)
    {
      case 9:
        sub_10003D314((_QWORD *)v9, 4, a3, a4, a5, a6, a7, a8);
        sub_10003C1C4(a1);
        return;
      case 5:
        if (*(_DWORD *)(v9 + 8) == 1)
        {
          v10 = 3;
LABEL_22:
          sub_10003D314((_QWORD *)v9, v10, a3, a4, a5, a6, a7, a8);
        }
        break;
      case 4:
        if (a3)
        {
          *(_DWORD *)(v9 + 12) = a3;
          v10 = 2;
        }
        else
        {
          v10 = 1;
        }
        goto LABEL_22;
    }
  }
  else
  {
    switch(a2)
    {
      case 9:
        v11 = 4;
        break;
      case 5:
        if (*(_DWORD *)(a1 + 352) != 1)
          return;
        v11 = 3;
        break;
      case 4:
        if (a3)
          v11 = 2;
        else
          v11 = 1;
        break;
      default:
        return;
    }
    *(_DWORD *)(a1 + 352) = v11;
  }
}

void sub_10003D314(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  char *v10;
  uint64_t v11;
  void *v12;
  uint64_t i;
  uint64_t v14;

  if (!a2)
    sub_10004D738();
  *((_DWORD *)a1 + 2) = a2;
  v9 = *a1;
  v10 = *(char **)(v9 + 344);
  if (v10)
  {
    v11 = *((int *)v10 + 2);
    if (v11 > 4)
      LOBYTE(v10) = 0;
    else
      v10 = (&off_10006CEF0)[v11];
  }
  sub_10001D418(v9, 5, "job state = %s", a4, a5, a6, a7, a8, (char)v10);
  v12 = (void *)a1[9];
  if (v12)
  {
    sub_10003DB0C((uint64_t)a1, (xpc_object_t)a1[9], 0);
    xpc_dictionary_set_uuid(v12, "job-handle", (const unsigned __int8 *)a1 + 16);
    if ((xpc_pipe_routine_reply(v12) | 0x20) != 0x20)
      _os_assumes_log_ctx(sub_10001F174, *a1);
    xpc_release((xpc_object_t)a1[9]);
    a1[9] = 0;
  }
  for (i = a1[8]; i; i = *(_QWORD *)(i + 24))
  {
    *(_BYTE *)(i + 40) |= 1u;
    v14 = *(_QWORD *)(i + 16);
    if (v14)
    {
      sub_10003DB0C((uint64_t)a1, *(xpc_object_t *)(i + 16), 0);
      if ((xpc_pipe_routine_reply(v14) | 0x20) != 0x20)
        _os_assumes_log_ctx(sub_10001F174, *a1);
      xpc_release(*(xpc_object_t *)(i + 16));
      *(_QWORD *)(i + 16) = 0;
      *(_BYTE *)(i + 40) &= ~1u;
    }
  }
}

uint64_t sub_10003D470(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(a1 + 344);
  if (v1)
    return *(_QWORD *)(v1 + 72);
  else
    return 0;
}

uint64_t sub_10003D488(uint64_t a1, xpc_object_t object)
{
  uint64_t result;
  unsigned __int8 *v5;

  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_array)
  {
    result = (uint64_t)xpc_get_type(object);
    if ((_UNKNOWN *)result != &_xpc_type_string)
      return result;
    goto LABEL_6;
  }
  result = xpc_array_get_count(object);
  if (result)
  {
    result = sub_100015894(object);
    if ((result & 1) != 0)
    {
LABEL_6:
      v5 = sub_10003D50C(a1);
      result = (uint64_t)xpc_retain(object);
      *((_QWORD *)v5 + 6) = result;
    }
  }
  return result;
}

unsigned __int8 *sub_10003D50C(uint64_t a1)
{
  unsigned __int8 *v1;
  uint64_t v3;

  v1 = *(unsigned __int8 **)(a1 + 344);
  if (!v1)
  {
    v1 = (unsigned __int8 *)sub_10001389C(0x50uLL);
    *(_QWORD *)(a1 + 344) = v1;
    *(_QWORD *)v1 = a1;
    uuid_generate(v1 + 16);
    v3 = qword_1000725F0;
    *((_QWORD *)v1 + 4) = qword_1000725F0;
    if (v3)
      *(_QWORD *)(v3 + 40) = v1 + 32;
    qword_1000725F0 = (uint64_t)v1;
    *((_QWORD *)v1 + 5) = &qword_1000725F0;
  }
  return v1;
}

uint64_t sub_10003D574(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  void *v3;

  v2 = *(_QWORD *)(result + 344);
  if (v2)
  {
    v3 = *(void **)(v2 + 48);
    if (v3)
      return sub_10003D488(a2, v3);
  }
  return result;
}

uint64_t sub_10003D594(uint64_t a1, xpc_object_t object)
{
  uint64_t result;
  unsigned __int8 *v5;

  result = (uint64_t)xpc_get_type(object);
  if ((_UNKNOWN *)result == &_xpc_type_array)
  {
    result = xpc_array_get_count(object);
    if (result)
    {
      result = sub_100015894(object);
      if ((_DWORD)result)
      {
        v5 = sub_10003D50C(a1);
        result = (uint64_t)xpc_retain(object);
        *((_QWORD *)v5 + 7) = result;
      }
    }
  }
  return result;
}

uint64_t sub_10003D600(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  void *v3;

  v2 = *(_QWORD *)(result + 344);
  if (v2)
  {
    v3 = *(void **)(v2 + 56);
    if (v3)
      return sub_10003D594(a2, v3);
  }
  return result;
}

char *sub_10003D620(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 344);
  if (v1 && (v2 = *(int *)(v1 + 8), v2 <= 4))
    return (&off_10006CEF0)[v2];
  else
    return 0;
}

_QWORD *sub_10003D64C(uint64_t *a1, int *a2)
{
  mach_port_name_t v4;
  mach_port_name_t v5;
  int v6;
  _QWORD *v7;
  uint64_t reply_with_port;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  NSObject *v12;
  NSObject *v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD v23[5];
  _QWORD handler[5];
  mach_port_t poly;

  v4 = sub_10000D880(0x12u, 1u, 0);
  if (!v4)
  {
LABEL_11:
    v16 = *a1;
    v14 = 12;
    xpc_strerror(12);
    sub_10001D418(v16, 3, "Failed to create a job monitor. error = %d: %s", v17, v18, v19, v20, v21, 12);
    v7 = 0;
    goto LABEL_12;
  }
  v5 = v4;
  poly = 0;
  v6 = sub_10000D928(v4, &poly);
  if (v6 || !poly)
  {
    if (!v6)
      _os_assumes_log(0);
    v15 = sub_10000D994(v5, 0, 0);
    if (v15)
      sub_10004D764(v15);
    goto LABEL_11;
  }
  v7 = sub_10001389C(0x30uLL);
  *(_DWORD *)v7 = v5;
  reply_with_port = _xpc_dictionary_create_reply_with_port(poly);
  v7[2] = reply_with_port;
  if (!reply_with_port)
    sub_10004D738();
  v11 = a1[8];
  v10 = a1 + 8;
  v9 = v11;
  v7[3] = v11;
  if (v11)
    *(_QWORD *)(v9 + 32) = v7 + 3;
  *v10 = v7;
  v7[4] = v10;
  v12 = sub_1000146E4();
  v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, v5, 1uLL, v12);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_10003DA4C;
  handler[3] = &unk_10006CE90;
  handler[4] = v7;
  dispatch_source_set_event_handler(v13, handler);
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  v23[2] = sub_10003DA54;
  v23[3] = &unk_10006CEB0;
  v23[4] = v13;
  dispatch_source_set_mandatory_cancel_handler(v13, v23);
  dispatch_activate(v13);
  v14 = 0;
  v7[1] = v13;
LABEL_12:
  *a2 = v14;
  return v7;
}

uint64_t sub_10003D7EC(uint64_t a1, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;

  if (*(_QWORD *)(a1 + 72))
    sub_10004D738();
  if (*(_DWORD *)(a1 + 8) == 1)
    sub_10004D738();
  v3 = *(void **)a1;
  *(_QWORD *)(a1 + 72) = a2;
  sub_100019580(v3);
  v4 = *(_QWORD *)a1;
  if (sub_100006668(*(_QWORD *)a1))
  {
    v5 = 137;
  }
  else
  {
    v6 = sub_100020264(v4, 15);
    if ((_DWORD)v6 == 36)
      v7 = 0;
    else
      v7 = v6;
    if (!(_DWORD)v7)
    {
      v5 = v7;
      goto LABEL_18;
    }
    v5 = v6;
    if ((_DWORD)v7 == 37)
    {
      if (sub_100020D78(*(_QWORD *)a1))
      {
        v5 = 0;
        goto LABEL_18;
      }
      v5 = 37;
    }
  }
  if (*(_QWORD *)(a1 + 72))
  {
    xpc_strerror(v5);
    sub_10001D418((uint64_t)v3, 3, "Start job failed: error = %d: %s", v8, v9, v10, v11, v12, v5);
    v13 = *(void **)(a1 + 72);
    xpc_dictionary_set_int64(v13, "error", (int)v5);
    if ((xpc_pipe_routine_reply(v13) | 0x20) != 0x20)
      _os_assumes_log_ctx(sub_10001F174, v3);
    *(_QWORD *)(a1 + 72) = 0;
    xpc_release(v13);
  }
LABEL_18:
  sub_10001962C(v3);
  return v5;
}

unsigned __int8 *sub_10003D93C(void *a1, _DWORD *a2, char a3, uint64_t a4, int *a5)
{
  unsigned __int8 *result;
  const char *v11;
  int v12;
  char __str[16];
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _OWORD v21[4];

  result = (unsigned __int8 *)xpc_dictionary_get_value(a1, "_ManagedBy");
  if (result)
  {
    if (sub_10003C2B0(a4, result))
    {
      memset(v21, 0, sizeof(v21));
      v11 = sub_10003FBC0(a4, (char *)v21);
      v19 = 0u;
      v20 = 0u;
      v17 = 0u;
      v18 = 0u;
      v15 = 0u;
      v16 = 0u;
      *(_OWORD *)__str = 0u;
      v14 = 0u;
      snprintf(__str, 0x80uLL, "(submitted by %s.%d)", v11, *(_DWORD *)(a4 + 20));
      return sub_10003C434(a1, a2, a3, 0x200uLL, a4, __str, a5);
    }
    result = 0;
    v12 = 144;
  }
  else
  {
    v12 = 109;
  }
  *a5 = v12;
  return result;
}

void sub_10003DA4C(uint64_t a1)
{
  sub_10003C260(*(_QWORD *)(a1 + 32));
}

void sub_10003DA54(uint64_t a1)
{
  mach_port_name_t handle;
  int v3;

  handle = dispatch_source_get_handle(*(dispatch_source_t *)(a1 + 32));
  v3 = sub_10000D980(handle);
  if (v3)
    sub_10004D764(v3);
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t sub_10003DA88(void *a1, int *a2)
{
  const uint8_t *uuid;
  uint64_t v4;
  const unsigned __int8 *v5;
  int v6;

  if (!a2)
    sub_10004D738();
  uuid = xpc_dictionary_get_uuid(a1, "job-handle");
  if (uuid)
  {
    v4 = qword_1000725F0;
    if (qword_1000725F0)
    {
      v5 = uuid;
      while (uuid_compare((const unsigned __int8 *)(v4 + 16), v5))
      {
        v4 = *(_QWORD *)(v4 + 32);
        if (!v4)
          goto LABEL_7;
      }
      v6 = 0;
    }
    else
    {
LABEL_7:
      v6 = 3;
    }
  }
  else
  {
    v4 = 0;
    v6 = 22;
  }
  *a2 = v6;
  return v4;
}

void sub_10003DB0C(uint64_t a1, xpc_object_t xdict, char a3)
{
  uint64_t v6;
  void *v7;
  const unsigned __int8 *v8;
  int v9;
  int64_t v10;
  const char *v11;
  xpc_object_t v12;
  uint64_t v13;

  v6 = *(_QWORD *)a1;
  xpc_dictionary_set_uint64(xdict, "job-state", *(unsigned int *)(a1 + 8));
  v7 = *(void **)(v6 + 640);
  if (v7)
    xpc_dictionary_set_value(xdict, "additional-properties", v7);
  xpc_dictionary_set_BOOL(xdict, "removing", (*(_DWORD *)(v6 + 368) & 0x10) != 0);
  if (sub_10001FAFC(v6))
  {
    v8 = (const unsigned __int8 *)sub_100021504(v6);
    xpc_dictionary_set_uuid(xdict, "instance", v8);
  }
  switch(*(_DWORD *)(a1 + 8))
  {
    case 1:
      v9 = sub_100020D78(v6);
      xpc_dictionary_set_int64(xdict, "pid", v9);
      if ((a3 & 1) != 0)
        goto LABEL_10;
      break;
    case 2:
      v10 = *(int *)(a1 + 12);
      v11 = "spawn-error";
      v12 = xdict;
      goto LABEL_14;
    case 3:
      xpc_dictionary_set_int64(xdict, "wait4-status", 0);
      xpc_dictionary_set_uint64(xdict, "os-reason-ns", 7uLL);
      xpc_dictionary_set_uint64(xdict, "os-reason-code", 5uLL);
      xpc_dictionary_set_uint64(xdict, "os-reason-flags", 0);
LABEL_10:
      v13 = sub_10002153C(v6);
      if (sub_1000440E8((_DWORD *)v13))
      {
        xpc_dictionary_set_int64(xdict, "wait4-status", *(int *)(v13 + 28));
        xpc_dictionary_set_uint64(xdict, "os-reason-ns", *(unsigned int *)(v13 + 4));
        xpc_dictionary_set_uint64(xdict, "os-reason-code", *(_QWORD *)(v13 + 8));
        xpc_dictionary_set_uint64(xdict, "os-reason-flags", *(_QWORD *)(v13 + 16));
      }
      break;
    case 4:
      v11 = "error";
      v12 = xdict;
      v10 = 113;
LABEL_14:
      xpc_dictionary_set_int64(v12, v11, v10);
      break;
    default:
      return;
  }
}

void sub_10003DCE8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2)
  {
    v5 = sub_10003D50C(a2);
    xpc_dictionary_set_uuid(*(xpc_object_t *)(a1 + 32), "job-handle", v5 + 16);
    sub_1000239BC(a2, 15);
  }
  else
  {
    if (!(_DWORD)a3)
      sub_10004D738();
    xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 32), "error", (int)a3);
    v7 = *(_QWORD *)(a1 + 40);
    v8 = *(_QWORD *)(a1 + 48);
    xpc_strerror(a3);
    sub_100028C34(v7, 4, "Could not submit extension %s: %d - %s", v9, v10, v11, v12, v13, v8);
  }
  if ((xpc_pipe_routine_reply(*(_QWORD *)(a1 + 32)) | 0x20) != 0x20)
    _os_assumes_log_ctx(sub_100028C00, *(_QWORD *)(a1 + 40));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  free(*(void **)(a1 + 48));
}

uint64_t sub_10003DDCC(uint64_t a1, xpc_object_t object, void *a3)
{
  uint64_t result;
  xpc_object_t value;
  void *v8;
  char string;
  _DWORD *v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;

  if (!object)
    return 22;
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
    return 22;
  value = xpc_dictionary_get_value(object, "plist");
  if (!value)
    return 22;
  v8 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    return 22;
  string = xpc_dictionary_get_string(v8, "Label");
  v26 = 0;
  v10 = (_DWORD *)sub_10002E22C(object, 0, (int *)&v26);
  result = v26;
  if (!v26)
  {
    v11 = sub_10003D93C(v8, v10, 1, a1, (int *)&v26);
    v12 = v11;
    v13 = v26;
    if (v26)
    {
      if (v11)
        sub_10004D738();
LABEL_10:
      xpc_strerror(v13);
      sub_100028C34((uint64_t)v10, 3, "Submit job failed: service = %s, error = %d: %s", v14, v15, v16, v17, v18, string);
      if (v12)
        sub_100029C5C(v10, *(_QWORD *)v12);
      return v26;
    }
    if (xpc_dictionary_get_BOOL(object, "monitor"))
    {
      v19 = (unsigned int *)sub_10003D64C((uint64_t *)v12, (int *)&v26);
      v20 = v19;
      v13 = v26;
      if (v26)
      {
        if (v19)
          sub_10004D738();
        goto LABEL_10;
      }
      xpc_dictionary_set_uuid(a3, "job-handle", v12 + 16);
      if (v20)
        xpc_dictionary_set_mach_recv(a3, "monitor", *v20);
    }
    else
    {
      xpc_dictionary_set_uuid(a3, "job-handle", v12 + 16);
    }
    sub_100028C34((uint64_t)v10, 5, "Submit job succeeded: service = %s", v21, v22, v23, v24, v25, string);
    return 0;
  }
  return result;
}

BOOL sub_10003DF80(const char *a1)
{
  BOOL v2;
  _BOOL8 v3;
  char *v4;
  _BOOL8 v5;
  void *v7;

  v7 = 0;
  if (sub_10003FCE8("kern.bootobjectspath", (char **)&v7))
    v2 = v7 == 0;
  else
    v2 = 1;
  if (v2)
  {
    sub_100040F68(65540, "Unable to get boot-object-path. Giving up");
    return 0;
  }
  else
  {
    v4 = sub_100015630("%s/%s/%s", a1, (const char *)v7, ".roots-installed");
    v5 = sub_10003BCB0(v4);
    v3 = v5;
    if (v5)
      sub_100040F68(65541, "Found cookie: %s");
    else
      sub_100040F68(65541, "No cookie: %s");
    free(v7);
    free(v4);
  }
  return v3;
}

uint64_t sub_10003E054(const char *a1)
{
  char *v2;
  uint64_t v3;

  v2 = sub_100015630("%s/%s", a1, ".DarwinDepot");
  if (sub_10003BCB0(v2) || (free(v2), v2 = sub_100015630("%s/%s", a1, ".roots-installed"), sub_10003BCB0(v2)))
  {
    sub_100040F68(65541, "Found cookie: %s", v2);
    v3 = 1;
  }
  else
  {
    sub_100040F68(65541, "No cookie from system volume");
    v3 = 0;
  }
  free(v2);
  return v3;
}

BOOL sub_10003E10C(_BOOL8 result)
{
  _BOOL8 v1;
  mach_port_t v2;
  kern_return_t special_port;
  int v4;
  kern_return_t v5;
  int v6;
  mach_port_t port;
  _OWORD v8[8];

  if (result)
  {
    v1 = result;
    port = 0;
    v2 = mach_host_self();
    special_port = host_get_special_port(v2, -1, 3, &port);
    if (special_port)
    {
      _os_assumes_log(special_port);
      return 0;
    }
    else
    {
      memset(v8, 0, sizeof(v8));
      __strlcpy_chk(v8, v1, 128, 128);
      v6 = 0;
      v4 = sub_100049F7C(port, (const char *)v8, &v6);
      if (v4)
        _os_assumes_log(v4);
      v5 = mach_port_deallocate(mach_task_self_, port);
      if (v5)
        _os_assumes_log(v5);
      return v6 != 0;
    }
  }
  return result;
}

void sub_10003E208(char *a1, ...)
{
  char *v2[2];
  va_list va;

  va_start(va, a1);
  v2[0] = 0;
  va_copy((va_list)&v2[1], va);
  vasprintf(v2, a1, va);
  if (!v2[0])
    v2[0] = a1;
  sub_10003E248((uint64_t)v2[0]);
}

void sub_10003E248(uint64_t a1)
{
  char *v1;

  v1 = (char *)abort_with_reason(7, 1, a1, 0);
  sub_10003E264(v1);
}

void sub_10003E264(char *a1, ...)
{
  uint64_t v2;
  char *v3[2];
  va_list va;

  va_start(va, a1);
  v3[0] = 0;
  va_copy((va_list)&v3[1], va);
  vasprintf(v3, a1, va);
  if (!v3[0])
    v3[0] = a1;
  sub_100041014();
  v2 = syscall(55, 3072, v3[0]);
  _os_avoid_tail_call(v2);
  __break(1u);
}

_QWORD *sub_10003E2BC(uint64_t a1)
{
  unsigned int v2;
  _QWORD *result;

  if ((_UNKNOWN *)sub_10002E360(a1) != &unk_1000715B8)
    sub_10004D738();
  v2 = sub_10003E32C();
  result = sub_10002CE8C((uint64_t)qword_100071640, v2, 0, "iOSUser", 0, a1, (uint64_t)&qword_1000729A0);
  *((_BYTE *)result + 104) &= ~1u;
  return result;
}

uint64_t sub_10003E32C()
{
  uint64_t result;
  uint64_t v1;
  int v2;
  const char *v3;
  _BYTE v4[16];
  unsigned int v5;

  result = sub_100038FB8();
  if (!(_DWORD)result)
  {
    bzero(v4, 0x1090uLL);
    v1 = sub_10001A02C("mobile", 0, (uint64_t)v4);
    if ((_DWORD)v1)
    {
      v2 = v1;
      v3 = (const char *)xpc_strerror(v1);
      sub_10003E208("unable to resolve 'mobile': %d - %s", v2, v3);
    }
    return v5;
  }
  return result;
}

BOOL sub_10003E3D8(uint64_t a1)
{
  return *(_UNKNOWN **)(a1 + 112) == &unk_100071640 && sub_1000157A8(*(char **)(a1 + 968), "iOSUser");
}

uint64_t sub_10003E404()
{
  unsigned int v0;

  v0 = sub_10003E32C();
  return sub_10002E19C(qword_100071640, v0);
}

uint64_t sub_10003E424(uint64_t a1, void *a2)
{
  unsigned int v4;
  uint64_t i;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  xpc_object_t v14;
  uint64_t result;
  char v16;

  if ((_UNKNOWN *)sub_10002E360(a1) != &unk_1000715B8)
    sub_10004D738();
  if ((*(_BYTE *)(a1 + 1017) & 0x10) == 0)
  {
    v4 = sub_10003E32C();
    if (sub_10002E19C(qword_100071640, v4))
    {
      *(_DWORD *)(a1 + 1016) |= 0x1000u;
      if (a2)
      {
        if (*(_QWORD *)(a1 + 176))
          sub_10004D738();
        *(_QWORD *)(a1 + 176) = xpc_retain(a2);
      }
      sub_100010694("kern.willuserspacereboot", 1);
      for (i = *(_QWORD *)(a1 + 320); i; i = *(_QWORD *)(i + 16))
      {
        if (*(_QWORD **)(i + 112) == qword_100071640)
        {
          if (sub_1000157A8(*(char **)(i + 968), "iOSUser"))
          {
            if (*(_QWORD **)(i + 112) != qword_100071640 || !sub_1000157A8(*(char **)(i + 968), "iOSUser"))
              sub_10004D738();
            if (*(_QWORD *)(i + 168))
              sub_10004D738();
            *(_QWORD *)(i + 168) = sub_1000121A0();
          }
          sub_1000290BC(i, v6, v7, v8, v9, v10, v11, v12, v16);
        }
      }
      return 0;
    }
    return 37;
  }
  v13 = *(void **)(a1 + 176);
  if (!v13)
    return 37;
  if (xpc_get_type(v13) == (xpc_type_t)&_xpc_type_null)
  {
    if ((xpc_pipe_routine_reply(a2) | 0x20) != 0x20)
      _os_assumes_log_ctx(sub_100028C00, a1);
    return 0;
  }
  xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 176), "error", 89);
  if ((xpc_pipe_routine_reply(*(_QWORD *)(a1 + 176)) | 0x20) != 0x20)
    _os_assumes_log_ctx(sub_100028C00, a1);
  xpc_release(*(xpc_object_t *)(a1 + 176));
  v14 = xpc_retain(a2);
  result = 0;
  *(_QWORD *)(a1 + 176) = v14;
  return result;
}

uint64_t sub_10003E5E8(uint64_t a1)
{
  return sub_10003E424(a1, 0);
}

_QWORD *sub_10003E5F0(uint64_t a1)
{
  _QWORD *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if ((_UNKNOWN *)sub_10002E360(a1) != &unk_1000715B8)
    sub_10004D738();
  v2 = sub_10003E2BC(a1);
  v3 = *(void **)(a1 + 952);
  if (!v3)
    sub_10004D738();
  v2[119] = xpc_retain(v3);
  sub_100029A88(v2, (uint64_t)&qword_1000729A0, 0, v4, v5, v6, v7, v8);
  sub_10002DCD0((uint64_t)v2);
  return v2;
}

uint64_t sub_10003E664(uint64_t a1)
{
  unsigned int v3;
  void *v4;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;

  if ((_UNKNOWN *)sub_10002E360(a1) != &unk_1000715B8)
    sub_10004D738();
  if ((*(_BYTE *)(a1 + 1017) & 0x10) == 0)
    return 29;
  v3 = sub_10003E32C();
  if (sub_10002E19C(qword_100071640, v3))
    return 37;
  if (sub_1000291BC(a1))
    return 16;
  v4 = *(void **)(a1 + 176);
  if (v4)
  {
    xpc_release(v4);
    *(_QWORD *)(a1 + 176) = 0;
  }
  *(_DWORD *)(a1 + 1016) &= ~0x1000u;
  v5 = sub_10003E5F0(a1);
  if ((_QWORD *)v5[14] != qword_100071640 || (v6 = v5, !sub_1000157A8((char *)v5[121], "iOSUser")))
    sub_10004D738();
  if (v6[21])
    sub_10004D738();
  v7 = v6[29];
  v6[21] = *(_QWORD *)(v7 + 168);
  *(_QWORD *)(v7 + 168) = 0;
  sub_100028EE0(a1, 2);
  return 0;
}

uint64_t sub_10003E760(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  void *v7;
  uint32_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint32_t v21;
  char v22;
  char v23;

  v2 = result;
  if ((*(_BYTE *)(result + 1017) & 0x10) != 0 && *(_QWORD **)(a2 + 112) == qword_100071640)
  {
    result = sub_1000157A8(*(char **)(a2 + 968), "iOSUser");
    if ((_DWORD)result)
    {
      if (*(_QWORD **)(a2 + 112) != qword_100071640
        || (result = sub_1000157A8(*(char **)(a2 + 968), "iOSUser"), (result & 1) == 0))
      {
        sub_10004D738();
      }
      v4 = *(_QWORD *)(a2 + 232);
      if (*(_QWORD *)(v4 + 168))
        sub_10004D738();
      *(_QWORD *)(v4 + 168) = *(_QWORD *)(a2 + 168);
      *(_QWORD *)(a2 + 168) = 0;
    }
  }
  if ((*(_BYTE *)(v2 + 1017) & 0x10) != 0)
  {
    v5 = *(_QWORD *)(v2 + 320);
    if (v5)
    {
      while (*(_QWORD **)(v5 + 112) != qword_100071640)
      {
        v5 = *(_QWORD *)(v5 + 16);
        if (!v5)
          goto LABEL_12;
      }
    }
    else
    {
LABEL_12:
      if ((_UNKNOWN *)sub_10002E360(v2) != &unk_1000715B8)
        sub_10004D738();
      v6 = sub_10003E32C();
      if (sub_10002E19C(qword_100071640, v6))
        sub_10004D738();
      v7 = *(void **)(v2 + 176);
      if (v7)
      {
        if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_dictionary)
        {
          v21 = sub_10003E32C();
          sub_1000145B0(v21);
          if ((xpc_pipe_routine_reply(*(_QWORD *)(v2 + 176)) | 0x20) != 0x20)
            _os_assumes_log_ctx(sub_100028C00, v2);
          xpc_release(*(xpc_object_t *)(v2 + 176));
          result = (uint64_t)xpc_null_create();
          *(_QWORD *)(v2 + 176) = result;
        }
        else
        {
          result = (uint64_t)xpc_get_type(*(xpc_object_t *)(v2 + 176));
          if ((_UNKNOWN *)result != &_xpc_type_null)
            sub_10004D738();
        }
      }
      else
      {
        v8 = sub_10003E32C();
        sub_1000145B0(v8);
        sub_100041A80("keybag", 0, v9, v10, v11, v12, v13, v14, v22);
        sub_100041A80("usermanagerd-switch", 0, v15, v16, v17, v18, v19, v20, v23);
        result = sub_10003E664(v2);
        if ((_DWORD)result)
          return _os_assumes_log_ctx(sub_100028C00, v2);
      }
    }
  }
  return result;
}

uint64_t sub_10003E924(uint64_t a1, uint64_t a2)
{
  void *v4;
  uint64_t i;
  void *v6;
  xpc_object_t empty;
  uint64_t serialization;
  void *v9;
  size_t v10;
  size_t v11;
  _QWORD *v12;
  uint64_t readonly;
  uint64_t v14;
  char *v15;
  size_t count;
  size_t v17;
  size_t applier[5];

  v4 = (void *)qword_1000725F8;
  if (qword_1000725F8)
  {
    if (xpc_get_type((xpc_object_t)qword_1000725F8) != (xpc_type_t)&_xpc_type_array)
      sub_10003E208("invalid type for persistent services");
    xpc_array_apply(v4, &stru_10006CF38);
    xpc_release(v4);
    qword_1000725F8 = 0;
  }
  if (qword_100072600)
  {
    xpc_release((xpc_object_t)qword_100072600);
    qword_100072600 = 0;
  }
  if (qword_100072608)
  {
    xpc_release((xpc_object_t)qword_100072608);
    qword_100072608 = 0;
  }
  if ((_DWORD)a2)
  {
    qword_1000725F8 = (uint64_t)xpc_array_create_empty();
    qword_100072600 = (uint64_t)xpc_array_create_empty();
    sub_10003EBD0(a1, (void *)qword_1000725F8, a2);
    for (i = *(_QWORD *)(a1 + 320); i; i = *(_QWORD *)(i + 16))
      sub_10003EBD0(i, (void *)qword_1000725F8, a2);
    v6 = (void *)sub_10000F400();
    applier[0] = (size_t)_NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = (size_t)sub_10003F3AC;
    applier[3] = (size_t)&unk_10006CF70;
    applier[4] = qword_100072600;
    xpc_array_apply(v6, applier);
    empty = xpc_dictionary_create_empty();
    xpc_dictionary_set_value(empty, "services", (xpc_object_t)qword_1000725F8);
    xpc_dictionary_set_value(empty, "jetsam-properties", (xpc_object_t)qword_100072600);
    applier[0] = 0;
    serialization = xpc_make_serialization(empty, applier);
    if (serialization)
    {
      v9 = (void *)serialization;
      sub_100040F68(65541, "persistent object size is %zu bytes", applier[0]);
      v10 = applier[0];
      v11 = applier[0] + 16;
      if (applier[0] >= 0xFFFFFFFFFFFFFFF0)
      {
        sub_100040F68(65539, "overflow detected");
        free(v9);
        a2 = 84;
LABEL_19:
        xpc_release(empty);
        return a2;
      }
      v12 = (_QWORD *)sub_1000403B8(applier[0] + 16);
      *(_DWORD *)v12 = 772498902;
      v12[1] = v11;
      memcpy(v12 + 2, v9, v10);
      readonly = xpc_shmem_create_readonly(v12, v11);
      if (readonly)
      {
        v14 = readonly;
        v15 = sub_10000469C(a2);
        count = xpc_array_get_count((xpc_object_t)qword_1000725F8);
        sub_100040F68(65541, "gathered %zu services to persist into %s", count, v15);
        v17 = xpc_array_get_count((xpc_object_t)qword_100072600);
        sub_100040F68(65541, "gathered %zu jetsam property overlays to persist into %s", v17, v15);
        qword_100072608 = v14;
        sub_10003ED98(2);
        return 0;
      }
      free(v12);
      sub_100040F68(65539, "failed to create shmem");
    }
    else
    {
      sub_100040F68(65539, "failed to serialize persistent object: %p");
    }
    a2 = 12;
    goto LABEL_19;
  }
  return a2;
}

void sub_10003EBD0(uint64_t a1, void *a2, int a3)
{
  uint64_t v6;
  char *v7;
  uint64_t i;
  int8x16_t *j;
  int v10;
  int v11;
  void *v12;
  uint64_t v13;
  xpc_object_t v14;
  int v15;
  xpc_object_t values;
  int8x16_t v17;
  char *keys[2];
  const char *v19;

  v6 = *(_QWORD *)(a1 + 112);
  if ((_UNKNOWN *)v6 != &unk_1000715B8)
  {
    if ((_QWORD *)v6 == qword_100071640)
    {
      if (sub_10003E3D8(a1))
        goto LABEL_4;
      v6 = *(_QWORD *)(a1 + 112);
    }
    sub_100040F68(65541, "Skipped persisting services in domain: %s", *(const char **)(v6 + 112));
    return;
  }
LABEL_4:
  v7 = sub_10000469C(a3);
  for (i = 0; i != 23; ++i)
  {
    for (j = *(int8x16_t **)(a1 + 8 * i + 336); j; j = (int8x16_t *)j[7].i64[1])
    {
      v15 = 0;
      v10 = sub_100028DF4(*(_QWORD *)(a1 + 112), &v15);
      if (!v15 && (j[86].i8[5] & 4) != 0)
      {
        v11 = v10;
        v12 = (void *)j[40].i64[1];
        if (v12)
        {
          if (sub_10003F2A8(v12, v7))
          {
            v13 = j[41].i64[0];
            if (!v13 || !sub_10003F368(v13))
              sub_10003E208("failed to serialize service plist: %s", j[87].i8);
            *(_OWORD *)keys = *(_OWORD *)off_10006CF58;
            v19 = "plist";
            values = xpc_uint64_create(v11);
            v17 = vextq_s8(j[41], j[41], 8uLL);
            v14 = xpc_dictionary_create((const char *const *)keys, &values, 3uLL);
            xpc_array_append_value(a2, v14);
            sub_100040F68(65541, "persisting service %s (%s) into %s", j[87].i8, *(const char **)(*(_QWORD *)(a1 + 112) + 112), v7);
          }
        }
      }
    }
  }
}

uint64_t sub_10003ED98(uint64_t result)
{
  unint64_t v1;
  BOOL v2;
  uint64_t *v3;

  v1 = 0;
  v2 = 1;
  v3 = &qword_100071950;
  do
  {
    if (*(v3 - 1) == qword_100071998 && *v3 == result)
      break;
    v2 = v1 < 4;
    v3 += 2;
    ++v1;
  }
  while (v1 != 5);
  if (!v2)
    sub_10004D738();
  qword_100071998 = result;
  return result;
}

uint64_t sub_10003EE00()
{
  return qword_100072608;
}

void sub_10003EE0C()
{
  kern_return_t v0;
  mem_entry_name_port_t v1;
  int v2;
  char *v3;
  mach_vm_size_t v4;
  void *v5;
  xpc_object_t array;
  void *v7;
  xpc_object_t v8;
  void *v9;
  size_t count;
  size_t v11;
  uint64_t v12;
  mach_msg_type_number_t init_port_setCnt;
  mach_port_array_t init_port_set;

  sub_10003ED98(3);
  if (qword_100072610)
    sub_10004D738();
  if (qword_100072618)
    sub_10004D738();
  init_port_set = 0;
  init_port_setCnt = 0;
  v0 = mach_ports_lookup(mach_task_self_, &init_port_set, &init_port_setCnt);
  if (v0)
    sub_10003E208("mach_ports_lookup() failed: %d", v0);
  if (init_port_setCnt < 2 || (v1 = init_port_set[1], v1 + 1 <= 1))
  {
    v2 = 65541;
    v12 = 2;
    v3 = "no mach port for persistent services: %d";
LABEL_7:
    sub_100040F68(v2, v3, v12);
    return;
  }
  init_port_set = 0;
  if (sub_100040010(v1, 0x10uLL, (mach_vm_address_t *)&init_port_set, 1))
  {
    v3 = "failed to map persistent services header";
    goto LABEL_11;
  }
  if (*init_port_set != 772498902)
  {
    sub_100040F68(65539, "persistent services header magic is invalid");
LABEL_16:
    sub_100040F68(65539, "failed to validate services header: %d", 22);
    if (munmap(init_port_set, 0x10uLL) == -1)
      goto LABEL_26;
    return;
  }
  v4 = *((_QWORD *)init_port_set + 1);
  if (v4 <= 0xF)
  {
    sub_100040F68(65539, "persistent services header size is less than header size");
    goto LABEL_16;
  }
  if (sub_100040084(v4, (mach_vm_address_t *)&init_port_set, 1))
  {
    sub_100040F68(65539, "failed to map persistent services");
    if (munmap(init_port_set, 0x10uLL) == -1)
      goto LABEL_26;
  }
  else
  {
    if (*init_port_set == 772498902)
    {
      if (*((_QWORD *)init_port_set + 1) > 0xFuLL)
      {
        init_port_setCnt = 0;
        v5 = (void *)sub_10003F40C((uint64_t)init_port_set, (int *)&init_port_setCnt);
        if (munmap(init_port_set, *((_QWORD *)init_port_set + 1)) == -1)
          sub_10004DE84();
        if (init_port_setCnt)
        {
          if (v5)
            sub_10004D738();
          v12 = init_port_setCnt;
          v3 = "failed to restore persistent object: %d";
        }
        else
        {
          array = xpc_dictionary_get_array(v5, "services");
          if (!array)
            sub_10003E208("no services found in persistent object");
          v7 = array;
          v8 = xpc_dictionary_get_array(v5, "jetsam-properties");
          if (!v8)
            sub_10003E208("no jetsam property overlays found in persistent object");
          v9 = v8;
          if (xpc_get_type(v7) == (xpc_type_t)&_xpc_type_array)
          {
            count = xpc_array_get_count(v7);
            sub_100040F68(65541, "validating %zu persistent services", count);
            if (xpc_array_apply(v7, &stru_10006CFB0))
            {
              if (xpc_get_type(v9) == (xpc_type_t)&_xpc_type_array)
              {
                v11 = xpc_array_get_count(v9);
                sub_100040F68(65541, "validating %zu jetsam property overlays", v11);
                qword_100072618 = (uint64_t)v9;
                qword_100072610 = (uint64_t)v7;
                return;
              }
              sub_100040F68(65539, "jetsam properties object is not an array");
              v3 = "persistent jetsam properties object is invalid";
              goto LABEL_11;
            }
          }
          else
          {
            sub_100040F68(65539, "persistent services object is not an array");
          }
          v3 = "persistent services object is invalid";
        }
LABEL_11:
        v2 = 65539;
        goto LABEL_7;
      }
      sub_100040F68(65539, "persistent services header size is less than header size");
    }
    else
    {
      sub_100040F68(65539, "persistent services header magic is invalid");
    }
    sub_100040F68(65539, "failed to validate remapped services header: %d", 22);
    if (munmap(init_port_set, *((_QWORD *)init_port_set + 1)) == -1)
LABEL_26:
      sub_10004DE84();
  }
}

void sub_10003F19C()
{
  size_t count;
  size_t v1;

  sub_10003ED98(4);
  if (qword_100072618)
  {
    count = xpc_array_get_count((xpc_object_t)qword_100072618);
    sub_100040F68(65541, "restoring %zu jetsam property overlays", count);
    xpc_array_apply((xpc_object_t)qword_100072618, &stru_10006CFF0);
    xpc_release((xpc_object_t)qword_100072618);
    qword_100072618 = 0;
  }
  if (qword_100072610)
  {
    v1 = xpc_array_get_count((xpc_object_t)qword_100072610);
    sub_100040F68(65541, "restoring %zu persistent services", v1);
    xpc_array_apply((xpc_object_t)qword_100072610, &stru_10006D030);
    xpc_release((xpc_object_t)qword_100072610);
    qword_100072610 = 0;
  }
}

BOOL sub_10003F24C(id a1, unint64_t a2, void *a3)
{
  if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_dictionary)
    sub_10003E208("invalid type for persistent service[%zu]", a2);
  xpc_release(a3);
  return 1;
}

BOOL sub_10003F2A8(void *a1, char *a2)
{
  uint64_t v4;
  const char *string_ptr;
  size_t v7;
  xpc_object_t value;

  if (xpc_get_type(a1) == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    return sub_1000157A8(a2, string_ptr);
  }
  else
  {
    if (xpc_get_type(a1) != (xpc_type_t)&_xpc_type_array || !xpc_array_get_count(a1))
      return 0;
    v7 = 0;
    do
    {
      value = xpc_array_get_value(a1, v7);
      v4 = sub_10003F2A8(value, a2);
      if ((_DWORD)v4)
        break;
      ++v7;
    }
    while (v7 < xpc_array_get_count(a1));
    return v4;
  }
}

BOOL sub_10003F368(uint64_t a1)
{
  void *serialization;
  void *v2;
  uint64_t v4;

  v4 = 0;
  serialization = (void *)xpc_make_serialization(a1, &v4);
  v2 = serialization;
  if (serialization)
    free(serialization);
  return v2 != 0;
}

uint64_t sub_10003F3AC(uint64_t a1, uint64_t a2, void *a3)
{
  if (!sub_10003F368((uint64_t)a3))
    sub_10003E208("failed to serialize jetsam properties[%zu]", a2);
  xpc_array_append_value(*(xpc_object_t *)(a1 + 32), a3);
  return 1;
}

uint64_t sub_10003F40C(uint64_t a1, int *a2)
{
  uint64_t v3;
  int v4;

  v3 = xpc_create_from_serialization(a1 + 16, *(_QWORD *)(a1 + 8) - 16);
  if (v3)
  {
    v4 = 0;
  }
  else
  {
    sub_100040F68(65539, "failed to deserialize persistent object");
    v4 = 22;
  }
  *a2 = v4;
  return v3;
}

BOOL sub_10003F46C(id a1, unint64_t a2, void *a3)
{
  if (xpc_get_type(a3) != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100040F68(65539, "services[%zu] is not a dictionary");
    return 0;
  }
  if (!xpc_dictionary_get_dictionary(a3, "plist"))
  {
    sub_100040F68(65539, "services[%zu] is missing or has invalid plist key");
    return 0;
  }
  if (!xpc_dictionary_get_uint64(a3, "xpc-domain"))
  {
    sub_100040F68(65539, "services[%zu] is missing or has invalid xpc-domain key");
    return 0;
  }
  if (!xpc_dictionary_get_string(a3, "origin"))
  {
    sub_100040F68(65539, "services[%zu] is missing or has invalid origin key");
    return 0;
  }
  return 1;
}

BOOL sub_10003F530(id a1, unint64_t a2, void *a3)
{
  int v4;

  v4 = sub_10000E518(a3);
  if (v4)
    sub_100040F68(65539, "failed to merge persisted jetsam property overlay[%zu]: %d", a2, v4);
  return 1;
}

BOOL sub_10003F57C(id a1, unint64_t a2, void *a3)
{
  int uint64;
  xpc_object_t value;
  char *string;
  const char *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 *v11;
  int v12;
  const char *v13;
  unsigned int v15;

  uint64 = xpc_dictionary_get_uint64(a3, "xpc-domain");
  value = xpc_dictionary_get_value(a3, "plist");
  string = (char *)xpc_dictionary_get_string(a3, "origin");
  v7 = xpc_dictionary_get_string(value, "Label");
  v8 = (_QWORD *)sub_100028E38(uint64);
  if (v8 == (_QWORD *)&unk_1000715B8)
  {
    v10 = sub_10002E190();
    if (!v10)
    {
LABEL_15:
      sub_100040F68(65539, "failed to lookup domain for persisted service");
      goto LABEL_16;
    }
  }
  else
  {
    if (v8 != qword_100071640)
      sub_10004D738();
    v9 = 0;
    while (1)
    {
      v10 = qword_100071640[v9];
      if (v10)
        break;
LABEL_7:
      if (++v9 == 11)
        goto LABEL_15;
    }
    while (!sub_10003E3D8(v10))
    {
      v10 = *(_QWORD *)(v10 + 32);
      if (!v10)
        goto LABEL_7;
    }
  }
  v15 = 0;
  v11 = sub_10003C3F8(value, (_DWORD *)v10, string, &v15);
  v12 = v15;
  if (!v15)
  {
    sub_100040F68(65541, "successfully submitted persisted service: %s to %s domain");
    return 1;
  }
  if (v11)
    sub_10004D738();
  v13 = (const char *)xpc_strerror(v15);
  sub_100040F68(65539, "persisted submit job failed: service = %s, error = %d: %s", v7, v12, v13);
  if (v15)
LABEL_16:
    sub_100040F68(65539, "failed to restore service[%zu]: %d");
  return 1;
}

void sub_10003F72C()
{
  mach_port_t v0;

  v0 = mach_host_self();
  host_reboot(v0, 4096);
  __break(1u);
}

void *sub_10003F744(int a1)
{
  void *result;

  if (a1)
  {
    if (dlopen("/usr/lib/system/libsystem_notify.dylib", 1))
      notify_set_options(0x8000000);
    if (!dlopen("/usr/lib/system/libsystem_info.dylib", 1))
    {
LABEL_8:
      result = dlopen("/usr/lib/system/libsystem_trace.dylib", 1);
      if (!result)
        return result;
      return (void *)os_trace_set_mode(256);
    }
  }
  else
  {
    notify_set_options(0x8000000);
  }
  si_search_module_set_flags("mdns", 1);
  si_search_module_set_flags("ds", 1);
  if (a1)
    goto LABEL_8;
  return (void *)os_trace_set_mode(256);
}

char *sub_10003F7E8(uint64_t a1, uint64_t a2)
{
  return sub_10003F7F0(a1, a2, 11);
}

char *sub_10003F7F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  char *v7;
  uint64_t v8;
  int8x8_t *v9;
  int v10;
  uint64_t v11;
  _BYTE v13[4];
  unsigned int size;
  char size_4;

  bzero(v13, 0x408uLL);
  sub_10003FA9C(a1, a2, a3, (int8x8_t *)v13, 1032);
  if ((v6 & 0x80000000) == 0)
  {
    if (!v6)
      return sub_1000154A0(&size_4, size - 8);
    return 0;
  }
  if (*__error() != 34)
    return 0;
  v8 = size;
  v9 = (int8x8_t *)sub_10001389C(size);
  sub_10003FA9C(a1, a2, a3, v9, v8);
  if (v10)
  {
    if (*__error() != 3)
    {
      v11 = *__error();
      if ((_DWORD)v11)
        _os_assumes_log(v11);
    }
    v7 = 0;
  }
  else
  {
    v7 = sub_1000154A0((const char *)&v9[1], v9->u32[1] - 8);
  }
  free(v9);
  return v7;
}

xpc_object_t sub_10003F930(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  xpc_object_t v7;
  uint64_t v8;
  int8x8_t *v9;
  int v10;
  uint64_t v11;
  uint64_t v13;
  int v14;
  unsigned int size;
  size_t size_4;

  bzero(&v14, 0x408uLL);
  if ((_DWORD)a3 != 16 && (_DWORD)a3 != 7)
    return 0;
  sub_10003FA9C(a1, a2, a3, (int8x8_t *)&v14, 1032);
  if (v6 < 0)
  {
    if (*__error() != 34)
      return 0;
    v8 = size;
    v9 = (int8x8_t *)sub_10001389C(size);
    sub_10003FA9C(a1, a2, a3, v9, v8);
    if (v10)
    {
      if (*__error() != 3)
      {
        v11 = *__error();
        if ((_DWORD)v11)
          _os_assumes_log(v11);
      }
    }
    else
    {
      v13 = v9->u32[1];
      if ((_DWORD)v13 && v9->i32[0])
      {
        v7 = xpc_data_create(&v9[1], v13 - 8);
LABEL_19:
        free(v9);
        return v7;
      }
    }
    v7 = 0;
    goto LABEL_19;
  }
  if (v6)
    return 0;
  v7 = 0;
  if (size && v14)
    return xpc_data_create(&size_4, size - 8);
  return v7;
}

int8x8_t sub_10003FA9C(uint64_t a1, uint64_t a2, uint64_t a3, int8x8_t *a4, uint64_t a5)
{
  int8x8_t result;

  if (a2)
    csops_audittoken(a1, a3, a4, a5, a2);
  else
    csops(a1, a3, a4, a5);
  result = vrev32_s8(*a4);
  *a4 = result;
  return result;
}

xpc_object_t sub_10003FAF4(uint64_t a1, uint64_t a2)
{
  xpc_object_t result;
  void *v3;
  const void *bytes_ptr;
  size_t length;
  uint64_t v6;

  result = sub_10003F930(a1, a2, 16);
  if (result)
  {
    v3 = result;
    bytes_ptr = xpc_data_get_bytes_ptr(result);
    length = xpc_data_get_length(v3);
    v6 = xpc_create_from_ce_der((unint64_t)bytes_ptr, length);
    xpc_release(v3);
    return (xpc_object_t)v6;
  }
  return result;
}

uint64_t sub_10003FB48(int a1, void *buffer)
{
  if (proc_pidinfo(a1, 13, 1uLL, buffer, 64) == 64)
    return 0;
  else
    return *__error();
}

uint64_t sub_10003FB84(int a1, void *buffer)
{
  if (proc_pidinfo(a1, 18, 1uLL, buffer, 192) == 192)
    return 0;
  else
    return *__error();
}

const char *sub_10003FBC0(uint64_t a1, char *a2)
{
  int v3;
  const char *v4;

  v3 = sub_10003FB48(*(_DWORD *)(a1 + 20), a2);
  v4 = "(dead-on-arrival)";
  if (v3 != 3)
    v4 = "(confusing)";
  if (v3)
    return v4;
  else
    return a2 + 16;
}

char *sub_10003FC08(int a1, char *a2)
{
  int v4;
  const char *v5;
  __int128 buffer;
  _OWORD v8[3];

  buffer = 0u;
  memset(v8, 0, sizeof(v8));
  v4 = sub_10003FB48(a1, &buffer);
  v5 = "(unknown)";
  if (!v4)
    v5 = (const char *)v8;
  snprintf(a2, 0x20uLL, "%s[%d]", v5, a1);
  return a2;
}

uint64_t sub_10003FCAC(int a1, void *buffer)
{
  if (proc_pidinfo(a1, 20, 1uLL, buffer, 40) == 40)
    return 0;
  else
    return *__error();
}

size_t sub_10003FCE8(const char *a1, char **a2)
{
  int v4;
  int v5;
  int v6;
  size_t result;
  char *v8;
  int v9;
  char *v10;
  size_t size;
  _OWORD v12[8];

  *__error() = 0;
  memset(v12, 0, sizeof(v12));
  size = 128;
  v4 = sysctlbyname(a1, v12, &size, 0, 0);
  v5 = v4;
  if (size)
  {
    if (!v4)
      goto LABEL_6;
  }
  else
  {
    size = 128;
    *__error() = 12;
    if (!v5)
      goto LABEL_6;
  }
  if (*__error() != 12)
    return 0;
LABEL_6:
  if (size != 128 || *__error() != 12)
  {
    v10 = 0;
    v8 = (char *)v12;
    if (v5)
      goto LABEL_13;
LABEL_16:
    *a2 = strdup(v8);
    goto LABEL_17;
  }
  v6 = sysctlbyname(a1, 0, &size, 0, 0);
  result = 0;
  if (v6)
    return result;
  if (size < 0x81)
  {
    v10 = 0;
    v8 = (char *)v12;
    goto LABEL_16;
  }
  v8 = (char *)sub_10001389C(size);
  v9 = sysctlbyname(a1, v8, &size, 0, 0);
  v10 = v8;
  if (!v9)
    goto LABEL_16;
LABEL_13:
  size = 0;
LABEL_17:
  free(v10);
  return size;
}

uint64_t sub_10003FE74(const char *a1, _QWORD *a2)
{
  int v4;
  uint64_t result;
  int v6;
  int v7;
  size_t v8;

  v8 = 0;
  v4 = sysctlbyname(a1, 0, &v8, 0, 0);
  result = 0;
  if (!v4)
  {
    if (v8 == 8)
    {
      return 8 * (sysctlbyname(a1, a2, &v8, 0, 0) == 0);
    }
    else if (v8 == 4)
    {
      v7 = 0;
      v6 = sysctlbyname(a1, &v7, &v8, 0, 0);
      result = 0;
      if (!v6)
      {
        *a2 = v7;
        return 8;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

int *sub_10003FF3C(const char *a1, int a2)
{
  int *result;
  int v3;
  int v4;

  v4 = a2;
  result = (int *)sysctlbyname(a1, 0, 0, &v4, 4uLL);
  if ((_DWORD)result)
  {
    v3 = (int)result;
    result = __error();
    if (v3 == -1 && *result != 2)
      return (int *)sub_10004D870();
  }
  return result;
}

unint64_t sub_10003FF9C(char *a1, const char *a2, uint64_t a3)
{
  char *v5;
  const char *v6;
  unint64_t v7;
  char *__endptr;

  v5 = strstr(a1, a2);
  if (v5)
  {
    __endptr = 0;
    v6 = &v5[strlen(a2)];
    v7 = strtoul(v6, &__endptr, 10);
    if (v6 != __endptr)
      return v7;
  }
  return a3;
}

unint64_t sub_100040008(char *a1, const char *a2)
{
  return sub_10003FF9C(a1, a2, 0);
}

uint64_t sub_100040010(mem_entry_name_port_t object, mach_vm_size_t size, mach_vm_address_t *a3, int a4)
{
  uint64_t result;
  mach_vm_address_t address;

  address = 0;
  result = mach_vm_map(mach_task_self_, &address, size, 0, 1, object, 0, a4 ^ 1, 67, 67, 2u);
  if (!(_DWORD)result)
    *a3 = address;
  return result;
}

uint64_t sub_100040084(mach_vm_size_t size, mach_vm_address_t *a2, int a3)
{
  uint64_t result;
  mach_vm_address_t target_address;
  vm_prot_t v6;
  vm_prot_t cur_protection;

  v6 = 67;
  cur_protection = 67;
  target_address = 0;
  result = mach_vm_remap(mach_task_self_, &target_address, size, 0, 16385, mach_task_self_, *a2, a3 ^ 1, &cur_protection, &v6, 2u);
  if (!(_DWORD)result)
    *a2 = target_address;
  return result;
}

uint64_t sub_100040104(int a1, rlim_t *a2, rlim_t *a3)
{
  uint64_t result;
  rlim_t rlim_cur;
  rlim_t rlim_max;
  rlimit v8;

  v8.rlim_cur = 0;
  v8.rlim_max = 0;
  result = getrlimit(a1, &v8);
  if (!(_DWORD)result)
  {
    rlim_cur = v8.rlim_cur;
    if (v8.rlim_cur == 0x7FFFFFFFFFFFFFFFLL)
      rlim_cur = -1;
    if (v8.rlim_max == 0x7FFFFFFFFFFFFFFFLL)
      rlim_max = -1;
    else
      rlim_max = v8.rlim_max;
    *a2 = rlim_cur;
    *a3 = rlim_max;
  }
  return result;
}

uint64_t sub_10004015C(int a1, unint64_t a2, uint64_t a3, int a4)
{
  unint64_t v6;
  uint64_t v7;
  rlim_t v8;
  const char *v9;
  const char *v10;
  rlim_t rlim_max;
  uint64_t result;
  rlimit v13;
  rlimit v14;

  if (a2 >= 0x7FFFFFFFFFFFFFFFLL)
    v6 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v6 = a2;
  if (a3 < 0)
    v7 = -1;
  else
    v7 = a3;
  if (a3 >= 0)
    v8 = v7;
  else
    v8 = 0x7FFFFFFFFFFFFFFFLL;
  if (a1 == 8)
  {
    v9 = "kern.maxfilesperproc";
    v10 = "kern.maxfiles";
    goto LABEL_14;
  }
  if (a1 == 7)
  {
    v9 = "kern.maxprocperuid";
    v10 = "kern.maxproc";
LABEL_14:
    sub_100040254(v10, v8, a4);
    sub_100040254(v9, v6, a4);
  }
  v14.rlim_cur = v6;
  v14.rlim_max = v8;
  if (a4)
  {
    v13.rlim_cur = 0;
    v13.rlim_max = 0;
    if (!getrlimit(a1, &v13))
    {
      rlim_max = 0x7FFFFFFFFFFFFFFFLL;
      if (v13.rlim_max == 0x7FFFFFFFFFFFFFFFLL || (rlim_max = v13.rlim_max, v8 < v13.rlim_max))
        v14.rlim_max = rlim_max;
    }
  }
  result = setrlimit(a1, &v14);
  if ((_DWORD)result)
    return _os_assumes_log((int)result);
  return result;
}

uint64_t sub_100040254(const char *a1, unint64_t a2, int a3)
{
  uint64_t result;
  int v7;
  int v8;
  size_t v9;
  unsigned int v10;

  v10 = 0x7FFFFFFF;
  v9 = 4;
  result = sysctlbyname(a1, &v10, &v9, 0, 0);
  if (!a3 || !(_DWORD)result && v9 == 4 && (v10 & 0x80000000) == 0 && v10 < a2)
  {
    if (a2 >> 31)
      v7 = 0x7FFFFFFF;
    else
      v7 = a2;
    v8 = v7;
    return sysctlbyname(a1, 0, 0, &v8, 4uLL);
  }
  return result;
}

uint64_t sub_1000402F8(char *__s2, unint64_t a2, uint64_t a3, int a4)
{
  uint64_t v8;
  uint64_t result;

  v8 = 0;
  while (1)
  {
    result = strcmp((&off_1000719A0)[v8], __s2);
    if (!(_DWORD)result)
      break;
    v8 += 2;
    if (v8 == 18)
      return result;
  }
  return sub_10004015C((int)(&off_1000719A0)[v8 + 1], a2, a3, a4);
}

char *sub_100040380(int a1)
{
  uint64_t v1;

  v1 = 0;
  while (LODWORD((&off_1000719A0)[v1 + 1]) != a1)
  {
    v1 += 2;
    if (v1 == 18)
      return 0;
  }
  return (&off_1000719A0)[v1];
}

vm_address_t sub_1000403B8(uint64_t a1)
{
  kern_return_t v1;
  vm_address_t address;

  address = 0;
  v1 = vm_allocate(mach_task_self_, &address, (a1 + vm_page_size - 1) & -(uint64_t)vm_page_size, -268435453);
  if (v1)
    _os_assumes_log(v1);
  return address;
}

vm_address_t sub_100040420(uint64_t a1)
{
  kern_return_t v1;
  vm_address_t address;

  address = 0;
  v1 = vm_allocate(mach_task_self_, &address, (a1 + vm_page_size - 1) & -(uint64_t)vm_page_size, -268435455);
  if (v1)
    _os_assumes_log(v1);
  return address;
}

uint64_t sub_100040488(int a1)
{
  return sub_10001592C(a1, (uint64_t)&unk_10006D050, 27);
}

uint64_t sub_100040498(int a1)
{
  return sub_10001592C(a1, (uint64_t)&unk_10006D200, 26);
}

void sub_1000404A8(int a1, int a2)
{
  int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;

  if (a1 == 1)
  {
    sub_100011420(570425404, 0);
    reboot(a2);
    if (*__error() == 16)
      sub_10004054C();
    goto LABEL_8;
  }
  if (a1 == 2)
    sub_10003F72C();
  if (a1 != 3)
  {
    sub_100011420(570425404, 2);
    sub_10004055C(a2);
LABEL_8:
    v3 = __error();
    v4 = _os_assert_log(*v3);
    _os_crash(v4, v5, v6, v7);
    __break(1u);
  }
  sub_100011420(570425404, 1);
  sub_100042B30("recovery-mode", v8, v9, v10, v11, v12, v13, v14, v15);
  __break(1u);
}

void sub_10004054C()
{
  while (1)
    pause();
}

uint64_t sub_10004055C(char a1)
{
  char ***v2;
  char *v3;
  int v4;
  int v5;
  int v6;
  char *v7;
  uint64_t v8;
  xpc_object_t empty;
  xpc_object_t v10;
  void *v11;
  const void *bytes_ptr;
  size_t length;
  int v14;
  char ***v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t result;
  _DWORD v51[3];
  pid_t v52;
  char *__argv[3];
  posix_spawnattr_t v54;

  v54 = 0;
  v2 = _NSGetArgv();
  v3 = "-s";
  if ((a1 & 2) == 0)
    v3 = 0;
  __argv[0] = **v2;
  __argv[1] = v3;
  __argv[2] = 0;
  v52 = 0;
  sub_1000145B0(0);
  v51[0] = 1;
  if ((sub_100039000() & 1) == 0 && sysctlbyname("vm.shared_region_pivot", 0, 0, v51, 4uLL) == -1)
    goto LABEL_21;
  unsetenv("MallocProbGuard");
  unsetenv("XPC_IN_REM");
  unsetenv("XPC_IN_REM_DEVELOPMENT");
  if (setenv("XPC_USERSPACE_REBOOTED", "1", 1) == -1)
    goto LABEL_19;
  v4 = posix_spawnattr_init(&v54);
  if (v4)
    _os_assumes_log(v4);
  v5 = posix_spawnattr_setflags(&v54, 16448);
  if (v5)
    _os_assumes_log(v5);
  v6 = sub_100042BDC();
  if (!v6)
  {
LABEL_17:
    empty = xpc_dictionary_create_empty();
    xpc_dictionary_set_BOOL(empty, "on-system-volume", 1);
    xpc_dictionary_set_string(empty, "signing-identifier", "com.apple.xpc.launchd");
    xpc_dictionary_set_int64(empty, "validation-category", 1);
    v10 = sub_100011648(1, 0, empty);
    v11 = (void *)sub_1000116F4(v10);
    bytes_ptr = xpc_data_get_bytes_ptr(v11);
    length = xpc_data_get_length(v11);
    v14 = amfi_launch_constraint_set_spawnattr(&v54, bytes_ptr, length);
    if (v14)
    {
LABEL_20:
      v26 = _os_assert_log(v14);
      _os_crash(v26, v27, v28, v29);
      __break(1u);
LABEL_21:
      v30 = __error();
      v31 = _os_assert_log(*v30);
      _os_crash(v31, v32, v33, v34);
      __break(1u);
      goto LABEL_22;
    }
    v15 = _NSGetEnviron();
    v16 = posix_spawn(&v52, "/sbin/launchd", 0, &v54, __argv, *v15);
    v17 = _os_assert_log(v16);
    _os_crash(v17, v18, v19, v20);
    __break(1u);
LABEL_19:
    v21 = __error();
    v22 = _os_assert_log(*v21);
    v14 = _os_crash(v22, v23, v24, v25);
    __break(1u);
    goto LABEL_20;
  }
  v7 = sub_10000469C(v6);
  if (setenv("XPC_USERSPACE_REBOOT_TO_BOOT_MODE", v7, 1) == -1)
  {
LABEL_22:
    v35 = __error();
    v36 = _os_assert_log(*v35);
    _os_crash(v36, v37, v38, v39);
    __break(1u);
LABEL_23:
    v40 = __error();
    v41 = _os_assert_log(*v40);
    _os_crash(v41, v42, v43, v44);
    __break(1u);
    goto LABEL_24;
  }
  if (!sub_100042BF4() || setenv("XPC_IN_REM_DEVELOPMENT", "1", 1) != -1)
  {
    v51[2] = 0;
    v8 = sub_10003EE00();
    if (!v8)
      _os_assumes_log(0);
    v51[0] = 0;
    v51[1] = _xpc_shmem_get_mach_port(v8);
    if (posix_spawnattr_set_registered_ports_np(&v54, v51, 2) == -1)
      goto LABEL_23;
    goto LABEL_17;
  }
LABEL_24:
  v45 = __error();
  v46 = _os_assert_log(*v45);
  result = _os_crash(v46, v47, v48, v49);
  __break(1u);
  return result;
}

uint64_t sub_1000407FC(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;

  result = terminate_with_reason(a1, 7, a2, a3, a4 | 0x100);
  if ((_DWORD)result)
  {
    if (*__error() == 3)
      return 0;
    else
      return *__error();
  }
  return result;
}

uint64_t sub_100040848()
{
  uint64_t v0;

  v0 = kill(-1, 9);
  if ((_DWORD)v0)
  {
    if (*__error() == 1)
    {
      sub_100040F68(65540, "kill(-1, SIGKILL) returned EPERM (expected at most twice)");
    }
    else if ((_DWORD)v0 == -1)
    {
      sub_10004D870();
    }
  }
  return v0;
}

uint64_t sub_1000408B0(_OWORD *a1)
{
  __int128 v1;
  _OWORD v3[2];

  v1 = a1[1];
  v3[0] = *a1;
  v3[1] = v1;
  return proc_terminate_with_audittoken(v3);
}

uint64_t sub_1000408D8(uint64_t a1, int a2)
{
  uint64_t result;
  int v4;

  v4 = 0;
  if (!csops_audittoken(*(unsigned int *)(a1 + 20), 0, &v4, 4, a1))
    return (a2 & ~v4) == 0;
  if (*__error() == 3)
    return 0;
  result = *__error();
  if ((_DWORD)result)
  {
    _os_assumes_log(result);
    return 0;
  }
  return result;
}

xpc_object_t sub_100040958(uint64_t a1)
{
  return sub_10003FAF4(*(unsigned int *)(a1 + 20), a1);
}

BOOL sub_100040964(pid_t a1)
{
  if (a1 < 1)
    return 0;
  if (kill(a1, 0))
    return *__error() != 3;
  return 1;
}

uint64_t sub_1000409A8(_OWORD *a1)
{
  __int128 v1;
  _OWORD v3[2];

  v1 = a1[1];
  v3[0] = *a1;
  v3[1] = v1;
  return proc_signal_with_audittoken(v3);
}

uint64_t sub_1000409D0(pid_t a1, int *a2, int a3, rusage *a4)
{
  if (wait4(a1, a2, a3, a4) == -1)
    return *__error();
  else
    return 0;
}

uint64_t sub_100040A08(int pid, integer_t *a2)
{
  uint64_t v3;
  mach_port_name_t tn;
  mach_msg_type_number_t task_info_outCnt;

  tn = 0;
  task_info_outCnt = 8;
  v3 = task_name_for_pid(mach_task_self_, pid, &tn);
  if (!(_DWORD)v3)
  {
    v3 = task_info(tn, 0xFu, a2, &task_info_outCnt);
    mach_port_deallocate(mach_task_self_, tn);
  }
  return v3;
}

uint64_t sub_100040A84(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t result;

  v2 = memorystatus_control(1, a1, 0, a2, 24);
  result = 0;
  if (v2 != 24)
    return *__error();
  return result;
}

uint64_t sub_100040AC4(int a1)
{
  _OWORD v2[2];
  __int128 v3;
  __int128 v4;

  v3 = 0u;
  v4 = 0u;
  memset(v2, 0, sizeof(v2));
  if (!sub_10003FB48(a1, v2))
    return (v3 >> 1) & 1;
  _os_assumes_log(0);
  return 0;
}

uint64_t sub_100040B48()
{
  return qword_100071AF8;
}

void sub_100040B54(const char *a1)
{
  char __str[16];
  __int128 v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;

  v9 = 0u;
  v10 = 0u;
  v7 = 0u;
  v8 = 0u;
  v5 = 0u;
  v6 = 0u;
  v3 = 0u;
  v4 = 0u;
  *(_OWORD *)__str = 0u;
  v2 = 0u;
  snprintf(__str, 0xA0uLL, "XPC API Misuse: %s", a1);
  qword_100071AF8 = (uint64_t)__str;
  __break(1u);
}

void sub_100040BA8(uint64_t a1)
{
  free(*(void **)(a1 + 24));
  free(*(void **)(a1 + 48));
}

uint64_t sub_100040BD0(const char *a1)
{
  int v1;

  if (byte_100072630)
    v1 = 3;
  else
    v1 = 65539;
  sub_100040F68(v1, "%s", a1);
  return 1;
}

void sub_100040C1C()
{
  const char *v0;
  pid_t v1;
  int *v2;
  int *v3;
  int v4;
  int v5;
  int v6;
  int *v7;
  const char *v8;
  int *v9;
  int v10;
  int *v11;
  const char *v12;
  int *v13;
  sockaddr v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _WORD v19[13];
  char __str[1024];

  if (qword_100072620 != -1)
    dispatch_once_f(&qword_100072620, 0, (dispatch_function_t)sub_100040EF8);
  mkdir(off_100071A70[0], 0x1C0u);
  if (!byte_100072A63)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "/private/%s", "/var/run/syslog");
    v18 = 0u;
    memset(v19, 0, sizeof(v19));
    v16 = 0u;
    v17 = 0u;
    v14 = (sockaddr)0;
    v15 = 0u;
    v14.sa_family = 1;
    strncpy(v14.sa_data, __str, 0x67uLL);
    v2 = (int *)socket(1, 2, 0);
    if ((_DWORD)v2 == -1)
    {
      v6 = *__error();
      v7 = __error();
      v8 = (const char *)xpc_strerror(*v7);
      sub_100040F68(65539, "Could not create system logger socket: error = %d: %s", v6, v8);
      goto LABEL_4;
    }
    v3 = v2;
    if (unlink(v14.sa_data) == -1 && *__error() != 2)
    {
      __error();
      v9 = __error();
      xpc_strerror(*v9);
      sub_100040F68(65539, "Could not unlink previous system logger socket: error = %d: %s");
    }
    else
    {
      v4 = bind((int)v3, &v14, 0x6Au);
      if (!v4)
        goto LABEL_17;
      v5 = v4;
      while (*__error() == 35 || *__error() == 4)
      {
        v5 = bind((int)v3, &v14, 0x6Au);
        if (!v5)
          goto LABEL_17;
      }
      if (v5 != -1)
      {
LABEL_17:
        if (chmod(v14.sa_data, 0x1B6u) == -1)
        {
          v10 = *__error();
          v11 = __error();
          v12 = (const char *)xpc_strerror(*v11);
          sub_100040F68(65539, "Could not make system logger socket world-writable: error = %d: %s", v10, v12);
          if (unlink(v14.sa_data) == -1)
            sub_10004D83C();
        }
        else
        {
          _os_log_simple_reinit_4launchd();
          dword_100071A30 = (int)v3;
        }
        goto LABEL_4;
      }
      __error();
      v13 = __error();
      xpc_strerror(*v13);
      sub_100040F68(65539, "Could not bind to system logger socket: error = %d: %s");
    }
    sub_10003BAF4(v3);
  }
LABEL_4:
  dispatch_activate((dispatch_object_t)qword_100072628);
  byte_100072630 = 1;
  v0 = off_100071A88;
  v1 = getpid();
  sub_100040F68(65541, "launchd logging initialized. name: %s pid: %d", v0, v1);
}

void sub_100040EF8()
{
  NSObject *v0;

  v0 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_UTILITY, 0);
  qword_100072638 = (uint64_t)dispatch_queue_create("com.apple.xpc.launchd.logq", v0);
  qword_100072628 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_or, 0, 0, (dispatch_queue_t)qword_100072638);
  dispatch_source_set_event_handler((dispatch_source_t)qword_100072628, &stru_10006D440);
  qword_1000729E0 = 0;
  qword_1000729E8 = (uint64_t)&qword_1000729E0;
}

void sub_100040F68(int a1, char *a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  sub_1000412EC(0, a1, a2, va, v2);
}

void sub_100040FA0()
{
  sub_100040FC8(5, "bye");
  dispatch_suspend((dispatch_object_t)qword_100072638);
}

void sub_100040FC8(int a1, char *a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  sub_1000412EC(0, a1, a2, va, v2);
  dispatch_sync((dispatch_queue_t)qword_100072638, &stru_10006D400);
}

void sub_100041014()
{
  dispatch_sync((dispatch_queue_t)qword_100072638, &stru_10006D3C0);
}

void sub_100041028(id a1)
{
  int v1;

  sub_100041058();
  if (qword_100072640)
  {
    v1 = fileno((FILE *)qword_100072640);
    fcntl(v1, 51);
  }
}

uint64_t sub_100041058()
{
  unint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  char *v7;
  timeval *v8;
  char *v9;
  int v10;
  timeval *v11;
  timeval *v12;
  uint64_t result;
  int v14;
  uint64_t v15;
  uint64_t *v16;

  v15 = 0;
  v16 = &v15;
  os_unfair_lock_lock((os_unfair_lock_t)&unk_100072648);
  if (qword_1000729E0)
  {
    *v16 = qword_1000729E0;
    v16 = (uint64_t *)qword_1000729E8;
    qword_1000729E0 = 0;
    qword_1000729E8 = (uint64_t)&qword_1000729E0;
  }
  v0 = qword_100072650;
  qword_100072650 = 0;
  v1 = qword_100072658;
  qword_100072658 = 0;
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_100072648);
  v2 = v15;
  if (v15)
  {
    v3 = 0;
    v4 = 0;
    while (1)
    {
      v5 = qword_100072660;
      if (!qword_100072660)
        goto LABEL_14;
      if (*(_DWORD *)(qword_100072660 + 16) != *(_DWORD *)(v2 + 16)
        || !sub_1000157A8(*(char **)(qword_100072660 + 24), *(const char **)(v2 + 24))
        || !sub_1000157A8(*(char **)(v5 + 48), *(const char **)(v2 + 48)))
      {
        break;
      }
      ++qword_100072668;
LABEL_16:
      v15 = *(_QWORD *)(v15 + 80);
      if (!v15)
        v16 = &v15;
      sub_10001962C((void *)v2);
      ++v3;
      v2 = v15;
      if (!v15)
        goto LABEL_21;
    }
    v6 = (void *)qword_100072660;
    if (qword_100072660)
    {
      if (qword_100072668)
      {
        v7 = sub_100015630("Last log repeated %llu times", qword_100072668);
        v8 = sub_100041498(5, 0, (__darwin_time_t)v7, 0);
        sub_10004158C((uint64_t)v8, 0);
        sub_10001962C(v8);
        v6 = (void *)qword_100072660;
      }
      sub_10001962C(v6);
      qword_100072660 = 0;
    }
LABEL_14:
    qword_100072660 = (uint64_t)sub_100019580((void *)v2);
    qword_100072668 = 0;
    v14 = 0;
    sub_10004158C(v2, &v14);
    if (v14)
      ++v4;
    goto LABEL_16;
  }
  v4 = 0;
  v3 = 0;
LABEL_21:
  if (v3 == v0)
  {
    if (v1)
    {
LABEL_23:
      v9 = sub_100015630("%lld file logs dropped [in-flight %lld]: %lld os_log_simple logs dropped", v1, v0, v4);
      v10 = 4;
      goto LABEL_27;
    }
  }
  else
  {
    _os_assumes_log(0);
    if (v1)
      goto LABEL_23;
  }
  if (v0 < dword_100071AC0)
    goto LABEL_29;
  v9 = sub_100015630("Flushed %lld logs [limit: %d]", v0, dword_100071AC0);
  v10 = 5;
LABEL_27:
  v11 = sub_100041498(v10, 0, (__darwin_time_t)v9, 0);
  v12 = v11;
  if (v11)
  {
    sub_10004158C((uint64_t)v11, 0);
    sub_10001962C(v12);
  }
LABEL_29:
  result = qword_100072640;
  if (qword_100072640)
    return fflush((FILE *)qword_100072640);
  return result;
}

void sub_1000412EC(const char *a1, int a2, char *a3, va_list a4, uint64_t a5)
{
  char *v5;
  char *v6;
  timeval *v10;
  timeval *v11;
  char *v12;
  char *v13[7];

  if ((a2 & 0xFFFEu) <= 5)
  {
    v13[5] = v5;
    v13[6] = v6;
    v13[0] = 0;
    if (vasprintf(v13, a3, a4) != -1)
    {
      v10 = sub_100041498(a2, a1, (__darwin_time_t)v13[0], a5);
      v11 = v10;
      if (!byte_100072630 && BYTE4(v10[1].tv_sec))
      {
        v12 = sub_10004197C((uint64_t)v10);
        sub_10000FD8C("%s|%s", off_100071A88, v12);
        BYTE4(v11[1].tv_sec) = 0;
        free(v12);
      }
      if (qword_100072620 != -1)
        dispatch_once_f(&qword_100072620, 0, (dispatch_function_t)sub_100040EF8);
      os_unfair_lock_lock((os_unfair_lock_t)&unk_100072648);
      if ((unint64_t)qword_100072650 >> 4 > 0x270)
      {
        ++qword_100072658;
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_100072648);
        sub_10001962C(v11);
      }
      else
      {
        v11[5].tv_sec = 0;
        *(_QWORD *)qword_1000729E8 = v11;
        qword_1000729E8 = (uint64_t)&v11[5];
        ++qword_100072650;
        os_unfair_lock_unlock((os_unfair_lock_t)&unk_100072648);
        dispatch_source_merge_data((dispatch_source_t)qword_100072628, 1uLL);
      }
    }
  }
}

void sub_100041468(const char *a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;

  sub_1000412EC(a1, a2, a3, &a9, v9);
}

timeval *sub_100041498(int a1, const char *a2, __darwin_time_t a3, uint64_t a4)
{
  uint64_t v4;
  char *v9;
  timeval *v10;
  BOOL v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  __uint64_t v16;

  v9 = (char *)sub_100019C9C(0);
  v10 = (timeval *)v9;
  if ((a1 & 0x10000) != 0 || (!byte_100072ABA ? (v11 = dword_100071A30 == -1) : (v11 = 1), v11))
    v9[20] = 1;
  if ((a1 & 0x20000) != 0)
    v9[23] = 1;
  *(_WORD *)(v9 + 21) = 257;
  *((_DWORD *)v9 + 4) = (unsigned __int16)a1;
  if (a2)
    v12 = sub_10001544C(a2);
  else
    v12 = 0;
  *(_QWORD *)&v10[1].tv_usec = v12;
  v10[3].tv_sec = a3;
  v13 = gettimeofday(v10 + 2, 0);
  if (a4)
    v14 = a4;
  else
    v14 = v4;
  *(_QWORD *)&v10[3].tv_usec = v14;
  v10[4].tv_sec = os_log_simple_now(v13);
  v16 = 0;
  pthread_threadid_np(0, &v16);
  *(_QWORD *)&v10[4].tv_usec = v16;
  return v10;
}

void sub_10004158C(uint64_t a1, _DWORD *a2)
{
  int v5;
  pid_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  const char *v13;
  FILE *v14;
  std::error_code *v15;
  std::error_code *v16;
  FILE *v17;
  int *v18;
  size_t v19;
  std::__fs::filesystem::path __to;
  std::__fs::filesystem::path __str[42];
  __int128 buffer;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  if (*(_BYTE *)(a1 + 21))
  {
    if (dword_100071A30 == -1 || byte_100072A63 != 0)
    {
      v5 = 0;
      if (!a2)
        goto LABEL_12;
LABEL_11:
      *a2 = v5;
      goto LABEL_12;
    }
    if (!(_QWORD)xmmword_100072690)
    {
      *(_QWORD *)&xmmword_100072690 = getpid();
      *(_QWORD *)&v25 = 0;
      v24 = 0u;
      v23 = 0u;
      buffer = 0u;
      v6 = getpid();
      proc_pidinfo(v6, 17, 0, &buffer, 56);
      *((_QWORD *)&xmmword_100072690 + 1) = v23;
      *(_QWORD *)&xmmword_1000726A0 = (int)v24;
      uuid_copy((unsigned __int8 *)&xmmword_1000726B0 + 8, (const unsigned __int8 *)&buffer);
      uuid_copy(byte_1000726C8, (const unsigned __int8 *)&buffer);
      uuid_clear((unsigned __int8 *)&xmmword_1000726D0 + 8);
      _dyld_get_shared_cache_uuid((char *)&xmmword_1000726D0 + 8);
      qword_1000726E8 = (uint64_t)_NSGetMachExecuteHeader();
    }
    v26 = xmmword_1000726B0;
    v27 = unk_1000726C0;
    v28 = xmmword_1000726D0;
    v29 = qword_1000726E0;
    buffer = xmmword_100072670;
    v23 = unk_100072680;
    v24 = xmmword_100072690;
    v25 = xmmword_1000726A0;
    LOBYTE(buffer) = os_log_simple_type_from_asl(*(unsigned int *)(a1 + 16));
    v7 = *(_QWORD *)(a1 + 48);
    v8 = *(_QWORD *)(a1 + 56);
    *((_QWORD *)&buffer + 1) = *(_QWORD *)(a1 + 24);
    *(_QWORD *)&v23 = v7;
    v9 = *(_QWORD *)(a1 + 72);
    *((_QWORD *)&v23 + 1) = *(_QWORD *)(a1 + 64);
    *((_QWORD *)&v25 + 1) = v9;
    *(_QWORD *)&v26 = v8 - qword_1000726E8;
    v5 = _os_log_simple_send(&buffer);
    if (a2)
      goto LABEL_11;
  }
LABEL_12:
  v10 = sub_10004197C(a1);
  if (v10)
  {
    v11 = v10;
    if (*(_BYTE *)(a1 + 20))
      sub_10000FE04("%s|%s", off_100071A88, v10);
    if (*(_BYTE *)(a1 + 23))
    {
      v12 = *(unsigned int *)(a1 + 16);
      if (v12 < 8)
      {
        if (*(_QWORD *)(a1 + 24))
          v13 = *(const char **)(a1 + 24);
        else
          v13 = "launchd";
        if (record_system_event_as_kernel(byte_10004FECA[v12], 1, v13, *(_QWORD *)(a1 + 48)))
        {
          __error();
          sub_100040F68(3, "Unable to record system event. Result: %d errno: %d Message: %s");
        }
      }
      else
      {
        sub_100040F68(3, "Log level out of bounds for system state conversion: %d");
      }
    }
    if (*(_BYTE *)(a1 + 22))
    {
      v14 = (FILE *)qword_100072640;
      if (!qword_100072640 && !byte_100072A63)
      {
        bzero(&buffer, 0x400uLL);
        snprintf((char *)&buffer, 0x400uLL, "%s/launchd.log", off_100071A70[0]);
        if (!access((const char *)&buffer, 0))
        {
          bzero(__str, 0x400uLL);
          snprintf((char *)__str, 0x400uLL, "%s/launchd.log.1", off_100071A70[0]);
          if (!access((const char *)__str, 0))
          {
            bzero(&__to, 0x400uLL);
            snprintf((char *)&__to, 0x400uLL, "%s/launchd.log.2", off_100071A70[0]);
            rename(__str, &__to, v16);
          }
          rename((const std::__fs::filesystem::path *)&buffer, __str, v15);
        }
        v17 = fopen((const char *)&buffer, "w");
        qword_100072640 = (uint64_t)v17;
        if (v17)
        {
          setvbuf(v17, 0, 0, 0x4000uLL);
        }
        else
        {
          v18 = __error();
          sub_10000FE04("launchd.log: fopen(%s): %d\n", (const char *)&buffer, *v18);
        }
        v14 = (FILE *)qword_100072640;
      }
      if (v14)
      {
        v19 = strlen(v11);
        fwrite(v11, 1uLL, v19, v14);
        if (qword_100071AB8 >= 1)
        {
          qword_1000726F0 += v19;
          if (qword_1000726F0 >= qword_100071AB8)
          {
            sub_10003BC70((FILE *)qword_100072640);
            qword_100072640 = 0;
            qword_1000726F0 = 0;
          }
        }
      }
    }
    free(v11);
  }
  else
  {
    sub_10000FC98("_launch_log_format failed");
  }
}

char *sub_10004197C(uint64_t a1)
{
  tm v3;
  char __str[8];
  uint64_t v5;
  _BYTE v6[11];

  *(_QWORD *)__str = 0;
  v5 = 0;
  memset(v6, 0, sizeof(v6));
  memset(&v3, 0, sizeof(v3));
  localtime_r((const time_t *)(a1 + 32), &v3);
  snprintf(__str, 0x1BuLL, "%04d-%02d-%02d %02d:%02d:%02d.%06d", v3.tm_year + 1900, v3.tm_mon + 1, v3.tm_mday, v3.tm_hour, v3.tm_min, v3.tm_sec, *(_DWORD *)(a1 + 40));
  if (*(_QWORD *)(a1 + 24))
    return sub_100015630("%s (%s) <%s>: %s\n");
  else
    return sub_100015630("%s <%s>: %s\n");
}

void *sub_100041A78()
{
  return sub_10003F744(0);
}

void sub_100041A80(char *key, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  xpc_object_t value;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (!qword_100072AC0)
    sub_10003E208("boot task dictionary is not populated");
  value = xpc_dictionary_get_value((xpc_object_t)qword_100072AC0, key);
  if (!value)
    sub_10003E208("undefined boot task %s", key);
  v12 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    sub_10003E208("boot task %s is not a dictionary", key);
  if (sub_100041B54(key, v12))
    sub_100041C58(key, v12, a2, v13, v14, v15, v16, v17);
  else
    sub_100041468(key, 196613, "Skipping boot-task", v13, v14, v15, v16, v17, a9);
}

uint64_t sub_100041B54(const char *a1, xpc_object_t xdict)
{
  uint64_t result;
  _BOOL4 v5;
  BOOL v6;
  BOOL v7;

  if (xpc_dictionary_get_BOOL(xdict, "PerformAlways"))
    return 1;
  if (!byte_100072A80 || (result = xpc_dictionary_get_BOOL(xdict, "PerformAfterUserspaceReboot"), (_DWORD)result))
  {
    v5 = xpc_dictionary_get_BOOL(xdict, "PerformInRestore");
    if (byte_100072A64)
      v6 = !v5;
    else
      v6 = 0;
    if (v6)
      return 0;
    v7 = xpc_dictionary_get_BOOL(xdict, "PerformInLeanTestEnvironment");
    if (byte_100072A61 && !v7)
    {
      sub_100040F68(65543, "%s not set, Skipping boot-task: %s", "PerformInLeanTestEnvironment", a1);
      return 0;
    }
    LODWORD(result) = xpc_dictionary_get_BOOL(xdict, "PerformInBaseSystem");
    if (byte_100072A65)
      return result;
    else
      return 1;
  }
  return result;
}

uint64_t sub_100041C58(const char *a1, void *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *string;
  void (**v12)(void);
  xpc_object_t value;
  void *v15;
  int v16;
  char *v17;
  char *v18;
  const char *v19;
  xpc_object_t v20;
  void *v21;
  xpc_object_t v22;
  void *v23;
  const char *v24;
  size_t count;
  size_t v26;
  uint64_t v27;
  size_t v28;
  char **v29;
  size_t i;
  const char *v31;
  int v32;
  int v33;
  uint64_t v34;
  xpc_object_t v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  task_t v41;
  mach_port_t v42;
  task_t v43;
  int v44;
  task_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _BOOL4 v51;
  uint64_t v52;
  const char *v53;
  char *v54;
  char *v55;
  const char *v56;
  char *v57;
  int v58;
  const char *v59;
  const char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  char *v66;
  char *v67;
  const char *v68;
  char *v69;
  int v70;
  int64_t v71;
  xpc_object_t empty;
  char *v73;
  int *v74;
  char *v75;
  char v76;
  pid_t v77;
  posix_spawn_file_actions_t v78;
  sigset_t v79;
  sigset_t v80;
  posix_spawnattr_t v81;
  stat v82;
  int mach_port;
  uint64_t v84;

  sub_100041468(a1, 196613, "Doing boot task", a4, a5, a6, a7, a8, v76);
  sub_10001143C(570425413, a1);
  if (xpc_dictionary_get_string(a2, "Block"))
  {
    if (xpc_dictionary_get_string(a2, "Program"))
      sub_10004D738();
    if (xpc_dictionary_get_value(a2, "ProgramArguments"))
      sub_10004D738();
    string = (char *)xpc_dictionary_get_string(a2, "Block");
    if (!string)
      sub_10003E208("Malformed boot-task (missing block key): %s", a1);
    v12 = (void (**)(void))sub_100027DC4(string);
    v12[2]();
    _Block_release(v12);
    return sub_10001143C(570425414, a1);
  }
  value = xpc_dictionary_get_value(a2, "RebootOnExitCode");
  if (value)
  {
    v15 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
    {
      v16 = xpc_int64_get_value(v15);
      sub_100040F68(65543, "%s: will reboot if exits with code: %d", a1, v16);
    }
  }
  if (xpc_dictionary_get_BOOL(a2, "RemoveOnSuccess"))
  {
    v17 = sub_100042C00(a2);
    memset(&v82, 0, sizeof(v82));
    if (stat(v17, &v82))
      return sub_10001143C(570425414, a1);
  }
  *(_OWORD *)&v82.st_dev = *(_OWORD *)off_10006D4A0;
  *(_OWORD *)&v82.st_uid = *(_OWORD *)&off_10006D4B0;
  v18 = sub_100042C00(a2);
  if (!v18)
    sub_10003E208("boot task has no program");
  v19 = v18;
  v20 = xpc_dictionary_get_value(a2, "ProgramArguments");
  if (v20)
  {
    v21 = v20;
    if (xpc_get_type(v20) != (xpc_type_t)&_xpc_type_array)
      goto LABEL_107;
    v22 = xpc_retain(v21);
  }
  else
  {
    v22 = xpc_array_create(0, 0);
  }
  v23 = v22;
  if (!xpc_array_get_count(v22))
    xpc_array_set_string(v23, 0xFFFFFFFFFFFFFFFFLL, v19);
  if (xpc_dictionary_get_BOOL(a2, "PassLaunchBootModeAsArgument"))
  {
    v24 = (const char *)sub_1000047E4();
    if (v24)
      xpc_array_set_string(v23, 0xFFFFFFFFFFFFFFFFLL, v24);
  }
  count = xpc_array_get_count(v23);
  v26 = count + 1;
  v27 = count == -1;
  if (v27 << 63 >> 63 != v27 || v27 | (v26 >> 61))
  {
    __break(1u);
LABEL_107:
    sub_10003E208("boot task argument vector is not an array");
  }
  v28 = count;
  v29 = (char **)sub_10001389C(8 * v26);
  if (v28)
  {
    for (i = 0; i != v28; ++i)
    {
      v31 = xpc_array_get_string(v23, i);
      if (v31)
        v29[i] = (char *)v31;
    }
  }
  v81 = 0;
  v32 = posix_spawnattr_init(&v81);
  if (v32)
    sub_10004D764(v32);
  v33 = posix_spawnattr_setflags(&v81, 16524);
  if (v33)
    sub_10004D764(v33);
  if ((a3 & 1) == 0)
  {
    v34 = !xpc_dictionary_get_BOOL(a2, "AllowCrash");
    v35 = xpc_dictionary_get_value(a2, "RebootOnExitCode");
    if (!v35 || xpc_get_type(v35) != (xpc_type_t)&_xpc_type_int64)
    {
      if (xpc_dictionary_get_BOOL(a2, "RequireSuccess"))
        v34 = 3;
      else
        v34 = v34;
    }
    v36 = posix_spawnattr_set_crash_behavior_np(&v81, v34);
    if (v36)
      sub_10004D764(v36);
  }
  v37 = posix_spawnattr_setprocesstype_np(&v81, 1024);
  if (v37)
    sub_10004D764(v37);
  v38 = posix_spawnattr_set_launch_type_np(&v81, 1);
  if (v38)
    sub_10004D764(v38);
  v80 = 0;
  v39 = posix_spawnattr_setsigmask(&v81, &v80);
  if (v39)
    sub_10004D764(v39);
  v79 = -1;
  v40 = posix_spawnattr_setsigdefault(&v81, &v79);
  if (v40)
    sub_10004D764(v40);
  v78 = 0;
  if (posix_spawn_file_actions_init(&v78) == -1)
    sub_10004D914();
  if (posix_spawn_file_actions_addopen(&v78, 0, "/dev/console", 0x20000, 0) == -1)
    sub_10004D914();
  if (posix_spawn_file_actions_addopen(&v78, 1, "/dev/console", 131073, 0) == -1)
    sub_10004D914();
  if (posix_spawn_file_actions_addopen(&v78, 2, "/dev/console", 131074, 0) == -1)
    sub_10004D914();
  v41 = mach_host_self();
  v42 = sub_10000DBB8(v41);
  v43 = mach_host_self();
  sub_100042AAC(v43, 0);
  if ((a3 & 4) != 0)
  {
    if (qword_100072700)
    {
      v84 = 0;
      mach_port = _xpc_shmem_get_mach_port(qword_100072700);
      if (posix_spawnattr_set_registered_ports_np(&v81, &mach_port, 1) == -1)
        sub_10004D914();
    }
    else
    {
      sub_100040F68(65539, "Skipping setting up shared memory with cache loader");
    }
  }
  v77 = 0;
  v44 = posix_spawnp(&v77, v19, &v78, &v81, v29, (char *const *)&v82);
  if (posix_spawn_file_actions_destroy(&v78) == -1)
    sub_10004D914();
  if (posix_spawnattr_destroy(&v81) == -1)
    sub_10004D914();
  free(v29);
  xpc_release(v23);
  v45 = mach_host_self();
  sub_100042AAC(v45, v42);
  if (v44)
  {
    v51 = (a3 & 1) == 0 && xpc_dictionary_get_BOOL(a2, "RequireRun");
    if (v44 != 2)
    {
      strerror(v44);
      sub_100041468(a1, 196611, "posix_spawn(): %d: %s", v61, v62, v63, v64, v65, v44);
      if (!v51)
        return sub_10001143C(570425414, a1);
      memset(&v82, 0, 64);
      v66 = strerror(v44);
      snprintf((char *)&v82, 0x40uLL, "posix_spawn: %d: %s", v44, v66);
      v60 = (const char *)&v82;
LABEL_72:
      sub_100042B38(a1, v60);
    }
    if (v51)
      v58 = 196611;
    else
      v58 = 196613;
    v59 = "optional";
    if (v51)
      v59 = "required";
    sub_100041468(a1, v58, "%s boot task not present", v46, v47, v48, v49, v50, (char)v59);
    if (v51)
    {
      v60 = "required boot task executable not found";
      goto LABEL_72;
    }
  }
  else
  {
    v52 = v77;
    v53 = xpc_dictionary_get_string(a2, "CSIdentityOverride");
    mach_port = 0;
    if (csops(v52, 0, &mach_port, 4) || (mach_port & 0x4000000) == 0)
    {
      v73 = sub_100042C00(a2);
      sub_10003E264("boot task is not a platform binary (%s, %s)", a1, v73);
    }
    *__error() = 0;
    v54 = sub_10003F7E8(v52, 0);
    v55 = sub_100042C00(a2);
    v56 = v55;
    if (!v54)
    {
      v74 = __error();
      sub_10003E208("failed to get the code signing identity for a boot-task (%s, %s) errno: %d", a1, v56, *v74);
    }
    if (v53)
    {
      v57 = sub_10001544C(v53);
    }
    else
    {
      v67 = strrchr(v55, 47);
      if (v67)
        v68 = v67 + 1;
      else
        v68 = v56;
      v57 = sub_100015630("com.apple.%s", v68);
    }
    v69 = v57;
    if (!v57)
      sub_10004D738();
    if (strcmp(v57, v54))
    {
      v75 = sub_100042C00(a2);
      sub_10003E264("code signing identity mismatch for a boot-task (%s, %s) observed=%s expected=%s", a1, v75, v54, v69);
    }
    free(v54);
    free(v69);
    if (kill(v77, 19) == -1)
    {
      v70 = *__error();
      if (v70)
        sub_10004D764(v70);
    }
    v71 = v77;
    if (xpc_dictionary_get_BOOL(a2, "Async"))
    {
      if (a3)
        sub_10003E208("Async boot task %s must not have flags", a1);
      empty = (xpc_object_t)qword_1000729F8;
      if (!qword_1000729F8)
      {
        empty = xpc_dictionary_create_empty();
        qword_1000729F8 = (uint64_t)empty;
      }
      xpc_dictionary_set_int64(empty, a1, v71);
    }
    else
    {
      sub_100042C80(a1, a2, a3, v71);
    }
  }
  return sub_10001143C(570425414, a1);
}

void sub_10004240C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  int v120;
  char *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  int *v152;
  std::error_code *v153;
  xpc_object_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  void *v161;
  void *bytes_ptr;
  size_t length;
  xpc_object_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  int *v184;
  char v185;
  char v186;
  char v187;
  char v188;
  char v189;
  char v190;
  char v191;
  char v192;
  char v193;
  char v194;
  char v195;
  char v196;
  char v197;
  char v198;
  char v199;
  char v200;
  char v201;
  char v202;
  char v203;
  char v204;
  char v205;
  char v206;
  char v207;
  char v208;
  char v209;
  char v210;
  char v211;
  char v212;
  statfs v213;

  sub_100041A80("exclaves-boot", 0, a3, a4, a5, a6, a7, a8, v185);
  bzero(&v213, 0x878uLL);
  if (statfs("/", &v213) == -1)
  {
    v184 = __error();
    _os_assumes_log(*v184);
  }
  else if ((v213.f_flags & 1) != 0)
  {
    sub_100041A80("fsck", 0, v8, v9, v10, v11, v12, v13, v186);
  }
  sub_100041A80("mount-phase-1", 0, v8, v9, v10, v11, v12, v13, v186);
  sub_100041A80("data-protection", 0, v14, v15, v16, v17, v18, v19, v187);
  sub_100041A80("finish-obliteration", 0, v20, v21, v22, v23, v24, v25, v188);
  sub_100041A80("detect-installed-roots", 0, v26, v27, v28, v29, v30, v31, v189);
  sub_100041A80("select-boot-mode", 0, v32, v33, v34, v35, v36, v37, v190);
  sub_100041A80("commit-boot-mode", 0, v38, v39, v40, v41, v42, v43, v191);
  if (sub_10002EB18())
    sub_100041A80("rem-enable-fuse", 0, v44, v45, v46, v47, v48, v49, v192);
  sub_100041A80("restore-datapartition", 0, v44, v45, v46, v47, v48, v49, v192);
  sub_100041A80("mount-phase-2", 0, v50, v51, v52, v53, v54, v55, v193);
  sub_100041A80("init-with-data-volume", 0, v56, v57, v58, v59, v60, v61, v194);
  sub_100041A80("fixup-mobile-tmp", 0, v62, v63, v64, v65, v66, v67, v195);
  sub_100041A80("MSUEarlyBootTask", 0, v68, v69, v70, v71, v72, v73, v196);
  sub_100041A80("fips", 0, v74, v75, v76, v77, v78, v79, v197);
  if (os_variant_is_darwinos("com.apple.xpc.launchd"))
    sub_100041A80("darwinos-boot-task", 0, v80, v81, v82, v83, v84, v85, v198);
  sub_100041A80("keybag", 0, v80, v81, v82, v83, v84, v85, v198);
  sub_100041A80("usermanagerd", 0, v86, v87, v88, v89, v90, v91, v199);
  sub_100041A80("dirs_cleaner", 0, v92, v93, v94, v95, v96, v97, v200);
  sub_100040C1C();
  if (!(byte_100072A64 | byte_100072A65))
    nullsub_23(v98, v99);
  sub_100041A80("xpcroleaccountd", 0, v100, v101, v102, v103, v104, v105, v201);
  sub_100041A80("init_featureflags", 0, v106, v107, v108, v109, v110, v111, v202);
  v112 = j__libSystem_init_after_boot_tasks_4launchd();
  if (!byte_100072A64 && !byte_100072A65 && !byte_100072A80)
  {
    v119 = ne_session_initialize_necp_drop_all(v112);
    if (v119)
    {
      v120 = v119;
      v121 = strerror(v119);
      sub_100040F68(65539, "Could not opt into Always-On VPN: %d: %s", v120, v121);
    }
  }
  sub_100041A80("auearlyboot", 0, v113, v114, v115, v116, v117, v118, v203);
  sub_100041A80("tzinit", 0, v122, v123, v124, v125, v126, v127, v204);
  sub_100041A80("finish-restore", 0, v128, v129, v130, v131, v132, v133, v205);
  sub_100041A80("finish-demo-restore", 0, v134, v135, v136, v137, v138, v139, v206);
  sub_1000479D0();
  sub_100041A80("sysstatuscheck", 0, v140, v141, v142, v143, v144, v145, v207);
  sub_100041A80("prng_seedctl", 0, v146, v147, v148, v149, v150, v151, v208);
  if (!byte_100072A64)
  {
    v209 = -74;
    v152 = (int *)open("/var/run/utmpx", 512);
    if ((_DWORD)v152 != -1)
      sub_10003BAF4(v152);
    remove((const std::__fs::filesystem::path *)"/etc/nologin", v153);
  }
  v154 = sub_100018BF8();
  v161 = v154;
  if (v154)
  {
    bytes_ptr = (void *)xpc_data_get_bytes_ptr(v154);
    length = xpc_data_get_length(v161);
    v164 = xpc_shmem_create(bytes_ptr, (length + vm_page_size - 1) & -(uint64_t)vm_page_size);
    if (!v164)
      sub_10004D738();
    qword_100072700 = (uint64_t)v164;
  }
  sub_100041A80("launchd_cache_loader", 4, v155, v156, v157, v158, v159, v160, v209);
  v166 = qword_100072700;
  if (qword_100072700)
  {
    xpc_release((xpc_object_t)qword_100072700);
    qword_100072700 = 0;
  }
  nullsub_23(v166, v165);
  sub_100041A80("workload-properties-init", 0, v167, v168, v169, v170, v171, v172, v210);
  sub_100041A80("init-exclavekit", 0, v173, v174, v175, v176, v177, v178, v211);
  if (qword_1000729F8)
  {
    xpc_dictionary_apply((xpc_object_t)qword_1000729F8, &stru_10006D520);
    xpc_release((xpc_object_t)qword_1000729F8);
    qword_1000729F8 = 0;
  }
  sub_100018D2C(v161);
  if (v161)
    xpc_release(v161);
  sub_100041468("boot", 196613, "Early boot complete. Continuing system boot.", v179, v180, v181, v182, v183, v212);
  sub_10002DE88();
  sub_10003F19C();
}

void sub_100042808()
{
  int *v0;
  int *v1;
  int *v2;
  int *v3;
  NSObject *v4;
  __int128 v5;
  __int128 v6;
  _OWORD v7[4];
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;

  if (!byte_100072A80 && sysctlbyname("kern.hostname", 0, 0, "localhost", 0xAuLL) == -1)
    sub_10004D914();
  sub_100010F04();
  if (!byte_100072A80)
  {
    v5 = 0u;
    v6 = 0u;
    LODWORD(v5) = 3174252;
    v0 = (int *)socket(2, 2, 0);
    if ((_DWORD)v0 == -1)
    {
      sub_10004DE84();
    }
    else
    {
      v1 = v0;
      if (ioctl((int)v0, 0xC0206911uLL, &v5) == -1)
        goto LABEL_17;
      LOWORD(v6) = v6 | 1;
      if (ioctl((int)v1, 0x80206910uLL, &v5) == -1)
        goto LABEL_17;
      memset((char *)&v7[1] + 4, 0, 32);
      *(_OWORD *)((char *)v7 + 4) = 0u;
      *((_QWORD *)&v7[3] + 1) = 0;
      strcpy((char *)v7, "lo0");
      DWORD1(v7[1]) = 16777343;
      LOWORD(v7[1]) = 528;
      DWORD1(v7[3]) = 255;
      LOWORD(v7[3]) = 528;
      if (ioctl((int)v1, 0x8040691AuLL, v7) == -1)
LABEL_17:
        sub_10004E1B8();
      else
        sub_10003BAF4(v1);
    }
    if (!byte_100072A80)
    {
      v2 = (int *)socket(30, 2, 0);
      if ((_DWORD)v2 == -1)
      {
        sub_10004DE84();
      }
      else
      {
        v3 = v2;
        v5 = 0u;
        v6 = 0u;
        LODWORD(v5) = 3174252;
        if (ioctl((int)v2, 0xC0206911uLL, &v5) == -1)
          goto LABEL_19;
        memset(v7, 0, sizeof(v7));
        v8 = 0u;
        v9 = 0u;
        v11 = 0;
        v10 = 0u;
        strcpy((char *)v7, "lo0");
        *(in6_addr *)((char *)&v7[1] + 8) = in6addr_loopback;
        LOWORD(v7[1]) = 7708;
        *(_QWORD *)&v9 = -1;
        *((_QWORD *)&v9 + 1) = -1;
        WORD4(v8) = 7708;
        v12 = -1;
        if (ioctl((int)v3, 0x8080691AuLL, v7) != -1)
          goto LABEL_14;
        if (*__error() != 17)
LABEL_19:
          sub_10004E1B8();
        else
LABEL_14:
          sub_10003BAF4(v3);
      }
    }
  }
  v4 = sub_1000146E4();
  dispatch_async(v4, &stru_10006D4E0);
}

uint64_t sub_100042AAC(task_t a1, mach_port_t new_port)
{
  exception_mask_t v3;
  mach_port_t v5;

  if (byte_100072AB8)
    v3 = 7168;
  else
    v3 = 10240;
  if (mach_task_self_ == a1)
    return task_set_exception_ports(a1, v3, new_port, -1610612732, 1);
  v5 = mach_host_self();
  return host_set_exception_ports(v5, v3, new_port, -1610612732, 1);
}

void sub_100042B30(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_100041A80(a1, 0, a3, a4, a5, a6, a7, a8, a9);
}

void sub_100042B38(const char *a1, const char *a2)
{
  char *v2;
  const char *v3;
  char __str[16];
  __int128 v5;
  __int128 v6;
  __int128 v7;

  if (a2)
    v2 = sub_100015630("%s - %s", a1, a2);
  else
    v2 = sub_10001544C(a1);
  v3 = v2;
  v6 = 0u;
  v7 = 0u;
  *(_OWORD *)__str = 0u;
  v5 = 0u;
  snprintf(__str, 0x40uLL, "boot task failure: %s", v2);
  pthread_setname_np(__str);
  sub_100040F68(196608, "Boot task failed: %s", v3);
  sub_100040F68(196608, "Panicking in 3 seconds.");
  sleep(3u);
  sub_10003E264("boot task failure: %s", v3);
}

uint64_t sub_100042BD0(uint64_t result)
{
  dword_1000726F8 = result;
  return result;
}

uint64_t sub_100042BDC()
{
  return dword_1000726F8;
}

uint64_t sub_100042BE8(uint64_t result)
{
  byte_1000726FC = result;
  return result;
}

uint64_t sub_100042BF4()
{
  return byte_1000726FC;
}

char *sub_100042C00(void *a1)
{
  char *result;
  char *v3;

  result = (char *)xpc_dictionary_get_string(a1, "Program");
  if (!result)
  {
    result = (char *)xpc_dictionary_get_value(a1, "ProgramArguments");
    if (result)
    {
      v3 = result;
      if (xpc_get_type(result) == (xpc_type_t)&_xpc_type_array)
      {
        result = (char *)xpc_array_get_count(v3);
        if (result)
          return (char *)xpc_array_get_string(v3, 0);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

void sub_100042C80(const char *a1, void *a2, char a3, pid_t pid)
{
  char *v7;
  char *v8;
  _BOOL4 v9;
  _BOOL4 v10;
  _BOOL4 v11;
  xpc_object_t value;
  void *v13;
  int v14;
  _BOOL4 v15;
  char *v16;
  const std::__fs::filesystem::path *v18;
  std::error_code *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  char *v33;
  char *v34;
  char v35;
  _OWORD v36[3];
  uint64_t v37;
  _OWORD v38[29];
  char __str[16];
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;

  v37 = 0;
  memset(v36, 0, sizeof(v36));
  memset(v38, 0, sizeof(v38));
  v7 = sub_1000439A4((uint64_t)v36, pid, (uint64_t)v38);
  if (LODWORD(v36[0]) != 3)
  {
    v33 = sub_100042C00(a2);
    sub_10003E208("failed to reap boot-task (%s, %s)", a1, v33);
  }
  v8 = v7;
  if ((a3 & 1) != 0)
  {
    v11 = 0;
    v10 = 0;
    v9 = 0;
  }
  else
  {
    v9 = xpc_dictionary_get_BOOL(a2, "RequireSuccess");
    v10 = xpc_dictionary_get_BOOL(a2, "RebootOnSuccess");
    v11 = xpc_dictionary_get_BOOL(a2, "AssumeSingleUserSuccess");
    value = xpc_dictionary_get_value(a2, "RebootOnExitCode");
    if (value)
    {
      v13 = value;
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_int64)
      {
        v14 = xpc_int64_get_value(v13);
        goto LABEL_8;
      }
    }
  }
  v14 = -1;
LABEL_8:
  v15 = sub_100044038((uint64_t)v36) && sub_100044064(v36) == 0;
  if (xpc_dictionary_get_BOOL(a2, "RemoveOnSuccess"))
  {
    v16 = sub_100042C00(a2);
    if (v16 && v15)
    {
      v18 = (const std::__fs::filesystem::path *)v16;
      sub_100040F68(65543, "%s: exited successfully, removing", a1);
      if (remove(v18, v19) == -1 && *__error() != 2)
      {
        v20 = *__error();
        if ((_DWORD)v20)
          _os_assumes_log(v20);
      }
    }
  }
  if (sub_100044038((uint64_t)v36) && sub_100044064(v36) == v14)
  {
    v35 = v14;
    v34 = "rebooting on exit code: %d";
LABEL_37:
    sub_100041468(a1, 196615, v34, v21, v22, v23, v24, v25, v35);
    sub_1000404A8(1, 0, 0);
  }
  if (v15)
  {
    v26 = 1;
  }
  else
  {
    if (sub_100044038((uint64_t)v36))
      v32 = 196615;
    else
      v32 = 196611;
    sub_100041468(a1, v32, "exited due to %s", v27, v28, v29, v30, v31, (char)v8);
    if (byte_100072A62)
      v26 = v11;
    else
      v26 = 0;
    if ((v26 & 1) == 0 && v9)
    {
      v45 = 0u;
      v46 = 0u;
      v43 = 0u;
      v44 = 0u;
      v41 = 0u;
      v42 = 0u;
      *(_OWORD *)__str = 0u;
      v40 = 0u;
      snprintf(__str, 0x80uLL, "exited due to %s", v8);
      sub_100042B38(a1, __str);
    }
  }
  if ((v10 & v26) == 1)
  {
    v34 = "rebooting after success";
    goto LABEL_37;
  }
  free(v8);
}

BOOL sub_100042FA8(id a1, const char *a2, void *a3)
{
  xpc_object_t value;

  value = xpc_dictionary_get_value((xpc_object_t)qword_100072AC0, a2);
  LODWORD(a3) = xpc_int64_get_value(a3);
  sub_100040F68(196615, "waiting for boot-task %s with pid %d", a2, (_DWORD)a3);
  sub_100042C80(a2, value, 0, (pid_t)a3);
  return 1;
}

int *sub_100043028()
{
  int *v0;

  return sub_10003BAF4(v0);
}

uint64_t sub_100043030(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return strcmp(*(const char **)(a2 + 24), *(const char **)(a3 + 24));
}

uint64_t sub_10004303C(int a1, uint64_t a2, char *__s2)
{
  return strcmp(*(const char **)(a2 + 24), __s2);
}

void sub_100043048(uint64_t a1, const void *a2, void *a3)
{
  void **node;
  void **v7;
  _QWORD *v8;

  if (*(_DWORD *)(a1 + 24) == 4981)
  {
    node = (void **)rb_tree_find_node(*(rb_tree_t **)(a1 + 16), a2);
    if (node)
    {
      v7 = node;
      rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), node);
      os_release(v7[4]);
      free(v7[3]);
      free(v7);
    }
    if (a3)
    {
      v8 = malloc_type_malloc(0x28uLL, 0x9004093B45C08uLL);
      v8[3] = strdup((const char *)a2);
      v8[4] = os_retain(a3);
      if (rb_tree_insert_node(*(rb_tree_t **)(a1 + 16), v8) != v8)
        sub_10004D74C();
    }
  }
  else
  {
    __break(1u);
  }
}

rb_tree_t **sub_10004310C(rb_tree_t **result, const void *a2)
{
  if (*((_DWORD *)result + 6) == 4981)
  {
    result = (rb_tree_t **)rb_tree_find_node(result[2], a2);
    if (result)
      return (rb_tree_t **)result[4];
  }
  else
  {
    __break(1u);
  }
  return result;
}

rb_tree_t **sub_100043140(rb_tree_t **result, uint64_t a2)
{
  rb_tree_t **v3;
  rb_tree_t **v4;

  if (*((_DWORD *)result + 6) == 4981)
  {
    v3 = result;
    result = (rb_tree_t **)rb_tree_iterate(result[2], 0, 1u);
    if (result)
    {
      v4 = result;
      do
      {
        (*(void (**)(uint64_t, rb_tree_t *, rb_tree_t *))(a2 + 16))(a2, v4[3], v4[4]);
        result = (rb_tree_t **)rb_tree_iterate(v3[2], v4, 1u);
        v4 = result;
      }
      while (result);
    }
  }
  else
  {
    __break(1u);
  }
  return result;
}

size_t sub_1000431BC(size_t result)
{
  if (*(_DWORD *)(result + 24) == 4981)
    return rb_tree_count(*(rb_tree_t **)(result + 16));
  __break(1u);
  return result;
}

_QWORD *sub_1000431D8()
{
  _QWORD *v0;
  rb_tree_t *v1;

  v0 = sub_100019A98(0);
  v1 = (rb_tree_t *)malloc_type_malloc(0x40uLL, 0x80040A284212CuLL);
  v0[2] = v1;
  rb_tree_init(v1, (const rb_tree_ops_t *)&off_100071A38);
  *((_DWORD *)v0 + 6) = 4981;
  return v0;
}

void sub_100043230(uint64_t a1)
{
  void **v2;
  void **v3;
  void **v4;

  if (*(_DWORD *)(a1 + 24) == 4981)
  {
    *(_DWORD *)(a1 + 24) = 0;
    v2 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), 0, 1u);
    if (v2)
    {
      v3 = v2;
      do
      {
        v4 = (void **)rb_tree_iterate(*(rb_tree_t **)(a1 + 16), v3, 1u);
        rb_tree_remove_node(*(rb_tree_t **)(a1 + 16), v3);
        os_release(v3[4]);
        free(v3[3]);
        free(v3);
        v3 = v4;
      }
      while (v4);
    }
    free(*(void **)(a1 + 16));
  }
  else
  {
    __break(1u);
  }
}

_QWORD *sub_1000432C8(uint64_t a1)
{
  uint64_t serialization;
  void *v2;
  _QWORD *v3;
  size_t v4;
  size_t __n;

  __n = 0;
  serialization = xpc_make_serialization(a1, &__n);
  if (!serialization)
    sub_10004D738();
  v2 = (void *)serialization;
  if (!__n)
    sub_10004D738();
  v3 = sub_100019E10(__n);
  v4 = __n;
  v3[2] = __n;
  memcpy(v3 + 3, v2, v4);
  free(v2);
  return v3;
}

uint64_t sub_100043334(uint64_t a1)
{
  uint64_t result;

  result = xpc_create_from_serialization(a1 + 24, *(_QWORD *)(a1 + 16));
  if (!result)
    sub_10004D738();
  return result;
}

void sub_10004335C(uint64_t a1, const void *a2, void *a3)
{
  rb_tree_t **v6;
  xpc_object_t v7;
  rb_tree_t **v8;
  const char *string;
  void *pointer;
  void *v11;
  uint64_t v12;
  _QWORD v13[6];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD v18[4];

  v6 = sub_10004310C(*(rb_tree_t ***)(a1 + 16), a2);
  v7 = v6;
  if (!v6)
  {
    if (sub_1000431BC(*(_QWORD *)(a1 + 16)) >= *(_QWORD *)(a1 + 24))
    {
      v18[0] = 0;
      v18[1] = v18;
      v18[2] = 0x2000000000;
      v18[3] = -1;
      v14 = 0;
      v15 = &v14;
      v16 = 0x2000000000;
      v17 = 0;
      v8 = *(rb_tree_t ***)(a1 + 16);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 0x40000000;
      v13[2] = sub_10004368C;
      v13[3] = &unk_10006D568;
      v13[4] = v18;
      v13[5] = &v14;
      sub_100043140(v8, (uint64_t)v13);
      string = xpc_dictionary_get_string((xpc_object_t)v15[3], "key");
      pointer = (void *)xpc_dictionary_get_pointer(v15[3], "value");
      (*(void (**)(const char *, void *))(a1 + 40))(string, pointer);
      sub_100043048(*(_QWORD *)(a1 + 16), string, 0);
      os_release(pointer);
      if (sub_1000431BC(*(_QWORD *)(a1 + 16)) >= *(_QWORD *)(a1 + 24))
        sub_10004D74C();
      _Block_object_dispose(&v14, 8);
      _Block_object_dispose(v18, 8);
    }
    v7 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v7, "key", (const char *)a2);
  }
  v11 = os_retain(a3);
  xpc_dictionary_set_pointer(v7, "value", v11);
  v12 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = v12 + 1;
  xpc_dictionary_set_uint64(v7, "timestamp", v12);
  if (!v6)
  {
    sub_100043048(*(_QWORD *)(a1 + 16), a2, v7);
    xpc_release(v7);
  }
}

rb_tree_t **sub_100043528(uint64_t a1, const void *a2)
{
  rb_tree_t **result;
  rb_tree_t **v4;
  uint64_t v5;
  void *pointer;

  result = sub_10004310C(*(rb_tree_t ***)(a1 + 16), a2);
  if (result)
  {
    v4 = result;
    v5 = *(_QWORD *)(a1 + 32);
    *(_QWORD *)(a1 + 32) = v5 + 1;
    xpc_dictionary_set_uint64(result, "timestamp", v5);
    pointer = (void *)xpc_dictionary_get_pointer(v4, "value");
    return (rb_tree_t **)os_retain(pointer);
  }
  return result;
}

_QWORD *sub_100043588(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  v4 = sub_100019D8C(0);
  v4[2] = sub_1000431D8();
  v4[3] = a1;
  v4[4] = 1;
  v4[5] = a2;
  return v4;
}

void sub_1000435D0(uint64_t a1)
{
  rb_tree_t **v2;
  _QWORD v3[5];

  v2 = *(rb_tree_t ***)(a1 + 16);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100043638;
  v3[3] = &unk_10006D540;
  v3[4] = a1;
  sub_100043140(v2, (uint64_t)v3);
  os_release(*(void **)(a1 + 16));
}

void sub_100043638(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *pointer;

  pointer = (void *)xpc_dictionary_get_pointer(a3, "value");
  (*(void (**)(uint64_t, void *))(*(_QWORD *)(a1 + 32) + 40))(a2, pointer);
  os_release(pointer);
}

uint64_t sub_10004368C(uint64_t a1, int a2, xpc_object_t object)
{
  uint64_t result;
  uint64_t v6;

  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary)
    sub_10004D74C();
  result = xpc_dictionary_get_uint64(object, "timestamp");
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (result < *(_QWORD *)(v6 + 24))
  {
    *(_QWORD *)(v6 + 24) = result;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = object;
  }
  return result;
}

uint64_t sub_1000436FC(void *a1, _QWORD *a2, uint64_t a3)
{
  xpc_object_t value;
  vm_size_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  FILE *v11;
  FILE *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  xpc_object_t reply;
  void *region;

  value = xpc_dictionary_get_value(a1, "shmem");
  if (!value)
    return 22;
  region = 0;
  v7 = xpc_shmem_map(value, &region);
  if (region)
    v8 = v7 >= vm_page_size;
  else
    v8 = 0;
  if (v8)
  {
    v11 = fmemopen(region, v7, "w");
    if (v11)
    {
      v12 = v11;
      (*(void (**)(uint64_t, FILE *))(a3 + 16))(a3, v11);
      v13 = ftello(v12);
      if (v13 <= 0x40000000)
      {
        v15 = v13;
        reply = xpc_dictionary_create_reply(a1);
        *a2 = reply;
        xpc_dictionary_set_uint64(reply, "bytes-written", v15);
        v10 = 0;
      }
      else
      {
        v10 = 153;
      }
      sub_10003BC70(v12);
    }
    else
    {
      v14 = *__error();
      if ((_DWORD)v14)
        _os_assumes_log(v14);
      v10 = 9;
    }
  }
  else
  {
    v9 = *__error();
    if ((_DWORD)v9)
      _os_assumes_log(v9);
    v10 = 22;
  }
  if (region)
  {
    if (!v7)
      sub_10004D74C();
    munmap(region, v7);
  }
  return v10;
}

uint64_t sub_100043840(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  FILE *v9;
  char v10;

  if (a2)
  {
    v8 = a2;
    v9 = (FILE *)result;
    do
    {
      result = sub_100043888(v9, "\t", a3, a4, a5, a6, a7, a8, v10);
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t sub_100043888(FILE *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return vfprintf(a1, a2, &a9);
}

uint64_t sub_1000438B0(FILE *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v10;
  char v12;
  va_list va;

  va_start(va, a8);
  if (a2)
  {
    v10 = a2;
    do
    {
      sub_100043888(a1, "\t", (uint64_t)a3, a4, a5, a6, a7, a8, v12);
      --v10;
    }
    while (v10);
  }
  return vfprintf(a1, a3, va);
}

uint64_t sub_10004391C(FILE *a1, uint64_t a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v18;
  va_list va;

  va_start(va, a8);
  if (a2)
  {
    v10 = a2;
    do
    {
      sub_100043888(a1, "\t", (uint64_t)a3, a4, a5, a6, a7, a8, v18);
      --v10;
    }
    while (v10);
  }
  vfprintf(a1, a3, va);
  return sub_100043888(a1, "\n", v11, v12, v13, v14, v15, v16, v18);
}

uint64_t sub_100043998(FILE *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  return sub_100043888(a1, "\n", a3, a4, a5, a6, a7, a8, a9);
}

char *sub_1000439A4(uint64_t a1, pid_t pid, uint64_t a3)
{
  int dirty;
  _DWORD *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  size_t v11;
  _DWORD *v12;
  uint64_t v13;
  int v14;
  int v15;
  char *v16;
  int *v17;
  uint64_t v18;
  unint64_t v19;
  _DWORD *v20;
  unint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  unint64_t v25;
  _DWORD *v26;
  _DWORD *v27;
  int v28;
  uint64_t v29;
  int *v30;
  int v31;
  unsigned int v32;
  BOOL v33;
  unsigned int v34;
  size_t v35;
  unsigned int v36;
  int v37;
  uint64_t v38;
  char *v39;
  const char *v40;
  char *v41;
  char *v42;
  const char *v43;
  int v44;
  int v45;
  unint64_t v47;
  int v48;
  unsigned int v50;
  int v51;
  char *v52;
  char *v53;
  uint32_t flags;
  char *v55[3];

  *(_QWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a3 + 432) = 0u;
  *(_OWORD *)(a3 + 448) = 0u;
  *(_OWORD *)(a3 + 400) = 0u;
  *(_OWORD *)(a3 + 416) = 0u;
  *(_OWORD *)(a3 + 368) = 0u;
  *(_OWORD *)(a3 + 384) = 0u;
  *(_OWORD *)(a3 + 336) = 0u;
  *(_OWORD *)(a3 + 352) = 0u;
  *(_OWORD *)(a3 + 304) = 0u;
  *(_OWORD *)(a3 + 320) = 0u;
  *(_OWORD *)(a3 + 272) = 0u;
  *(_OWORD *)(a3 + 288) = 0u;
  *(_OWORD *)(a3 + 240) = 0u;
  *(_OWORD *)(a3 + 256) = 0u;
  *(_OWORD *)(a3 + 208) = 0u;
  *(_OWORD *)(a3 + 224) = 0u;
  *(_OWORD *)(a3 + 176) = 0u;
  *(_OWORD *)(a3 + 192) = 0u;
  *(_OWORD *)(a3 + 144) = 0u;
  *(_OWORD *)(a3 + 160) = 0u;
  *(_OWORD *)(a3 + 112) = 0u;
  *(_OWORD *)(a3 + 128) = 0u;
  *(_OWORD *)(a3 + 80) = 0u;
  *(_OWORD *)(a3 + 96) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)(a3 + 64) = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  flags = 0;
  dirty = j__proc_get_dirty(pid, &flags);
  if (dirty)
    _os_assumes_log(dirty);
  *(_BYTE *)(a1 + 48) = *(_BYTE *)(a1 + 48) & 0xFC | flags & 2 | ((flags & 4) != 0);
  v7 = (_DWORD *)(a1 + 4);
  if (j__proc_pidinfo(pid, 25, 1uLL, (void *)(a1 + 4), 24) != 24 && *__error() != 2)
  {
    v8 = *__error();
    if ((_DWORD)v8)
      _os_assumes_log(v8);
  }
  v9 = j__proc_pid_rusage(pid, 6, (rusage_info_t *)a3);
  if (v9)
    _os_assumes_log(v9);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a3 + 80);
  if ((*(_BYTE *)(a1 + 48) & 3) == 2 && *v7 == 1)
  {
    v10 = *(_QWORD *)(a1 + 8);
    if (v10 != 2 && v10 != 7)
      *(_QWORD *)(a1 + 8) = 9;
  }
  v11 = *(unsigned int *)(a1 + 24);
  if (v11 >= 0x1401)
    sub_10003E208("retrieved exit reason with invalid reason buffer size");
  if ((_DWORD)v11)
  {
    v12 = sub_10001389C(0x20uLL);
    *((_QWORD *)v12 + 3) = sub_10001389C(v11);
    v12[5] = v11;
    if (proc_pidinfo(pid, 24, 1uLL, v12, 32) == 32)
      goto LABEL_21;
    v13 = *__error();
    if ((_DWORD)v13)
      _os_assumes_log(v13);
    free(*((void **)v12 + 3));
    free(v12);
  }
  v12 = 0;
LABEL_21:
  v14 = sub_1000409D0(pid, (int *)(a1 + 28), 0, 0);
  if (v14)
  {
    _os_assumes_log(v14);
    v15 = 2;
  }
  else
  {
    v15 = 3;
  }
  *(_DWORD *)a1 = v15;
  if (!v12)
  {
LABEL_63:
    v43 = sub_100043F58(a1);
    if (!v43)
      v43 = "(unknown reason)";
    v39 = sub_10001544C(v43);
    goto LABEL_66;
  }
  v16 = (char *)sub_100043F58(a1);
  v17 = (int *)*((_QWORD *)v12 + 3);
  if (!v17)
    goto LABEL_30;
  v18 = v12[5];
  if (!(_DWORD)v18)
    goto LABEL_30;
  v19 = (unint64_t)v17 + v18;
  v20 = v17 + 4;
  if (v17 + 4 <= (int *)((char *)v17 + v18))
  {
    v21 = *((_QWORD *)v12 + 3);
    do
    {
      v47 = (unint64_t)v20 + *(unsigned int *)(v21 + 4);
      if (v47 > v19 || *(_DWORD *)v21 == -242132755)
        break;
      if (*(_DWORD *)v21 == 4098)
        goto LABEL_28;
      v20 = (_DWORD *)(v47 + 16);
      v21 = v47;
    }
    while (v47 + 16 <= v19);
  }
  v21 = 0;
  v19 = 0;
LABEL_28:
  if (v21 + 16 > v19 || (v22 = *(unsigned int *)(v21 + 4), v21 + 16 + v22 > v19))
  {
LABEL_30:
    v23 = 0;
    goto LABEL_31;
  }
  v48 = *(_DWORD *)v21;
  if ((*(_DWORD *)v21 & 0xFFFFFFF0) == 0x20)
    v48 = 17;
  if (v48 <= 2309)
  {
    if (v48 == 17 || v48 == 19)
      goto LABEL_97;
    goto LABEL_94;
  }
  if (v48 != 2312)
  {
    if (v48 == 2310 && (_DWORD)v22 == 112 && (*(_BYTE *)(v21 + 8) & 0x8F) == 0)
    {
      LODWORD(v22) = 104;
      goto LABEL_97;
    }
LABEL_94:
    v50 = *(_DWORD *)(v21 + 8) & 0xF;
    v33 = v22 >= v50;
    v51 = v22 - v50;
    if (v33)
      LODWORD(v22) = v51;
    else
      LODWORD(v22) = 0;
    goto LABEL_97;
  }
  if ((_DWORD)v22 != 32 || (*(_BYTE *)(v21 + 8) & 0x8F) != 0)
    goto LABEL_94;
  LODWORD(v22) = 24;
LABEL_97:
  v52 = (char *)(v21 + 16);
  if (strnlen((const char *)(v21 + 16), v22) >= v22)
    v23 = 0;
  else
    v23 = v52;
LABEL_31:
  v24 = 0;
  v55[0] = 0;
  if (*v12 == 2)
  {
    v25 = (unint64_t)v17 + v12[5];
    v26 = v17 + 4;
    if ((unint64_t)(v17 + 4) > v25)
      goto LABEL_33;
    v53 = v23;
    v27 = 0;
    v28 = -1;
    do
    {
      v29 = v17[1];
      v30 = (_DWORD *)((char *)v26 + v29);
      if ((unint64_t)v26 + v29 > v25)
        break;
      v31 = *v17;
      if (*v17 == -242132755)
        break;
      if ((v31 & 0xFFFFFFF0) == 0x20)
        v31 = 17;
      if (v31 == 54)
      {
        v36 = v17[2] & 0xF;
        v33 = v29 >= v36;
        v37 = v29 - v36;
        if (!v33)
          v37 = 0;
        if (v37 != 4)
          sub_10003E208("PID size for exit reason mismatch");
        v28 = v17[4];
      }
      else if (v31 == 55)
      {
        v32 = v17[2] & 0xF;
        v33 = v29 >= v32;
        v34 = v29 - v32;
        v35 = v33 ? v34 : 0;
        v27 = v17 + 4;
        if (strnlen((const char *)v17 + 16, v35) >= v35)
          sub_10003E208("kernel returned invalid sender procname for signal");
      }
      v26 = v30 + 4;
      v17 = v30;
    }
    while ((unint64_t)(v30 + 4) <= v25);
    v23 = v53;
    if (!v27 || v28 == -1)
LABEL_33:
      asprintf(v55, "(signal info malformed)");
    else
      asprintf(v55, "sent by %s[%d]");
    v24 = v55[0];
    v7 = (_DWORD *)(a1 + 4);
  }
  v38 = 0;
  v39 = 0;
  v55[0] = v16;
  v55[1] = v23;
  v55[2] = v24;
  do
  {
    v40 = v55[v38];
    if (v40)
    {
      if (v39)
        v41 = sub_100015630("%s | %s", v39, v40);
      else
        v41 = sub_10001544C(v40);
      v42 = v41;
      free(v39);
      v39 = v42;
    }
    ++v38;
  }
  while (v38 != 3);
  free(v24);
  free(*((void **)v12 + 3));
  free(v12);
  if (!v39)
    goto LABEL_63;
LABEL_66:
  v44 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 == 3)
  {
    if (*v7 || (*(_BYTE *)(a1 + 28) & 0x7F) != 0)
      return v39;
    free(v39);
    v45 = sub_100044064((_DWORD *)a1);
    v39 = sub_100015630("exit(%d)", v45);
    v44 = *(_DWORD *)a1;
  }
  if (!v44)
    sub_10004D738();
  return v39;
}

const char *sub_100043F58(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v4;
  int v5;
  const char *result;
  void *v7;
  uint64_t v8;
  uint64_t v9;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_DWORD *)(a1 + 4);
  if (*(_DWORD *)a1 != 3 || v2 != 0)
  {
    switch(v2)
    {
      case 0:
        if (*(_DWORD *)a1 != 3)
          return (const char *)sub_100040498(v2);
        v4 = *(_DWORD *)(a1 + 28) & 0x7F;
        goto LABEL_9;
      case 1:
        goto LABEL_13;
      case 2:
        goto LABEL_11;
      case 7:
        result = (const char *)xpc_exit_reason_get_label(*(_QWORD *)(a1 + 8));
        if (!result)
          return (const char *)sub_100040498(v2);
        return result;
      case 9:
        v7 = &unk_10006D588;
        v8 = *(_QWORD *)(a1 + 8);
        v9 = 1;
        goto LABEL_18;
      default:
        return (const char *)sub_100040498(v2);
    }
  }
  v4 = *(_DWORD *)(a1 + 28) & 0x7F;
  if (!v4)
    return "exit()";
LABEL_9:
  if (!v4 || v4 == 127)
    return (const char *)sub_100040498(v2);
LABEL_11:
  v5 = sub_100044154((_DWORD *)a1);
  result = (const char *)sub_100040488(v5);
  if (result)
    return result;
  if (v2 != 1)
    return (const char *)sub_100040498(v2);
LABEL_13:
  v7 = &unk_10006D598;
  LODWORD(v8) = v1;
  v9 = 3;
LABEL_18:
  result = (const char *)sub_10001592C(v8, (uint64_t)v7, v9);
  if (!result)
    return (const char *)sub_100040498(v2);
  return result;
}

BOOL sub_100044038(uint64_t a1)
{
  return *(_DWORD *)a1 == 3 && !*(_DWORD *)(a1 + 4) && (*(_BYTE *)(a1 + 28) & 0x7F) == 0;
}

uint64_t sub_100044064(_DWORD *a1)
{
  int v1;

  if (*a1 != 3 || a1[1] || (v1 = a1[7], (v1 & 0x7F) != 0))
    sub_10004D738();
  return BYTE1(v1);
}

uint64_t sub_10004409C(uint64_t a1)
{
  return sub_10000D768(*(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32));
}

uint64_t sub_1000440A8(uint64_t a1)
{
  return *(_QWORD *)(a1 + 32);
}

double sub_1000440B0(uint64_t a1)
{
  double result;

  *(_QWORD *)(a1 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_DWORD *)a1 = 1;
  return result;
}

uint64_t sub_1000440CC(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 4))
    return (*(unsigned __int8 *)(a1 + 16) >> 6) & 1;
  else
    return 0;
}

BOOL sub_1000440E8(_DWORD *a1)
{
  return *a1 == 3 || a1[1] != 0;
}

BOOL sub_10004410C(_DWORD *a1)
{
  int v1;

  v1 = a1[1];
  if (v1 == 2)
    return 1;
  if (v1 || *a1 != 3)
    return 0;
  if ((a1[7] & 0x7F) != 0)
    return (a1[7] & 0x7F) != 127;
  return 0;
}

uint64_t sub_100044154(_DWORD *a1)
{
  int v1;
  uint64_t result;
  BOOL v3;

  v1 = a1[1];
  if (v1 == 2)
    return a1[2];
  if (v1 || *a1 != 3 || ((result = a1[7] & 0x7F, (_DWORD)result != 127) ? (v3 = (_DWORD)result == 0) : (v3 = 1), v3))
    sub_10004D738();
  return result;
}

uint64_t sub_10004419C(uint64_t a1)
{
  int v2;
  unsigned int v3;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 != 2)
  {
    if (v2)
    {
LABEL_9:
      if ((*(_BYTE *)(a1 + 17) & 2) != 0)
        return 1;
      return v2 == 30;
    }
    if (*(_DWORD *)a1 != 3)
    {
      v2 = 0;
      return v2 == 30;
    }
    v2 = 0;
    if ((*(_DWORD *)(a1 + 28) & 0x7F) == 0 || (*(_DWORD *)(a1 + 28) & 0x7F) == 0x7F)
      return v2 == 30;
  }
  v3 = sub_100044154((_DWORD *)a1) - 4;
  if (v3 < 9 && ((0x1D7u >> v3) & 1) != 0)
    return 1;
  v2 = *(_DWORD *)(a1 + 4);
  if (v2)
    goto LABEL_9;
  return v2 == 30;
}

uint64_t sub_100044230(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 17) >> 2) & 1;
}

BOOL sub_10004423C(_DWORD *a1)
{
  int v1;

  v1 = a1[1];
  return (*a1 == 3 || v1 != 0) && v1 == 1;
}

BOOL sub_100044254(uint64_t a1)
{
  int v1;
  BOOL v2;
  uint64_t v5;

  v1 = *(_DWORD *)(a1 + 4);
  if (v1)
    v2 = 1;
  else
    v2 = *(_DWORD *)a1 == 3;
  if (!v2 || v1 != 1)
    return 0;
  v5 = *(_QWORD *)(a1 + 8);
  return v5 == 2 || v5 == 7;
}

BOOL sub_100044284(uint64_t a1)
{
  int v1;
  BOOL v2;

  v1 = *(_DWORD *)(a1 + 4);
  if (v1)
    v2 = 1;
  else
    v2 = *(_DWORD *)a1 == 3;
  return v2 && v1 == 1 && *(_QWORD *)(a1 + 8) == 9;
}

BOOL sub_1000442B0(uint64_t a1)
{
  int v1;
  BOOL v2;

  v1 = *(_DWORD *)(a1 + 4);
  if (v1)
    v2 = 1;
  else
    v2 = *(_DWORD *)a1 == 3;
  return v2 && v1 == 9 && *(_QWORD *)(a1 + 8) == 10;
}

BOOL sub_1000442DC(_DWORD *a1)
{
  int v1;

  v1 = a1[1];
  return (*a1 == 3 || v1 != 0) && v1 == 3;
}

BOOL sub_1000442F4(uint64_t a1)
{
  int v1;
  BOOL v2;

  v1 = *(_DWORD *)(a1 + 4);
  if (v1)
    v2 = 1;
  else
    v2 = *(_DWORD *)a1 == 3;
  return v2 && v1 == 7 && *(_QWORD *)(a1 + 8) == 3;
}

void sub_100044320(uint64_t a1)
{
  sub_10001962C(*(void **)(a1 + 56));
}

__n128 sub_100044334(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  _QWORD *v7;
  __n128 result;
  _QWORD *v9;
  _OWORD *v10;
  __int128 v11;

  v7 = sub_100012584(a1, a2, a5);
  if (v7)
  {
    v9 = v7;
    v10 = sub_100019D14(0);
    result = *(__n128 *)a3;
    v11 = *(_OWORD *)(a3 + 16);
    v10[1] = *(_OWORD *)a3;
    v10[2] = v11;
    *((_QWORD *)v10 + 6) = a4;
    *((_QWORD *)v10 + 7) = v9;
  }
  return result;
}

uint64_t sub_100044380(uint64_t a1)
{
  return *(_QWORD *)(a1 + 56) + 40;
}

uint64_t sub_10004438C(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 56) + 16);
}

uint64_t sub_100044398(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 56) + 24);
}

uint64_t sub_1000443A4()
{
  sub_100040F68(3, "misfired notification: port-deleted");
  return 5;
}

uint64_t *sub_1000443C8(uint64_t a1, int a2)
{
  uint64_t *result;

  if (dword_10007271C)
    return (uint64_t *)5;
  result = sub_10004440C(a2, 1);
  if (result)
  {
    dispatch_source_merge_data((dispatch_source_t)result[3], 0x45uLL);
    return 0;
  }
  return result;
}

uint64_t *sub_10004440C(int a1, int a2)
{
  uint64_t *result;
  int v5;

  v5 = a1;
  for (result = (uint64_t *)qword_100072788[sub_1000158C8(&v5, 4) % 0x35uLL]; result; result = (uint64_t *)*result)
  {
    if (*((unsigned __int8 *)result + 40) == a2 && *((_DWORD *)result + 4) == a1)
      break;
  }
  return result;
}

uint64_t sub_10004449C()
{
  sub_100040F68(3, "misfired notification: no-senders");
  return 5;
}

uint64_t sub_1000444C0()
{
  sub_100040F68(3, "misfired notification: send-once");
  return 5;
}

uint64_t sub_1000444E4()
{
  sub_100040F68(3, "misfired notification: dead-name");
  return 5;
}

double sub_100044508()
{
  double result;

  qword_100072728 = 0;
  result = 0.0;
  xmmword_100072708 = 0u;
  unk_100072718 = 0u;
  return result;
}

__int128 *sub_100044524()
{
  return &xmmword_100072708;
}

uint64_t sub_100044530()
{
  return qword_100072728;
}

void sub_10004453C()
{
  byte_100072730 = 1;
}

_DWORD *sub_10004454C(int a1, uint64_t a2)
{
  uint64_t v4;
  _DWORD *result;

  if (qword_100072738 != -1)
    dispatch_once_f(&qword_100072738, 0, (dispatch_function_t)sub_100044624);
  v4 = qword_100072740;
  if (qword_100072740 == qword_100071A58)
  {
    qword_100072748 = (uint64_t)sub_100013900((void *)qword_100072748, 8 * (int)qword_100072740, 16 * qword_100072740);
    result = sub_100013900((void *)qword_100072750, 4 * (int)qword_100071A58, 8 * qword_100071A58);
    qword_100072750 = (uint64_t)result;
    qword_100071A58 *= 2;
    v4 = qword_100072740;
  }
  else
  {
    result = (_DWORD *)qword_100072750;
  }
  *(_QWORD *)(qword_100072748 + 8 * v4) = a2;
  result[v4] = a1;
  qword_100072740 = v4 + 1;
  return result;
}

_QWORD *sub_100044624()
{
  _QWORD *result;

  result = (_QWORD *)sub_100044790(dword_100072A00, 0);
  if ((unint64_t)qword_100071A58 >> 61
    || (result = sub_10001389C(8 * qword_100071A58),
        qword_100072748 = (uint64_t)result,
        (unint64_t)qword_100071A58 >> 62)
    || (result = sub_10001389C(4 * qword_100071A58),
        qword_100072750 = (uint64_t)result,
        (unint64_t)qword_100071A60 >> 61))
  {
    __break(1u);
  }
  else
  {
    result = sub_10001389C(8 * qword_100071A60);
    qword_100072760 = (uint64_t)result;
    *result = sub_10004885C;
    qword_100072758 = 1;
    qword_100072768 = 40;
  }
  return result;
}

_QWORD *sub_1000446D0(uint64_t a1, unint64_t a2)
{
  uint64_t v4;
  _QWORD *result;

  if (qword_100072738 != -1)
    dispatch_once_f(&qword_100072738, 0, (dispatch_function_t)sub_100044624);
  v4 = qword_100072758;
  result = (_QWORD *)qword_100072760;
  if (qword_100072758 == qword_100071A60)
  {
    result = sub_100013900((void *)qword_100072760, 8 * (int)qword_100072758, 16 * qword_100072758);
    qword_100072760 = (uint64_t)result;
    qword_100071A60 *= 2;
    v4 = qword_100072758;
  }
  result[v4] = a1;
  qword_100072758 = v4 + 1;
  if (qword_100072768 < a2)
    qword_100072768 = a2;
  return result;
}

uint64_t sub_100044790(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  uint64_t v5;
  uint64_t f;
  int v7;

  v4 = sub_10001389C(0x30uLL);
  v4[4] = a1;
  *((_BYTE *)v4 + 40) = 0;
  *((_QWORD *)v4 + 4) = a2;
  v5 = sub_1000146E4();
  f = dispatch_mach_create_f("server", v5, v4, sub_10004546C);
  *((_QWORD *)v4 + 3) = f;
  if (dword_100072A00 == (_DWORD)a1)
    qword_100072930 = f;
  v7 = sub_10000D964(a1);
  if (v7)
    _os_assumes_log(v7);
  sub_100044B28((uint64_t)v4);
  return dispatch_mach_connect(*((_QWORD *)v4 + 3), a1, 0, 0);
}

uint64_t *sub_10004483C(int a1)
{
  uint64_t *v1;
  uint64_t *v2;

  v1 = sub_10004440C(a1, 0);
  if (!v1)
    sub_10003E208("attempt to remove non-existent server port");
  v2 = v1;
  dispatch_mach_cancel(v1[3]);
  return sub_100044A48(v2);
}

uint64_t sub_10004487C(mach_port_name_t a1, int a2, uint64_t a3)
{
  _DWORD *v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  int v10;
  mach_port_name_t name;
  _QWORD v13[5];
  _QWORD handler[6];

  if (a2 != 69)
    sub_10004D738();
  v5 = sub_10001389C(0x30uLL);
  v5[4] = a1;
  *((_BYTE *)v5 + 40) = 1;
  v6 = sub_1000146E4();
  v7 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0, 0, v6);
  dispatch_set_context(v7, v5);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_1000449EC;
  handler[3] = &unk_10006D5D0;
  handler[4] = a3;
  handler[5] = v7;
  dispatch_source_set_event_handler(v7, handler);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v13[2] = sub_100044A9C;
  v13[3] = &unk_10006D5F0;
  v13[4] = v7;
  dispatch_source_set_mandatory_cancel_handler(v7, v13);
  dispatch_activate(v7);
  v8 = sub_10000D90C(a1);
  if (v8)
    _os_assumes_log(v8);
  name = 0;
  v9 = sub_10000D9D0(a1, dword_100072A00, &name);
  if (name)
  {
    sub_100040F68(4, "Attempt to share port-destroyed. Ignoring.");
    v10 = sub_10000D980(name);
    if (v10)
      _os_assumes_log(v10);
  }
  *((_QWORD *)v5 + 3) = v7;
  sub_100044B28((uint64_t)v5);
  return v9;
}

uint64_t *sub_1000449EC(uint64_t a1)
{
  NSObject *v2;
  NSObject **context;
  uint64_t *v4;

  v2 = *(NSObject **)(a1 + 40);
  context = (NSObject **)dispatch_get_context(v2);
  if (v2 != context[3])
    sub_10004D738();
  v4 = (uint64_t *)context;
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
  return sub_100044A48(v4);
}

uint64_t *sub_100044A48(uint64_t *result)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *result;
  if (*result == -1)
  {
    v2 = result[1];
    if (v2 == -1)
      sub_10003E208("multiple removals of port entry");
    goto LABEL_5;
  }
  if (v1)
  {
    v2 = result[1];
LABEL_5:
    *(_QWORD *)(v1 + 8) = v2;
  }
  *(_QWORD *)result[1] = v1;
  *result = -1;
  result[1] = -1;
  return result;
}

void sub_100044A9C(uint64_t a1)
{
  NSObject *v2;
  void *context;
  void *v4;
  char v5;
  mach_port_name_t v6;
  int v7;

  v2 = *(NSObject **)(a1 + 32);
  context = dispatch_get_context(v2);
  if (v2 != *((NSObject **)context + 3))
    sub_10004D738();
  v4 = context;
  v5 = *((_BYTE *)context + 41);
  v6 = *((_DWORD *)context + 4);
  if ((v5 & 1) != 0)
  {
    sub_100040F68(4, "Abandoning send right to 0x%x (canceled notification)", v6);
  }
  else
  {
    v7 = sub_10000D980(v6);
    if (v7)
      _os_assumes_log(v7);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
  free(v4);
}

unint64_t sub_100044B28(uint64_t a1)
{
  unint64_t result;
  uint64_t *v3;
  uint64_t v4;
  int v5;

  v5 = *(_DWORD *)(a1 + 16);
  result = sub_1000158C8(&v5, 4);
  v3 = &qword_100072788[result % 0x35];
  v4 = *v3;
  *(_QWORD *)a1 = *v3;
  if (v4)
    *(_QWORD *)(v4 + 8) = a1;
  *v3 = a1;
  *(_QWORD *)(a1 + 8) = v3;
  return result;
}

uint64_t *sub_100044BAC(int a1)
{
  uint64_t *v1;
  uint64_t *v2;

  v1 = sub_10004440C(a1, 1);
  if (!v1)
    sub_10003E208("attempt to cancel notification on non-existent port entry");
  v2 = v1;
  dispatch_source_cancel((dispatch_source_t)v1[3]);
  *((_BYTE *)v2 + 41) |= 1u;
  return sub_100044A48(v2);
}

void sub_100044BF8(unsigned int a1, void *a2)
{
  _QWORD *v3;
  NSObject *v4;

  v3 = sub_1000195A8(a2, 0, a1);
  sub_100044C48(a2, "dispatching request");
  v4 = sub_1000146E4();
  dispatch_async_f(v4, v3, (dispatch_function_t)sub_100044D20);
}

void sub_100044C48(void *a1, const char *a2)
{
  int uint64;
  int v5;
  const char *v6;
  __int128 v7;
  __int128 v8;
  _OWORD v9[4];

  v7 = 0u;
  v8 = 0u;
  if (byte_100072ABB)
  {
    memset(v9, 0, sizeof(v9));
    uint64 = xpc_dictionary_get_uint64(a1, "subsystem");
    v5 = xpc_dictionary_get_uint64(a1, "routine");
    xpc_dictionary_get_audit_token(a1, &v7);
    v6 = sub_10003FBC0((uint64_t)&v7, (char *)v9);
    sub_100040F68(5, "ipc: caller = %s.%d, subsystem = %d, routine = %d, %s", v6, DWORD1(v8), uint64, v5, a2);
  }
}

void sub_100044D20(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t *v4;

  v2 = *(void **)a1;
  v3 = *(unsigned int *)(a1 + 16);
  v4 = sub_10004440C(*(_DWORD *)(a1 + 16), 0);
  if (v4)
    qword_100072728 = v4[4];
  sub_100044C48(v2, "processing dispatched request");
  sub_100044E20(v3, v2);
  qword_100072728 = 0;
  sub_100019650((void **)a1);
}

void sub_100044D8C(void *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char __str[2048];

  bzero(__str, 0x800uLL);
  vsnprintf(__str, 0x800uLL, a2, &a9);
  sub_100044C48(a1, __str);
}

void sub_100044E20(uint64_t a1, void *a2)
{
  uint64_t *v4;
  xpc_object_t value;
  void *v6;
  const void *bytes_ptr;
  size_t v8;
  int v9;
  uint64_t v10;

  if (byte_100072780 == 1)
    sub_10003E208("attempt to re-enter the server layer");
  v4 = sub_10004440C(a1, 0);
  if (v4)
    qword_100072728 = v4[4];
  value = xpc_dictionary_get_value(a2, "mig-request");
  if (value)
  {
    v6 = value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_data)
    {
      byte_100072A10 = 1;
      bytes_ptr = xpc_data_get_bytes_ptr(v6);
      if (xpc_data_get_length(v6) <= 0x17)
        sub_10003E208("Message buffer was shorter than mach_msg_header");
      v8 = qword_100072768;
      __chkstk_darwin();
      bzero((char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), v8);
      bzero((char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), v8);
      v9 = _xpc_pipe_handle_mig(bytes_ptr, (char *)&v10 - ((v8 + 15) & 0xFFFFFFFFFFFFFFF0), sub_100044F9C);
      if (v9)
        _os_assumes_log(v9);
      byte_100072A10 = 0;
    }
  }
  else
  {
    sub_10004513C(a1, 0, a2);
  }
  qword_100072728 = 0;
}

uint64_t sub_100044F9C(_DWORD *a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  const char *v7;
  int v8;
  uint64_t result;
  _OWORD v10[4];

  v4 = sub_10000DA04((uint64_t)a1);
  v5 = *(_OWORD *)(v4 + 16);
  xmmword_100072708 = *(_OWORD *)v4;
  unk_100072718 = v5;
  qword_100072770 = (uint64_t)a1;
  qword_100072778 = ((a1[1] + 3) & 0x1FFFFFFFCLL) + 52;
  if (qword_100072758)
  {
    v6 = 0;
    while (!(*(unsigned int (**)(_DWORD *, uint64_t))(qword_100072760 + 8 * v6))(a1, a2))
    {
      if (++v6 >= (unint64_t)qword_100072758)
        goto LABEL_5;
    }
    result = 1;
  }
  else
  {
LABEL_5:
    memset(v10, 0, sizeof(v10));
    v7 = sub_10003FBC0((uint64_t)&xmmword_100072708, (char *)v10);
    sub_100040F68(65540, "%s.%d sent an invalid request: msgh_bits = 0x%x, msgh_size = %u, msgh_remote_port = 0x%x, msgh_local_port = 0x%x, msgh_id = 0x%x", v7, *(_DWORD *)(v4 + 20), *a1, a1[1], a1[2], a1[3], a1[5]);
    if (byte_100072A7D)
    {
      sub_100040F68(65541, "Killing sender of bogus IPC message: %s.%d", v7, *(_DWORD *)(v4 + 20));
      v8 = sub_1000407FC(*(unsigned int *)(v4 + 20), 2u, (uint64_t)"unknown IPC", 0);
      if (v8)
        _os_assumes_log(v8);
    }
    result = 0;
  }
  qword_100072770 = 0;
  qword_100072778 = 0;
  return result;
}

void sub_10004513C(uint64_t a1, uint64_t a2, xpc_object_t xdict)
{
  uint64_t v4;
  uint64_t v6;
  int v7;
  int uint64;
  uint64_t v9;
  const char *v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  xpc_object_t reply;
  void *v21;
  int v22;
  xpc_object_t xdicta;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  if (byte_100072780 == 1)
    sub_10003E208("reentrant call into server layer", a2, xdict);
  v4 = a2;
  byte_100072780 = 1;
  byte_100072730 = 0;
  xpc_dictionary_set_value(xdict, "mig-request", 0);
  xdicta = 0;
  v24 = 0u;
  v25 = 0u;
  xpc_dictionary_get_audit_token(xdict, &v24);
  xmmword_100072708 = v24;
  unk_100072718 = v25;
  if ((_DWORD)v4)
  {
    if (v4 <= 0x513)
    {
      v6 = (unsigned __int16)v4 / 0x64u;
      if (((0x861uLL >> v6) & 1) == 0)
      {
        v7 = dword_10004FEDC[v6];
        xpc_dictionary_set_uint64(xdict, "subsystem", v7);
        xpc_dictionary_set_uint64(xdict, "routine", v4);
        goto LABEL_9;
      }
    }
LABEL_13:
    v26 = 0u;
    v27 = 0u;
    v24 = 0u;
    v25 = 0u;
    v10 = sub_10003FBC0((uint64_t)&xmmword_100072708, (char *)&v24);
    sub_100044C48(xdict, "xpc demux failed");
    sub_100040F68(65541, "%s.%d sent an invalid request", v10, dword_10007271C);
    if (byte_100072A7D)
    {
      sub_100040F68(65541, "Killing sender of bogus IPC message: %s.%d", v10, dword_10007271C);
      v11 = sub_1000407FC(dword_10007271C, 2u, (uint64_t)"unknown IPC", 0);
      if (v11)
        _os_assumes_log(v11);
    }
    goto LABEL_16;
  }
  uint64 = xpc_dictionary_get_uint64(xdict, "subsystem");
  v7 = uint64;
  if (!uint64)
    goto LABEL_13;
  if (uint64 > 12)
    goto LABEL_13;
  v4 = xpc_dictionary_get_uint64(xdict, "routine");
  if (!(_DWORD)v4)
    goto LABEL_13;
LABEL_9:
  if (!qword_100072740)
    goto LABEL_13;
  v9 = 0;
  while (*(_DWORD *)(qword_100072750 + 4 * v9) != v7)
  {
    if (qword_100072740 == ++v9)
      goto LABEL_13;
  }
  v12 = (*(uint64_t (**)(uint64_t, uint64_t, xpc_object_t, xpc_object_t *))(qword_100072748 + 8 * v9))(a1, v4, xdict, &xdicta);
  if (v12)
  {
    v19 = v12;
    sub_100044D8C(xdict, "demux error = %d", v13, v14, v15, v16, v17, v18, v12);
    reply = xpc_dictionary_create_reply(xdict);
    if (reply)
    {
      v21 = reply;
      xpc_dictionary_set_int64(reply, "error", v19);
      xdicta = v21;
    }
  }
  sub_100044C48(xdict, "xpc demux succeeded");
  if (xdicta)
  {
    sub_100044C48(xdict, "sending reply");
    if (byte_100072730 == 1)
    {
      xpc_dictionary_set_uint64(xdicta, "req_pid", dword_10007271C);
      xpc_dictionary_set_uint64(xdicta, "rec_execcnt", dword_100072724);
    }
    v22 = xpc_pipe_routine_reply(xdicta);
    if ((v22 & 0xFFFFFFDF) != 0)
      _os_assumes_log(v22);
    xpc_release(xdicta);
  }
LABEL_16:
  byte_100072780 = 0;
}

void sub_10004546C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t msg;
  const void *v6;
  int v7;
  int v8;
  int v9;

  if (a2 == 8)
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 24));
    free((void *)a1);
  }
  else
  {
    v4 = *(unsigned int *)(a1 + 16);
    if (a2 == 7)
    {
      msg = dispatch_mach_msg_get_msg(a3, 0);
      v6 = (const void *)*(unsigned int *)(msg + 8);
      if (((_DWORD)v6 + 1) >= 2)
        sub_10004E1D8(v6);
      v7 = *(_DWORD *)(msg + 12);
      if ((v7 + 1) >= 2)
      {
        if ((_DWORD)v4 != v7)
          sub_10004E200(v6);
        v8 = sub_10000D980(v4);
        if (v8)
          _os_assumes_log(v8);
        v9 = sub_10000D994(v4, 0, *(_QWORD *)(a1 + 32));
        if (v9)
          sub_10004D778(v9);
      }
    }
    else if (a2 == 2)
    {
      qword_100072728 = *(_QWORD *)(a1 + 32);
      sub_10004554C(v4, a3);
      qword_100072728 = 0;
    }
  }
}

void sub_10004554C(uint64_t a1, uint64_t a2)
{
  uint64_t msg;
  uint64_t v5;
  int v6;
  unsigned int v7;
  size_t v9;
  int v10;
  int v11;
  char *v12;
  uint64_t v13;
  xpc_object_t v14;
  unint64_t v15;

  v15 = 0;
  msg = dispatch_mach_msg_get_msg(a2, &v15);
  v14 = 0;
  if (v15 <= 0x17)
    sub_10003E208("Message buffer was shorter than mach_msg_header");
  v5 = msg;
  v6 = *(_DWORD *)(msg + 20);
  v7 = v6 & 0xFF000000;
  if ((v6 & 0xFF000000) == 0x40000000 || v7 == 0x10000000)
  {
    *(_DWORD *)(msg + 20) = v7;
    if (!xpc_receive_mach_msg(a2, 0, 0, 0, &v14))
    {
      sub_100038EB0((uint64_t)v14);
      sub_10004513C(a1, v6 & 0xFFFFFF, v14);
      xpc_release(v14);
      sub_100038EB0(0);
    }
  }
  else
  {
    v9 = qword_100072768;
    __chkstk_darwin();
    bzero((char *)&v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0), v9);
    bzero((char *)&v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0), v9);
    v10 = _xpc_pipe_handle_mig(v5, (char *)&v13 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0), sub_100044F9C);
    if (v10)
    {
      v11 = v10;
      if (v10 == 22)
      {
        sub_100040F68(65539, "Rejected invalid request.");
      }
      else
      {
        v12 = strerror(v10);
        sub_100040F68(65539, "Rejected bogus request: %d: %s", v11, v12);
      }
    }
  }
}

void sub_1000456E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v9;
  mach_port_name_t v10;

  if (*(_QWORD *)(a1 + 16) != -1 || *(_QWORD *)(a1 + 24) != -1)
    sub_10003E208("endpoint deallocation while still in service list");
  if (*(_QWORD *)(a1 + 32) != -1 || *(_QWORD *)(a1 + 40) != -1)
    sub_10003E208("endpoint deallocation while still in domain list");
  v9 = *(_WORD *)(a1 + 160);
  if ((v9 & 1) != 0)
    sub_10003E208("endpoint deallocation while still active");
  if ((v9 & 2) != 0)
    sub_10003E208("endpoint deallocation while still being watched");
  if ((v9 & 0x20) == 0 && (*(_BYTE *)(a1 + 88) & 0x20) != 0)
    sub_10003E208("endpoint deallocation without cancellation");
  if (*(_QWORD *)(a1 + 104))
  {
    if ((v9 & 0x88) == 0)
    {
      v10 = sub_1000457E0(a1, 4, a3, a4, a5, a6, a7, a8);
      if (sub_10000D994(v10, 0, *(_QWORD *)(a1 + 112)))
        _os_assumes_log_ctx(sub_100045814, a1);
    }
    xpc_release(*(xpc_object_t *)(a1 + 104));
  }
}

uint64_t sub_1000457E0(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface");
  result = sub_1000461B0(a1, a2, a3, a4, a5, a6, a7, a8);
  if (result)
    return xpc_mach_send_get_right(result);
  return result;
}

uint64_t sub_100045814(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100045848(a2, 3, "%s", a4, a5, a6, a7, a8, a3);
  return 1;
}

void sub_100045848(uint64_t a1, int a2, char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char **v19;
  uint64_t v20;
  char *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;

  v19 = (const char **)sub_1000106C8(0x40uLL);
  v20 = *(_QWORD *)(a1 + 96);
  if (v20)
  {
    v21 = sub_10001F264(v20, 1);
    sub_100010740((uint64_t)v19, "%s - ", v22, v23, v24, v25, v26, v27, (char)v21);
    free(v21);
  }
  sub_100010740((uint64_t)v19, "%s", v13, v14, v15, v16, v17, v18, a1 - 88);
  v28 = sub_100010710(v19);
  sub_100010718((void **)v19);
  sub_1000412EC(v28, a2, a3, &a9, v9);
  free(v28);
}

__n128 sub_100045918(unint64_t a1, const char *a2, unint64_t a3, unint64_t a4)
{
  __n128 *v7;
  __n128 result;

  v7 = (__n128 *)sub_100019B48(a2);
  v7[6].n128_u64[0] = a1;
  v7[9].n128_u64[0] = a3;
  v7[9].n128_u64[1] = a4;
  result.n128_u64[0] = -1;
  result.n128_u64[1] = -1;
  v7[1] = result;
  v7[2] = result;
  return result;
}

char *sub_10004595C(uint64_t a1, const char *a2, void *a3, uint64_t a4, uint64_t a5)
{
  char *v9;
  __int128 v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v9 = sub_100019B48(a2);
  *((_QWORD *)v9 + 12) = a1;
  *((_QWORD *)v9 + 18) = a4;
  *((_QWORD *)v9 + 19) = a5;
  *(_QWORD *)&v10 = -1;
  *((_QWORD *)&v10 + 1) = -1;
  *((_OWORD *)v9 + 1) = v10;
  *((_OWORD *)v9 + 2) = v10;
  *((_QWORD *)v9 + 13) = xpc_retain(a3);
  *((_WORD *)v9 + 80) |= 8u;
  sub_1000459D4((uint64_t)v9, v11, v12, v13, v14, v15, v16, v17);
  return v9;
}

uint64_t sub_1000459D4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v9;
  mach_port_name_t v10;
  uint64_t result;
  void *v12;
  uintptr_t right;
  NSObject *v14;
  NSObject *v15;
  _QWORD v16[5];
  _QWORD v17[6];
  _QWORD handler[5];

  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface");
  v9 = *(_WORD *)(a1 + 160);
  if ((v9 & 1) != 0)
    return 37;
  if ((v9 & 8) != 0)
  {
    v12 = *(void **)(a1 + 104);
    right = xpc_mach_send_get_right(v12);
    v14 = sub_1000146E4();
    v15 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_send, right, 1uLL, v14);
    xpc_retain(v12);
    dispatch_set_context(v15, (void *)a1);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_100046F00;
    handler[3] = &unk_10006D6B0;
    handler[4] = v15;
    dispatch_source_set_event_handler(v15, handler);
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 0x40000000;
    v17[2] = sub_100046F70;
    v17[3] = &unk_10006D6D0;
    v17[4] = v15;
    v17[5] = v12;
    dispatch_source_set_mandatory_cancel_handler(v15, v17);
    dispatch_activate(v15);
    sub_100019580((void *)a1);
    if (*(_QWORD *)(a1 + 120))
      sub_10004D738();
    *(_QWORD *)(a1 + 120) = v15;
  }
  else
  {
    v10 = sub_1000457E0(a1, 1, a3, a4, a5, a6, a7, a8);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    v16[2] = sub_100046A38;
    v16[3] = &unk_10006D630;
    v16[4] = a1;
    if (sub_10004487C(v10, 69, (uint64_t)v16))
      _os_assumes_log_ctx(sub_100045814, a1);
    sub_10000D8AC(v10, *(_QWORD *)(a1 + 112));
  }
  result = 0;
  *(_WORD *)(a1 + 160) |= 1u;
  return result;
}

char *sub_100045B90(uint64_t a1, const char *a2, xpc_object_t object, uint64_t a4, _BYTE *a5, uint64_t a6)
{
  xpc_type_t type;
  xpc_type_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  __int16 v18;
  _QWORD applier[6];

  if (object == &_xpc_BOOL_false)
    return 0;
  type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_BOOL && type != (xpc_type_t)&_xpc_type_dictionary)
    return 0;
  v14 = type;
  v15 = sub_100019B48(a2);
  v16 = v15;
  *((_QWORD *)v15 + 12) = a1;
  *((_QWORD *)v15 + 18) = a4;
  *((_QWORD *)v15 + 19) = a6;
  *(_QWORD *)&v17 = -1;
  *((_QWORD *)&v17 + 1) = -1;
  *((_OWORD *)v15 + 1) = v17;
  *((_OWORD *)v15 + 2) = v17;
  if (v14 == (xpc_type_t)&_xpc_type_dictionary)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = sub_100045D00;
    applier[3] = &unk_10006D610;
    applier[4] = v15;
    applier[5] = a5;
    xpc_dictionary_apply(object, applier);
  }
  if (v16[88] < 0 && (*((_WORD *)v16 + 80) & 4) != 0)
  {
    sub_100014830(a5, 3, "%s: _ExperimentalNonLaunching is not compatible with HideUntilCheckIn, ignoring", v16 + 168);
    sub_10001962C(v16);
    return 0;
  }
  if (strlen(v16 + 168) >= 0xFF)
    sub_100014830(a5, 4, "The endpoint name %s is too long to support some features", v16 + 168);
  v18 = *((_WORD *)v16 + 80);
  if ((v18 & 4) == 0)
    *((_WORD *)v16 + 80) = v18 | 0x200;
  return v16;
}

uint64_t sub_100045D00(uint64_t a1, const char *a2, xpc_object_t object)
{
  _BYTE *v5;
  uint64_t v6;
  xpc_type_t type;
  int64_t v8;
  int value;
  uint64_t v10;
  __int16 v11;
  int v12;

  v6 = *(_QWORD *)(a1 + 32);
  v5 = *(_BYTE **)(a1 + 40);
  type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_int64)
  {
    if (type == (xpc_type_t)&_xpc_type_BOOL)
    {
      if (!strcasecmp(a2, "ResetAtClose"))
      {
        v11 = *(_WORD *)(v6 + 160) & 0xFFEF | (16 * (object == &_xpc_BOOL_true));
      }
      else if (!strcasecmp(a2, "HideUntilCheckIn"))
      {
        sub_100014830(v5, 4, "The HideUntilCheckIn property is an architectural performance issue. Please transition away from it.");
        v11 = *(_WORD *)(v6 + 160) & 0xFFFB | (4 * (object == &_xpc_BOOL_true));
      }
      else
      {
        if (strcasecmp(a2, "_ExperimentalNonLaunching"))
        {
          if (!strcasecmp(a2, "ExceptionServer"))
          {
            sub_100014830(v5, 3, "An empty dictionary needs to be used as the value for %s.");
            return 1;
          }
          goto LABEL_20;
        }
        if (object != &_xpc_BOOL_true)
          return 1;
        *(_BYTE *)(v6 + 88) |= 0x80u;
        v11 = *(_WORD *)(v6 + 160) | 0x400;
      }
      *(_WORD *)(v6 + 160) = v11;
      return 1;
    }
    if (type != (xpc_type_t)&_xpc_type_string)
    {
      if (type != (xpc_type_t)&_xpc_type_dictionary)
        return 1;
      if (!strcmp(a2, "ExceptionServer"))
      {
        if (xpc_dictionary_get_count(object))
          sub_100014830(v5, 3, "Non-empty dictionary property on MachService: %s");
        else
          *(_BYTE *)(v6 + 88) |= 0x10u;
        return 1;
      }
LABEL_20:
      sub_100014830(v5, 3, "Unrecognized MachService property: %s");
      return 1;
    }
    if (!strcasecmp(a2, "TaskSpecialPort"))
    {
      xpc_string_get_string_ptr(object);
      v12 = mach_task_special_port_for_id();
      if (v12 <= 0)
        sub_100014830(v5, 3, "Tried to set an unknown task-special port: %s");
    }
    else
    {
      if (strcasecmp(a2, "HostSpecialPort"))
        goto LABEL_20;
      xpc_string_get_string_ptr(object);
      v12 = mach_host_special_port_for_id();
      if (v12 <= 0)
        sub_100014830(v5, 3, "Tried to set an unknown host-special port: %s");
    }
    v10 = v6;
    value = v12;
LABEL_34:
    sub_100046DD8(v10, value, v5);
    return 1;
  }
  if (!strcasecmp(a2, "TaskSpecialPort"))
  {
    value = xpc_int64_get_value(object);
    v10 = v6;
    goto LABEL_34;
  }
  if (strcasecmp(a2, "HostSpecialPort"))
    goto LABEL_20;
  v8 = xpc_int64_get_value(object);
  if (v8 < 8)
  {
    mach_host_special_port_description(v8);
    sub_100014830(v5, 3, "Tried to set a reserved host-special port: %lld: %s");
  }
  else if ((unint64_t)v8 > 0x23)
  {
    sub_100014830(v5, 3, "Tried to set an invalid host-special port: %lld");
  }
  else
  {
    *(_DWORD *)(v6 + 84) = v8;
  }
  return 1;
}

uint64_t sub_100045FE0(uint64_t result)
{
  *(_WORD *)(result + 160) |= 0x200u;
  return result;
}

__n128 sub_100045FF0(uint64_t a1, unint64_t a2, unint64_t a3, unint64_t a4)
{
  __n128 *v8;
  __n128 result;

  v8 = (__n128 *)sub_100019B48((const char *)(a1 + 168));
  v8[6].n128_u64[0] = a3;
  v8[9].n128_u64[0] = a2;
  v8[9].n128_u64[1] = a4;
  result.n128_u64[0] = -1;
  result.n128_u64[1] = -1;
  v8[1] = result;
  v8[2] = result;
  v8[10].n128_u16[0] = v8[10].n128_u16[0] & 0xFFEB | *(_WORD *)(a1 + 160) & 0x14;
  return result;
}

xpc_object_t sub_100046058(uint64_t a1, int a2)
{
  xpc_object_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  void *v12;

  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface");
  v4 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v4, launch_perfcheck_property_endpoint_name, (const char *)(a1 + 168));
  xpc_dictionary_set_BOOL(v4, launch_perfcheck_property_endpoint_active, *(_WORD *)(a1 + 160) & 1);
  xpc_dictionary_set_BOOL(v4, launch_perfcheck_property_endpoint_needs_activation, (*(_WORD *)(a1 + 160) & 0x200) != 0);
  xpc_dictionary_set_BOOL(v4, launch_perfcheck_property_endpoint_event, (*(_BYTE *)(a1 + 88) & 8) != 0);
  xpc_dictionary_set_BOOL(v4, "XPCServiceEndpointNonLaunching", *(_BYTE *)(a1 + 88) >> 7);
  if (a2)
  {
    v11 = (void *)sub_10004616C(a1, 1, v5, v6, v7, v8, v9, v10);
    if (v11)
    {
      v12 = v11;
      if (xpc_get_type(v11) == (xpc_type_t)&_xpc_type_mach_send)
        xpc_dictionary_set_value(v4, "XPCServiceEndpointPort", v12);
    }
  }
  return v4;
}

uint64_t sub_10004616C(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface");
  if ((*(_WORD *)(a1 + 160) & 5) == 4)
    return 0;
  else
    return sub_1000461B0(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1000461B0(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  __int16 v10;
  uint64_t v11;
  const char *v12;
  const char **v13;
  char v14;
  mach_port_context_t v16;
  uint64_t v17;
  char v19;
  mach_port_options_t v20;
  _BYTE v21[255];
  char v22;

  if (!*(_QWORD *)(a1 + 104))
  {
    v9 = a2 & 7;
    switch(v9)
    {
      case 1:
        v10 = *(_WORD *)(a1 + 160);
        if ((v10 & 8) != 0)
          sub_10004D738();
        if ((v10 & 1) != 0)
          sub_10004D738();
        if ((v10 & 0x20) != 0)
        {
          sub_100045848(a1, 4, "Refusing to make a port for a canceled endpoint", a4, a5, a6, a7, a8, v19);
        }
        else
        {
          v20.reserved[1] = 0;
          *(_OWORD *)&v20.flags = xmmword_10004FF10;
          v11 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 248);
          v12 = (const char *)(a1 + 168);
          if (strlen((const char *)(a1 + 168)) > 0xFE)
            v12 = "<endpoint name too long>";
          v13 = (const char **)sub_10002E360(v11);
          if (sub_100028DB4(v11))
          {
            v14 = 1;
          }
          else if (v13 == (const char **)&unk_100071640 || v13 == (const char **)&unk_1000716C8)
          {
            v14 = 2;
          }
          else
          {
            if (v13 != (const char **)&unk_100071750)
              sub_10003E208("Endpoint with unexpected domain type \"%s\"", v13[14]);
            v14 = 5;
          }
          memset(v21, 0, sizeof(v21));
          v22 = v14;
          __strlcpy_chk(v21, v12, 255, 255);
          v20.flags = 1079;
          v20.reserved[0] = (uint64_t)v21;
          if ((sub_100005BA8(*(_QWORD *)(a1 + 96), 4) & 1) == 0)
            v20.flags = 9271;
          v16 = qword_100071A68++;
          v17 = sub_10000D850(&v20, v16);
          *(_QWORD *)(a1 + 112) = v16;
          *(_QWORD *)(a1 + 104) = xpc_mach_send_create_with_disposition(v17, 17);
          if ((*(_WORD *)(a1 + 160) & 0x402) == 2)
            sub_1000467E0((_QWORD *)a1);
        }
        break;
      case 2:
        break;
      case 4:
        sub_10003E208("GET_PORT_FORCE for endpoint %s but port not yet made", (const char *)(a1 + 168));
      default:
        sub_10003E208("Invalid get_port() flags");
    }
  }
  return *(_QWORD *)(a1 + 104);
}

uint64_t sub_1000463E0(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface");
  return *(_QWORD *)(a1 + 96);
}

BOOL sub_100046408(uint64_t a1)
{
  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface");
  return (*(_WORD *)(a1 + 160) & 8) == 0;
}

uint64_t sub_100046438(uint64_t a1, FILE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  const char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v68;
  mach_port_type_t ptype;

  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface", a2);
  sub_10004391C(a2, a3, "\"%s\" = {", a4, a5, a6, a7, a8, a1 + 168);
  v22 = sub_1000457E0(a1, 2, v11, v12, v13, v14, v15, v16);
  ptype = 0;
  if ((_DWORD)v22 && (mach_port_type(mach_task_self_, v22, &ptype) || (ptype & 0x100000) != 0))
  {
    *(_BYTE *)(a1 + 88) |= 0x40u;
    v23 = " (dead)";
  }
  else
  {
    v23 = (const char *)&unk_100056F87;
  }
  sub_10004391C(a2, a3 + 1, "port = 0x%x%s", v17, v18, v19, v20, v21, v22, v23);
  v29 = *(unsigned int *)(a1 + 84);
  if ((_DWORD)v29)
  {
    v68 = mach_host_special_port_description(*(unsigned int *)(a1 + 84));
    sub_10004391C(a2, a3 + 1, "host-special port = %u (%s)", v30, v31, v32, v33, v34, v29, v68);
  }
  else
  {
    v35 = *(unsigned int *)(a1 + 80);
    if ((_DWORD)v35)
    {
      if ((_DWORD)v35 == 128)
      {
        v36 = "exception";
      }
      else
      {
        v36 = (const char *)mach_task_special_port_description(v35);
        v35 = *(unsigned int *)(a1 + 80);
      }
      sub_10004391C(a2, a3 + 1, "task-special port = %u (%s)", v24, v25, v26, v27, v28, v35, v36);
    }
  }
  if ((*(_WORD *)(a1 + 160) & 1) != 0)
    v37 = "1";
  else
    v37 = "0";
  sub_10004391C(a2, a3 + 1, "active = %s", v24, v25, v26, v27, v28, v37);
  if ((*(_WORD *)(a1 + 160) & 8) != 0)
    v43 = "0";
  else
    v43 = "1";
  sub_10004391C(a2, a3 + 1, "managed = %s", v38, v39, v40, v41, v42, v43);
  if ((*(_WORD *)(a1 + 160) & 0x10) != 0)
    v49 = "1";
  else
    v49 = "0";
  sub_10004391C(a2, a3 + 1, "reset = %s", v44, v45, v46, v47, v48, v49);
  if ((*(_WORD *)(a1 + 160) & 4) != 0)
    v55 = "1";
  else
    v55 = "0";
  sub_10004391C(a2, a3 + 1, "hide = %s", v50, v51, v52, v53, v54, v55);
  if ((*(_WORD *)(a1 + 160) & 2) != 0)
    v61 = "1";
  else
    v61 = "0";
  sub_10004391C(a2, a3 + 1, "watching = %s", v56, v57, v58, v59, v60, v61);
  if ((*(_WORD *)(a1 + 160) & 0x400) != 0)
    sub_10004391C(a2, a3 + 1, "non-launching = 1", v62, v63, v64, v65, v66);
  return sub_10004391C(a2, a3, "}", v62, v63, v64, v65, v66);
}

void *sub_100046670(uint64_t a1)
{
  __int16 v2;
  void *result;

  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface");
  v2 = *(_WORD *)(a1 + 160);
  if ((v2 & 8) != 0)
    sub_10003E208("attempt to watch unmanaged endpoint");
  if ((v2 & 2) != 0)
    sub_10003E208("attempt to watch endpoint that is already watched");
  if ((v2 & 1) != 0)
    sub_10003E208("attempt to watch an active endpoint");
  if ((v2 & 0x50) == 0x10)
  {
    sub_100046738((_QWORD *)a1);
    v2 = *(_WORD *)(a1 + 160);
  }
  *(_WORD *)(a1 + 160) = v2 & 0xFFBD | 2;
  result = (void *)sub_1000239C4(*(_QWORD *)(a1 + 96), 1);
  if ((_DWORD)result)
    *(_WORD *)(a1 + 160) |= 0x400u;
  if (*(_QWORD *)(a1 + 104))
  {
    if ((*(_WORD *)(a1 + 160) & 0x400) == 0)
      return sub_1000467E0((_QWORD *)a1);
  }
  return result;
}

void sub_100046738(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  _QWORD block[7];

  if (a1[16])
    sub_10004D738();
  if (a1[15])
    sub_10004D738();
  v2 = a1[13];
  if (v2)
  {
    v3 = a1[14];
    a1[13] = 0;
    sub_100019580(a1);
    v4 = sub_1000146E4();
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100046E3C;
    block[3] = &unk_10006D650;
    block[4] = v2;
    block[5] = v3;
    block[6] = a1;
    dispatch_async(v4, block);
  }
}

void *sub_1000467E0(_QWORD *a1)
{
  void *v2;
  uintptr_t right;
  NSObject *v4;
  NSObject *v5;
  void *result;
  _QWORD v7[6];
  _QWORD handler[5];

  v2 = (void *)a1[13];
  right = xpc_mach_send_get_right(v2);
  v4 = sub_1000146E4();
  v5 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_mach_recv, right, 0x8000uLL, v4);
  dispatch_set_context(v5, a1);
  xpc_retain(v2);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = sub_100046EA0;
  handler[3] = &unk_10006D670;
  handler[4] = v5;
  dispatch_source_set_event_handler(v5, handler);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100046EC0;
  v7[3] = &unk_10006D690;
  v7[4] = v5;
  v7[5] = v2;
  dispatch_source_set_cancel_handler(v5, v7);
  dispatch_activate(v5);
  result = sub_100019580(a1);
  if (a1[16])
    sub_10004D738();
  a1[16] = v5;
  return result;
}

void sub_1000468E8(uint64_t a1, integer_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_name_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  __int16 v17;
  integer_t port_info;

  v10 = sub_1000457E0(a1, 2, a3, a4, a5, a6, a7, a8);
  if (v10 - 1 <= 0xFFFFFFFD)
  {
    port_info = a2;
    if (mach_port_set_attributes(mach_task_self_, v10, 9, &port_info, 1u))
    {
      v16 = "mark";
      if (!port_info)
        v16 = "unmark";
      sub_10001D418(*(_QWORD *)(a1 + 96), 4, "Failed to %s endpoint '%s' as throttled", v11, v12, v13, v14, v15, (char)v16);
    }
    if (a2)
      v17 = 2048;
    else
      v17 = 0;
    *(_WORD *)(a1 + 160) = *(_WORD *)(a1 + 160) & 0xF7FF | v17;
  }
}

void sub_1000469A0(uint64_t a1)
{
  __int16 v2;
  NSObject *v3;

  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface");
  v2 = *(_WORD *)(a1 + 160);
  if ((v2 & 8) != 0)
    sub_10003E208("attempt to ignore unmanaged endpoint");
  if ((v2 & 2) == 0)
    sub_10003E208("attempt to ignore endpoint that is already ignored");
  *(_WORD *)(a1 + 160) = v2 & 0xFFFD;
  v3 = *(NSObject **)(a1 + 128);
  if ((v2 & 0x400) != 0 || !*(_QWORD *)(a1 + 104))
  {
    if (v3)
      sub_10003E208("endpoint %s has unexpected receive_source", (const char *)(a1 + 168));
  }
  else
  {
    dispatch_source_cancel(v3);
    *(_QWORD *)(a1 + 128) = 0;
  }
}

uint64_t sub_100046A38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  mach_port_name_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __int16 v17;

  v8 = *(_QWORD *)(a1 + 32);
  if ((*(_WORD *)(v8 + 160) & 0x10) != 0)
  {
    sub_100046738(*(_QWORD **)(a1 + 32));
  }
  else
  {
    v9 = sub_1000457E0(*(_QWORD *)(a1 + 32), 4, a3, a4, a5, a6, a7, a8);
    sub_10000D8C4(v9, *(_QWORD *)(v8 + 112));
    if (sub_10000D9B0(v9))
      _os_assumes_log_ctx(sub_100045814, v8);
  }
  v17 = *(_WORD *)(v8 + 160);
  *(_WORD *)(v8 + 160) = v17 & 0xFFBE | 0x40;
  if ((v17 & 0x100) != 0)
  {
    sub_100046B90(v8, v10, v11, v12, v13, v14, v15, v16);
    *(_WORD *)(v8 + 160) &= ~0x100u;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(v8 + 144))(v8, 1, *(_QWORD *)(v8 + 152));
}

void sub_100046AD4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v9;
  int v10;

  if (*(_QWORD *)(a1 + 72))
    sub_10003E208("alias endpoint given to endpoint interface");
  v9 = *(_WORD *)(a1 + 160);
  *(_WORD *)(a1 + 160) = v9 | 0x20;
  if ((v9 & 2) != 0)
  {
    sub_1000469A0(a1);
  }
  else if ((v9 & 1) != 0)
  {
    if ((v9 & 8) != 0)
    {
      dispatch_source_cancel(*(dispatch_source_t *)(a1 + 120));
      *(_QWORD *)(a1 + 120) = 0;
    }
    else
    {
      v10 = sub_1000457E0(a1, 4, a3, a4, a5, a6, a7, a8);
      sub_100044BAC(v10);
    }
    *(_WORD *)(a1 + 160) = *(_WORD *)(a1 + 160) & 0xFF7E | 0x80;
    (*(void (**)(uint64_t, uint64_t, _QWORD))(a1 + 144))(a1, 1, *(_QWORD *)(a1 + 152));
  }
}

void sub_100046B74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v8;

  v8 = *(_WORD *)(a1 + 160);
  if ((v8 & 0x100) == 0)
  {
    if ((v8 & 1) != 0)
      *(_WORD *)(a1 + 160) = v8 | 0x100;
    else
      sub_100046B90(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void sub_100046B90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_port_name_t v9;
  mach_port_name_t v10;
  int v11;
  mach_msg_return_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE msg[32];

  if ((*(_WORD *)(a1 + 160) & 1) != 0)
    sub_10003E208("attempt to drain active endpoint");
  v9 = sub_1000457E0(a1, 2, a3, a4, a5, a6, a7, a8);
  if (v9 - 1 <= 0xFFFFFFFD)
  {
    v10 = v9;
    v11 = 20;
    do
    {
      memset(msg, 0, sizeof(msg));
      v12 = mach_msg((mach_msg_header_t *)msg, 258, 0, 0x20u, v10, 0, 0);
      if (v12)
      {
        if (v12 == 268451843)
          return;
      }
      else
      {
        sub_100045848(a1, 5, "draining message: id = 0x%x", v13, v14, v15, v16, v17, msg[20]);
        mach_msg_destroy((mach_msg_header_t *)msg);
      }
      --v11;
    }
    while (v11);
  }
}

uint64_t sub_100046C64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int16 v9;
  int v11;
  uint64_t result;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  int v19;
  int v20;
  char v21;

  if (*(_QWORD *)(a1 + 72))
    return 0;
  v9 = *(_WORD *)(a1 + 160);
  if ((v9 & 8) != 0)
    return 0;
  if ((v9 & 0x20) == 0)
    sub_10004D738();
  if ((v9 & 2) != 0)
    sub_10004D738();
  v11 = sub_1000457E0(a1, 2, a3, a4, a5, a6, a7, a8);
  if ((v11 - 1) > 0xFFFFFFFD)
    return 0;
  if ((*(_WORD *)(a1 + 160) & 0x80) != 0)
  {
    v19 = v11;
    v20 = sub_100020D78(*(_QWORD *)(a1 + 96));
    sub_10003E208("Unable to stash abandoned service port 0x%x owner PID %d (%s)", v19, v20, (const char *)(a1 + 168));
  }
  result = sub_10001A19C(a2, (const char *)(a1 + 168), v11, *(_QWORD *)(a1 + 112));
  if (!(_DWORD)result)
  {
    sub_100045848(a1, 5, "Saved the port to stash", v13, v14, v15, v16, v17, v21);
    v18 = *(void **)(a1 + 104);
    if (!v18)
      sub_10004D738();
    xpc_release(v18);
    result = 0;
    *(_QWORD *)(a1 + 104) = 0;
  }
  return result;
}

void sub_100046D3C(uint64_t a1, uint64_t a2)
{
  __int16 v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  uint64_t v11;

  if (!*(_QWORD *)(a1 + 72))
  {
    v3 = *(_WORD *)(a1 + 160);
    if ((v3 & 8) == 0)
    {
      if (*(_QWORD *)(a1 + 104))
        sub_10004D738();
      if ((v3 & 1) != 0)
        sub_10004D738();
      if ((v3 & 2) != 0)
        sub_10004D738();
      v11 = 0;
      v4 = sub_10001A218(a2, a1 + 168, &v11);
      if ((v4 - 1) <= 0xFFFFFFFD)
      {
        *(_QWORD *)(a1 + 112) = v11;
        *(_QWORD *)(a1 + 104) = xpc_mach_send_create_with_disposition(v4, 20);
        sub_100045848(a1, 5, "Restored the port from stash", v5, v6, v7, v8, v9, v10);
      }
    }
  }
}

void sub_100046DD8(uint64_t a1, int a2, _BYTE *a3)
{
  if (a2 < 7 || a2 == 9)
  {
    sub_100014830(a3, 3, "Tried to set a reserved task special port: %d");
  }
  else if (a2 > 11)
  {
    sub_100014830(a3, 3, "Bogus TaskSpecialPort number: %d");
  }
  else
  {
    *(_DWORD *)(a1 + 80) = a2;
  }
}

void sub_100046E3C(uint64_t a1)
{
  mach_port_name_t right;

  right = xpc_mach_send_get_right(*(_QWORD *)(a1 + 32));
  if (sub_10000D994(right, 0, *(_QWORD *)(a1 + 40)))
    _os_assumes_log_ctx(sub_100045814, *(_QWORD *)(a1 + 48));
  xpc_release(*(xpc_object_t *)(a1 + 32));
  sub_10001962C(*(void **)(a1 + 48));
}

uint64_t sub_100046EA0(uint64_t a1)
{
  void *context;

  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  return (*((uint64_t (**)(void *, _QWORD, _QWORD))context + 18))(context, 0, *((_QWORD *)context + 19));
}

void sub_100046EC0(uint64_t a1)
{
  void *context;

  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  sub_10001962C(context);
  xpc_release(*(xpc_object_t *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void sub_100046F00(uint64_t a1)
{
  void *context;

  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  *((_WORD *)context + 80) = *((_WORD *)context + 80) & 0xFFDE | 0x20;
  sub_100019580(context);
  (*((void (**)(void *, uint64_t, _QWORD))context + 18))(context, 1, *((_QWORD *)context + 19));
  dispatch_source_cancel(*((dispatch_source_t *)context + 15));
  *((_QWORD *)context + 15) = 0;
  sub_10001962C(context);
}

void sub_100046F70(uint64_t a1)
{
  void *context;

  context = dispatch_get_context(*(dispatch_object_t *)(a1 + 32));
  sub_10001962C(context);
  xpc_release(*(xpc_object_t *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t sub_100046FB0(uint64_t a1)
{
  return os_parse_boot_arg_from_buffer_string(qword_100072938, a1, 0, 0);
}

char *sub_100046FC8()
{
  BOOL v0;
  uint8_t *v1;
  char *v2;
  char *v3;
  uint64_t v4;
  char v5;
  char *v6;
  BOOL v7;
  uint64_t v8;
  char *v9;
  const char *v10;
  unint64_t v11;
  int v12;
  xpc_object_t value;
  uint64_t v14;
  xpc_object_t v15;
  uint64_t v16;
  xpc_object_t v17;
  uint64_t v18;
  xpc_object_t v19;
  xpc_object_t v20;
  xpc_object_t v21;
  xpc_object_t v22;
  xpc_object_t v23;
  xpc_object_t v24;
  char *result;
  unint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  xpc_object_t v29;
  uint32_t bufsize;
  char *__str;
  size_t v32;
  int v33;
  size_t v34;
  int v35;
  uint64_t v36;

  if (sub_10003FCE8("kern.bootargs", (char **)&qword_100072938))
    v0 = qword_100072938 == 0;
  else
    v0 = 1;
  if (v0)
    sub_10003E208("no bootargs string");
  v1 = sub_10003BC00(0, "__TEXT", "__config");
  qword_100072940 = (uint64_t)v1;
  if (!v1 || xpc_get_type(v1) != (xpc_type_t)&_xpc_type_dictionary)
    sub_10003E208("launchd built improperly: no __TEXT,__config");
  byte_100072A80 = getenv("XPC_USERSPACE_REBOOTED") != 0;
  byte_100072A66 = os_variant_has_internal_content("com.apple.libxpc.launchd");
  if (sub_10001578C((char *)qword_100072938, "rd=md0")
    || sub_10001114C("Restore")
    || sub_10001114C("Ramdisk")
    || sub_10001114C("RamDisk"))
  {
    byte_100072A63 = 1;
    byte_100072A64 = 1;
  }
  if (byte_100072A65 && byte_100072A80)
    sub_10003E208("after the userspace reboot, os_variant_is_basesystem() should not be true");
  if (byte_100072A61)
  {
    byte_100072A63 = 0;
    byte_100072A65 = 0;
    byte_100072A64 = 0;
  }
  if (os_variant_is_darwinos("com.apple.libxpc.launchd"))
    byte_100072A64 = 0;
  v2 = (char *)qword_100072938;
  byte_100072A68 = strstr((char *)qword_100072938, "-v") != 0;
  v3 = strstr(v2, "-no-corpses");
  byte_100072AB8 = v3 != 0;
  if (v3)
  {
    if (_os_alloc_once_table[2] == -1)
    {
      v4 = _os_alloc_once_table[3];
      v5 = 1;
    }
    else
    {
      v4 = _os_alloc_once(&_os_alloc_once_table[2], 216, 0);
      v5 = byte_100072AB8;
      v2 = (char *)qword_100072938;
    }
    *(_BYTE *)(v4 + 42) = v5;
  }
  qword_100072AA8 = sub_10003FF9C(v2, "launchd_force_data_status=", 0);
  byte_100071AC4 = sub_10003FF9C((char *)qword_100072938, "launchd_proxyless_spawn=", 1) != 0;
  qword_100072A70 = sub_10003FF9C((char *)qword_100072938, "launchd_instance_limit=", 0);
  byte_100072A81 = sub_100040008((char *)qword_100072938, "launchd_usr_abandon_unmanaged=") != 0;
  byte_100072A82 = sub_100040008((char *)qword_100072938, "launchd_verbose_coalition_logs=") != 0;
  if (sub_10001578C((char *)qword_100072938, "launchd_upward_connections_support="))
    byte_100072A90 = sub_100040008((char *)qword_100072938, "launchd_upward_connections_support=") != 0;
  byte_100072A60 = sub_10003FF9C((char *)qword_100072938, "launchd_workload_properties_disabled=", 0) != 0;
  v6 = (char *)qword_100072938;
  if (strstr((char *)qword_100072938, "launchd_automation="))
  {
    byte_100072A67 = sub_100040008(v6, "launchd_automation=") != 0;
    v6 = (char *)qword_100072938;
  }
  else if (strstr(v6, "BATS_TESTPLAN_ID="))
  {
    byte_100072A67 = 1;
  }
  if (sub_10001578C(v6, "launch_prob_guard_self="))
  {
    v7 = sub_100040008((char *)qword_100072938, "launch_prob_guard_self=") != 0;
    qword_100072A98 = (uint64_t)xpc_BOOL_create(v7);
  }
  if (sub_10001578C((char *)qword_100072938, "launch_prob_guard_sample_rate_self="))
  {
    v8 = sub_100040008((char *)qword_100072938, "launch_prob_guard_sample_rate_self=");
    qword_100072AA0 = (uint64_t)xpc_uint64_create(v8);
  }
  sub_100004520(qword_100072938, (uint64_t (*)(const char *, void **))sub_10003FCE8);
  v33 = 0;
  v32 = 4;
  sysctlbyname("kern.minimalboot", &v33, &v32, 0, 0);
  if (v33)
    byte_1000729F0 = 1;
  __str = 0;
  if (sub_10003FCE8("kern.osrelease", &__str))
    qword_100072A20 = strtoul(__str, 0, 0);
  free(__str);
  bufsize = 1024;
  _NSGetExecutablePath(byte_100072AE0, &bufsize);
  v9 = strrchr(byte_100072AE0, 47);
  v10 = "launchd";
  if (v9)
    v10 = v9 + 1;
  qword_100072A18 = (uint64_t)v10;
  byte_100072AB9 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "LogServiceLifecycle");
  byte_100072ABB = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "LogIPC");
  sub_100048118(&byte_100072ABA, "LogToConsole", "launchd_log_serial=");
  byte_100072A7B = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "UseGuardMalloc");
  byte_100072A7C = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "UseNanoAllocator");
  byte_100072A7D = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "AbortOnUnknownIPC");
  byte_100072A7E = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "RequireDomainBinding");
  byte_100072A69 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "LogToFlatFile");
  sub_10004818C(&qword_100071AB8, "LogFileMaxSize");
  sub_1000481DC(&dword_100071AC0, "LogFileVerboseMetaLimit", "launchd_log_verbose_meta_limit=");
  byte_100072A78 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "LogAllBootstrapErrors");
  byte_100072A79 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "PureOnDemand");
  if (!qword_100072A70)
  {
    v36 = 0;
    sub_10004818C(&v36, "MultipleInstanceLimit");
    v11 = v36;
    if (v36 <= 0)
    {
      v35 = 0;
      v34 = 4;
      v12 = sysctlbyname("kern.maxproc", &v35, &v34, 0, 0);
      if (v12)
        sub_10004D778(v12);
      if (v35 <= 0)
        sub_10004D74C();
      v11 = (unint64_t)v35 >> 1;
    }
    qword_100072A70 = v11;
  }
  sub_1000481DC(&dword_100071A90, "SIGTERMTimeout", 0);
  sub_1000481DC(&dword_100071A94, "SIGKILLTimeout", 0);
  byte_100072A44 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "CrashOnSIGTERMTimeout");
  if ((os_variant_has_internal_diagnostics("com.apple.libxpc.launchd") & 1) == 0)
    byte_100072A44 = 0;
  byte_100072AC8 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "ExtensionWatchdog");
  sub_1000481DC(&dword_100071A98, "ExtensionWatchdogTimeout", 0);
  sub_1000481DC(&dword_100071A9C, "ShutdownTimeout", 0);
  sub_1000481DC(&dword_100071AB4, "HighWatermark", 0);
  v36 = 0;
  if (os_parse_boot_arg_from_buffer_int(qword_100072938, "max_task_pmem", &v36) && !v36)
    dword_100071AB4 = -1;
  byte_100072A47 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "DisableAllMemoryLimit");
  byte_100072A48 = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, "DisableExtensionMemoryLimit");
  if (os_variant_allows_internal_security_policies("com.apple.libxpc.launchd")
    && !access("/usr/local/share/launchd-disable-memory-limits", 0))
  {
    byte_100072A47 = 1;
  }
  sub_1000481DC(&dword_100071AB0, "SyncInterval", "launchd_sync_interval=");
  value = xpc_dictionary_get_value((xpc_object_t)qword_100072940, "Bootstrap");
  if (value)
  {
    v14 = (uint64_t)value;
    if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_dictionary)
      qword_100072948 = v14;
  }
  sub_100048118(&byte_100072A45, "SuddenShutdown", "launchd_sudden_shutdown=");
  sub_100048118(&byte_100072A46, "ServiceStubsDisabled", "launch_service_stubs_disabled=");
  if (sub_10003FF9C((char *)qword_100072938, "launchd_disable_all_timeouts=", 0))
  {
    dword_100071A94 = 600;
    byte_100072AC8 = 0;
    dword_100071A9C = 0;
    dword_100072EE0 = 0;
  }
  if (!qword_100072948)
    goto LABEL_77;
  v15 = xpc_dictionary_get_value((xpc_object_t)qword_100072948, "Paths");
  if (v15)
  {
    v16 = (uint64_t)v15;
    if (xpc_get_type(v15) == (xpc_type_t)&_xpc_type_array)
      qword_100072A30 = v16;
  }
  v17 = xpc_dictionary_get_value((xpc_object_t)qword_100072948, "UserPaths");
  if (v17)
  {
    v18 = (uint64_t)v17;
    if (xpc_get_type(v17) == (xpc_type_t)&_xpc_type_array)
      qword_100072A38 = v18;
  }
  v19 = sub_100047F70();
  v20 = v19;
  if (byte_100072A65)
  {
    if (!v19)
      v20 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_string(v20, "__OSINSTALL_ENVIRONMENT", "1");
  }
  if (v20)
    xpc_dictionary_apply_f(v20);
  v21 = xpc_dictionary_get_value((xpc_object_t)qword_100072948, "ChildDefaults");
  if (v21)
  {
    v22 = v21;
    if (xpc_get_type(v21) == (xpc_type_t)&_xpc_type_dictionary)
      xpc_dictionary_apply_f(v22);
  }
  v23 = sub_100047F1C();
  if (v23)
  {
    v24 = v23;
    result = (char *)xpc_dictionary_get_count(v23);
    v26 = (unint64_t)(result + 2);
    v27 = (unint64_t)result >= 0xFFFFFFFFFFFFFFFELL;
    if (v27 << 63 >> 63 != v27 || v27 | (v26 >> 61))
    {
      __break(1u);
      return result;
    }
    qword_100072A28 = (uint64_t)sub_10001389C(8 * v26);
    v36 = 1;
    *(_QWORD *)qword_100072A28 = "XPC_FLAGS=0x0000000000000000";
    xpc_dictionary_apply_f(v24);
    *(_QWORD *)(qword_100072A28 + 8 * v36) = 0;
  }
  else
  {
LABEL_77:
    v28 = sub_10001389C(0x10uLL);
    qword_100072A28 = (uint64_t)v28;
    *v28 = "XPC_FLAGS=0x0000000000000000";
    v28[1] = 0;
  }
  if (!qword_100072940)
  {
    qword_100072AC0 = 0;
    goto LABEL_89;
  }
  v29 = xpc_dictionary_get_value((xpc_object_t)qword_100072940, "Boot");
  qword_100072AC0 = (uint64_t)v29;
  if (!v29 || (result = (char *)xpc_get_type(v29), result != (char *)&_xpc_type_dictionary))
LABEL_89:
    sub_10003E208("no boot tasks");
  return result;
}

xpc_object_t sub_1000479B8(char *key)
{
  xpc_object_t result;

  result = (xpc_object_t)qword_100072940;
  if (qword_100072940)
    return xpc_dictionary_get_value((xpc_object_t)qword_100072940, key);
  return result;
}

void *sub_1000479D0()
{
  void *result;
  FTS *v1;
  FTS *v2;
  FTSENT *v3;
  FTSENT *v4;
  uint64_t v5;
  int fts_info;
  _copyfile_state *v7;
  int v8;
  int *v9;
  const char *v10;
  int *v11;
  uint64_t v12;
  stat v13;
  char to[1024];
  char from[1024];
  char *v16[2];
  char __str[1024];

  if (!byte_100072A63)
  {
    bzero(__str, 0x400uLL);
    snprintf(__str, 0x400uLL, "%s/disabled.migrated", off_100071A78[0]);
    memset(&v13, 0, sizeof(v13));
    if (stat(__str, &v13))
    {
      *(_OWORD *)v16 = off_10006D730;
      v1 = fts_open(v16, 92, 0);
      if (v1)
      {
        v2 = v1;
        v3 = fts_read(v1);
        if (v3)
        {
          v4 = v3;
          v5 = 0;
          do
          {
            fts_info = v4->fts_info;
            if (fts_info == 6)
            {
              --v5;
            }
            else if (fts_info == 1)
            {
              if (v5)
                fts_set(v2, v4, 4);
              bzero(from, 0x400uLL);
              bzero(to, 0x400uLL);
              if (!strcmp(v4->fts_name, "com.apple.launchd"))
              {
                snprintf(from, 0x400uLL, "%s/overrides.plist", v4->fts_path);
                snprintf(to, 0x400uLL, "%s/disabled.plist", off_100071A78[0]);
                v7 = copyfile_state_alloc();
                if (copyfile(from, to, v7, 8u) == -1)
                  sub_10004D870();
                if (copyfile_state_free(v7) == -1)
                  sub_10004D870();
              }
              ++v5;
            }
            v4 = fts_read(v2);
          }
          while (v4);
        }
        if (fts_close(v2) == -1)
          sub_10004D83C();
      }
      else
      {
        v8 = *__error();
        v9 = __error();
        v10 = (const char *)xpc_strerror(*v9);
        sub_100040F68(4, "failed to fts_open(/private/var/db/launchd.db, 0x%x): %d: %s", 92, v8, v10);
      }
      v11 = (int *)open(__str, 512, 438);
      if ((_DWORD)v11 == -1)
      {
        if (*__error() != 30)
        {
          v12 = *__error();
          if ((_DWORD)v12)
            _os_assumes_log(v12);
        }
      }
      else
      {
        sub_10003BAF4(v11);
      }
    }
  }
  qword_100072950 = (uint64_t)sub_100015630("%s/disabled.plist", off_100071A78[0]);
  result = sub_10003BB38((const char *)qword_100072950);
  qword_100072958 = (uint64_t)result;
  if (!result)
  {
    result = xpc_dictionary_create(0, 0, 0);
    qword_100072958 = (uint64_t)result;
  }
  return result;
}

void sub_100047C90()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  xpc_object_t value;
  void *v5;
  int is_darwinos;
  const char *v7;
  char v8[1032];

  v0 = sub_10003BB38("/private/etc/com.apple.xpc.launchd.limits.plist");
  if (v0)
  {
    v1 = v0;
    xpc_dictionary_apply_f(v0);
    xpc_release(v1);
  }
  qword_100072AB0 = (uint64_t)sub_1000431D8();
  v2 = sub_10003BB38("/System/Library/UserManagement/com.apple.xpc.launchd.personas.plist");
  if (v2)
  {
    v3 = v2;
    value = xpc_dictionary_get_value(v2, "SystemPersonaServices");
    if (value)
    {
      v5 = value;
      if (xpc_get_type(value) == (xpc_type_t)&_xpc_type_array)
        xpc_array_apply(v5, &stru_10006D760);
    }
    xpc_release(v3);
  }
  bzero(&v8[52], 0x3CCuLL);
  strcpy(v8, "/System/Library/xpc/foreground_user_endpoints.plist");
  qword_100072A88 = (uint64_t)sub_10003BB38(v8);
  sub_10003FCE8("hw.targettype", (char **)&qword_100072A50);
  is_darwinos = os_variant_is_darwinos("com.apple.xpc.launchd");
  v7 = (const char *)&unk_100056F87;
  if (is_darwinos)
    v7 = ".darwin";
  qword_100072A58 = (uint64_t)v7;
  sub_10000ED1C();
}

void *sub_100047DF8(char *a1, xpc_object_t object)
{
  xpc_object_t value;
  void *result;
  int64_t v5;
  char *v6;
  int64_t v7;
  xpc_object_t v8;
  xpc_object_t v9;
  int64_t v10;

  value = object;
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_int64)
    goto LABEL_6;
  result = xpc_get_type(value);
  if (result != &_xpc_type_array)
    return result;
  if (xpc_array_get_count(value) == 1)
  {
    value = xpc_array_get_value(value, 0);
    result = xpc_get_type(value);
    if (result == &_xpc_type_int64)
    {
LABEL_6:
      v5 = xpc_int64_get_value(value);
      v6 = a1;
      v7 = v5;
      return (void *)sub_1000402F8(v6, v5, v7, 0);
    }
  }
  else
  {
    result = (void *)xpc_array_get_count(value);
    if (result == (void *)2)
    {
      v8 = xpc_array_get_value(value, 0);
      v9 = xpc_array_get_value(value, 1uLL);
      result = xpc_get_type(v8);
      if (result == &_xpc_type_int64)
      {
        result = xpc_get_type(v9);
        if (result == &_xpc_type_int64)
        {
          v10 = xpc_int64_get_value(v8);
          v7 = xpc_int64_get_value(v9);
          v6 = a1;
          v5 = v10;
          return (void *)sub_1000402F8(v6, v5, v7, 0);
        }
      }
    }
  }
  return result;
}

xpc_object_t sub_100047F1C()
{
  xpc_object_t value;
  xpc_object_t v1;

  if (!qword_100072948)
    return 0;
  value = xpc_dictionary_get_value((xpc_object_t)qword_100072948, "Self");
  if (!value)
    return 0;
  v1 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    return 0;
  return v1;
}

xpc_object_t sub_100047F70()
{
  xpc_object_t value;
  xpc_object_t v1;

  if (!qword_100072948)
    return 0;
  value = xpc_dictionary_get_value((xpc_object_t)qword_100072948, "Child");
  if (!value)
    return 0;
  v1 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    return 0;
  return v1;
}

uint64_t sub_100047FC4()
{
  return qword_100072958;
}

uint64_t sub_100047FD0(uint64_t a1, char *__str)
{
  uint64_t result;

  result = snprintf(__str, 0x40uLL, "XPC_FLAGS=0x%llx", a1);
  *(_QWORD *)qword_100072A28 = __str;
  return result;
}

void sub_100048018()
{
  void *v0;
  const char *v1;
  xpc_object_t v2;
  char *v3;
  NSObject *v4;
  _QWORD v5[6];

  v0 = (void *)qword_100072958;
  if (qword_100072958)
  {
    v1 = (const char *)qword_100072950;
    if (xpc_dictionary_get_BOOL((xpc_object_t)qword_100072958, "_dirty"))
    {
      xpc_dictionary_set_value(v0, "_dirty", 0);
      v2 = xpc_copy(v0);
      v3 = sub_10001544C(v1);
      v4 = sub_1000146FC();
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 0x40000000;
      v5[2] = sub_100048404;
      v5[3] = &unk_10006D780;
      v5[4] = v2;
      v5[5] = v3;
      dispatch_async(v4, v5);
    }
  }
}

void sub_1000480C8()
{
  NSObject *v0;

  sub_100048018();
  v0 = sub_1000146FC();
  dispatch_sync(v0, &stru_10006D710);
}

uint64_t sub_1000480EC(char *key)
{
  uint64_t result;

  if (byte_100072A90)
    return 1;
  result = qword_100072A88;
  if (qword_100072A88)
    return xpc_dictionary_get_BOOL((xpc_object_t)qword_100072A88, key);
  return result;
}

BOOL sub_100048118(_BYTE *a1, char *key, char *__s2)
{
  char *v6;
  _BOOL8 result;

  if (__s2 && (v6 = (char *)qword_100072938, strstr((char *)qword_100072938, __s2)))
    result = sub_100040008(v6, __s2) != 0;
  else
    result = xpc_dictionary_get_BOOL((xpc_object_t)qword_100072940, key);
  *a1 = result;
  return result;
}

void *sub_10004818C(_QWORD *a1, const char *a2)
{
  void *result;
  void *v4;

  result = xpc_dictionary_get_value((xpc_object_t)qword_100072940, a2);
  if (result)
  {
    v4 = result;
    result = xpc_get_type(result);
    if (result == &_xpc_type_int64)
    {
      result = (void *)xpc_int64_get_value(v4);
      *a1 = result;
    }
  }
  return result;
}

void *sub_1000481DC(_DWORD *a1, char *key, char *__s2)
{
  char *v6;
  void *result;
  void *v8;

  if (__s2)
  {
    v6 = (char *)qword_100072938;
    if (strstr((char *)qword_100072938, __s2))
    {
      result = (void *)sub_100040008(v6, __s2);
LABEL_7:
      *a1 = (_DWORD)result;
      return result;
    }
  }
  result = xpc_dictionary_get_value((xpc_object_t)qword_100072940, key);
  if (result)
  {
    v8 = result;
    result = xpc_get_type(result);
    if (result == &_xpc_type_int64)
    {
      result = (void *)xpc_int64_get_value(v8);
      goto LABEL_7;
    }
  }
  return result;
}

_QWORD *sub_10004826C(char *a1, xpc_object_t object, uint64_t a3)
{
  _QWORD *result;
  const char *string_ptr;
  uint64_t *v8;
  uint64_t v9;
  size_t v10;

  result = xpc_get_type(object);
  if (result == (_QWORD *)&_xpc_type_string)
  {
    v10 = 0;
    string_ptr = xpc_string_get_string_ptr(object);
    result = sub_10001967C(a1, string_ptr, 0, &v10, 1);
    if (result)
    {
      if (a3)
        v8 = &qword_100072AD8;
      else
        v8 = &qword_100072AD0;
      v9 = *v8;
      *result = *v8;
      if (v9)
        *(_QWORD *)(v9 + 8) = result;
      *v8 = (uint64_t)result;
      result[1] = v8;
    }
  }
  return result;
}

uint64_t sub_100048314(const char *a1, xpc_object_t object, uint64_t *a3)
{
  uint64_t result;
  const char *string_ptr;
  uint64_t v8;

  result = (uint64_t)xpc_get_type(object);
  if ((_UNKNOWN *)result == &_xpc_type_string)
  {
    result = strcmp(a1, "MallocStackLogging");
    if ((_DWORD)result)
    {
      string_ptr = xpc_string_get_string_ptr(object);
      result = (uint64_t)sub_100015630("%s=%s", a1, string_ptr);
      v8 = *a3;
      *(_QWORD *)(qword_100072A28 + 8 * *a3) = result;
      *a3 = v8 + 1;
    }
  }
  return result;
}

BOOL sub_1000483A4(id a1, unint64_t a2, void *a3)
{
  uint64_t v4;
  const char *string_ptr;

  if (a3 && xpc_get_type(a3) == (xpc_type_t)&_xpc_type_string)
  {
    v4 = qword_100072AB0;
    string_ptr = xpc_string_get_string_ptr(a3);
    sub_100043048(v4, string_ptr, &_xpc_BOOL_true);
  }
  return 1;
}

void sub_100048404(uint64_t a1)
{
  void *v2;
  FILE *v3;
  FILE *v4;
  const char *v5;
  uint64_t v6;

  v2 = *(void **)(a1 + 32);
  v3 = fopen(*(const char **)(a1 + 40), "w");
  if (v3)
  {
    v4 = v3;
    fprintf(v3, "%s\n", "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n<plist version=\"1.0\">");
    if (xpc_dictionary_get_count(v2))
    {
      fwrite("<dict>\n", 7uLL, 1uLL, v4);
      xpc_dictionary_apply_f(v2);
      v5 = "</dict>\n";
    }
    else
    {
      v5 = "<dict/>\n";
    }
    fwrite(v5, 8uLL, 1uLL, v4);
    fwrite("</plist>\n", 9uLL, 1uLL, v4);
    sub_10003BC70(v4);
  }
  else
  {
    v6 = *__error();
    if ((_DWORD)v6)
      _os_assumes_log(v6);
  }
  xpc_release(*(xpc_object_t *)(a1 + 32));
  free(*(void **)(a1 + 40));
}

void *sub_1000484FC(char *a1, xpc_object_t object, FILE *a3)
{
  xpc_object_t v4;
  void *result;
  const char *string_ptr;
  const char *v8;
  size_t v9;

  v4 = object;
  if (xpc_get_type(object) != (xpc_type_t)&_xpc_type_dictionary
    || (result = xpc_dictionary_get_value(v4, "Disabled"), (v4 = result) != 0))
  {
    if (xpc_get_type(v4) == (xpc_type_t)&_xpc_type_BOOL || (result = xpc_get_type(v4), result == &_xpc_type_string))
    {
      result = strchr(a1, 60);
      if (!result)
      {
        fprintf(a3, "\t<key>%s</key>\n", a1);
        if (v4 == &_xpc_BOOL_true)
        {
          v8 = "\t<true/>\n";
          v9 = 9;
        }
        else
        {
          if (v4 != &_xpc_BOOL_false)
          {
            string_ptr = xpc_string_get_string_ptr(v4);
            return (void *)fprintf(a3, "\t<string>%s</string>\n", string_ptr);
          }
          v8 = "\t<false/>\n";
          v9 = 10;
        }
        return (void *)fwrite(v8, v9, 1uLL, a3);
      }
    }
  }
  return result;
}

uint64_t (*sub_10004862C(uint64_t a1))()
{
  int v1;

  v1 = *(_DWORD *)(a1 + 20);
  if ((v1 - 73) >= 0xFFFFFFF7)
    return off_10006D7A0[5 * (v1 - 64) + 5];
  else
    return 0;
}

_DWORD *sub_100048660(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = (_DWORD *)sub_1000443A4();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  return result;
}

uint64_t *sub_1000486C0(uint64_t *result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) != 0 && *((_DWORD *)result + 6) == 1 && *((_DWORD *)result + 1) == 40)
  {
    if (*((unsigned __int16 *)result + 19) << 16 == 0x100000)
    {
      result = sub_1000443C8(*((unsigned int *)result + 3), *((_DWORD *)result + 7));
      *(_DWORD *)(a2 + 32) = (_DWORD)result;
      return result;
    }
    v3 = -300;
  }
  else
  {
    v3 = -304;
  }
  *(_DWORD *)(a2 + 32) = v3;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100048744(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = (_DWORD *)sub_10004449C();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  return result;
}

_DWORD *sub_1000487A4(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = (_DWORD *)sub_1000444C0();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  return result;
}

_DWORD *sub_1000487FC(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = (_DWORD *)sub_1000444E4();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  return result;
}

uint64_t sub_10004885C(_DWORD *a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  void (*v5)(void);
  uint64_t result;

  v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  v4 = a1[5];
  if ((v4 - 73) >= 0xFFFFFFF7
    && (v5 = (void (*)(void))off_10006D7A0[5 * (v4 - 64) + 5]) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    result = 0;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t sub_1000488E4(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 20);
  if ((v1 - 440) >= 0xFFFFFFD8)
    return (uint64_t)*(&off_10006D928 + 5 * (v1 - 400) + 5);
  else
    return 0;
}

_DWORD *sub_100048918(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 552 || (result = memchr(result + 8, 0, 0x200uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(_QWORD *)(a2 + 32) = 0x14000000000000;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_1000489D0(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 40)
  {
    *(_DWORD *)(a2 + 32) = -304;
  }
  else
  {
    result = (_DWORD *)sub_10000FE74();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100048A30(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 168 || (result = memchr(result + 8, 0, 0x80uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(_QWORD *)(a2 + 32) = 0x10000000000000;
  result = (_DWORD *)sub_10000FE7C();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(NDR_record_t *)(a2 + 40) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 64;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_100048AF8(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 184)
    goto LABEL_7;
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    v3 = -300;
    goto LABEL_8;
  }
  result = (uint64_t)memchr((void *)(result + 48), 0, 0x80uLL);
  if (!result)
  {
LABEL_7:
    v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  result = sub_10000FE7C();
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100048BA4(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 188 || (result = memchr(result + 8, 0, 0x80uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(_QWORD *)(a2 + 32) = 0x13000000000000;
  result = (_DWORD *)sub_10000FE8C();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100048C60(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) == 0 && result[1] == 164 && (result = memchr(result + 8, 0, 0x80uLL)) != 0)
  {
    result = (_DWORD *)sub_10000FE74();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  else
  {
    *(_DWORD *)(a2 + 32) = -304;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100048CE4(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_QWORD *)(a2 + 32) = 0x14000000000000;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_100048D70(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 40)
  {
    v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    v3 = -300;
    goto LABEL_8;
  }
  *(_QWORD *)(a2 + 32) = 0x13000000000000;
  result = sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_9:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100048E24(_DWORD *result, uint64_t a2)
{
  int v3;

  if ((*result & 0x80000000) != 0 || result[1] != 40)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  *(_DWORD *)(a2 + 52) = 16777473;
  *(_DWORD *)(a2 + 68) = 16777473;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  v3 = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 84) << 7;
  *(_DWORD *)(a2 + 56) = v3 << 7;
  *(_DWORD *)(a2 + 72) = 4 * *(_DWORD *)(a2 + 92);
  *(NDR_record_t *)(a2 + 76) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 96;
  *(_DWORD *)(a2 + 24) = 3;
  return result;
}

uint64_t sub_100048F00(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 40)
  {
    v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    v3 = -300;
    goto LABEL_8;
  }
  *(_QWORD *)(a2 + 32) = 0x14000000000000;
  result = sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_9:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100048FB4(_DWORD *result, uint64_t a2)
{
  int v3;

  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 96) = 0;
  *(_QWORD *)(a2 + 32) = 0x11000000000000;
  *(_QWORD *)(a2 + 44) = 0x10000000000000;
  *(_DWORD *)(a2 + 60) = 16777473;
  *(_DWORD *)(a2 + 76) = (*(unsigned __int8 *)(a2 + 77) << 8) | 0x2110001;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  v3 = *(_DWORD *)(a2 + 96);
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 92);
  *(_DWORD *)(a2 + 80) = v3;
  *(NDR_record_t *)(a2 + 84) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 100;
  *(_DWORD *)(a2 + 24) = 4;
  return result;
}

_DWORD *sub_10004909C(_DWORD *result, uint64_t a2)
{
  NDR_record_t v3;

  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    v3 = NDR_record;
  }
  else
  {
    result = (_DWORD *)sub_10000FE74();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 164;
      return result;
    }
  }
  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_100049114(_DWORD *result, uint64_t a2)
{
  NDR_record_t v3;

  if ((*result & 0x80000000) != 0 || result[1] != 48)
  {
    *(_DWORD *)(a2 + 32) = -304;
    v3 = NDR_record;
  }
  else
  {
    result = (_DWORD *)sub_10000FE7C();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 44;
      return result;
    }
  }
  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_100049198(_DWORD *result, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  BOOL v5;
  unsigned int v6;
  BOOL v7;

  if ((*result & 0x80000000) == 0
    && (v3 = result[1], v3 >= 0x30)
    && v3 <= 0x830
    && ((v4 = result[11], v4 <= 0x800) ? (v5 = (int)v3 - 48 >= v4) : (v5 = 0),
        (v6 = ((v4 + 3) & 0xFFFFFFFC) + 48, v5) ? (v7 = (_DWORD)v3 == v6) : (v7 = 0),
        v7 && (result = memchr(result + 12, 0, v3 - 48)) != 0))
  {
    result = (_DWORD *)sub_10000FE74();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
  }
  else
  {
    *(_DWORD *)(a2 + 32) = -304;
  }
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_100049248(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_QWORD *)(a2 + 32) = 0x13000000000000;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_1000492D8(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 196)
    goto LABEL_8;
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
  {
    v3 = -300;
    goto LABEL_9;
  }
  result = (uint64_t)memchr((void *)(result + 60), 0, 0x80uLL);
  if (!result)
  {
LABEL_8:
    v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  result = sub_10000FE74();
  *(_DWORD *)(a2 + 32) = result;
LABEL_10:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_100049398(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    v3 = -304;
LABEL_9:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_10;
  }
  if (*(_BYTE *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 60))
  {
    v3 = -300;
    goto LABEL_9;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_10:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_10004947C(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 36) = 16777473;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_100049524(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 56)
  {
    v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  if (*(_BYTE *)(result + 39) != 1 || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 52))
  {
    v3 = -300;
    goto LABEL_8;
  }
  result = sub_10000FE74();
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

_DWORD *sub_1000495B4(_DWORD *result, uint64_t a2)
{
  NDR_record_t v3;

  if ((*result & 0x80000000) == 0 && result[1] == 164 && (result = memchr(result + 8, 0, 0x80uLL)) != 0)
  {
    result = (_DWORD *)sub_10000FE74();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 40;
      return result;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 32) = -304;
    v3 = NDR_record;
  }
  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_100049658(_DWORD *result, uint64_t a2)
{
  int v3;

  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 84) = 0;
  *(_DWORD *)(a2 + 36) = (*(unsigned __int8 *)(a2 + 37) << 8) | 0x2110001;
  *(_DWORD *)(a2 + 52) = 16777473;
  *(_DWORD *)(a2 + 68) = 16777473;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  v3 = *(_DWORD *)(a2 + 88);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 84);
  *(_DWORD *)(a2 + 56) = v3 << 7;
  *(_DWORD *)(a2 + 72) = 4 * *(_DWORD *)(a2 + 92);
  *(NDR_record_t *)(a2 + 76) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 96;
  *(_DWORD *)(a2 + 24) = 3;
  return result;
}

uint64_t sub_10004973C(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 188)
    goto LABEL_9;
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112 || *(unsigned __int16 *)(result + 50) << 16 != 1114112)
  {
    v3 = -300;
    goto LABEL_10;
  }
  result = (uint64_t)memchr((void *)(result + 60), 0, 0x80uLL);
  if (!result)
  {
LABEL_9:
    v3 = -304;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_11;
  }
  *(_QWORD *)(a2 + 32) = 0x14000000000000;
  result = sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_11:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100049828(_DWORD *result, uint64_t a2)
{
  NDR_record_t v3;

  if ((*result & 0x80000000) != 0 || result[1] != 36)
  {
    *(_DWORD *)(a2 + 32) = -304;
    v3 = NDR_record;
  }
  else
  {
    result = (_DWORD *)sub_10000FE74();
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
    v3 = NDR_record;
    if (!(_DWORD)result)
    {
      *(NDR_record_t *)(a2 + 24) = NDR_record;
      *(_DWORD *)(a2 + 4) = 40;
      return result;
    }
  }
  *(NDR_record_t *)(a2 + 24) = v3;
  return result;
}

_DWORD *sub_1000498A8(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 160 || (result = memchr(result + 8, 0, 0x80uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(_QWORD *)(a2 + 32) = 0x14000000000000;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_100049958(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 176)
    goto LABEL_7;
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    v3 = -300;
    goto LABEL_8;
  }
  result = (uint64_t)memchr((void *)(result + 48), 0, 0x80uLL);
  if (!result)
  {
LABEL_7:
    v3 = -304;
LABEL_8:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_9;
  }
  result = sub_10000FE74();
  *(_DWORD *)(a2 + 32) = result;
LABEL_9:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_100049A00(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 1 || *(_DWORD *)(result + 4) != 64)
  {
    v3 = -304;
LABEL_7:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_8;
  }
  if (*(unsigned __int16 *)(result + 38) << 16 != 1114112)
  {
    v3 = -300;
    goto LABEL_7;
  }
  result = sub_10000FE74();
  *(_DWORD *)(a2 + 32) = result;
LABEL_8:
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t sub_100049A88(uint64_t result, uint64_t a2)
{
  int v3;

  if ((*(_DWORD *)result & 0x80000000) == 0 || *(_DWORD *)(result + 24) != 2 || *(_DWORD *)(result + 4) != 68)
  {
    v3 = -304;
LABEL_10:
    *(_DWORD *)(a2 + 32) = v3;
    goto LABEL_11;
  }
  if (*(_BYTE *)(result + 39) != 1
    || *(unsigned __int16 *)(result + 54) << 16 != 1114112
    || *(_DWORD *)(result + 40) != *(_DWORD *)(result + 64))
  {
    v3 = -300;
    goto LABEL_10;
  }
  *(_QWORD *)(a2 + 32) = 0x10000000000000;
  result = sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
LABEL_11:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(NDR_record_t *)(a2 + 40) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 52;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100049B70(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_QWORD *)(a2 + 32) = 0x11000000000000;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 40;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

void sub_100049BF8(uint64_t a1, uint64_t a2)
{
  int v4;
  int v5;
  int v6;

  if ((*(_DWORD *)a1 & 0x80000000) == 0 || *(_DWORD *)(a1 + 24) != 3 || *(_DWORD *)(a1 + 4) != 88)
  {
    v5 = -304;
LABEL_12:
    *(_DWORD *)(a2 + 32) = v5;
    goto LABEL_13;
  }
  if (*(_BYTE *)(a1 + 39) != 1
    || *(_WORD *)(a1 + 54) != 529
    || *(unsigned __int16 *)(a1 + 70) << 16 != 1114112
    || *(_DWORD *)(a1 + 40) != *(_DWORD *)(a1 + 80)
    || *(_DWORD *)(a1 + 56) != *(_DWORD *)(a1 + 84))
  {
    v5 = -300;
    goto LABEL_12;
  }
  *(_DWORD *)(a2 + 72) = 0;
  *(_DWORD *)(a2 + 36) = 16777473;
  *(_DWORD *)(a2 + 52) = (*(unsigned __int8 *)(a2 + 53) << 8) | 0x2110001;
  v4 = sub_10000FE74();
  mig_deallocate(*(_QWORD *)(a1 + 44), (4 * *(_DWORD *)(a1 + 56)));
  *(_QWORD *)(a1 + 44) = 0;
  *(_DWORD *)(a1 + 56) = 0;
  if (v4)
  {
    *(_DWORD *)(a2 + 32) = v4;
LABEL_13:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return;
  }
  v6 = *(_DWORD *)(a2 + 72);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 56) = v6;
  *(NDR_record_t *)(a2 + 60) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 76;
  *(_DWORD *)(a2 + 24) = 2;
}

_DWORD *sub_100049D64(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 24)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_6;
  }
  *(_DWORD *)(a2 + 52) = 0;
  *(_DWORD *)(a2 + 36) = (*(unsigned __int8 *)(a2 + 37) << 8) | 0x2140001;
  result = (_DWORD *)sub_10000FE74();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_6:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a2 + 52);
  *(NDR_record_t *)(a2 + 44) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

_DWORD *sub_100049E14(_DWORD *result, uint64_t a2)
{
  if ((*result & 0x80000000) != 0 || result[1] != 188 || (result = memchr(result + 8, 0, 0x80uLL)) == 0)
  {
    *(_DWORD *)(a2 + 32) = -304;
    goto LABEL_7;
  }
  *(_QWORD *)(a2 + 32) = 0x13000000000000;
  result = (_DWORD *)sub_10000FE80();
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = (_DWORD)result;
LABEL_7:
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    return result;
  }
  *(NDR_record_t *)(a2 + 40) = NDR_record;
  *(_DWORD *)a2 |= 0x80000000;
  *(_DWORD *)(a2 + 4) = 56;
  *(_DWORD *)(a2 + 24) = 1;
  return result;
}

uint64_t sub_100049EF4(_DWORD *a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  void (*v5)(void);
  uint64_t result;

  v2 = a1[2];
  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  v3 = a1[5] + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  v4 = a1[5];
  if ((v4 - 440) >= 0xFFFFFFD8
    && (v5 = (void (*)(void))*(&off_10006D928 + 5 * (v4 - 400) + 5)) != 0)
  {
    v5();
    return 1;
  }
  else
  {
    result = 0;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

uint64_t sub_100049F7C(unsigned int a1, const char *a2, _DWORD *a3)
{
  int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  mach_msg_header_t reply_port;
  NDR_record_t v13;
  _OWORD v14[8];
  uint64_t v15;

  v15 = 0;
  memset(v14, 0, sizeof(v14));
  memset(&reply_port, 0, sizeof(reply_port));
  v13 = NDR_record;
  if (&_mig_strncpy_zerofill)
    v5 = mig_strncpy_zerofill((char *)v14 + 8, a2, 128);
  else
    v5 = mig_strncpy((char *)v14 + 8, a2, 128);
  LODWORD(v14[0]) = 0;
  DWORD1(v14[0]) = v5;
  v6 = ((v5 + 3) & 0xFFFFFFFC) + 40;
  v7 = mig_get_reply_port();
  reply_port.msgh_bits = 5395;
  reply_port.msgh_size = v6;
  *(_QWORD *)&reply_port.msgh_remote_port = __PAIR64__(v7, a1);
  *(_QWORD *)&reply_port.msgh_voucher_port = 0xB4700000000;
  v8 = mach_msg2_internal(&reply_port, 0x200000003, ((unint64_t)(v6 >> 2) << 34) | 0x1513, __PAIR64__(v7, a1), 0xB4700000000, v7 << 32, 48, 0);
  v9 = v8;
  if ((v8 - 268435458) > 0xE || ((1 << (v8 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v8)
    {
      mig_dealloc_reply_port(reply_port.msgh_local_port);
      return v9;
    }
    if (reply_port.msgh_id == 71)
    {
      v9 = 4294966988;
    }
    else if (reply_port.msgh_id == 2987)
    {
      if ((reply_port.msgh_bits & 0x80000000) == 0)
      {
        if (reply_port.msgh_size == 40)
        {
          if (!reply_port.msgh_remote_port)
          {
            v9 = LODWORD(v14[0]);
            if (!LODWORD(v14[0]))
            {
              *a3 = DWORD1(v14[0]);
              return v9;
            }
            goto LABEL_24;
          }
        }
        else if (reply_port.msgh_size == 36)
        {
          if (reply_port.msgh_remote_port)
            v10 = 1;
          else
            v10 = LODWORD(v14[0]) == 0;
          if (v10)
            v9 = 4294966996;
          else
            v9 = LODWORD(v14[0]);
          goto LABEL_24;
        }
      }
      v9 = 4294966996;
    }
    else
    {
      v9 = 4294966995;
    }
LABEL_24:
    mach_msg_destroy(&reply_port);
    return v9;
  }
  mig_put_reply_port(reply_port.msgh_local_port);
  return v9;
}

uint64_t sub_10004A150(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  uint64_t result;

  v2 = *(_DWORD *)(a1 + 8);
  *(_DWORD *)a2 = *(_DWORD *)a1 & 0x1F;
  *(_DWORD *)(a2 + 4) = 36;
  v3 = *(_DWORD *)(a1 + 20) + 100;
  *(_DWORD *)(a2 + 8) = v2;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 16) = 0;
  *(_DWORD *)(a2 + 20) = v3;
  if (*(_DWORD *)(a1 + 20) == 5300)
  {
    if ((*(_DWORD *)a1 & 0x80000000) != 0 || *(_DWORD *)(a1 + 4) != 44)
    {
      *(_DWORD *)(a2 + 32) = -304;
      *(NDR_record_t *)(a2 + 24) = NDR_record;
    }
    else
    {
      *(_DWORD *)(a2 + 32) = sub_10002CD08(*(unsigned int *)(a1 + 12), *(_QWORD *)(a1 + 32));
    }
    return 1;
  }
  else
  {
    result = 0;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
  }
  return result;
}

char *sub_10004A20C(char *result, unint64_t a2, _QWORD *a3)
{
  unint64_t v3;
  char *v4;
  char *v6;
  uint64_t v7;
  char *v8;
  char *v9;
  uint64_t v10;

  *a3 = 0;
  v10 = 0;
  if (a2 <= 1 || *(_QWORD *)result != 7)
    return (char *)&unk_10006DFC8;
  v3 = (unint64_t)&result[32 * a2];
  v4 = (char *)(v3 - 32);
  if (v3 >= 0x20 && v4 >= result)
  {
    if (*(_QWORD *)v4 == 8)
    {
      v8 = result + 32;
      v9 = &result[32 * a2];
      v6 = sub_10004D420(result, (uint64_t)&v8, &v10);
      if (v6 == (char *)&unk_10006DFA8)
      {
        if (v8 == v9)
        {
          v7 = ccder_sizeof(2, 1);
          *a3 = ccder_sizeof(0x6000000000000010, v10 + v7);
        }
        else
        {
          return (char *)&unk_10006DFE8;
        }
      }
      return v6;
    }
    return (char *)&unk_10006DFC8;
  }
  __break(0x5519u);
  return result;
}

uint64_t sub_10004A2E8(uint64_t result, _BYTE *a2, unint64_t a3, uint64_t a4, unint64_t a5, unint64_t a6)
{
  void *v6;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  int v14;
  char v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  unint64_t v19;
  char *v20;
  BOOL v21;
  char *v22;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  char *v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;

  v27 = result;
  v32 = 0;
  v33 = 0;
  if (a5 <= a6)
  {
    v32 = a5;
    v33 = a6;
    v26 = a6 - a5;
    if (a6 > a5)
    {
      v11 = a3 + 32 * a4;
      v12 = (_QWORD *)(v11 - 32);
      v13 = a4;
      while (2)
      {
        if ((--v13 & 0x8000000000000000) == 0)
        {
          if ((unint64_t)(v12 + 4) <= v11 && (unint64_t)v12 >= a3)
          {
            v14 = 4;
            switch(*v12)
            {
              case 1:
                v29 = 0;
                v30 = 0;
                result = ccder_blob_reserve_tl(&v32, 1, v12[2], &v29);
                if ((result & 1) == 0 || (unint64_t)v29 >= v30)
                {
                  v6 = &unk_10006DFC8;
                  v14 = 1;
                  goto LABEL_6;
                }
                if (v12[1])
                  v15 = -1;
                else
                  v15 = 0;
                *v29 = v15;
                goto LABEL_5;
              case 2:
              case 3:
                if ((unint64_t)v12 >= v11 || v12[1] + v12[2] < v12[1])
                  goto LABEL_50;
                result = ccder_blob_encode_body_tl(&v32, 12);
                if ((result & 1) == 0)
                  return (uint64_t)&unk_10006DFC8;
                goto LABEL_5;
              case 4:
                result = sub_10004D5D0((uint64_t)&v32, v12[1]);
                if ((result & 1) != 0)
                  goto LABEL_5;
                return (uint64_t)&unk_10006DFC8;
              case 5:
                v16 = v12[2];
                v17 = 0x2000000000000010;
                goto LABEL_23;
              case 7:
                v16 = v12[2];
                v17 = 0xA000000000000010;
LABEL_23:
                result = ccder_blob_encode_tl(&v32, v17, v16);
                if ((result & 1) == 0)
                  return (uint64_t)&unk_10006DFC8;
LABEL_5:
                v14 = 4;
                goto LABEL_6;
              case 9:
                if ((unint64_t)v12 >= v11 || v12[1] + v12[2] < v12[1])
                  goto LABEL_50;
                v14 = 4;
                result = ccder_blob_encode_body_tl(&v32, 4);
                if ((result & 1) != 0)
                  goto LABEL_6;
                return (uint64_t)&unk_10006DFC8;
              default:
LABEL_6:
                v12 -= 4;
                if (v14 == 4)
                  continue;
                return (uint64_t)v6;
            }
          }
          goto LABEL_50;
        }
        break;
      }
    }
    v29 = 0;
    v30 = 0;
    result = ccder_blob_reserve_tl(&v32, 2, 1, &v29);
    if ((result & 1) == 0)
      return (uint64_t)&unk_10006DFE8;
    v18 = v29;
    v19 = v30;
    if ((char *)v30 != v29)
    {
      v20 = (char *)(v30 - 1);
      if (v30)
        v21 = v20 >= v29;
      else
        v21 = 0;
      if (!v21)
        goto LABEL_50;
      *v20 = 1;
      if (v20 != v29)
      {
        v22 = (char *)(v19 - 2);
        while ((unint64_t)v22 < v19 && v22 >= v18)
        {
          *v22 = 0;
          if (v22-- == v29)
            goto LABEL_43;
        }
        goto LABEL_50;
      }
    }
LABEL_43:
    if (a4)
    {
      v24 = ccder_sizeof(0xA000000000000010, *(_QWORD *)(a3 + 16));
      v25 = ccder_sizeof(2, 1);
      if ((ccder_blob_encode_tl(&v32, 0x6000000000000010, v25 + v24) & 1) != 0)
      {
        v29 = 0;
        v30 = 0;
        v31 = 0;
        v6 = (void *)sub_10004BEE8(v27, a2, (uint64_t *)&v29, a5, a6);
        if (v6 != &unk_10006DFA8)
          cc_clear(v26, a5);
        return (uint64_t)v6;
      }
      return (uint64_t)&unk_10006DFE8;
    }
  }
LABEL_50:
  __break(0x5519u);
  return result;
}

uint64_t sub_10004A5C8(uint64_t result, unint64_t a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(unint64_t, const char *, ...);
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  int v17;
  BOOL v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  _BOOL4 v22;
  uint64_t v23;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  size_t *v28;
  __int128 v29;
  __int128 v30;
  const void *v31;
  void **v32;
  __int128 v33;
  size_t *v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  const void *v39;
  size_t *v40;
  __int128 v41;
  __int128 v42;
  uint64_t (*v43)(unint64_t, const char *, ...);
  const char *v44;
  __int128 v45;
  __int128 v46;
  const void *v47;
  size_t *v48;
  uint64_t v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;
  __int128 v53;
  uint64_t (*v54)(unint64_t, const char *, ...);
  const char *v55;
  const char *v56;
  size_t v57;
  const void *v58;
  uint64_t (*v59)(unint64_t, const char *, ...);
  size_t v60;
  uint64_t v61;
  __int128 v62;
  uint64_t v63;
  unint64_t v64;
  BOOL v65;
  char v66;
  unint64_t v67;
  unint64_t v68;
  const void *v69;
  size_t v70;
  int v71;
  int v73;
  uint64_t (*v74)(unint64_t, const char *, ...);
  const char *v75;
  size_t v76;
  uint64_t v77;
  __int128 v78;
  size_t v79;
  uint64_t v80;
  __int128 v81;
  size_t v82;
  size_t v83;
  uint64_t (*v85)(unint64_t, const char *, ...);
  char *v87;
  char *v88;
  const void *v89;
  char *v90;
  _BYTE *v91;
  void *v93;
  uint64_t v94;
  uint64_t v95;
  unsigned __int8 *v96;
  uint64_t (*v97)(unint64_t, const char *, ...);
  const char *v98;
  __int128 v99;
  uint64_t (*v100)(uint64_t *);
  __int128 v101;
  uint64_t (*v102)(unint64_t, const char *, ...);
  const char *v103;
  size_t v104;
  char v105;
  __int128 v106;
  unint64_t v107;
  unint64_t v108;
  __int128 v110;
  _BYTE *v111;
  size_t *v112;
  size_t v113;
  void (*v114)(unint64_t, const char *, ...);
  void (*v115)(unint64_t, const char *, ...);
  __int128 v116;
  uint64_t v117;
  uint64_t v118;
  unsigned __int8 *v119;
  BOOL v120;
  void (*v121)(unint64_t, const char *, ...);
  uint64_t v122;
  uint64_t v123;
  void *__s1;
  __int128 v125;
  void *__s2;
  size_t v127;
  __int128 v128;
  void *v129[2];
  uint64_t v130[4];
  __int128 v131;
  __int128 v132;
  __int128 v133;
  uint64_t v134;

  v4 = result;
  if (!*(_BYTE *)(a2 + 33))
  {
LABEL_6:
    v10 = *(_OWORD *)(a2 + 16);
    *(_OWORD *)v4 = *(_OWORD *)a2;
    *(_OWORD *)(v4 + 16) = v10;
    *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 32);
    v11 = *(_QWORD *)(a2 + 48);
LABEL_7:
    *(_QWORD *)(v4 + 48) = v11;
    return result;
  }
  v6 = *(_QWORD *)a2;
  v7 = *(_QWORD *)a2 + 64;
  v8 = *(_QWORD *)a3;
  switch(*(_QWORD *)a3 & 0xBFFFFFFFFFFFFFFFLL)
  {
    case 0uLL:
      v9 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v9)
        goto LABEL_6;
      if (v6 >= v7)
        goto LABEL_317;
      result = v9(v6, "[%s]: %s\n", "der_vm_execute_nocopy", "noop");
      goto LABEL_6;
    case 1uLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v33 = *(_OWORD *)(a2 + 16);
      v131 = *(_OWORD *)a2;
      v132 = v33;
      LOBYTE(v133) = *(_BYTE *)(a2 + 32);
      *(_OWORD *)v130 = *(_OWORD *)(a2 + 34);
      *(uint64_t *)((char *)&v130[1] + 6) = *(_QWORD *)(a2 + 48);
      *((_QWORD *)&v131 + 1) = 0;
      *(_QWORD *)&v132 = 0;
      if ((v8 & 0x4000000000000000) != 0)
      {
        __s1 = *(void **)(a3 + 8);
        v34 = (size_t *)(a3 + 16);
      }
      else
      {
        __s1 = (void *)(a3 + 8);
        v34 = (size_t *)(a3 + 248);
      }
      v60 = *v34;
      v61 = *(_QWORD *)(a2 + 16);
      if (v61)
      {
        v6 = 0;
        v62 = *(_OWORD *)(a2 + 32);
        *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
        *(_OWORD *)(result + 32) = v62;
        *(_OWORD *)result = *(_OWORD *)a2;
        v63 = *(_QWORD *)(a2 + 40);
        *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
        *(_BYTE *)(result + 33) = 0;
        v64 = v61 - 1;
        *(_QWORD *)(result + 8) = 0;
        *(_QWORD *)(result + 16) = 0;
        if (__s1)
          v65 = v60 == 0;
        else
          v65 = 1;
        v66 = v65;
        v122 = *(_QWORD *)(a2 + 8);
        v123 = v63;
        while (1)
        {
          v67 = (v6 + v64) >> 1;
          if ((v66 & 1) != 0)
            goto LABEL_325;
          v68 = *(_QWORD *)(v122 + 8 * v67);
          v69 = (const void *)(v123 + v68);
          if (!v69)
            goto LABEL_86;
          if (v60 >= HIDWORD(v68))
            v70 = HIDWORD(v68);
          else
            v70 = v60;
          if (v60 < HIDWORD(v68))
            v71 = -1;
          else
            v71 = 1;
          result = memcmp(__s1, v69, v70);
          if (v60 != HIDWORD(v68) && (_DWORD)result == 0)
            v73 = v71;
          else
            v73 = result;
          if (!v73)
          {
            *(_BYTE *)(v4 + 33) = 1;
            v107 = *(_QWORD *)(v4 + 40);
            v108 = v107 + (HIDWORD(v68) + v68);
            if (v108 <= *(_QWORD *)(v4 + 48) && v107 <= v108)
            {
              *(_QWORD *)(v4 + 40) = v108;
              return result;
            }
            while (1)
            {
              do
              {
LABEL_317:
                __break(0x5519u);
LABEL_318:
                v121 = *(void (**)(unint64_t, const char *, ...))(v6 + 24);
                if (v121)
                  v121(v6, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
              }
              while (v6 && v6 >= v6 + 64);
              (*(void (**)(unint64_t, const char *, ...))(v6 + 32))(v6, "[%s]: %s\n", "der_vm_string_from_context", "Attempting to select a string value from a non-string DER object");
LABEL_316:
              v129[0] = 0;
              v129[1] = 0;
            }
          }
          if (v73 < 0)
          {
LABEL_325:
            if (v6 + v64 < 2)
              return result;
            v64 = v67 - 1;
            if (v6 > v67 - 1)
              return result;
          }
          else
          {
LABEL_86:
            v6 = v67 + 1;
            if (v67 + 1 > v64)
              return result;
          }
        }
      }
      v129[0] = 0;
      v129[1] = 0;
      v128 = *(_OWORD *)(a2 + 40);
      result = sub_10004CEB4(v6, 0, 0, v129, (uint64_t *)&v128);
      if ((result & 1) != 0)
      {
        if (v60)
        {
          if (v129[0] < v129[1])
          {
            if (v6 && v6 >= v7)
              goto LABEL_317;
            while (1)
            {
              __s2 = 0;
              v127 = 0;
              v125 = 0uLL;
              result = sub_10004D054(v6, &__s2, &v125, v129);
              if (!(_DWORD)result)
                break;
              if (__s1 && __s2)
              {
                v82 = v127;
                v83 = v60 >= v127 ? v127 : v60;
                result = memcmp(__s1, __s2, v83);
                if (!(_DWORD)result && v60 == v82)
                {
                  *(_OWORD *)((char *)v130 + 6) = v125;
                  LOBYTE(v85) = 1;
                  goto LABEL_294;
                }
              }
              if (v129[0] >= v129[1])
                goto LABEL_254;
            }
            v85 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
            if (v85)
            {
              result = v85(v6, "[%s]: %s\n", "der_vm_execute_select_key", "invalid dictionary element");
              LOBYTE(v85) = 0;
            }
LABEL_294:
            v116 = v132;
            *(_OWORD *)v4 = v131;
            *(_OWORD *)(v4 + 16) = v116;
            *(_BYTE *)(v4 + 32) = v133;
            *(_BYTE *)(v4 + 33) = (_BYTE)v85;
            goto LABEL_255;
          }
LABEL_254:
          v110 = v132;
          *(_OWORD *)v4 = v131;
          *(_OWORD *)(v4 + 16) = v110;
          *(_BYTE *)(v4 + 32) = v133;
          *(_BYTE *)(v4 + 33) = 0;
LABEL_255:
          *(_OWORD *)(v4 + 34) = *(_OWORD *)v130;
          v11 = *(uint64_t *)((char *)&v130[1] + 6);
          goto LABEL_7;
        }
        v102 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v102)
          goto LABEL_254;
        if (v6 && v6 >= v7)
          goto LABEL_317;
        v103 = "key length is invalid";
      }
      else
      {
        v102 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v102)
          goto LABEL_254;
        if (v6 && v6 >= v7)
          goto LABEL_317;
        v103 = "dictionary decoding failure";
      }
      result = v102(v6, "[%s]: %s\n", "der_vm_execute_select_key", v103);
      goto LABEL_254;
    case 2uLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v19 = *(_OWORD *)(a2 + 32);
      v20 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v19;
      *(_OWORD *)result = v20;
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      v21 = *(_QWORD *)(a3 + 8);
      v131 = 0uLL;
      *(_OWORD *)v130 = *(_OWORD *)(a2 + 40);
      result = sub_10004CEB4(v6, 0, 0, &v131, v130);
      if (!(_DWORD)result)
      {
        v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54)
          return result;
        if (v6 && v6 >= v7)
          goto LABEL_317;
        v55 = "array decoding failure";
        goto LABEL_229;
      }
      v22 = (unint64_t)v131 < *((_QWORD *)&v131 + 1);
      if ((unint64_t)v131 < *((_QWORD *)&v131 + 1) && v21 >= 1)
      {
        while (1)
        {
          result = sub_10004CEB4(v6, 0, 0, 0, (uint64_t *)&v131);
          if ((result & 1) == 0)
            break;
          v23 = v21 - 1;
          v22 = (unint64_t)v131 < *((_QWORD *)&v131 + 1);
          if ((unint64_t)v131 >= *((_QWORD *)&v131 + 1) || v21-- <= 1)
            goto LABEL_148;
        }
        v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54)
          return result;
        if (v6 && v6 >= v7)
          goto LABEL_317;
        v55 = "encountered invalid element in an array";
LABEL_229:
        v56 = "der_vm_execute_select_index";
        return v54(v6, "[%s]: %s\n", v56, v55);
      }
      v23 = v21;
LABEL_148:
      if (v22 && v23 == 0)
      {
        if (!v6 || v6 < v7)
        {
          result = sub_10004CEB4(v6, 0, (_QWORD *)(v4 + 40), 0, (uint64_t *)&v131);
          *(_BYTE *)(v4 + 33) = result;
          return result;
        }
        goto LABEL_317;
      }
      return result;
    case 3uLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      return sub_10004C32C(result, (__int128 *)a2, a3);
    case 4uLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v25 = *(_OWORD *)(a2 + 32);
      v26 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v25;
      *(_OWORD *)result = v26;
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      if ((v8 & 0x4000000000000000) != 0)
      {
        v27 = *(_QWORD *)(a3 + 8);
        v28 = (size_t *)(a3 + 16);
      }
      else
      {
        v27 = a3 + 8;
        v28 = (size_t *)(a3 + 248);
      }
      v57 = *v28;
      *(_OWORD *)v130 = *(_OWORD *)(a2 + 40);
      v131 = 0uLL;
      result = ccder_blob_decode_range(v130, 12, &v131);
      if ((result & 1) != 0)
      {
        if (!v57)
          goto LABEL_308;
        v58 = (const void *)v131;
        if (v57 > *((_QWORD *)&v131 + 1) - (_QWORD)v131)
        {
LABEL_63:
          *(_BYTE *)(v4 + 33) = 0;
          return result;
        }
        result = v27;
        v104 = v57;
        goto LABEL_224;
      }
      v59 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v59)
        return result;
      result = v59(v6, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54)
        return result;
      if (v6 && v6 >= v7)
        goto LABEL_317;
      v55 = "string decode failure";
      v56 = "der_vm_execute_match_string_prefix";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 5uLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v35 = *(_OWORD *)(a2 + 32);
      v36 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v35;
      *(_OWORD *)result = v36;
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      *(_OWORD *)v130 = *(_OWORD *)(a2 + 40);
      v131 = 0uLL;
      result = ccder_blob_decode_range(v130, 1, &v131);
      if ((result & 1) == 0)
      {
        v74 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v74)
          goto LABEL_187;
        v75 = "Unknown BOOLean encoding";
        goto LABEL_186;
      }
      if (*((_QWORD *)&v131 + 1) - (_QWORD)v131 == 1)
      {
        if ((unint64_t)v131 >= *((_QWORD *)&v131 + 1))
          goto LABEL_317;
        v18 = *(_QWORD *)(a3 + 8) == (*(_BYTE *)v131 != 0);
        goto LABEL_235;
      }
      v74 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (v74)
      {
        v75 = "BOOLean should be exactly 1 byte";
LABEL_186:
        result = v74(v6, "[%s]: %s\n", "der_decode_BOOLean", v75);
      }
LABEL_187:
      v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54)
        return result;
      if (v6 && v6 >= v7)
        goto LABEL_317;
      v55 = "BOOL decode failure";
      v56 = "der_vm_execute_match_BOOL";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 6uLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v37 = *(_OWORD *)(a2 + 32);
      v38 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v37;
      *(_OWORD *)result = v38;
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      if ((v8 & 0x4000000000000000) != 0)
      {
        v39 = *(const void **)(a3 + 8);
        v40 = (size_t *)(a3 + 16);
      }
      else
      {
        v39 = (const void *)(a3 + 8);
        v40 = (size_t *)(a3 + 248);
      }
      v76 = *v40;
      v77 = *(_QWORD *)(a2 + 24);
      v78 = *(_OWORD *)(a2 + 40);
      v130[0] = 0;
      v131 = v78;
      result = sub_10004CEB4(v6, v130, 0, 0, (uint64_t *)&v131);
      if (!(_DWORD)result || v77 == v130[0])
        goto LABEL_112;
      if (v130[0] != 12)
      {
        if (v130[0] == 0x2000000000000010 || v130[0] == 0x6000000000000010)
        {
          v130[0] = v4;
          v130[1] = a3;
          v99 = *(_OWORD *)(a2 + 16);
          v131 = *(_OWORD *)a2;
          v132 = v99;
          v133 = *(_OWORD *)(a2 + 32);
          v134 = *(_QWORD *)(a2 + 48);
          v100 = sub_10004C488;
          return sub_10004B818((unint64_t)&v131, (uint64_t)v130, (uint64_t)v100);
        }
LABEL_112:
        v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v54)
        {
          if (v6 >= v7)
            goto LABEL_317;
          v55 = "Unexpected type to match against";
          v56 = "der_vm_execute_string_value_allowed";
          return v54(v6, "[%s]: %s\n", v56, v55);
        }
        return result;
      }
      result = sub_10004C32C((uint64_t)&v131, (__int128 *)a2, a3);
      if (BYTE1(v133))
        goto LABEL_308;
      v6 = *(_QWORD *)a2;
      *(_OWORD *)v129 = *(_OWORD *)(a2 + 40);
      *(_OWORD *)v130 = 0uLL;
      if ((ccder_blob_decode_range(v129, 12, v130) & 1) == 0)
        goto LABEL_318;
      result = v130[0];
      if (v130[1] == v130[0])
        return result;
      v111 = (_BYTE *)(v130[1] - 1);
      if (!v130[1] || (unint64_t)v111 < v130[0])
        goto LABEL_317;
      if (*v111 != 42)
        return result;
      v104 = ~v130[0] + v130[1];
      if (!v104)
        goto LABEL_308;
      if (v104 > v76)
        goto LABEL_63;
      v58 = v39;
      goto LABEL_224;
    case 7uLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v41 = *(_OWORD *)(a2 + 32);
      v42 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v41;
      *(_OWORD *)result = v42;
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      *(_OWORD *)v130 = *(_OWORD *)(a2 + 40);
      v131 = 0uLL;
      result = ccder_blob_decode_range(v130, 2, &v131);
      if ((result & 1) == 0)
      {
        v43 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v43)
          goto LABEL_118;
        v44 = "unknown number encoding";
        goto LABEL_117;
      }
      if (*((_QWORD *)&v131 + 1) - (_QWORD)v131 < 9uLL)
      {
        if ((unint64_t)v131 >= *((_QWORD *)&v131 + 1))
        {
          v95 = 0;
        }
        else
        {
          v94 = 0;
          v95 = 0;
          do
          {
            if (!v94 && *(char *)v131 < 0)
              v95 = -1;
            v96 = (unsigned __int8 *)(v131 + v94);
            if ((unint64_t)(v131 + v94) >= *((_QWORD *)&v131 + 1)
              || (unint64_t)v96 < (unint64_t)v131)
            {
              goto LABEL_317;
            }
            v95 = *v96 | (unint64_t)(v95 << 8);
            ++v94;
          }
          while (*((_QWORD *)&v131 + 1) - (_QWORD)v131 != v94);
        }
        v18 = v95 == *(_QWORD *)(a3 + 8);
        goto LABEL_235;
      }
      v43 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (v43)
      {
        v44 = "number too large";
LABEL_117:
        result = v43(v6, "[%s]: %s\n", "der_decode_number", v44);
      }
LABEL_118:
      v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54)
        return result;
      if (v6 && v6 >= v7)
        goto LABEL_317;
LABEL_121:
      v55 = "BOOL decode failure";
      v56 = "der_vm_execute_match_integer";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 8uLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v45 = *(_OWORD *)(a2 + 32);
      v46 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v45;
      *(_OWORD *)result = v46;
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      v47 = (const void *)(a3 + 8);
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      if ((v8 & 0x4000000000000000) != 0)
      {
        v49 = *(_QWORD *)(a3 + 8);
        v48 = (size_t *)(a3 + 16);
      }
      else
      {
        v48 = (size_t *)(a3 + 248);
        v49 = a3 + 8;
      }
      v79 = *v48;
      v80 = *(_QWORD *)(a2 + 24);
      v81 = *(_OWORD *)(a2 + 40);
      v130[0] = 0;
      v131 = v81;
      result = sub_10004CEB4(v6, v130, 0, 0, (uint64_t *)&v131);
      if (!(_DWORD)result || v80 == v130[0])
        goto LABEL_125;
      if (v130[0] != 12)
      {
        if (v130[0] == 0x2000000000000010 || v130[0] == 0x6000000000000010)
        {
          v130[0] = v4;
          v130[1] = a3;
          v101 = *(_OWORD *)(a2 + 16);
          v131 = *(_OWORD *)a2;
          v132 = v101;
          v133 = *(_OWORD *)(a2 + 32);
          v134 = *(_QWORD *)(a2 + 48);
          v100 = sub_10004C638;
          return sub_10004B818((unint64_t)&v131, (uint64_t)v130, (uint64_t)v100);
        }
LABEL_125:
        v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v54)
        {
          if (v6 >= v7)
            goto LABEL_317;
          v55 = "Unexpected type to match against";
          v56 = "der_vm_execute_string_prefix_value_allowed";
          return v54(v6, "[%s]: %s\n", v56, v55);
        }
        return result;
      }
      if ((*(_BYTE *)(a3 + 7) & 0x40) != 0)
      {
        v47 = *(const void **)(a3 + 8);
        v112 = (size_t *)(a3 + 16);
      }
      else
      {
        v112 = (size_t *)(a3 + 248);
      }
      v6 = *(_QWORD *)a2;
      v113 = *v112;
      *(_OWORD *)v130 = *(_OWORD *)(a2 + 40);
      v131 = 0uLL;
      result = ccder_blob_decode_range(v130, 12, &v131);
      if ((result & 1) != 0)
      {
        if (!v113)
          goto LABEL_308;
        if (v113 <= *((_QWORD *)&v131 + 1) - (_QWORD)v131)
        {
          result = memcmp(v47, (const void *)v131, v113);
          if (!(_DWORD)result)
            goto LABEL_308;
        }
      }
      else
      {
        v114 = *(void (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v114)
        {
          v114(v6, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
          v115 = *(void (**)(unint64_t, const char *, ...))(v6 + 24);
          if (v115)
          {
            if (v6 && v6 >= v6 + 64)
              goto LABEL_317;
            v115(v6, "[%s]: %s\n", "der_vm_execute_match_string_prefix", "string decode failure");
          }
        }
      }
      v6 = *(_QWORD *)a2;
      *(_OWORD *)v130 = *(_OWORD *)(a2 + 40);
      v131 = 0uLL;
      result = ccder_blob_decode_range(v130, 12, &v131);
      if ((result & 1) == 0)
        goto LABEL_318;
      if (v79)
      {
        v58 = (const void *)v131;
        if (v79 > *((_QWORD *)&v131 + 1) - (_QWORD)v131)
          goto LABEL_63;
        result = v49;
        v104 = v79;
LABEL_224:
        result = memcmp((const void *)result, v58, v104);
        v18 = (_DWORD)result == 0;
LABEL_235:
        v105 = v18;
        goto LABEL_309;
      }
      goto LABEL_308;
    case 9uLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v29 = *(_OWORD *)(a2 + 32);
      v30 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v29;
      *(_OWORD *)result = v30;
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      v131 = 0uLL;
      *(_OWORD *)v130 = *(_OWORD *)(a2 + 40);
      result = sub_10004CEB4(v6, 0, 0, &v131, v130);
      if ((result & 1) == 0)
      {
        v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54)
          return result;
        if (v6 && v6 >= v7)
          goto LABEL_317;
        v55 = "dictionary decoding failure";
        goto LABEL_247;
      }
      if ((*(_BYTE *)(a3 + 7) & 0x40) != 0)
      {
        v31 = *(const void **)(a3 + 8);
        v32 = (void **)(a3 + 16);
      }
      else
      {
        v31 = (const void *)(a3 + 8);
        v32 = (void **)(a3 + 248);
      }
      v87 = (char *)*v32;
      if (!*v32)
      {
        v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54)
          return result;
        if (v6 && v6 >= v7)
          goto LABEL_317;
        v55 = "key length is invalid";
        goto LABEL_247;
      }
      if ((unint64_t)v131 >= *((_QWORD *)&v131 + 1))
        return result;
      if (v6 && v6 >= v7)
        goto LABEL_316;
      while (2)
      {
        v129[0] = 0;
        v129[1] = 0;
        v128 = 0uLL;
        result = sub_10004D054(v6, v129, &v128, &v131);
        if ((_DWORD)result)
        {
          v88 = (char *)v129[1];
          if (v129[1])
          {
            v89 = v129[0];
            v90 = (char *)v129[1] - 1;
            v91 = (char *)v129[0] + (unint64_t)v129[1] - 1;
            if (v91 < v129[0] || v91 >= (char *)v129[0] + (unint64_t)v129[1])
              goto LABEL_317;
            if (*v91 == 42)
            {
              if (v129[1] == (void *)1 || v90 <= v87 && (result = memcmp(v129[0], v31, (size_t)v90), !(_DWORD)result))
              {
LABEL_162:
                *(_BYTE *)(v4 + 33) = 1;
                *(_OWORD *)(v4 + 40) = v128;
              }
LABEL_163:
              if ((unint64_t)v131 >= *((_QWORD *)&v131 + 1))
                return result;
              continue;
            }
          }
          else
          {
            v89 = v129[0];
          }
          if (v31 && v89)
          {
            v93 = v87 >= v129[1] ? v129[1] : v87;
            result = memcmp(v31, v89, (size_t)v93);
            if (v87 == v88 && !(_DWORD)result)
              goto LABEL_162;
          }
          goto LABEL_163;
        }
        break;
      }
      v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
      if (!v54)
        return result;
      v55 = "invalid dictionary element";
LABEL_247:
      v56 = "der_vm_execute_select_longest_matching_key";
      return v54(v6, "[%s]: %s\n", v56, v55);
    case 0xAuLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v50 = *(_OWORD *)(a2 + 32);
      v51 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v50;
      *(_OWORD *)result = v51;
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      v52 = *(_QWORD *)(a2 + 24);
      v53 = *(_OWORD *)(a2 + 40);
      v130[0] = 0;
      v131 = v53;
      result = sub_10004CEB4(v6, v130, 0, 0, (uint64_t *)&v131);
      if (!(_DWORD)result || v52 == v130[0])
        goto LABEL_56;
      if (v130[0] == 0x6000000000000010 || v130[0] == 0x2000000000000010)
      {
        v130[0] = v4;
        v130[1] = a3;
        v106 = *(_OWORD *)(a2 + 16);
        v131 = *(_OWORD *)a2;
        v132 = v106;
        v133 = *(_OWORD *)(a2 + 32);
        v134 = *(_QWORD *)(a2 + 48);
        v100 = sub_10004C84C;
        return sub_10004B818((unint64_t)&v131, (uint64_t)v130, (uint64_t)v100);
      }
      if (v130[0] != 2)
      {
LABEL_56:
        v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54)
          return result;
        if (v6 >= v7)
          goto LABEL_317;
        v55 = "Unexpected type to match against";
        v56 = "der_vm_execute_integer_value_allowed";
        return v54(v6, "[%s]: %s\n", v56, v55);
      }
      v6 = *(_QWORD *)a2;
      *(_OWORD *)v130 = *(_OWORD *)(a2 + 40);
      v131 = 0uLL;
      result = ccder_blob_decode_range(v130, 2, &v131);
      if ((result & 1) == 0)
      {
        v97 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v97)
        {
          v98 = "unknown number encoding";
          goto LABEL_272;
        }
LABEL_273:
        v54 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (!v54)
          return result;
        if (v6 && v6 >= v6 + 64)
          goto LABEL_317;
        goto LABEL_121;
      }
      if (*((_QWORD *)&v131 + 1) - (_QWORD)v131 >= 9uLL)
      {
        v97 = *(uint64_t (**)(unint64_t, const char *, ...))(v6 + 24);
        if (v97)
        {
          v98 = "number too large";
LABEL_272:
          result = v97(v6, "[%s]: %s\n", "der_decode_number", v98);
          goto LABEL_273;
        }
        goto LABEL_273;
      }
      if ((unint64_t)v131 >= *((_QWORD *)&v131 + 1))
      {
        v118 = 0;
      }
      else
      {
        v117 = 0;
        v118 = 0;
        do
        {
          if (!v117 && *(char *)v131 < 0)
            v118 = -1;
          v119 = (unsigned __int8 *)(v131 + v117);
          if ((unint64_t)(v131 + v117) >= *((_QWORD *)&v131 + 1)
            || (unint64_t)v119 < (unint64_t)v131)
          {
            goto LABEL_317;
          }
          v118 = *v119 | (unint64_t)(v118 << 8);
          ++v117;
        }
        while (*((_QWORD *)&v131 + 1) - (_QWORD)v131 != v117);
      }
      if (v118 != *(_QWORD *)(a3 + 8))
        return result;
LABEL_308:
      v105 = 1;
LABEL_309:
      *(_BYTE *)(v4 + 33) = v105;
      return result;
    case 0xBuLL:
      if (a2 + 56 < a2)
        goto LABEL_317;
      v12 = *(_OWORD *)(a2 + 32);
      v13 = *(_OWORD *)a2;
      *(_OWORD *)(result + 16) = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(result + 32) = v12;
      *(_OWORD *)result = v13;
      *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
      *(_BYTE *)(result + 33) = 0;
      *(_QWORD *)(result + 8) = 0;
      *(_QWORD *)(result + 16) = 0;
      v14 = *(_QWORD *)(a3 + 8);
      if ((unint64_t)(v14 - 7) < 0xFFFFFFFFFFFFFFFALL)
        return result;
      v15 = *(_QWORD *)(a2 + 24);
      v16 = *(_OWORD *)(a2 + 40);
      v130[0] = 0;
      v131 = v16;
      result = sub_10004CEB4(v6, v130, 0, 0, (uint64_t *)&v131);
      if (!(_DWORD)result)
        return result;
      if (v15 == v130[0])
      {
        v17 = 1;
LABEL_13:
        v18 = v17 == (_DWORD)v14;
        goto LABEL_235;
      }
      if (v130[0] > 0x200000000000000FLL)
      {
        if (v130[0] == 0x6000000000000010 || v130[0] == 0x2000000000000010)
        {
          v17 = 2;
          goto LABEL_13;
        }
      }
      else
      {
        v17 = 5;
        switch(v130[0])
        {
          case 1:
            goto LABEL_13;
          case 2:
            v17 = 3;
            goto LABEL_13;
          case 4:
            v17 = 6;
            goto LABEL_13;
          case 0xCLL:
            v17 = 4;
            goto LABEL_13;
          default:
            return result;
        }
      }
      return result;
    default:
      if (v6)
        v120 = v6 >= v7;
      else
        v120 = 0;
      if (v120)
        goto LABEL_317;
      (*(void (**)(unint64_t, const char *, ...))(v6 + 32))(v6, "[%s]: %s\n", "der_vm_execute_nocopy", "unhandled opcode");
      goto LABEL_316;
  }
}

uint64_t sub_10004B6B8@<X0>(uint64_t result@<X0>, unint64_t a2@<X1>, uint64_t a3@<X8>)
{
  __int128 v3;
  _OWORD v4[3];
  uint64_t v5;

  if (a2 && a2 + 256 < a2)
  {
    __break(0x5519u);
  }
  else
  {
    v3 = *(_OWORD *)(result + 16);
    v4[0] = *(_OWORD *)result;
    v4[1] = v3;
    v4[2] = *(_OWORD *)(result + 32);
    v5 = *(_QWORD *)(result + 48);
    return sub_10004A5C8(a3, (unint64_t)v4, a2);
  }
  return result;
}

uint64_t sub_10004B70C(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 33);
}

uint64_t sub_10004B714(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  uint64_t result;
  uint64_t v6;
  __int128 v7;
  uint64_t v8;

  v8 = 0;
  if (!*(_BYTE *)(a1 + 33))
    return 0;
  v4 = *(_QWORD *)a1;
  v7 = *(_OWORD *)(a1 + 40);
  result = sub_10004CEB4(v4, &v8, 0, 0, (uint64_t *)&v7);
  if (!(_DWORD)result)
    return result;
  v6 = v8;
  if (a2)
    *a2 = v8;
  if (*(_QWORD *)(a1 + 24) == v6)
    return 1;
  if (v6 > 0x200000000000000FLL)
  {
    if (v6 == 0x6000000000000010 || v6 == 0x2000000000000010)
      return 2;
    return 0;
  }
  result = 5;
  switch(v6)
  {
    case 1:
      return result;
    case 2:
      result = 3;
      break;
    case 3:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
      return 0;
    case 4:
      result = 6;
      break;
    case 12:
      result = 4;
      break;
    default:
      return v6 == 0xA000000000000010;
  }
  return result;
}

unint64_t sub_10004B818(unint64_t result, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  void (*v7)(unint64_t, const char *, ...);
  const char *v8;
  int v9;
  __int128 v10;
  __int128 v11;
  void (*v12)(unint64_t, const char *, ...);
  _QWORD v13[2];
  uint64_t (*v14)(uint64_t, uint64_t);
  void *v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD v18[3];
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  int v24;
  int v25;
  uint64_t v26;
  __int128 v27;
  unint64_t v28;
  unint64_t v29;
  _QWORD v30[2];

  v3 = result;
  if (result && result + 56 < result)
    goto LABEL_41;
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 0x40000000;
  v14 = sub_10004BAF4;
  v15 = &unk_10006DF88;
  v16 = a2;
  v17 = a3;
  if (!*(_BYTE *)(result + 33))
    return (unint64_t)&unk_10006DFC8;
  v4 = *(_QWORD *)result;
  v5 = *(_QWORD *)result + 64;
  v29 = 0;
  v30[0] = 0;
  v28 = 0;
  v27 = *(_OWORD *)(result + 40);
  result = sub_10004CEB4(v4, v30, 0, &v28, (uint64_t *)&v27);
  if ((result & 1) != 0)
  {
    if (*(_QWORD *)(v3 + 24) == v30[0])
    {
LABEL_6:
      v6 = 1;
      goto LABEL_14;
    }
    v6 = 2;
    if (v30[0] != 0x6000000000000010 && v30[0] != 0x2000000000000010)
    {
      if (v30[0] == 0xA000000000000010)
        goto LABEL_6;
      v12 = *(void (**)(unint64_t, const char *, ...))(v4 + 24);
      if (!v12)
        return (unint64_t)&unk_10006DFC8;
      if (!v4 || v4 < v5)
      {
        v12(v4, "[%s]: %s\n", "der_vm_iterate_b", "iteration over a non-iterable type");
        return (unint64_t)&unk_10006DFC8;
      }
      goto LABEL_41;
    }
    while (1)
    {
LABEL_14:
      if (v28 >= v29)
        return (unint64_t)&unk_10006DFA8;
      v10 = *(_OWORD *)(v3 + 16);
      v11 = *(_OWORD *)(v3 + 32);
      v18[0] = *(_OWORD *)v3;
      v18[1] = v10;
      v18[2] = v11;
      v19 = *(_QWORD *)(v3 + 48);
      v20 = v18[0];
      v21 = v10;
      v22 = v11;
      v23 = v19;
      v24 = v6;
      v25 = 0;
      v26 = 0;
      result = sub_10004CEB4(*(_QWORD *)v3, v30, (_QWORD *)&v22 + 1, 0, (uint64_t *)&v28);
      if ((result & 1) == 0)
        break;
      if (*((_QWORD *)&v21 + 1) == v30[0])
      {
        v9 = 1;
      }
      else if (v30[0] > 0x200000000000000FLL)
      {
        if (v30[0] == 0x6000000000000010 || v30[0] == 0x2000000000000010)
          v9 = 2;
        else
LABEL_23:
          v9 = 0;
      }
      else
      {
        v9 = 5;
        switch(v30[0])
        {
          case 1:
            break;
          case 2:
            v9 = 3;
            break;
          case 4:
            v9 = 6;
            break;
          case 0xCLL:
            v9 = 4;
            break;
          default:
            goto LABEL_23;
        }
      }
      v25 = v9;
      if ((v14((uint64_t)v13, (uint64_t)v18) & 1) == 0)
        return (unint64_t)&unk_10006DFA8;
    }
    v7 = *(void (**)(unint64_t, const char *, ...))(v4 + 24);
    if (v7)
    {
      if (!v4 || v4 < v5)
      {
        v8 = "encountered invalid element in an iterable";
        goto LABEL_39;
      }
      goto LABEL_41;
    }
    return (unint64_t)&unk_10006DFE8;
  }
  v7 = *(void (**)(unint64_t, const char *, ...))(v4 + 24);
  if (!v7)
    return (unint64_t)&unk_10006DFE8;
  if (!v4 || v4 < v5)
  {
    v8 = "iterable decoding failure";
LABEL_39:
    v7(v4, "[%s]: %s\n", "der_vm_iterate_b", v8);
    return (unint64_t)&unk_10006DFE8;
  }
LABEL_41:
  __break(0x5519u);
  return result;
}

uint64_t sub_10004BAF4(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(_OWORD *);
  __int128 v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;
  _OWORD v8[8];

  *(_QWORD *)(a2 + 120) = *(_QWORD *)(a1 + 32);
  v2 = *(uint64_t (**)(_OWORD *))(a1 + 40);
  v3 = *(_OWORD *)(a2 + 80);
  v8[4] = *(_OWORD *)(a2 + 64);
  v8[5] = v3;
  v4 = *(_OWORD *)(a2 + 112);
  v8[6] = *(_OWORD *)(a2 + 96);
  v8[7] = v4;
  v5 = *(_OWORD *)(a2 + 16);
  v8[0] = *(_OWORD *)a2;
  v8[1] = v5;
  v6 = *(_OWORD *)(a2 + 48);
  v8[2] = *(_OWORD *)(a2 + 32);
  v8[3] = v6;
  return v2(v8);
}

uint64_t sub_10004BB40(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;
  uint64_t result;
  unsigned __int8 *v4;
  void (*v5)(unint64_t, const char *, ...);
  const char *v6;
  uint64_t v7;
  __int128 v8;
  unsigned __int8 *v9;
  unint64_t v10;

  v1 = *(_QWORD *)a1;
  v8 = *(_OWORD *)(a1 + 40);
  v9 = 0;
  v10 = 0;
  if ((ccder_blob_decode_range(&v8, 2, &v9) & 1) == 0)
  {
    v5 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v5)
    {
      v6 = "unknown number encoding";
LABEL_18:
      v5(v1, "[%s]: %s\n", "der_decode_number", v6);
    }
LABEL_19:
    if (!v1 || v1 < v1 + 64)
      goto LABEL_22;
    goto LABEL_21;
  }
  if (v10 - (unint64_t)v9 >= 9)
  {
    v5 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v5)
    {
      v6 = "number too large";
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  if ((unint64_t)v9 < v10)
  {
    v2 = 0;
    result = 0;
    while (1)
    {
      if (!v2 && (*v9 & 0x80u) != 0)
        result = -1;
      v4 = &v9[v2];
      if ((unint64_t)&v9[v2] >= v10 || v4 < v9)
        break;
      result = *v4 | (unint64_t)(result << 8);
      if (v10 - (_QWORD)v9 == ++v2)
        return result;
    }
LABEL_21:
    __break(0x5519u);
LABEL_22:
    v7 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))(v1, "[%s]: %s\n", "der_vm_integer_from_context", "Attempting to select an integer value from a non-integer DER object");
    return sub_10004BC60(v7);
  }
  return 0;
}

uint64_t sub_10004BC60(uint64_t a1)
{
  unint64_t v1;
  void (*v3)(unint64_t, const char *, ...);
  uint64_t v4;
  __int128 v5;
  _QWORD v6[2];

  v1 = *(_QWORD *)a1;
  v5 = *(_OWORD *)(a1 + 40);
  v6[0] = 0;
  v6[1] = 0;
  if ((ccder_blob_decode_range(&v5, 12, v6) & 1) != 0)
    return v6[0];
  v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
  if (v3)
    v3(v1, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
  if (v1)
  {
    if (v1 >= v1 + 64)
      __break(0x5519u);
  }
  v4 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))(v1, "[%s]: %s\n", "der_vm_string_from_context", "Attempting to select a string value from a non-string DER object");
  return sub_10004BD14(v4);
}

uint64_t sub_10004BD14(uint64_t a1)
{
  unint64_t v1;
  void (*v3)(unint64_t, const char *, ...);
  const char *v4;
  uint64_t v5;
  __int128 v6;
  unsigned __int8 *v7;
  unint64_t v8;

  v1 = *(_QWORD *)a1;
  v6 = *(_OWORD *)(a1 + 40);
  v7 = 0;
  v8 = 0;
  if ((ccder_blob_decode_range(&v6, 1, &v7) & 1) == 0)
  {
    v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v3)
    {
      v4 = "Unknown BOOLean encoding";
LABEL_9:
      v3(v1, "[%s]: %s\n", "der_decode_BOOLean", v4);
    }
LABEL_10:
    if (!v1 || v1 < v1 + 64)
      goto LABEL_13;
    goto LABEL_12;
  }
  if (v8 - (_QWORD)v7 != 1)
  {
    v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
    if (v3)
    {
      v4 = "BOOLean should be exactly 1 byte";
      goto LABEL_9;
    }
    goto LABEL_10;
  }
  if ((unint64_t)v7 < v8)
    return *v7 != 0;
LABEL_12:
  __break(0x5519u);
LABEL_13:
  v5 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))(v1, "[%s]: %s\n", "der_vm_BOOL_from_context", "Attempting to select a BOOLean value from a non-BOOLean DER object");
  return sub_10004BDF8(v5);
}

uint64_t sub_10004BDF8(uint64_t a1)
{
  unint64_t v1;
  void (*v3)(unint64_t, const char *, ...);
  uint64_t v4;
  __int128 v5;
  _QWORD v6[2];

  v1 = *(_QWORD *)a1;
  v5 = *(_OWORD *)(a1 + 40);
  v6[0] = 0;
  v6[1] = 0;
  if ((ccder_blob_decode_range(&v5, 4, v6) & 1) != 0)
    return v6[0];
  v3 = *(void (**)(unint64_t, const char *, ...))(v1 + 24);
  if (v3)
    v3(v1, "[%s]: %s\n", "der_decode_data", "Unknown data encoding");
  if (v1)
  {
    if (v1 >= v1 + 64)
      __break(0x5519u);
  }
  v4 = (*(uint64_t (**)(unint64_t, const char *, ...))(v1 + 32))(v1, "[%s]: %s\n", "der_vm_data_from_context", "Attempting to select a data value from a non-data DER object");
  return sub_10004BEAC(v4);
}

uint64_t sub_10004BEAC(uint64_t result, uint64_t *a2, unint64_t a3, unint64_t a4)
{
  char v4;

  v4 = 0;
  if (a3 <= a4)
    return sub_10004BEE8(result, &v4, a2, a3, a4);
  __break(0x5519u);
  return result;
}

uint64_t sub_10004BEE8(uint64_t result, _BYTE *a2, uint64_t *a3, unint64_t a4, unint64_t a5)
{
  char *v5;
  BOOL v10;
  void (*v11)(char *, const char *, ...);
  const char *v12;
  void (*v13)(uint64_t, const char *, ...);
  uint64_t v14;
  _UNKNOWN **v15;
  const char *v16;
  void (*v17)(uint64_t, const char *, ...);
  uint64_t v18;
  uint64_t v19;
  unsigned __int8 *v20;
  void (*v21)(char *, const char *, ...);
  _QWORD v22[2];
  uint64_t v23[2];
  uint64_t v24;
  __int128 v25;
  unsigned __int8 *v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  __int128 v32;

  v5 = (char *)result;
  if (!a3)
    goto LABEL_16;
  *a3 = 0;
  if (a4 > a5)
  {
LABEL_56:
    __break(0x5519u);
    return result;
  }
  a3[1] = a4;
  a3[2] = a5;
  if (a4 && a4 < a5)
  {
    if (a5 - a4 >= 5 && (*(_DWORD *)a4 == 1836597052 ? (v10 = *(_BYTE *)(a4 + 4) == 108) : (v10 = 0), v10))
    {
      v17 = *(void (**)(uint64_t, const char *, ...))(result + 24);
      if (v17)
        v17(result, "[%s]: %s\n", "CEValidateWithOptions", "xml-looking blob was passed in");
      return (uint64_t)&unk_10006DFB8;
    }
    else
    {
      v23[1] = a5;
      v24 = 0;
      v22[1] = a5;
      v23[0] = a4;
      v22[0] = a4;
      if (ccder_blob_decode_tl(v22, 0x6000000000000010, &v24))
      {
        v32 = 0uLL;
        if ((ccder_blob_decode_range(v23, 0x6000000000000010, &v32) & 1) == 0)
        {
          v11 = (void (*)(char *, const char *, ...))*((_QWORD *)v5 + 3);
          if (v11)
          {
            v12 = "entitlements blob does not have CCDER_ENTITLEMENTS coding";
LABEL_25:
            v16 = "validate_VNext";
            goto LABEL_34;
          }
          return (uint64_t)&unk_10006DFE8;
        }
        v26 = 0;
        v27 = 0;
        result = ccder_blob_decode_range(&v32, 2, &v26);
        if ((result & 1) == 0)
        {
          v11 = (void (*)(char *, const char *, ...))*((_QWORD *)v5 + 3);
          if (v11)
          {
            v12 = "unknown number encoding";
            goto LABEL_33;
          }
          return (uint64_t)&unk_10006DFE8;
        }
        if (v27 - (unint64_t)v26 >= 9)
        {
          v11 = (void (*)(char *, const char *, ...))*((_QWORD *)v5 + 3);
          if (v11)
          {
            v12 = "number too large";
LABEL_33:
            v16 = "der_decode_number";
            goto LABEL_34;
          }
          return (uint64_t)&unk_10006DFE8;
        }
        if ((unint64_t)v26 >= v27)
        {
          v19 = 0;
LABEL_52:
          v21 = (void (*)(char *, const char *, ...))*((_QWORD *)v5 + 3);
          if (v21)
            v21(v5, "[%s]: entitlements blob has unexpected version %lld\n", "validate_VNext", v19);
          return (uint64_t)&unk_10006DFE8;
        }
        v18 = 0;
        v19 = 0;
        while (1)
        {
          if (!v18 && (*v26 & 0x80u) != 0)
            v19 = -1;
          v20 = &v26[v18];
          if ((unint64_t)&v26[v18] >= v27 || v20 < v26)
            goto LABEL_56;
          v19 = *v20 | (unint64_t)(v19 << 8);
          if (v27 - (_QWORD)v26 == ++v18)
          {
            if (v19 != 1)
              goto LABEL_52;
            v30 = 0;
            v31 = 0;
            v25 = v32;
            if ((ccder_blob_decode_range(&v25, 0xA000000000000010, &v30) & 1) != 0)
            {
              v29 = 0;
              v26 = (unsigned __int8 *)v5;
              v27 = 0xA000000000000010;
              v28 = 1;
              LOBYTE(v29) = *a2;
              if (!sub_10004C9E0((uint64_t)&v26, (uint64_t *)&v32))
                goto LABEL_48;
              v14 = 2;
              goto LABEL_22;
            }
            v11 = (void (*)(char *, const char *, ...))*((_QWORD *)v5 + 3);
            if (!v11)
              return (uint64_t)&unk_10006DFE8;
            v12 = "entitlements blob does not have CCDER_ENTITLEMENTS_DICT as the second element";
            goto LABEL_25;
          }
        }
      }
      v32 = 0uLL;
      v30 = a4;
      v31 = a5;
      if ((ccder_blob_decode_range(&v30, 0x2000000000000011, &v32) & 1) == 0)
      {
        v11 = (void (*)(char *, const char *, ...))*((_QWORD *)v5 + 3);
        if (v11)
        {
          v12 = "entitlements blob does not have CCDER_CONSTRUCTED_SET coding";
          v16 = "validate_V0";
LABEL_34:
          v11(v5, "[%s]: %s\n", v16, v12);
          return (uint64_t)&unk_10006DFE8;
        }
        return (uint64_t)&unk_10006DFE8;
      }
      v28 = 0;
      v29 = 0;
      v26 = (unsigned __int8 *)v5;
      v27 = 0x2000000000000011;
      LOBYTE(v29) = *a2;
      if (sub_10004C9E0((uint64_t)&v26, v23))
      {
        v14 = 1;
LABEL_22:
        *a3 = v14;
        v15 = &off_10006E040;
      }
      else
      {
LABEL_48:
        v15 = &off_10006E048;
      }
      return (uint64_t)*v15;
    }
  }
  else
  {
LABEL_16:
    v13 = *(void (**)(uint64_t, const char *, ...))(result + 24);
    if (v13)
      v13(result, "[%s]: %s\n", "CEValidateWithOptions", "invalid arguments passed in");
    return (uint64_t)&unk_10006DFC8;
  }
}

uint64_t sub_10004C22C(uint64_t result, _QWORD *a2, uint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  __int128 v6;
  __int128 v7;
  _UNKNOWN **v8;
  _OWORD v9[3];
  unint64_t v10;
  _OWORD v11[3];
  unint64_t v12;

  if (!a3 || !*a2 || !a2[1] || !a2[2])
  {
    v8 = &off_10006E038;
    return (uint64_t)*v8;
  }
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)(a3 + 48) = 0u;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  v5 = a2[1];
  v4 = a2[2];
  if (*a2 == 2)
  {
    if (v5 <= v4)
    {
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)a3 = result;
      *(_OWORD *)(a3 + 24) = xmmword_1000500D0;
      *(_QWORD *)(a3 + 40) = v5;
      *(_QWORD *)(a3 + 48) = v4;
      v6 = *(_OWORD *)(a3 + 16);
      v9[0] = *(_OWORD *)a3;
      v9[1] = v6;
      v9[2] = *(_OWORD *)(a3 + 32);
      v10 = v4;
      sub_10004A5C8((uint64_t)v11, (unint64_t)v9, (uint64_t)&unk_10004FFB8);
      v7 = v11[1];
      *(_OWORD *)a3 = v11[0];
      *(_OWORD *)(a3 + 16) = v7;
      *(_OWORD *)(a3 + 32) = v11[2];
      v4 = v12;
LABEL_12:
      *(_QWORD *)(a3 + 48) = v4;
      v8 = &off_10006E040;
      return (uint64_t)*v8;
    }
  }
  else if (v5 <= v4)
  {
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(_QWORD *)a3 = result;
    *(_OWORD *)(a3 + 24) = xmmword_1000500C0;
    *(_QWORD *)(a3 + 40) = v5;
    goto LABEL_12;
  }
  __break(0x5519u);
  return result;
}

uint64_t sub_10004C32C(uint64_t a1, __int128 *a2, uint64_t a3)
{
  unint64_t v4;
  __int128 v5;
  __int128 v6;
  const void *v7;
  size_t *v8;
  size_t v9;
  uint64_t result;
  BOOL v11;
  const void *v12;
  const void *v13;
  int64_t v14;
  size_t v15;
  uint64_t (*v16)(unint64_t, const char *, ...);
  uint64_t (*v17)(unint64_t, const char *, ...);
  BOOL v18;
  __int128 v19;
  const void *v20;
  const void *v21;

  v4 = *(_QWORD *)a2;
  v5 = a2[2];
  v6 = *a2;
  *(_OWORD *)(a1 + 16) = a2[1];
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v6;
  *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 6);
  *(_BYTE *)(a1 + 33) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  if ((*(_BYTE *)(a3 + 7) & 0x40) != 0)
  {
    v7 = *(const void **)(a3 + 8);
    v8 = (size_t *)(a3 + 16);
  }
  else
  {
    v7 = (const void *)(a3 + 8);
    v8 = (size_t *)(a3 + 248);
  }
  v9 = *v8;
  v19 = *(__int128 *)((char *)a2 + 40);
  v20 = 0;
  v21 = 0;
  result = ccder_blob_decode_range(&v19, 12, &v20);
  if ((result & 1) != 0)
  {
    v11 = 0;
    v12 = v20;
    v13 = v21;
    if (v7 && v9)
    {
      if (v20)
      {
        v14 = (_BYTE *)v21 - (_BYTE *)v20;
        if (v9 >= (_BYTE *)v21 - (_BYTE *)v20)
          v15 = (_BYTE *)v21 - (_BYTE *)v20;
        else
          v15 = v9;
        result = memcmp(v7, v20, v15);
        v11 = (_DWORD)result == 0;
        if (v9 != v14)
          v11 = 0;
      }
      else
      {
        v11 = 0;
      }
    }
    if (v9)
      v18 = 0;
    else
      v18 = v13 == v12;
    if (v18)
      v11 = 1;
    *(_BYTE *)(a1 + 33) = v11;
  }
  else
  {
    v16 = *(uint64_t (**)(unint64_t, const char *, ...))(v4 + 24);
    if (v16)
    {
      result = v16(v4, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      v17 = *(uint64_t (**)(unint64_t, const char *, ...))(v4 + 24);
      if (v17)
      {
        if (v4 && v4 >= v4 + 64)
          __break(0x5519u);
        else
          return v17(v4, "[%s]: %s\n", "der_vm_execute_match_string", "string decode failure");
      }
    }
  }
  return result;
}

uint64_t sub_10004C488(uint64_t *a1)
{
  _QWORD *v2;
  uint64_t v3;
  const void *v4;
  size_t *v5;
  size_t v6;
  uint64_t result;
  uint64_t v8;
  void (*v9)(uint64_t, const char *, ...);
  unint64_t v10;
  size_t v11;
  _BYTE *v12;
  int v14;
  void (*v15)(unint64_t, const char *, ...);
  uint64_t *v16;
  _BYTE v17[56];
  __int128 v18;
  _BYTE *v19;
  unint64_t v20;

  v2 = (_QWORD *)a1[15];
  v3 = v2[1];
  if ((*(_BYTE *)(v3 + 7) & 0x40) != 0)
  {
    v4 = *(const void **)(v3 + 8);
    v5 = (size_t *)(v3 + 16);
  }
  else
  {
    v4 = (const void *)(v3 + 8);
    v5 = (size_t *)(v3 + 248);
  }
  if (*((_DWORD *)a1 + 29) != 4)
  {
    v8 = *a1;
    v9 = *(void (**)(uint64_t, const char *, ...))(*a1 + 24);
    if (v9)
      v9(v8, "[%s]: %s\n", "string_value_allowed_iterate", "Unexpected type to match against during iteration");
    return 1;
  }
  v6 = *v5;
  sub_10004C32C((uint64_t)v17, (__int128 *)(a1 + 7), v3);
  if (v17[33])
  {
    result = 0;
    *(_BYTE *)(*v2 + 33) = 1;
    return result;
  }
  v10 = a1[7];
  v18 = *((_OWORD *)a1 + 6);
  v19 = 0;
  v20 = 0;
  if ((ccder_blob_decode_range(&v18, 12, &v19) & 1) == 0)
  {
    v15 = *(void (**)(unint64_t, const char *, ...))(v10 + 24);
    if (v15)
      v15(v10, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
    if (!v10 || v10 < v10 + 64)
      goto LABEL_27;
    goto LABEL_26;
  }
  if (v20 - (unint64_t)v19 < 2)
    return 1;
  v11 = v20 - (_QWORD)v19 - 1;
  v12 = (_BYTE *)(v20 - 1);
  if (v20 - 1 >= v20 || v12 < v19)
  {
LABEL_26:
    __break(0x5519u);
LABEL_27:
    v16 = (uint64_t *)(*(uint64_t (**)(unint64_t, const char *, ...))(v10 + 32))(v10, "[%s]: %s\n", "der_vm_string_from_context", "Attempting to select a string value from a non-string DER object");
    return sub_10004C638(v16);
  }
  if (*v12 != 42 || v11 > v6)
    return 1;
  v14 = memcmp(v19, v4, v11);
  result = 1;
  if (!v14)
  {
    *(_BYTE *)(*v2 + 33) = 1;
    return 0;
  }
  return result;
}

uint64_t sub_10004C638(uint64_t *a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  int v5;
  const void *v6;
  size_t v7;
  unint64_t v8;
  void (*v9)(uint64_t, const char *, ...);
  void (*v10)(unint64_t, const char *, ...);
  void (*v11)(unint64_t, const char *, ...);
  uint64_t result;
  void (*v13)(unint64_t, const char *, ...);
  uint64_t v14;
  __int128 v15;
  const void *v16;
  uint64_t v17;

  v2 = *a1;
  v3 = (_QWORD *)a1[15];
  v4 = v3[1];
  v5 = *((_DWORD *)a1 + 29);
  if ((*(_BYTE *)(v4 + 7) & 0x40) == 0)
  {
    if (v5 == 4)
    {
      v6 = (const void *)(v4 + 8);
      v7 = *(_QWORD *)(v4 + 248);
      goto LABEL_6;
    }
LABEL_11:
    v9 = *(void (**)(uint64_t, const char *, ...))(v2 + 24);
    if (v9)
      v9(v2, "[%s]: %s\n", "string_prefix_allowed_iterate", "Unexpected type to match against during iteration");
    return 1;
  }
  if (v5 != 4)
    goto LABEL_11;
  v6 = *(const void **)(v4 + 8);
  v7 = *(_QWORD *)(v4 + 16);
LABEL_6:
  v8 = a1[7];
  v15 = *((_OWORD *)a1 + 6);
  v16 = 0;
  v17 = 0;
  if ((ccder_blob_decode_range(&v15, 12, &v16) & 1) != 0)
  {
    if (!v7 || v7 <= v17 - (uint64_t)v16 && !memcmp(v6, v16, v7))
      goto LABEL_23;
  }
  else
  {
    v10 = *(void (**)(unint64_t, const char *, ...))(v8 + 24);
    if (v10)
    {
      v10(v8, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
      v11 = *(void (**)(unint64_t, const char *, ...))(v8 + 24);
      if (v11)
      {
        if (v8 && v8 >= v8 + 64)
        {
LABEL_28:
          __break(0x5519u);
          goto LABEL_29;
        }
        v11(v8, "[%s]: %s\n", "der_vm_execute_match_string_prefix", "string decode failure");
      }
    }
  }
  v8 = a1[7];
  v15 = *((_OWORD *)a1 + 6);
  v16 = 0;
  v17 = 0;
  if ((ccder_blob_decode_range(&v15, 12, &v16) & 1) != 0)
  {
    if (!v7 || v7 <= v17 - (uint64_t)v16 && !memcmp(v6, v16, v7))
    {
LABEL_23:
      result = 0;
      *(_BYTE *)(*v3 + 33) = 1;
      return result;
    }
    return 1;
  }
  v13 = *(void (**)(unint64_t, const char *, ...))(v8 + 24);
  if (v13)
    v13(v8, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
  if (v8 && v8 >= v8 + 64)
    goto LABEL_28;
LABEL_29:
  v14 = (*(uint64_t (**)(unint64_t, const char *, ...))(v8 + 32))(v8, "[%s]: %s\n", "der_vm_string_from_context", "Attempting to select a string value from a non-string DER object");
  return sub_10004C84C(v14);
}

uint64_t sub_10004C84C(uint64_t *a1)
{
  _QWORD *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t result;
  uint64_t (*v5)(unint64_t, const char *, ...);
  const char *v6;
  uint64_t v7;
  void (*v8)(uint64_t, const char *, ...);
  void (*v9)(unint64_t, const char *, ...);
  uint64_t v10;
  uint64_t v11;
  unsigned __int8 *v12;
  __int128 v13;
  unsigned __int8 *v14;
  unint64_t v15;

  if (*((_DWORD *)a1 + 29) != 3)
  {
    v7 = *a1;
    v8 = *(void (**)(uint64_t, const char *, ...))(v7 + 24);
    if (v8)
      v8(v7, "[%s]: %s\n", "integer_allowed_iterate", "Unexpected type to match against during iteration");
    return 0;
  }
  v1 = (_QWORD *)a1[15];
  v2 = v1[1];
  v3 = a1[7];
  v13 = *((_OWORD *)a1 + 6);
  v14 = 0;
  v15 = 0;
  result = ccder_blob_decode_range(&v13, 2, &v14);
  if ((result & 1) == 0)
  {
    v5 = *(uint64_t (**)(unint64_t, const char *, ...))(v3 + 24);
    if (v5)
    {
      v6 = "unknown number encoding";
      goto LABEL_11;
    }
LABEL_12:
    v9 = *(void (**)(unint64_t, const char *, ...))(v3 + 24);
    if (!v9)
      return 1;
    if (!v3 || v3 < v3 + 64)
    {
      v9(v3, "[%s]: %s\n", "der_vm_execute_match_integer", "BOOL decode failure");
      return 1;
    }
LABEL_30:
    __break(0x5519u);
    return result;
  }
  if (v15 - (unint64_t)v14 >= 9)
  {
    v5 = *(uint64_t (**)(unint64_t, const char *, ...))(v3 + 24);
    if (v5)
    {
      v6 = "number too large";
LABEL_11:
      result = v5(v3, "[%s]: %s\n", "der_decode_number", v6);
      goto LABEL_12;
    }
    goto LABEL_12;
  }
  if ((unint64_t)v14 < v15)
  {
    v10 = 0;
    v11 = 0;
    while (1)
    {
      if (!v10 && (*v14 & 0x80u) != 0)
        v11 = -1;
      v12 = &v14[v10];
      if ((unint64_t)&v14[v10] >= v15 || v12 < v14)
        goto LABEL_30;
      v11 = *v12 | (unint64_t)(v11 << 8);
      if (v15 - (_QWORD)v14 == ++v10)
        goto LABEL_28;
    }
  }
  v11 = 0;
LABEL_28:
  result = 1;
  if (v11 == *(_QWORD *)(v2 + 8))
  {
    *(_BYTE *)(*v1 + 33) = 1;
    return 0;
  }
  return result;
}

uint64_t sub_10004C9E0(uint64_t result, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  void (*v4)(unint64_t, const char *);
  BOOL v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  const void *v9;
  size_t v10;
  size_t v11;
  const void *v12;
  size_t v13;
  BOOL v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  void *v24;
  size_t v25;
  char *v26;
  unint64_t v27;

  v2 = *(_QWORD *)result;
  v3 = *(_QWORD *)result + 64;
  if (*(int *)(result + 20) > 12)
  {
    v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
    if (v4)
    {
      if (v2 < v3)
        goto LABEL_33;
      goto LABEL_95;
    }
    return 0;
  }
  v21 = 0;
  v22 = 0;
  v20 = 0;
  if (v2)
    v5 = v2 >= v3;
  else
    v5 = 0;
  if (v5)
  {
LABEL_95:
    __break(0x5519u);
    return result;
  }
  v6 = result;
  if ((sub_10004CEB4(v2, &v22, &v20, 0, a2) & 1) == 0)
  {
    v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
    if (v4)
    {
LABEL_33:
      v16 = v2;
LABEL_34:
      v4(v16, "[%s]: %s\n");
      return 0;
    }
    return 0;
  }
  if (v22 != *(_QWORD *)(v6 + 8))
  {
    switch(v22)
    {
      case 1:
        v26 = 0;
        v27 = 0;
        if ((ccder_blob_decode_range(&v20, 1, &v26) & 1) != 0)
        {
          if (v27 - (_QWORD)v26 == 1)
            goto LABEL_89;
          v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4)
            return 0;
        }
        else
        {
          v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4)
            return 0;
        }
        goto LABEL_33;
      case 2:
        v26 = 0;
        v27 = 0;
        result = ccder_blob_decode_range(&v20, 2, &v26);
        if ((result & 1) == 0)
        {
          v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4)
            return 0;
          goto LABEL_33;
        }
        v18 = v27 - (_QWORD)v26;
        if (v27 - (unint64_t)v26 >= 9)
        {
          v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4)
            return 0;
          goto LABEL_33;
        }
        if ((unint64_t)v26 >= v27)
          goto LABEL_89;
        v19 = v26;
        while ((unint64_t)v19 < v27 && v19 >= v26)
        {
          ++v19;
          if (!--v18)
            goto LABEL_89;
        }
        goto LABEL_95;
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        goto LABEL_51;
      case 4:
        if (*(_BYTE *)(v6 + 24))
        {
          v26 = 0;
          v27 = 0;
          if ((sub_10004CFC0(v2, &v26, (uint64_t)&v20) & 1) == 0)
            return 0;
          goto LABEL_89;
        }
        v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
        if (!v4)
          return 0;
        goto LABEL_33;
      case 12:
        v26 = 0;
        v27 = 0;
        if ((ccder_blob_decode_range(&v20, 12, &v26) & 1) != 0)
        {
          if (!memchr(v26, 0, v27 - (_QWORD)v26))
            goto LABEL_89;
          v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4)
            return 0;
        }
        else
        {
          v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4)
            return 0;
        }
        goto LABEL_33;
      default:
        if (v22 != 0x2000000000000010)
        {
LABEL_51:
          v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
          if (!v4)
            return 0;
          goto LABEL_33;
        }
        v7 = *(_QWORD *)v6;
        v17 = *(_QWORD *)v6 + 64;
        v26 = 0;
        v27 = 0;
        result = ccder_blob_decode_sequence_tl(&v20, &v26);
        if ((_DWORD)result)
        {
          do
          {
            if ((unint64_t)v26 >= v27)
              goto LABEL_89;
            ++*(_DWORD *)(v6 + 20);
            result = sub_10004C9E0(v6, &v26);
            --*(_DWORD *)(v6 + 20);
          }
          while ((result & 1) != 0);
          v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
          if (!v4)
            return 0;
          if (v7 >= v17)
            goto LABEL_95;
        }
        else
        {
          v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
          if (!v4)
            return 0;
          if (v7 >= v17)
            goto LABEL_95;
        }
        break;
    }
    goto LABEL_43;
  }
  v7 = *(_QWORD *)v6;
  v8 = *(_QWORD *)v6 + 64;
  v26 = 0;
  v27 = 0;
  result = ccder_blob_decode_range(&v20, v22, &v26);
  if (!(_DWORD)result)
  {
    v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
    if (!v4)
      return 0;
    if (v7 >= v8)
      goto LABEL_95;
LABEL_43:
    v16 = v7;
    goto LABEL_34;
  }
  if ((unint64_t)v26 < v27)
  {
    v9 = 0;
    v10 = 0;
    while (1)
    {
      v24 = 0;
      v25 = 0;
      v23 = 0uLL;
      result = sub_10004D054(v7, &v24, &v23, &v26);
      if ((result & 1) == 0)
      {
        v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
        if (!v4)
          return 0;
        if (v7 >= v8)
          goto LABEL_95;
        goto LABEL_43;
      }
      v12 = v24;
      v11 = v25;
      result = (uint64_t)memchr(v24, 0, v25);
      if (result)
      {
        v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
        if (!v4)
          return 0;
        if (v7 >= v8)
          goto LABEL_95;
        goto LABEL_43;
      }
      if (*(_BYTE *)(v6 + 16) && v9 && v10)
      {
        if (!v12)
          break;
        v13 = v10 >= v11 ? v11 : v10;
        result = memcmp(v9, v12, v13);
        v14 = v10 != v11 && (_DWORD)result == 0;
        v15 = (v10 < v11) << 31;
        if (!v14)
          v15 = result;
        if ((v15 & 0x80000000) == 0)
          break;
      }
      ++*(_DWORD *)(v6 + 20);
      result = sub_10004C9E0(v6, &v23);
      --*(_DWORD *)(v6 + 20);
      if ((result & 1) == 0)
      {
        v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
        if (!v4)
          return 0;
        if (v7 >= v8)
          goto LABEL_95;
        goto LABEL_43;
      }
      v9 = v24;
      v10 = v25;
      if ((unint64_t)v26 >= v27)
        goto LABEL_89;
    }
    v4 = *(void (**)(unint64_t, const char *))(v7 + 24);
    if (!v4)
      return 0;
    if (v7 < v8)
      goto LABEL_43;
    goto LABEL_95;
  }
LABEL_89:
  if (v20 != v21)
  {
    v4 = *(void (**)(unint64_t, const char *))(v2 + 24);
    if (!v4)
      return 0;
    goto LABEL_33;
  }
  return 1;
}

uint64_t sub_10004CEB4(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t *a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  void (*v14)(uint64_t, const char *, ...);
  const char *v15;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;

  v11 = *a5;
  v10 = a5[1];
  v18 = 0;
  v19 = 0;
  if ((ccder_blob_decode_tag(a5, &v19) & 1) == 0)
  {
    v14 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v14)
    {
      v15 = "could not decode tag for next DER sub-sequence";
      goto LABEL_10;
    }
    return 0;
  }
  if ((ccder_blob_decode_len(a5, &v18) & 1) == 0)
  {
    v14 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v14)
    {
      v15 = "could not decode size for next DER sub-sequence";
      goto LABEL_10;
    }
    return 0;
  }
  v12 = *a5;
  v13 = v18;
  if (a5[1] - *a5 < v18)
  {
    v14 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v14)
    {
      v15 = "sub-sequence size is larger than sequence size";
LABEL_10:
      v14(a1, "[%s]: %s\n", "der_decode_next", v15);
      return 0;
    }
    return 0;
  }
  if (a2)
    *a2 = v19;
  v17 = v12 + v13;
  if (a3)
  {
    *a3 = v11;
    a3[1] = v17;
  }
  if (a4)
  {
    *a4 = v12;
    a4[1] = v17;
  }
  *a5 = v17;
  a5[1] = v10;
  return 1;
}

uint64_t sub_10004CFC0(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  void (*v7)(uint64_t, const char *, ...);
  uint64_t v9;
  uint64_t v10;

  v9 = 0;
  v10 = 0;
  v5 = ccder_blob_decode_range(a3, 4, &v9);
  if ((v5 & 1) != 0)
  {
    if (a2)
    {
      v6 = v10 - v9;
      *a2 = v9;
      a2[1] = v6;
    }
  }
  else
  {
    v7 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v7)
      v7(a1, "[%s]: %s\n", "der_decode_data", "Unknown data encoding");
  }
  return v5;
}

uint64_t sub_10004D054(uint64_t a1, _QWORD *a2, _OWORD *a3, _QWORD *a4)
{
  uint64_t v8;
  void (*v9)(uint64_t, const char *, ...);
  const char *v10;
  void (*v11)(uint64_t, const char *, ...);
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;

  v15 = 0uLL;
  v13 = 0;
  v14 = 0;
  if ((ccder_blob_decode_sequence_tl(a4, &v15) & 1) == 0)
  {
    v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v9)
    {
      v10 = "key / value decoding failure";
LABEL_12:
      v9(a1, "[%s]: %s\n", "der_decode_key_value", v10);
    }
    return 0;
  }
  v16 = 0uLL;
  if ((ccder_blob_decode_range(&v15, 12, &v16) & 1) == 0)
  {
    v11 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v11)
      v11(a1, "[%s]: %s\n", "der_decode_string", "Unknown string encoding");
LABEL_10:
    v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (v9)
    {
      v10 = "dictionary key is not a valid string";
      goto LABEL_12;
    }
    return 0;
  }
  if (a2)
  {
    v8 = *((_QWORD *)&v16 + 1) - v16;
    *a2 = v16;
    a2[1] = v8;
    if (!v8)
      goto LABEL_10;
  }
  else if (!MEMORY[8])
  {
    goto LABEL_10;
  }
  v16 = v15;
  if ((ccder_blob_decode_tag(&v16, &v14) & 1) == 0)
  {
    v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (!v9)
      return 0;
    v10 = "unable to decode value tag for key-value pair";
    goto LABEL_12;
  }
  if ((ccder_blob_decode_len(&v16, &v13) & 1) == 0)
  {
    v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (!v9)
      return 0;
    v10 = "unable to decode value size for key-value pair";
    goto LABEL_12;
  }
  if ((_QWORD)v16 + v13 != *a4)
  {
    v9 = *(void (**)(uint64_t, const char *, ...))(a1 + 24);
    if (!v9)
      return 0;
    v10 = "key-value pair contains extra elements";
    goto LABEL_12;
  }
  *a3 = v15;
  return 1;
}

char *sub_10004D1DC(_QWORD *a1, char **a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  char *result;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  uint64_t v16;

  if (!a1)
    return (char *)&unk_10006DFC8;
  switch(*a1)
  {
    case 1:
      a1[2] = 1;
      v6 = 1;
      v7 = 1;
      goto LABEL_30;
    case 2:
      v7 = a1[2];
      v6 = 12;
      goto LABEL_30;
    case 4:
      v9 = a1[1];
      v10 = HIBYTE(v9);
      if ((HIBYTE(v9) + 1) > 1u)
      {
        v16 = 8;
      }
      else
      {
        if ((_DWORD)v10 == BYTE6(v9))
        {
          if ((_DWORD)v10 == BYTE5(v9))
          {
            if ((_DWORD)v10 == BYTE4(v9))
            {
              if ((_DWORD)v10 == BYTE3(v9))
              {
                if ((_DWORD)v10 == BYTE2(v9))
                {
                  if (BYTE1(v9) == (_DWORD)v10)
                    v11 = 2;
                  else
                    v11 = 3;
                  v12 = 1;
                  if (BYTE1(v9) != (_DWORD)v10)
                    v12 = 2;
                }
                else
                {
                  v12 = 3;
                  v11 = 4;
                }
              }
              else
              {
                v12 = 4;
                v11 = 5;
              }
            }
            else
            {
              v12 = 5;
              v11 = 6;
            }
          }
          else
          {
            v12 = 6;
            v11 = 7;
          }
        }
        else
        {
          v12 = 7;
          v11 = 8;
        }
        if ((((v9 >> (8 * v12 - 8)) ^ v10) & 0x80) != 0)
          v16 = v11;
        else
          v16 = v12;
      }
      *a3 = ccder_sizeof(2, v16);
      a1[2] = v16;
      return (char *)&unk_10006DFA8;
    case 5:
      goto LABEL_18;
    case 7:
      return (char *)sub_10004D420(a1, a2, a3);
    case 9:
      v7 = a1[2];
      v6 = 4;
LABEL_30:
      *a3 = ccder_sizeof(v6, v7);
      return (char *)&unk_10006DFA8;
    default:
      return (char *)&unk_10006DFC8;
  }
  while (1)
  {
LABEL_18:
    result = *a2;
    v13 = (unint64_t)a2[1];
    if ((unint64_t)*a2 >= v13)
      return (char *)&unk_10006DFE8;
    v14 = result + 32;
    if ((unint64_t)(result + 32) > v13 || result >= v14)
      break;
    *a2 = v14;
    if (!result)
      return (char *)&unk_10006DFE8;
    if (*(_QWORD *)result == 6)
    {
      *a3 = ccder_sizeof(0x2000000000000010, 0);
      a1[2] = 0;
      return (char *)&unk_10006DFA8;
    }
    if (result >= v14)
      break;
    result = (char *)sub_10004D1DC();
    if (result != (char *)&unk_10006DFA8)
      return result;
  }
  __break(0x5519u);
  return result;
}

char *sub_10004D420(char *result, uint64_t a2, _QWORD *a3)
{
  char *v5;
  uint64_t v6;
  char *v7;
  unint64_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;

  v5 = result;
  v6 = 0;
  v7 = *(char **)a2;
  v8 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)a2 >= v8)
    return (char *)&unk_10006DFE8;
  while (1)
  {
    v9 = v7 + 32;
    if ((unint64_t)(v7 + 32) > v8 || v7 > v9)
    {
LABEL_28:
      __break(0x5519u);
      return result;
    }
    *(_QWORD *)a2 = v9;
    if (!v7)
      return (char *)&unk_10006DFE8;
    if (*(_QWORD *)v7 != 5)
      break;
    v7[24] = 1;
    if ((unint64_t)v9 >= v8)
      return (char *)&unk_10006DFE8;
    v10 = v7 + 64;
    if ((unint64_t)(v7 + 64) > v8 || v9 > v10)
      goto LABEL_28;
    *(_QWORD *)a2 = v10;
    if (v7 == (char *)-32)
      return (char *)&unk_10006DFE8;
    if (*(_QWORD *)v9 != 3)
      return (char *)&unk_10006DFE8;
    v11 = *((_QWORD *)v7 + 6);
    if (!v11)
      return (char *)&unk_10006DFE8;
    v12 = ccder_sizeof(12, v11);
    result = 0;
    v17 = 0;
    if ((unint64_t)v10 < v8)
    {
      v13 = v7 + 96;
      if ((unint64_t)(v7 + 96) > v8 || v10 > v13)
        goto LABEL_28;
      *(_QWORD *)a2 = v13;
      result = v7 + 64;
    }
    result = sub_10004D1DC(result, (char **)a2, &v17);
    if (result != (char *)&unk_10006DFA8)
      return result;
    v14 = *(char **)a2;
    v8 = *(_QWORD *)(a2 + 8);
    if (*(_QWORD *)a2 >= v8)
      return (char *)&unk_10006DFE8;
    v15 = v14 + 32;
    if ((unint64_t)(v14 + 32) > v8 || v14 > v15)
      goto LABEL_28;
    *(_QWORD *)a2 = v15;
    if (v14)
    {
      if (*(_QWORD *)v14 == 6)
      {
        v14[24] = 1;
        v16 = v17 + v12;
        *((_QWORD *)v7 + 2) = v17 + v12;
        result = (char *)ccder_sizeof(0x2000000000000010, v16);
        v6 += (uint64_t)result;
        v7 = v15;
        if ((unint64_t)v15 < v8)
          continue;
      }
    }
    return (char *)&unk_10006DFE8;
  }
  if (*(_QWORD *)v7 != 8)
    return (char *)&unk_10006DFE8;
  *a3 = ccder_sizeof(0xA000000000000010, v6);
  *((_QWORD *)v5 + 2) = v6;
  return (char *)&unk_10006DFA8;
}

uint64_t sub_10004D5D0(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  unint64_t v8;
  unint64_t v9;
  _BYTE *v10;
  _BYTE *v12;
  _BYTE *v13;

  v2 = a2;
  v3 = HIBYTE(a2);
  if ((HIBYTE(a2) + 1) > 1u)
  {
    v6 = 8;
  }
  else
  {
    if ((_DWORD)v3 == BYTE6(a2))
    {
      if ((_DWORD)v3 == BYTE5(a2))
      {
        if ((_DWORD)v3 == BYTE4(a2))
        {
          if ((_DWORD)v3 == BYTE3(a2))
          {
            if ((_DWORD)v3 == BYTE2(a2))
            {
              if (BYTE1(a2) == (_DWORD)v3)
                v4 = 2;
              else
                v4 = 3;
              v5 = 1;
              if (BYTE1(a2) != (_DWORD)v3)
                v5 = 2;
            }
            else
            {
              v5 = 3;
              v4 = 4;
            }
          }
          else
          {
            v5 = 4;
            v4 = 5;
          }
        }
        else
        {
          v5 = 5;
          v4 = 6;
        }
      }
      else
      {
        v5 = 6;
        v4 = 7;
      }
    }
    else
    {
      v5 = 7;
      v4 = 8;
    }
    if ((((a2 >> (8 * v5 - 8)) ^ v3) & 0x80) != 0)
      v6 = v4;
    else
      v6 = v5;
  }
  v12 = 0;
  v13 = 0;
  result = ccder_blob_reserve_tl(a1, 2, v6, &v12);
  if ((_DWORD)result)
  {
    v8 = (unint64_t)v12;
    v9 = (unint64_t)v13;
    if (v13 != v12)
    {
      v10 = v13 - 1;
      while ((unint64_t)v10 < v9 && (unint64_t)v10 >= v8)
      {
        *v10 = v2;
        v2 >>= 8;
        if (v10-- == v12)
          return result;
      }
      __break(0x5519u);
    }
  }
  return result;
}

void sub_10004D708(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _os_crash("optional cannot be created with NULL value", a2, a3, a4);
  __break(1u);
}

void sub_10004D720(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _os_crash("optional cannot be created with zero error", a2, a3, a4);
  __break(1u);
}

void sub_10004D738()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v0 = sub_100003D88();
  _os_crash(v0, v1, v2, v3);
  __break(1u);
}

void sub_10004D74C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v0 = _os_assert_log(0);
  _os_crash(v0, v1, v2, v3);
  __break(1u);
}

void sub_10004D764(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = sub_100004518(a1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_10004D778(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = _os_assert_log(a1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

uint64_t sub_10004D790(uint64_t a1)
{
  uint64_t result;

  result = _os_assumes_log_ctx(sub_10001F174, a1);
  *(_QWORD *)(a1 + 1376) |= 1uLL;
  return result;
}

void sub_10004D7CC(int a1)
{
  qword_100071AF8 = (uint64_t)"Bug in libxpc: mach_port_construct() failed";
  qword_100071B28 = a1;
  __break(1u);
}

void sub_10004D7F4(int a1)
{
  qword_100071AF8 = (uint64_t)"Bug in libxpc: mach_port_assert_attributes() failed";
  qword_100071B28 = a1;
  __break(1u);
}

void sub_10004D81C()
{
  qword_100071AF8 = (uint64_t)"Configuration error: failed to fetch our own audit token";
  __break(1u);
}

void sub_10004D83C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v0 = __error();
  v1 = _os_assert_log(*v0);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_10004D858(char a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = _os_assert_log(a1 & 1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

uint64_t sub_10004D870()
{
  int *v0;

  v0 = __error();
  return _os_assumes_log(*v0);
}

void sub_10004D88C(const char *a1)
{
  int v2;
  int *v3;
  const char *v4;

  _os_assumes_log(0);
  v2 = *__error();
  v3 = __error();
  v4 = (const char *)xpc_strerror(*v3);
  sub_100040F68(4, "Failed to set %s: %d - %s", a1, v2, v4);
}

void sub_10004D8E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _os_crash("string must be in a pool to be released", a2, a3, a4);
  __break(1u);
}

void sub_10004D8FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _os_crash("pool must be empty to be disposed", a2, a3, a4);
  __break(1u);
}

void sub_10004D914()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v0 = __error();
  v1 = sub_100015054(v0);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_10004D92C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _os_crash("invalid domain io type", a2, a3, a4);
  __break(1u);
}

void sub_10004D944(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _os_crash("invalid xpaths type", a2, a3, a4);
  __break(1u);
}

void sub_10004D95C(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = _os_assert_log(a1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_10004DE5C()
{
  sub_10001C7B0();
  sub_10001C7A8((uint64_t)sub_10001A6C4);
  sub_10001C7B8();
}

uint64_t sub_10004DE84()
{
  int *v0;

  v0 = __error();
  return sub_10001C7C0(v0);
}

uint64_t sub_10004DE9C(uint64_t a1)
{
  __error();
  return _os_assumes_log_ctx(sub_10001F174, a1);
}

void sub_10004DED0(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = _os_assert_log((a1 >> 4) ^ 1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

void sub_10004DEEC(char a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = _os_assert_log(a1 == 3);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

uint64_t sub_10004DF0C(int a1, uint64_t a2, char a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  strerror(a1);
  sub_10001D418(a2, 5, "could not signal service for %s: %d: %s", v5, v6, v7, v8, v9, a3);
  return _os_assumes_log_ctx(sub_10001F174, a2);
}

uint64_t sub_10004DF74(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100028C34(a1, 3, "Bootout error: %d", a4, a5, a6, a7, a8, a2);
  return _os_assumes_log_ctx(sub_100028C00, a1);
}

uint64_t sub_10004DFC4()
{
  return _os_assumes_log_ctx(sub_100028C00, qword_100072478);
}

void sub_10004DFEC(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = _os_assert_log(a1);
  _os_crash(v1, v2, v3, v4);
  __break(1u);
}

uint64_t sub_10004E004(uint64_t a1)
{
  __error();
  return _os_assumes_log_ctx(sub_100028C00, a1);
}

void sub_10004E038(uint64_t a1, uint64_t a2)
{
  int v2;
  char *v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = sub_100038DF8(a1, a2);
  v4 = sub_100038DEC();
  v5 = sub_100015630("overflow of service activation count during deactivation. Managed:%d. Domain: %s. Service:%s", v2, v3, v4);
  _os_crash(v5, v6, v7, v8);
  __break(1u);
}

void sub_10004E074(uint64_t a1, uint64_t a2)
{
  int v2;
  char *v3;
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v3 = sub_100038DF8(a1, a2);
  v4 = sub_100038DEC();
  v5 = sub_100015630("underflow of service activation count during deactivate. Managed:%d. Domain: %s. Service:%s", v2, v3, v4);
  _os_crash(v5, v6, v7, v8);
  __break(1u);
}

void sub_10004E0B0(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = sub_100038E28(a1);
  v3 = sub_100038DEC();
  v4 = sub_100015630("%s is being deactivated by a mismatched domain %s. Managed:%d.", v2, v3, *(_DWORD *)(v1 + 296) != 0);
  _os_crash(v4, v5, v6, v7);
  __break(1u);
}

void sub_10004E0F8(uint64_t a1)
{
  int v1;
  char *v2;
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = sub_100038E10(a1);
  v3 = sub_100038DEC();
  v4 = sub_100015630("overflow of service activation count during activate. Managed:%d. Domain:'%s'. Service:'%s'", v1, v2, v3);
  _os_crash(v4, v5, v6, v7);
  __break(1u);
}

void sub_10004E134(uint64_t a1)
{
  int v1;
  char *v2;
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = sub_100038E10(a1);
  v3 = sub_100038DEC();
  v4 = sub_100015630("underflow of service activation count during activate. Managed:%d. Domain:'%s'. Service:'%s'", v1, v2, v3);
  _os_crash(v4, v5, v6, v7);
  __break(1u);
}

void sub_10004E170(uint64_t a1)
{
  uint64_t v1;
  char *v2;
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = sub_100038E28(a1);
  v3 = sub_100038DEC();
  v4 = sub_100015630("%s is being activated by a mismatched domain %s. Managed:%d.", v2, v3, *(_DWORD *)(v1 + 296) != 0);
  _os_crash(v4, v5, v6, v7);
  __break(1u);
}

void sub_10004E1B8()
{
  int *v0;

  v0 = sub_10001C7B0();
  sub_10001C7C0(v0);
  sub_100043028();
  sub_10001C7B8();
}

void sub_10004E1D8(unsigned int a1)
{
  qword_100071AF8 = (uint64_t)"libdispatch bug: Unknown send-right";
  qword_100071B28 = a1;
  __break(1u);
}

void sub_10004E200(const void *aBlock)
{
  qword_100071AF8 = (uint64_t)"libdispatch bug: Unknown receive-right";
  qword_100071B28 = aBlock;
  __break(1u);
  _Block_copy(aBlock);
}
